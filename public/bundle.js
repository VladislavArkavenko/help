/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 31);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__(32);
} else {
  module.exports = __webpack_require__(33);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;

  var isValidElement = function isValidElement(object) {
    return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(46)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(47)();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function invariant(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var __DEV__ = process.env.NODE_ENV !== 'production';

var warning = function warning() {};

if (__DEV__) {
  var printWarning = function printWarning(format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      printWarning.apply(null, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPath = exports.parsePath = exports.locationsAreEqual = exports.createLocation = exports.createMemoryHistory = exports.createHashHistory = exports.createBrowserHistory = undefined;

var _LocationUtils = __webpack_require__(9);

Object.defineProperty(exports, 'createLocation', {
  enumerable: true,
  get: function get() {
    return _LocationUtils.createLocation;
  }
});
Object.defineProperty(exports, 'locationsAreEqual', {
  enumerable: true,
  get: function get() {
    return _LocationUtils.locationsAreEqual;
  }
});

var _PathUtils = __webpack_require__(7);

Object.defineProperty(exports, 'parsePath', {
  enumerable: true,
  get: function get() {
    return _PathUtils.parsePath;
  }
});
Object.defineProperty(exports, 'createPath', {
  enumerable: true,
  get: function get() {
    return _PathUtils.createPath;
  }
});

var _createBrowserHistory2 = __webpack_require__(50);

var _createBrowserHistory3 = _interopRequireDefault(_createBrowserHistory2);

var _createHashHistory2 = __webpack_require__(51);

var _createHashHistory3 = _interopRequireDefault(_createHashHistory2);

var _createMemoryHistory2 = __webpack_require__(52);

var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.createBrowserHistory = _createBrowserHistory3.default;
exports.createHashHistory = _createHashHistory3.default;
exports.createMemoryHistory = _createMemoryHistory3.default;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = exports.hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var stripBasename = exports.stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = exports.stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = exports.parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = exports.createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;

  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withRouter = exports.matchPath = exports.generatePath = exports.Switch = exports.StaticRouter = exports.Router = exports.Route = exports.Redirect = exports.Prompt = exports.NavLink = exports.MemoryRouter = exports.Link = exports.HashRouter = exports.BrowserRouter = undefined;

var _BrowserRouter2 = __webpack_require__(45);

var _BrowserRouter3 = _interopRequireDefault(_BrowserRouter2);

var _HashRouter2 = __webpack_require__(53);

var _HashRouter3 = _interopRequireDefault(_HashRouter2);

var _Link2 = __webpack_require__(22);

var _Link3 = _interopRequireDefault(_Link2);

var _MemoryRouter2 = __webpack_require__(54);

var _MemoryRouter3 = _interopRequireDefault(_MemoryRouter2);

var _NavLink2 = __webpack_require__(55);

var _NavLink3 = _interopRequireDefault(_NavLink2);

var _Prompt2 = __webpack_require__(57);

var _Prompt3 = _interopRequireDefault(_Prompt2);

var _Redirect2 = __webpack_require__(58);

var _Redirect3 = _interopRequireDefault(_Redirect2);

var _Route2 = __webpack_require__(24);

var _Route3 = _interopRequireDefault(_Route2);

var _Router2 = __webpack_require__(16);

var _Router3 = _interopRequireDefault(_Router2);

var _StaticRouter2 = __webpack_require__(59);

var _StaticRouter3 = _interopRequireDefault(_StaticRouter2);

var _Switch2 = __webpack_require__(60);

var _Switch3 = _interopRequireDefault(_Switch2);

var _generatePath2 = __webpack_require__(61);

var _generatePath3 = _interopRequireDefault(_generatePath2);

var _matchPath2 = __webpack_require__(62);

var _matchPath3 = _interopRequireDefault(_matchPath2);

var _withRouter2 = __webpack_require__(63);

var _withRouter3 = _interopRequireDefault(_withRouter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.BrowserRouter = _BrowserRouter3.default;
exports.HashRouter = _HashRouter3.default;
exports.Link = _Link3.default;
exports.MemoryRouter = _MemoryRouter3.default;
exports.NavLink = _NavLink3.default;
exports.Prompt = _Prompt3.default;
exports.Redirect = _Redirect3.default;
exports.Route = _Route3.default;
exports.Router = _Router3.default;
exports.StaticRouter = _StaticRouter3.default;
exports.Switch = _Switch3.default;
exports.generatePath = _generatePath3.default;
exports.matchPath = _matchPath3.default;
exports.withRouter = _withRouter3.default;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.locationsAreEqual = exports.createLocation = undefined;

var _resolvePathname = __webpack_require__(48);

var _resolvePathname2 = _interopRequireDefault(_resolvePathname);

var _valueEqual = __webpack_require__(49);

var _valueEqual2 = _interopRequireDefault(_valueEqual);

var _PathUtils = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = (0, _PathUtils.parsePath)(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, _valueEqual2.default)(a.state, b.state);
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function warning() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function warning(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.length < 10 || /^[s\W]*$/.test(format)) {
      throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(4);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(3);

var _invariant2 = _interopRequireDefault(_invariant);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for putting history on context.
 */

var Router = function (_React$Component) {
  _inherits(Router, _React$Component);

  function Router() {
    var _temp, _this, _ret;

    _classCallCheck(this, Router);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props.history.location.pathname)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Router.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        history: this.props.history,
        route: {
          location: this.props.history.location,
          match: this.state.match
        }
      })
    };
  };

  Router.prototype.computeMatch = function computeMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };

  Router.prototype.componentWillMount = function componentWillMount() {
    var _this2 = this;

    var _props = this.props,
        children = _props.children,
        history = _props.history;

    (0, _invariant2.default)(children == null || _react2.default.Children.count(children) === 1, "A <Router> may have only one child element");

    // Do this here so we can setState when a <Redirect> changes the
    // location in componentWillMount. This happens e.g. when doing
    // server rendering using a <StaticRouter>.
    this.unlisten = history.listen(function () {
      _this2.setState({
        match: _this2.computeMatch(history.location.pathname)
      });
    });
  };

  Router.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    (0, _warning2.default)(this.props.history === nextProps.history, "You cannot change <Router history>");
  };

  Router.prototype.componentWillUnmount = function componentWillUnmount() {
    this.unlisten();
  };

  Router.prototype.render = function render() {
    var children = this.props.children;

    return children ? _react2.default.Children.only(children) : null;
  };

  return Router;
}(_react2.default.Component);

Router.propTypes = {
  history: _propTypes2.default.object.isRequired,
  children: _propTypes2.default.node
};
Router.contextTypes = {
  router: _propTypes2.default.object
};
Router.childContextTypes = {
  router: _propTypes2.default.object.isRequired
};

exports.default = Router;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pathToRegexp = __webpack_require__(25);

var _pathToRegexp2 = _interopRequireDefault(_pathToRegexp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var patternCache = {};
var cacheLimit = 10000;
var cacheCount = 0;

var compilePath = function compilePath(pattern, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});

  if (cache[pattern]) return cache[pattern];

  var keys = [];
  var re = (0, _pathToRegexp2.default)(pattern, keys, options);
  var compiledPattern = { re: re, keys: keys };

  if (cacheCount < cacheLimit) {
    cache[pattern] = compiledPattern;
    cacheCount++;
  }

  return compiledPattern;
};

/**
 * Public API for matching a URL pathname to a path pattern.
 */
var matchPath = function matchPath(pathname) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var parent = arguments[2];

  if (typeof options === "string") options = { path: options };

  var _options = options,
      path = _options.path,
      _options$exact = _options.exact,
      exact = _options$exact === undefined ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === undefined ? false : _options$strict,
      _options$sensitive = _options.sensitive,
      sensitive = _options$sensitive === undefined ? false : _options$sensitive;

  if (path == null) return parent;

  var _compilePath = compilePath(path, { end: exact, strict: strict, sensitive: sensitive }),
      re = _compilePath.re,
      keys = _compilePath.keys;

  var match = re.exec(pathname);

  if (!match) return null;

  var url = match[0],
      values = match.slice(1);

  var isExact = pathname === url;

  if (exact && !isExact) return null;

  return {
    path: path, // the path pattern used to match
    url: path === "/" && url === "" ? "/" : url, // the matched portion of the URL
    isExact: isExact, // whether or not we matched exactly
    params: keys.reduce(function (memo, key, index) {
      memo[key.name] = values[index];
      return memo;
    }, {})
  };
};

exports.default = matchPath;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var printWarning = function printWarning() {};

if (process.env.NODE_ENV !== 'production') {
  var ReactPropTypesSecret = __webpack_require__(14);
  var loggedTypeFailures = {};

  printWarning = function printWarning(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + _typeof(typeSpecs[typeSpecName]) + '`.');
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + (typeof error === 'undefined' ? 'undefined' : _typeof(error)) + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
        }
      }
    }
  }
}

module.exports = checkPropTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _warning = __webpack_require__(10);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    (0, _warning2.default)(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          (0, _warning2.default)(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

exports.default = createTransitionManager;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Router = __webpack_require__(11);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Router2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(4);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(3);

var _invariant2 = _interopRequireDefault(_invariant);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _matchPath = __webpack_require__(12);

var _matchPath2 = _interopRequireDefault(_matchPath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var isEmptyChildren = function isEmptyChildren(children) {
  return _react2.default.Children.count(children) === 0;
};

/**
 * The public API for matching a single path and rendering.
 */

var Route = function (_React$Component) {
  _inherits(Route, _React$Component);

  function Route() {
    var _temp, _this, _ret;

    _classCallCheck(this, Route);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props, _this.context.router)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Route.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        route: {
          location: this.props.location || this.context.router.route.location,
          match: this.state.match
        }
      })
    };
  };

  Route.prototype.computeMatch = function computeMatch(_ref, router) {
    var computedMatch = _ref.computedMatch,
        location = _ref.location,
        path = _ref.path,
        strict = _ref.strict,
        exact = _ref.exact,
        sensitive = _ref.sensitive;

    if (computedMatch) return computedMatch; // <Switch> already computed the match for us

    (0, _invariant2.default)(router, "You should not use <Route> or withRouter() outside a <Router>");

    var route = router.route;

    var pathname = (location || route.location).pathname;

    return (0, _matchPath2.default)(pathname, { path: path, strict: strict, exact: exact, sensitive: sensitive }, route.match);
  };

  Route.prototype.componentWillMount = function componentWillMount() {
    (0, _warning2.default)(!(this.props.component && this.props.render), "You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored");

    (0, _warning2.default)(!(this.props.component && this.props.children && !isEmptyChildren(this.props.children)), "You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored");

    (0, _warning2.default)(!(this.props.render && this.props.children && !isEmptyChildren(this.props.children)), "You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored");
  };

  Route.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
    (0, _warning2.default)(!(nextProps.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    (0, _warning2.default)(!(!nextProps.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');

    this.setState({
      match: this.computeMatch(nextProps, nextContext.router)
    });
  };

  Route.prototype.render = function render() {
    var match = this.state.match;
    var _props = this.props,
        children = _props.children,
        component = _props.component,
        render = _props.render;
    var _context$router = this.context.router,
        history = _context$router.history,
        route = _context$router.route,
        staticContext = _context$router.staticContext;

    var location = this.props.location || route.location;
    var props = { match: match, location: location, history: history, staticContext: staticContext };

    if (component) return match ? _react2.default.createElement(component, props) : null;

    if (render) return match ? render(props) : null;

    if (typeof children === "function") return children(props);

    if (children && !isEmptyChildren(children)) return _react2.default.Children.only(children);

    return null;
  };

  return Route;
}(_react2.default.Component);

Route.propTypes = {
  computedMatch: _propTypes2.default.object, // private, from <Switch>
  path: _propTypes2.default.string,
  exact: _propTypes2.default.bool,
  strict: _propTypes2.default.bool,
  sensitive: _propTypes2.default.bool,
  component: _propTypes2.default.func,
  render: _propTypes2.default.func,
  children: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.node]),
  location: _propTypes2.default.object
};
Route.contextTypes = {
  router: _propTypes2.default.shape({
    history: _propTypes2.default.object.isRequired,
    route: _propTypes2.default.object.isRequired,
    staticContext: _propTypes2.default.object
  })
};
Route.childContextTypes = {
  router: _propTypes2.default.object.isRequired
};

exports.default = Route;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pathToRegexp = __webpack_require__(25);

var _pathToRegexp2 = _interopRequireDefault(_pathToRegexp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var patternCache = {};
var cacheLimit = 10000;
var cacheCount = 0;

var compileGenerator = function compileGenerator(pattern) {
  var cacheKey = pattern;
  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});

  if (cache[pattern]) return cache[pattern];

  var compiledGenerator = _pathToRegexp2.default.compile(pattern);

  if (cacheCount < cacheLimit) {
    cache[pattern] = compiledGenerator;
    cacheCount++;
  }

  return compiledGenerator;
};

/**
 * Public API for generating a URL pathname from a pattern and parameters.
 */
var generatePath = function generatePath() {
  var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "/";
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (pattern === "/") {
    return pattern;
  }
  var generator = compileGenerator(pattern);
  return generator(params, { pretty: true });
};

exports.default = generatePath;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fetchPopularRepos = fetchPopularRepos;
exports.fetchUser = fetchUser;

var _isomorphicFetch = __webpack_require__(68);

var _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function fetchPopularRepos() {
    var language = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';

    var encodedURI = encodeURI('https://api.github.com/search/repositories?q=stars:>1+language:' + language + '&sort=stars&order=desc&type=Repositories');

    return (0, _isomorphicFetch2.default)(encodedURI).then(function (data) {
        return data.json();
    }).then(function (repos) {
        return repos.items;
    }).catch(function (err) {
        console.warn(err);
        return null;
    });
}

function fetchUser() {
    var user = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'someone';

    var encodedURI = encodeURI('https://api.github.com/users/' + user);

    return (0, _isomorphicFetch2.default)(encodedURI).then(function (data) {
        return data.json();
    }).catch(function (err) {
        console.warn(err);
        return null;
    });
}

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__(36);
} else {
  module.exports = __webpack_require__(37);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = exports.getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = exports.supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = exports.supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = exports.isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _invariant = __webpack_require__(3);

var _invariant2 = _interopRequireDefault(_invariant);

var _history = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var isModifiedEvent = function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
};

/**
 * The public API for rendering a history-aware <a>.
 */

var Link = function (_React$Component) {
  _inherits(Link, _React$Component);

  function Link() {
    var _temp, _this, _ret;

    _classCallCheck(this, Link);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {
      if (_this.props.onClick) _this.props.onClick(event);

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && // ignore everything but left clicks
      !_this.props.target && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();

          var history = _this.context.router.history;
          var _this$props = _this.props,
              replace = _this$props.replace,
              to = _this$props.to;

          if (replace) {
            history.replace(to);
          } else {
            history.push(to);
          }
        }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Link.prototype.render = function render() {
    var _props = this.props,
        replace = _props.replace,
        to = _props.to,
        innerRef = _props.innerRef,
        props = _objectWithoutProperties(_props, ["replace", "to", "innerRef"]); // eslint-disable-line no-unused-vars

    (0, _invariant2.default)(this.context.router, "You should not use <Link> outside a <Router>");

    (0, _invariant2.default)(to !== undefined, 'You must specify the "to" property');

    var history = this.context.router.history;

    var location = typeof to === "string" ? (0, _history.createLocation)(to, null, null, history.location) : to;

    var href = history.createHref(location);
    return _react2.default.createElement("a", _extends({}, props, { onClick: this.handleClick, href: href, ref: innerRef }));
  };

  return Link;
}(_react2.default.Component);

Link.propTypes = {
  onClick: _propTypes2.default.func,
  target: _propTypes2.default.string,
  replace: _propTypes2.default.bool,
  to: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]).isRequired,
  innerRef: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func])
};
Link.defaultProps = {
  replace: false
};
Link.contextTypes = {
  router: _propTypes2.default.shape({
    history: _propTypes2.default.shape({
      push: _propTypes2.default.func.isRequired,
      replace: _propTypes2.default.func.isRequired,
      createHref: _propTypes2.default.func.isRequired
    }).isRequired
  }).isRequired
};

exports.default = Link;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(4);

var _warning2 = _interopRequireDefault(_warning);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _history = __webpack_require__(5);

var _Router = __webpack_require__(11);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for a <Router> that stores location in memory.
 */

var MemoryRouter = function (_React$Component) {
  _inherits(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, MemoryRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = (0, _history.createMemoryHistory)(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  MemoryRouter.prototype.componentWillMount = function componentWillMount() {
    (0, _warning2.default)(!this.props.history, "<MemoryRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { MemoryRouter as Router }`.");
  };

  MemoryRouter.prototype.render = function render() {
    return _react2.default.createElement(_Router2.default, { history: this.history, children: this.props.children });
  };

  return MemoryRouter;
}(_react2.default.Component);

MemoryRouter.propTypes = {
  initialEntries: _propTypes2.default.array,
  initialIndex: _propTypes2.default.number,
  getUserConfirmation: _propTypes2.default.func,
  keyLength: _propTypes2.default.number,
  children: _propTypes2.default.node
};

exports.default = MemoryRouter;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Route = __webpack_require__(17);

var _Route2 = _interopRequireDefault(_Route);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Route2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isarray = __webpack_require__(56);

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp;
module.exports.parse = parse;
module.exports.compile = compile;
module.exports.tokensToFunction = tokensToFunction;
module.exports.tokensToRegExp = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile(str, options) {
  return tokensToFunction(parse(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (_typeof(tokens[i]) === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp(path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */keys);
  }

  if (isarray(path)) {
    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);
}

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _invariant = __webpack_require__(3);

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for prompting the user before navigating away
 * from a screen with a component.
 */

var Prompt = function (_React$Component) {
  _inherits(Prompt, _React$Component);

  function Prompt() {
    _classCallCheck(this, Prompt);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Prompt.prototype.enable = function enable(message) {
    if (this.unblock) this.unblock();

    this.unblock = this.context.router.history.block(message);
  };

  Prompt.prototype.disable = function disable() {
    if (this.unblock) {
      this.unblock();
      this.unblock = null;
    }
  };

  Prompt.prototype.componentWillMount = function componentWillMount() {
    (0, _invariant2.default)(this.context.router, "You should not use <Prompt> outside a <Router>");

    if (this.props.when) this.enable(this.props.message);
  };

  Prompt.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.when) {
      if (!this.props.when || this.props.message !== nextProps.message) this.enable(nextProps.message);
    } else {
      this.disable();
    }
  };

  Prompt.prototype.componentWillUnmount = function componentWillUnmount() {
    this.disable();
  };

  Prompt.prototype.render = function render() {
    return null;
  };

  return Prompt;
}(_react2.default.Component);

Prompt.propTypes = {
  when: _propTypes2.default.bool,
  message: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.string]).isRequired
};
Prompt.defaultProps = {
  when: true
};
Prompt.contextTypes = {
  router: _propTypes2.default.shape({
    history: _propTypes2.default.shape({
      block: _propTypes2.default.func.isRequired
    }).isRequired
  }).isRequired
};

exports.default = Prompt;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _warning = __webpack_require__(4);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(3);

var _invariant2 = _interopRequireDefault(_invariant);

var _history = __webpack_require__(5);

var _generatePath = __webpack_require__(18);

var _generatePath2 = _interopRequireDefault(_generatePath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for updating the location programmatically
 * with a component.
 */

var Redirect = function (_React$Component) {
  _inherits(Redirect, _React$Component);

  function Redirect() {
    _classCallCheck(this, Redirect);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Redirect.prototype.isStatic = function isStatic() {
    return this.context.router && this.context.router.staticContext;
  };

  Redirect.prototype.componentWillMount = function componentWillMount() {
    (0, _invariant2.default)(this.context.router, "You should not use <Redirect> outside a <Router>");

    if (this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidMount = function componentDidMount() {
    if (!this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var prevTo = (0, _history.createLocation)(prevProps.to);
    var nextTo = (0, _history.createLocation)(this.props.to);

    if ((0, _history.locationsAreEqual)(prevTo, nextTo)) {
      (0, _warning2.default)(false, "You tried to redirect to the same route you're currently on: " + ("\"" + nextTo.pathname + nextTo.search + "\""));
      return;
    }

    this.perform();
  };

  Redirect.prototype.computeTo = function computeTo(_ref) {
    var computedMatch = _ref.computedMatch,
        to = _ref.to;

    if (computedMatch) {
      if (typeof to === "string") {
        return (0, _generatePath2.default)(to, computedMatch.params);
      } else {
        return _extends({}, to, {
          pathname: (0, _generatePath2.default)(to.pathname, computedMatch.params)
        });
      }
    }

    return to;
  };

  Redirect.prototype.perform = function perform() {
    var history = this.context.router.history;
    var push = this.props.push;

    var to = this.computeTo(this.props);

    if (push) {
      history.push(to);
    } else {
      history.replace(to);
    }
  };

  Redirect.prototype.render = function render() {
    return null;
  };

  return Redirect;
}(_react2.default.Component);

Redirect.propTypes = {
  computedMatch: _propTypes2.default.object, // private, from <Switch>
  push: _propTypes2.default.bool,
  from: _propTypes2.default.string,
  to: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]).isRequired
};
Redirect.defaultProps = {
  push: false
};
Redirect.contextTypes = {
  router: _propTypes2.default.shape({
    history: _propTypes2.default.shape({
      push: _propTypes2.default.func.isRequired,
      replace: _propTypes2.default.func.isRequired
    }).isRequired,
    staticContext: _propTypes2.default.object
  }).isRequired
};

exports.default = Redirect;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(4);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(3);

var _invariant2 = _interopRequireDefault(_invariant);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _history = __webpack_require__(5);

var _Router = __webpack_require__(11);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
};

var addBasename = function addBasename(basename, location) {
  if (!basename) return location;

  return _extends({}, location, {
    pathname: addLeadingSlash(basename) + location.pathname
  });
};

var stripBasename = function stripBasename(basename, location) {
  if (!basename) return location;

  var base = addLeadingSlash(basename);

  if (location.pathname.indexOf(base) !== 0) return location;

  return _extends({}, location, {
    pathname: location.pathname.substr(base.length)
  });
};

var createURL = function createURL(location) {
  return typeof location === "string" ? location : (0, _history.createPath)(location);
};

var staticHandler = function staticHandler(methodName) {
  return function () {
    (0, _invariant2.default)(false, "You cannot %s with <StaticRouter>", methodName);
  };
};

var noop = function noop() {};

/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */

var StaticRouter = function (_React$Component) {
  _inherits(StaticRouter, _React$Component);

  function StaticRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, StaticRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.createHref = function (path) {
      return addLeadingSlash(_this.props.basename + createURL(path));
    }, _this.handlePush = function (location) {
      var _this$props = _this.props,
          basename = _this$props.basename,
          context = _this$props.context;

      context.action = "PUSH";
      context.location = addBasename(basename, (0, _history.createLocation)(location));
      context.url = createURL(context.location);
    }, _this.handleReplace = function (location) {
      var _this$props2 = _this.props,
          basename = _this$props2.basename,
          context = _this$props2.context;

      context.action = "REPLACE";
      context.location = addBasename(basename, (0, _history.createLocation)(location));
      context.url = createURL(context.location);
    }, _this.handleListen = function () {
      return noop;
    }, _this.handleBlock = function () {
      return noop;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  StaticRouter.prototype.getChildContext = function getChildContext() {
    return {
      router: {
        staticContext: this.props.context
      }
    };
  };

  StaticRouter.prototype.componentWillMount = function componentWillMount() {
    (0, _warning2.default)(!this.props.history, "<StaticRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { StaticRouter as Router }`.");
  };

  StaticRouter.prototype.render = function render() {
    var _props = this.props,
        basename = _props.basename,
        context = _props.context,
        location = _props.location,
        props = _objectWithoutProperties(_props, ["basename", "context", "location"]);

    var history = {
      createHref: this.createHref,
      action: "POP",
      location: stripBasename(basename, (0, _history.createLocation)(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler("go"),
      goBack: staticHandler("goBack"),
      goForward: staticHandler("goForward"),
      listen: this.handleListen,
      block: this.handleBlock
    };

    return _react2.default.createElement(_Router2.default, _extends({}, props, { history: history }));
  };

  return StaticRouter;
}(_react2.default.Component);

StaticRouter.propTypes = {
  basename: _propTypes2.default.string,
  context: _propTypes2.default.object.isRequired,
  location: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object])
};
StaticRouter.defaultProps = {
  basename: "",
  location: "/"
};
StaticRouter.childContextTypes = {
  router: _propTypes2.default.object.isRequired
};

exports.default = StaticRouter;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _warning = __webpack_require__(4);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(3);

var _invariant2 = _interopRequireDefault(_invariant);

var _matchPath = __webpack_require__(12);

var _matchPath2 = _interopRequireDefault(_matchPath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch = function (_React$Component) {
  _inherits(Switch, _React$Component);

  function Switch() {
    _classCallCheck(this, Switch);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Switch.prototype.componentWillMount = function componentWillMount() {
    (0, _invariant2.default)(this.context.router, "You should not use <Switch> outside a <Router>");
  };

  Switch.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    (0, _warning2.default)(!(nextProps.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    (0, _warning2.default)(!(!nextProps.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');
  };

  Switch.prototype.render = function render() {
    var route = this.context.router.route;
    var children = this.props.children;

    var location = this.props.location || route.location;

    var match = void 0,
        child = void 0;
    _react2.default.Children.forEach(children, function (element) {
      if (match == null && _react2.default.isValidElement(element)) {
        var _element$props = element.props,
            pathProp = _element$props.path,
            exact = _element$props.exact,
            strict = _element$props.strict,
            sensitive = _element$props.sensitive,
            from = _element$props.from;

        var path = pathProp || from;

        child = element;
        match = (0, _matchPath2.default)(location.pathname, { path: path, exact: exact, strict: strict, sensitive: sensitive }, route.match);
      }
    });

    return match ? _react2.default.cloneElement(child, { location: location, computedMatch: match }) : null;
  };

  return Switch;
}(_react2.default.Component);

Switch.contextTypes = {
  router: _propTypes2.default.shape({
    route: _propTypes2.default.object.isRequired
  }).isRequired
};
Switch.propTypes = {
  children: _propTypes2.default.node,
  location: _propTypes2.default.object
};

exports.default = Switch;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _hoistNonReactStatics = __webpack_require__(64);

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _Route = __webpack_require__(17);

var _Route2 = _interopRequireDefault(_Route);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

/**
 * A public higher-order component to access the imperative API
 */
var withRouter = function withRouter(Component) {
  var C = function C(props) {
    var wrappedComponentRef = props.wrappedComponentRef,
        remainingProps = _objectWithoutProperties(props, ["wrappedComponentRef"]);

    return _react2.default.createElement(_Route2.default, {
      children: function children(routeComponentProps) {
        return _react2.default.createElement(Component, _extends({}, remainingProps, routeComponentProps, {
          ref: wrappedComponentRef
        }));
      }
    });
  };

  C.displayName = "withRouter(" + (Component.displayName || Component.name) + ")";
  C.WrappedComponent = Component;
  C.propTypes = {
    wrappedComponentRef: _propTypes2.default.func
  };

  return (0, _hoistNonReactStatics2.default)(C, Component);
};

exports.default = withRouter;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(34);

var _App = __webpack_require__(42);

var _App2 = _interopRequireDefault(_App);

var _reactRouterDom = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _reactDom.hydrate)(_react2.default.createElement(
    _reactRouterDom.BrowserRouter,
    null,
    _react2.default.createElement(_App2.default, { data: window.__INITIAL_DATA__ })
), document.getElementById('app'));

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.5.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var m = __webpack_require__(6),
    n = "function" === typeof Symbol && Symbol.for,
    p = n ? Symbol.for("react.element") : 60103,
    q = n ? Symbol.for("react.portal") : 60106,
    r = n ? Symbol.for("react.fragment") : 60107,
    t = n ? Symbol.for("react.strict_mode") : 60108,
    u = n ? Symbol.for("react.profiler") : 60114,
    v = n ? Symbol.for("react.provider") : 60109,
    w = n ? Symbol.for("react.context") : 60110,
    x = n ? Symbol.for("react.async_mode") : 60111,
    y = n ? Symbol.for("react.forward_ref") : 60112;n && Symbol.for("react.placeholder");
var z = "function" === typeof Symbol && Symbol.iterator;function A(a, b, d, c, e, g, h, f) {
  if (!a) {
    a = void 0;if (void 0 === b) a = Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else {
      var k = [d, c, e, g, h, f],
          l = 0;a = Error(b.replace(/%s/g, function () {
        return k[l++];
      }));a.name = "Invariant Violation";
    }a.framesToPop = 1;throw a;
  }
}
function B(a) {
  for (var b = arguments.length - 1, d = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 0; c < b; c++) {
    d += "&args[]=" + encodeURIComponent(arguments[c + 1]);
  }A(!1, "Minified React error #" + a + "; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ", d);
}var C = { isMounted: function isMounted() {
    return !1;
  }, enqueueForceUpdate: function enqueueForceUpdate() {}, enqueueReplaceState: function enqueueReplaceState() {}, enqueueSetState: function enqueueSetState() {} },
    D = {};
function E(a, b, d) {
  this.props = a;this.context = b;this.refs = D;this.updater = d || C;
}E.prototype.isReactComponent = {};E.prototype.setState = function (a, b) {
  "object" !== (typeof a === "undefined" ? "undefined" : _typeof(a)) && "function" !== typeof a && null != a ? B("85") : void 0;this.updater.enqueueSetState(this, a, b, "setState");
};E.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};function F() {}F.prototype = E.prototype;function G(a, b, d) {
  this.props = a;this.context = b;this.refs = D;this.updater = d || C;
}var H = G.prototype = new F();
H.constructor = G;m(H, E.prototype);H.isPureReactComponent = !0;var I = { current: null, currentDispatcher: null },
    J = Object.prototype.hasOwnProperty,
    K = { key: !0, ref: !0, __self: !0, __source: !0 };
function L(a, b, d) {
  var c = void 0,
      e = {},
      g = null,
      h = null;if (null != b) for (c in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (g = "" + b.key), b) {
    J.call(b, c) && !K.hasOwnProperty(c) && (e[c] = b[c]);
  }var f = arguments.length - 2;if (1 === f) e.children = d;else if (1 < f) {
    for (var k = Array(f), l = 0; l < f; l++) {
      k[l] = arguments[l + 2];
    }e.children = k;
  }if (a && a.defaultProps) for (c in f = a.defaultProps, f) {
    void 0 === e[c] && (e[c] = f[c]);
  }return { $$typeof: p, type: a, key: g, ref: h, props: e, _owner: I.current };
}
function M(a, b) {
  return { $$typeof: p, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
}function N(a) {
  return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && a.$$typeof === p;
}function escape(a) {
  var b = { "=": "=0", ":": "=2" };return "$" + ("" + a).replace(/[=:]/g, function (a) {
    return b[a];
  });
}var O = /\/+/g,
    P = [];function Q(a, b, d, c) {
  if (P.length) {
    var e = P.pop();e.result = a;e.keyPrefix = b;e.func = d;e.context = c;e.count = 0;return e;
  }return { result: a, keyPrefix: b, func: d, context: c, count: 0 };
}
function R(a) {
  a.result = null;a.keyPrefix = null;a.func = null;a.context = null;a.count = 0;10 > P.length && P.push(a);
}
function S(a, b, d, c) {
  var e = typeof a === "undefined" ? "undefined" : _typeof(a);if ("undefined" === e || "boolean" === e) a = null;var g = !1;if (null === a) g = !0;else switch (e) {case "string":case "number":
      g = !0;break;case "object":
      switch (a.$$typeof) {case p:case q:
          g = !0;}}if (g) return d(c, a, "" === b ? "." + T(a, 0) : b), 1;g = 0;b = "" === b ? "." : b + ":";if (Array.isArray(a)) for (var h = 0; h < a.length; h++) {
    e = a[h];var f = b + T(e, h);g += S(e, f, d, c);
  } else if (null === a || "object" !== (typeof a === "undefined" ? "undefined" : _typeof(a)) ? f = null : (f = z && a[z] || a["@@iterator"], f = "function" === typeof f ? f : null), "function" === typeof f) for (a = f.call(a), h = 0; !(e = a.next()).done;) {
    e = e.value, f = b + T(e, h++), g += S(e, f, d, c);
  } else "object" === e && (d = "" + a, B("31", "[object Object]" === d ? "object with keys {" + Object.keys(a).join(", ") + "}" : d, ""));return g;
}function U(a, b, d) {
  return null == a ? 0 : S(a, "", b, d);
}function T(a, b) {
  return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && null != a.key ? escape(a.key) : b.toString(36);
}function V(a, b) {
  a.func.call(a.context, b, a.count++);
}
function aa(a, b, d) {
  var c = a.result,
      e = a.keyPrefix;a = a.func.call(a.context, b, a.count++);Array.isArray(a) ? W(a, c, d, function (a) {
    return a;
  }) : null != a && (N(a) && (a = M(a, e + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(O, "$&/") + "/") + d)), c.push(a));
}function W(a, b, d, c, e) {
  var g = "";null != d && (g = ("" + d).replace(O, "$&/") + "/");b = Q(b, g, c, e);U(a, aa, b);R(b);
}function ba(a, b) {
  var d = I.currentDispatcher;null === d ? B("277") : void 0;return d.readContext(a, b);
}
var X = { Children: { map: function map(a, b, d) {
      if (null == a) return a;var c = [];W(a, c, null, b, d);return c;
    }, forEach: function forEach(a, b, d) {
      if (null == a) return a;b = Q(null, null, b, d);U(a, V, b);R(b);
    }, count: function count(a) {
      return U(a, function () {
        return null;
      }, null);
    }, toArray: function toArray(a) {
      var b = [];W(a, b, null, function (a) {
        return a;
      });return b;
    }, only: function only(a) {
      N(a) ? void 0 : B("143");return a;
    } }, createRef: function createRef() {
    return { current: null };
  }, Component: E, PureComponent: G, createContext: function createContext(a, b) {
    void 0 === b && (b = null);a = { $$typeof: w, _calculateChangedBits: b,
      _currentValue: a, _currentValue2: a, Provider: null, Consumer: null, unstable_read: null };a.Provider = { $$typeof: v, _context: a };a.Consumer = a;a.unstable_read = ba.bind(null, a);return a;
  }, forwardRef: function forwardRef(a) {
    return { $$typeof: y, render: a };
  }, Fragment: r, StrictMode: t, unstable_AsyncMode: x, unstable_Profiler: u, createElement: L, cloneElement: function cloneElement(a, b, d) {
    null === a || void 0 === a ? B("267", a) : void 0;var c = void 0,
        e = m({}, a.props),
        g = a.key,
        h = a.ref,
        f = a._owner;if (null != b) {
      void 0 !== b.ref && (h = b.ref, f = I.current);void 0 !== b.key && (g = "" + b.key);
      var k = void 0;a.type && a.type.defaultProps && (k = a.type.defaultProps);for (c in b) {
        J.call(b, c) && !K.hasOwnProperty(c) && (e[c] = void 0 === b[c] && void 0 !== k ? k[c] : b[c]);
      }
    }c = arguments.length - 2;if (1 === c) e.children = d;else if (1 < c) {
      k = Array(c);for (var l = 0; l < c; l++) {
        k[l] = arguments[l + 2];
      }e.children = k;
    }return { $$typeof: p, type: a.type, key: g, ref: h, props: e, _owner: f };
  }, createFactory: function createFactory(a) {
    var b = L.bind(null, a);b.type = a;return b;
  }, isValidElement: N, version: "16.5.2", __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { ReactCurrentOwner: I,
    assign: m } },
    Y = { default: X },
    Z = Y && X || Y;module.exports = Z.default || Z;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.5.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== "production") {
  (function () {
    'use strict';

    var _assign = __webpack_require__(6);
    var checkPropTypes = __webpack_require__(13);

    // TODO: this is special because it gets imported during build.

    var ReactVersion = '16.5.2';

    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var hasSymbol = typeof Symbol === 'function' && Symbol.for;

    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
    var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
    var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
    var REACT_PLACEHOLDER_TYPE = hasSymbol ? Symbol.for('react.placeholder') : 0xead1;

    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';

    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || (typeof maybeIterable === 'undefined' ? 'undefined' : _typeof(maybeIterable)) !== 'object') {
        return null;
      }
      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
      if (typeof maybeIterator === 'function') {
        return maybeIterator;
      }
      return null;
    }

    // Exports ReactDOM.createRoot


    // Experimental error-boundary API that can recover from errors within a single
    // render phase

    // Suspense
    var enableSuspense = false;
    // Helps identify side effects in begin-phase lifecycle hooks and setState reducers:


    // In some cases, StrictMode should also double-render lifecycles.
    // This can be confusing for tests though,
    // And it can be bad for performance in production.
    // This feature flag can be used to control the behavior:


    // To preserve the "Pause on caught exceptions" behavior of the debugger, we
    // replay the begin phase of a failed component inside invokeGuardedCallback.


    // Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:


    // Warn about legacy context API


    // Gather advanced timing metrics for Profiler subtrees.


    // Trace which interactions trigger each commit.


    // Only used in www builds.


    // Only used in www builds.


    // React Fire: prevent the value and checked attributes from syncing
    // with their related DOM properties

    /**
     * Use invariant() to assert state which your program assumes to be true.
     *
     * Provide sprintf-style format (only %s is supported) and arguments
     * to provide information about what broke and what you were
     * expecting.
     *
     * The invariant message will be stripped in production, but the invariant
     * will remain to ensure logic does not differ in production.
     */

    var validateFormat = function validateFormat() {};

    {
      validateFormat = function validateFormat(format) {
        if (format === undefined) {
          throw new Error('invariant requires an error message argument');
        }
      };
    }

    function invariant(condition, format, a, b, c, d, e, f) {
      validateFormat(format);

      if (!condition) {
        var error = void 0;
        if (format === undefined) {
          error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(format.replace(/%s/g, function () {
            return args[argIndex++];
          }));
          error.name = 'Invariant Violation';
        }

        error.framesToPop = 1; // we don't care about invariant's own frame
        throw error;
      }
    }

    // Relying on the `invariant()` implementation lets us
    // preserve the format and params in the www builds.

    /**
     * Forked from fbjs/warning:
     * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
     *
     * Only change is we use console.warn instead of console.error,
     * and do nothing when 'console' is not supported.
     * This really simplifies the code.
     * ---
     * Similar to invariant but only logs a warning if the condition is not met.
     * This can be used to log issues in development environments in critical
     * paths. Removing the logging code for production environments will keep the
     * same logic and follow the same code paths.
     */

    var lowPriorityWarning = function lowPriorityWarning() {};

    {
      var printWarning = function printWarning(format) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function () {
          return args[argIndex++];
        });
        if (typeof console !== 'undefined') {
          console.warn(message);
        }
        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };

      lowPriorityWarning = function lowPriorityWarning(condition, format) {
        if (format === undefined) {
          throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
        }
        if (!condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          printWarning.apply(undefined, [format].concat(args));
        }
      };
    }

    var lowPriorityWarning$1 = lowPriorityWarning;

    /**
     * Similar to invariant but only logs a warning if the condition is not met.
     * This can be used to log issues in development environments in critical
     * paths. Removing the logging code for production environments will keep the
     * same logic and follow the same code paths.
     */

    var warningWithoutStack = function warningWithoutStack() {};

    {
      warningWithoutStack = function warningWithoutStack(condition, format) {
        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        if (format === undefined) {
          throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
        }
        if (args.length > 8) {
          // Check before the condition to catch violations early.
          throw new Error('warningWithoutStack() currently supports at most 8 arguments.');
        }
        if (condition) {
          return;
        }
        if (typeof console !== 'undefined') {
          var _args$map = args.map(function (item) {
            return '' + item;
          }),
              a = _args$map[0],
              b = _args$map[1],
              c = _args$map[2],
              d = _args$map[3],
              e = _args$map[4],
              f = _args$map[5],
              g = _args$map[6],
              h = _args$map[7];

          var message = 'Warning: ' + format;

          // We intentionally don't use spread (or .apply) because it breaks IE9:
          // https://github.com/facebook/react/issues/13610
          switch (args.length) {
            case 0:
              console.error(message);
              break;
            case 1:
              console.error(message, a);
              break;
            case 2:
              console.error(message, a, b);
              break;
            case 3:
              console.error(message, a, b, c);
              break;
            case 4:
              console.error(message, a, b, c, d);
              break;
            case 5:
              console.error(message, a, b, c, d, e);
              break;
            case 6:
              console.error(message, a, b, c, d, e, f);
              break;
            case 7:
              console.error(message, a, b, c, d, e, f, g);
              break;
            case 8:
              console.error(message, a, b, c, d, e, f, g, h);
              break;
            default:
              throw new Error('warningWithoutStack() currently supports at most 8 arguments.');
          }
        }
        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          var argIndex = 0;
          var _message = 'Warning: ' + format.replace(/%s/g, function () {
            return args[argIndex++];
          });
          throw new Error(_message);
        } catch (x) {}
      };
    }

    var warningWithoutStack$1 = warningWithoutStack;

    var didWarnStateUpdateForUnmountedComponent = {};

    function warnNoop(publicInstance, callerName) {
      {
        var _constructor = publicInstance.constructor;
        var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
        var warningKey = componentName + '.' + callerName;
        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
          return;
        }
        warningWithoutStack$1(false, "Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
        didWarnStateUpdateForUnmountedComponent[warningKey] = true;
      }
    }

    /**
     * This is the abstract API for an update queue.
     */
    var ReactNoopUpdateQueue = {
      /**
       * Checks whether or not this composite component is mounted.
       * @param {ReactClass} publicInstance The instance we want to test.
       * @return {boolean} True if mounted, false otherwise.
       * @protected
       * @final
       */
      isMounted: function isMounted(publicInstance) {
        return false;
      },

      /**
       * Forces an update. This should only be invoked when it is known with
       * certainty that we are **not** in a DOM transaction.
       *
       * You may want to call this when you know that some deeper aspect of the
       * component's state has changed but `setState` was not called.
       *
       * This will not invoke `shouldComponentUpdate`, but it will invoke
       * `componentWillUpdate` and `componentDidUpdate`.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {
        warnNoop(publicInstance, 'forceUpdate');
      },

      /**
       * Replaces all of the state. Always use this or `setState` to mutate state.
       * You should treat `this.state` as immutable.
       *
       * There is no guarantee that `this.state` will be immediately updated, so
       * accessing `this.state` after calling this method may return the old value.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} completeState Next state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {
        warnNoop(publicInstance, 'replaceState');
      },

      /**
       * Sets a subset of the state. This only exists because _pendingState is
       * internal. This provides a merging strategy that is not available to deep
       * properties which is confusing. TODO: Expose pendingState or don't use it
       * during the merge.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} partialState Next partial state to be merged with state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} Name of the calling function in the public API.
       * @internal
       */
      enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {
        warnNoop(publicInstance, 'setState');
      }
    };

    var emptyObject = {};
    {
      Object.freeze(emptyObject);
    }

    /**
     * Base class helpers for the updating state of a component.
     */
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      // If a component has string refs, we will assign a different object later.
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    Component.prototype.isReactComponent = {};

    /**
     * Sets a subset of the state. Always use this to mutate
     * state. You should treat `this.state` as immutable.
     *
     * There is no guarantee that `this.state` will be immediately updated, so
     * accessing `this.state` after calling this method may return the old value.
     *
     * There is no guarantee that calls to `setState` will run synchronously,
     * as they may eventually be batched together.  You can provide an optional
     * callback that will be executed when the call to setState is actually
     * completed.
     *
     * When a function is provided to setState, it will be called at some point in
     * the future (not synchronously). It will be called with the up to date
     * component arguments (state, props, context). These values can be different
     * from this.* because your function may be called after receiveProps but before
     * shouldComponentUpdate, and this new state, props, and context will not yet be
     * assigned to this.
     *
     * @param {object|function} partialState Next partial state or function to
     *        produce next partial state to be merged with current state.
     * @param {?function} callback Called after state is updated.
     * @final
     * @protected
     */
    Component.prototype.setState = function (partialState, callback) {
      !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
      this.updater.enqueueSetState(this, partialState, callback, 'setState');
    };

    /**
     * Forces an update. This should only be invoked when it is known with
     * certainty that we are **not** in a DOM transaction.
     *
     * You may want to call this when you know that some deeper aspect of the
     * component's state has changed but `setState` was not called.
     *
     * This will not invoke `shouldComponentUpdate`, but it will invoke
     * `componentWillUpdate` and `componentDidUpdate`.
     *
     * @param {?function} callback Called after update is complete.
     * @final
     * @protected
     */
    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
    };

    /**
     * Deprecated APIs. These APIs used to exist on classic React classes but since
     * we would like to deprecate them, we're not going to move them over to this
     * modern base class. Instead, we define a getter that warns if it's accessed.
     */
    {
      var deprecatedAPIs = {
        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
      };
      var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
          get: function get() {
            lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
            return undefined;
          }
        });
      };
      for (var fnName in deprecatedAPIs) {
        if (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }

    function ComponentDummy() {}
    ComponentDummy.prototype = Component.prototype;

    /**
     * Convenience component with default shallow equality check for sCU.
     */
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      // If a component has string refs, we will assign a different object later.
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }

    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    // Avoid an extra prototype jump for these methods.
    _assign(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;

    // an immutable object with a single mutable value
    function createRef() {
      var refObject = {
        current: null
      };
      {
        Object.seal(refObject);
      }
      return refObject;
    }

    /**
     * Keeps track of the current owner.
     *
     * The current owner is the component who should own any components that are
     * currently being constructed.
     */
    var ReactCurrentOwner = {
      /**
       * @internal
       * @type {ReactComponent}
       */
      current: null,
      currentDispatcher: null
    };

    var BEFORE_SLASH_RE = /^(.*)[\\\/]/;

    var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
      var sourceInfo = '';
      if (source) {
        var path = source.fileName;
        var fileName = path.replace(BEFORE_SLASH_RE, '');
        {
          // In DEV, include code for a common special case:
          // prefer "folder/index.js" instead of just "index.js".
          if (/^index\./.test(fileName)) {
            var match = path.match(BEFORE_SLASH_RE);
            if (match) {
              var pathBeforeSlash = match[1];
              if (pathBeforeSlash) {
                var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');
                fileName = folderName + '/' + fileName;
              }
            }
          }
        }
        sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
      } else if (ownerName) {
        sourceInfo = ' (created by ' + ownerName + ')';
      }
      return '\n    in ' + (name || 'Unknown') + sourceInfo;
    };

    var Resolved = 1;

    function refineResolvedThenable(thenable) {
      return thenable._reactStatus === Resolved ? thenable._reactResult : null;
    }

    function getComponentName(type) {
      if (type == null) {
        // Host root, text node or just invalid type.
        return null;
      }
      {
        if (typeof type.tag === 'number') {
          warningWithoutStack$1(false, 'Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
        }
      }
      if (typeof type === 'function') {
        return type.displayName || type.name || null;
      }
      if (typeof type === 'string') {
        return type;
      }
      switch (type) {
        case REACT_ASYNC_MODE_TYPE:
          return 'AsyncMode';
        case REACT_FRAGMENT_TYPE:
          return 'Fragment';
        case REACT_PORTAL_TYPE:
          return 'Portal';
        case REACT_PROFILER_TYPE:
          return 'Profiler';
        case REACT_STRICT_MODE_TYPE:
          return 'StrictMode';
        case REACT_PLACEHOLDER_TYPE:
          return 'Placeholder';
      }
      if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {
        switch (type.$$typeof) {
          case REACT_CONTEXT_TYPE:
            return 'Context.Consumer';
          case REACT_PROVIDER_TYPE:
            return 'Context.Provider';
          case REACT_FORWARD_REF_TYPE:
            var renderFn = type.render;
            var functionName = renderFn.displayName || renderFn.name || '';
            return type.displayName || (functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef');
        }
        if (typeof type.then === 'function') {
          var thenable = type;
          var resolvedThenable = refineResolvedThenable(thenable);
          if (resolvedThenable) {
            return getComponentName(resolvedThenable);
          }
        }
      }
      return null;
    }

    var ReactDebugCurrentFrame = {};

    var currentlyValidatingElement = null;

    function setCurrentlyValidatingElement(element) {
      {
        currentlyValidatingElement = element;
      }
    }

    {
      // Stack implementation injected by the current renderer.
      ReactDebugCurrentFrame.getCurrentStack = null;

      ReactDebugCurrentFrame.getStackAddendum = function () {
        var stack = '';

        // Add an extra top frame while an element is being validated
        if (currentlyValidatingElement) {
          var name = getComponentName(currentlyValidatingElement.type);
          var owner = currentlyValidatingElement._owner;
          stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));
        }

        // Delegate to the injected renderer-specific implementation
        var impl = ReactDebugCurrentFrame.getCurrentStack;
        if (impl) {
          stack += impl() || '';
        }

        return stack;
      };
    }

    var ReactSharedInternals = {
      ReactCurrentOwner: ReactCurrentOwner,
      // Used by renderers to avoid bundling object-assign twice in UMD bundles:
      assign: _assign
    };

    {
      _assign(ReactSharedInternals, {
        // These should not be included in production.
        ReactDebugCurrentFrame: ReactDebugCurrentFrame,
        // Shim for React DOM 16.0.0 which still destructured (but not used) this.
        // TODO: remove in React 17.0.
        ReactComponentTreeHook: {}
      });
    }

    /**
     * Similar to invariant but only logs a warning if the condition is not met.
     * This can be used to log issues in development environments in critical
     * paths. Removing the logging code for production environments will keep the
     * same logic and follow the same code paths.
     */

    var warning = warningWithoutStack$1;

    {
      warning = function warning(condition, format) {
        if (condition) {
          return;
        }
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();
        // eslint-disable-next-line react-internal/warning-and-invariant-args

        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        warningWithoutStack$1.apply(undefined, [false, format + '%s'].concat(args, [stack]));
      };
    }

    var warning$1 = warning;

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };

    var specialPropKeyWarningShown = void 0;
    var specialPropRefWarningShown = void 0;

    function hasValidRef(config) {
      {
        if (hasOwnProperty.call(config, 'ref')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.ref !== undefined;
    }

    function hasValidKey(config) {
      {
        if (hasOwnProperty.call(config, 'key')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.key !== undefined;
    }

    function defineKeyPropWarningGetter(props, displayName) {
      var warnAboutAccessingKey = function warnAboutAccessingKey() {
        if (!specialPropKeyWarningShown) {
          specialPropKeyWarningShown = true;
          warningWithoutStack$1(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, 'key', {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }

    function defineRefPropWarningGetter(props, displayName) {
      var warnAboutAccessingRef = function warnAboutAccessingRef() {
        if (!specialPropRefWarningShown) {
          specialPropRefWarningShown = true;
          warningWithoutStack$1(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };
      warnAboutAccessingRef.isReactWarning = true;
      Object.defineProperty(props, 'ref', {
        get: warnAboutAccessingRef,
        configurable: true
      });
    }

    /**
     * Factory method to create a new React element. This no longer adheres to
     * the class pattern, so do not use new to call it. Also, no instanceof check
     * will work. Instead test $$typeof field against Symbol.for('react.element') to check
     * if something is a React Element.
     *
     * @param {*} type
     * @param {*} key
     * @param {string|object} ref
     * @param {*} self A *temporary* helper to detect places where `this` is
     * different from the `owner` when React.createElement is called, so that we
     * can warn. We want to get rid of owner and replace string `ref`s with arrow
     * functions, and as long as `this` and owner are the same, there will be no
     * change in behavior.
     * @param {*} source An annotation object (added by a transpiler or otherwise)
     * indicating filename, line number, and/or other information.
     * @param {*} owner
     * @param {*} props
     * @internal
     */
    var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
      var element = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: REACT_ELEMENT_TYPE,

        // Built-in properties that belong on the element
        type: type,
        key: key,
        ref: ref,
        props: props,

        // Record the component responsible for creating this element.
        _owner: owner
      };

      {
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {};

        // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.
        Object.defineProperty(element._store, 'validated', {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        });
        // self and source are DEV only properties.
        Object.defineProperty(element, '_self', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        });
        // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.
        Object.defineProperty(element, '_source', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });
        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }

      return element;
    };

    /**
     * Create and return a new ReactElement of the given type.
     * See https://reactjs.org/docs/react-api.html#createelement
     */
    function createElement(type, config, children) {
      var propName = void 0;

      // Reserved names are extracted
      var props = {};

      var key = null;
      var ref = null;
      var self = null;
      var source = null;

      if (config != null) {
        if (hasValidRef(config)) {
          ref = config.ref;
        }
        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        self = config.__self === undefined ? null : config.__self;
        source = config.__source === undefined ? null : config.__source;
        // Remaining properties are added to a new props object
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      }

      // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        {
          if (Object.freeze) {
            Object.freeze(childArray);
          }
        }
        props.children = childArray;
      }

      // Resolve default props
      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;
        for (propName in defaultProps) {
          if (props[propName] === undefined) {
            props[propName] = defaultProps[propName];
          }
        }
      }
      {
        if (key || ref) {
          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
          if (key) {
            defineKeyPropWarningGetter(props, displayName);
          }
          if (ref) {
            defineRefPropWarningGetter(props, displayName);
          }
        }
      }
      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    }

    /**
     * Return a function that produces ReactElements of a given type.
     * See https://reactjs.org/docs/react-api.html#createfactory
     */

    function cloneAndReplaceKey(oldElement, newKey) {
      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

      return newElement;
    }

    /**
     * Clone and return a new ReactElement using element as the starting point.
     * See https://reactjs.org/docs/react-api.html#cloneelement
     */
    function cloneElement(element, config, children) {
      !!(element === null || element === undefined) ? invariant(false, 'React.cloneElement(...): The argument must be a React element, but you passed %s.', element) : void 0;

      var propName = void 0;

      // Original props are copied
      var props = _assign({}, element.props);

      // Reserved names are extracted
      var key = element.key;
      var ref = element.ref;
      // Self is preserved since the owner is preserved.
      var self = element._self;
      // Source is preserved since cloneElement is unlikely to be targeted by a
      // transpiler, and the original source is probably a better indicator of the
      // true owner.
      var source = element._source;

      // Owner will be preserved, unless ref is overridden
      var owner = element._owner;

      if (config != null) {
        if (hasValidRef(config)) {
          // Silently steal the ref from the parent.
          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }
        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        // Remaining properties override existing props
        var defaultProps = void 0;
        if (element.type && element.type.defaultProps) {
          defaultProps = element.type.defaultProps;
        }
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            if (config[propName] === undefined && defaultProps !== undefined) {
              // Resolve default props
              props[propName] = defaultProps[propName];
            } else {
              props[propName] = config[propName];
            }
          }
        }
      }

      // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }

      return ReactElement(element.type, key, ref, self, source, owner, props);
    }

    /**
     * Verifies the object is a ReactElement.
     * See https://reactjs.org/docs/react-api.html#isvalidelement
     * @param {?object} object
     * @return {boolean} True if `object` is a ReactElement.
     * @final
     */
    function isValidElement(object) {
      return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }

    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';

    /**
     * Escape and wrap key so it is safe to use as a reactid
     *
     * @param {string} key to be escaped.
     * @return {string} the escaped key.
     */
    function escape(key) {
      var escapeRegex = /[=:]/g;
      var escaperLookup = {
        '=': '=0',
        ':': '=2'
      };
      var escapedString = ('' + key).replace(escapeRegex, function (match) {
        return escaperLookup[match];
      });

      return '$' + escapedString;
    }

    /**
     * TODO: Test that a single child and an array with one item have the same key
     * pattern.
     */

    var didWarnAboutMaps = false;

    var userProvidedKeyEscapeRegex = /\/+/g;
    function escapeUserProvidedKey(text) {
      return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
    }

    var POOL_SIZE = 10;
    var traverseContextPool = [];
    function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
      if (traverseContextPool.length) {
        var traverseContext = traverseContextPool.pop();
        traverseContext.result = mapResult;
        traverseContext.keyPrefix = keyPrefix;
        traverseContext.func = mapFunction;
        traverseContext.context = mapContext;
        traverseContext.count = 0;
        return traverseContext;
      } else {
        return {
          result: mapResult,
          keyPrefix: keyPrefix,
          func: mapFunction,
          context: mapContext,
          count: 0
        };
      }
    }

    function releaseTraverseContext(traverseContext) {
      traverseContext.result = null;
      traverseContext.keyPrefix = null;
      traverseContext.func = null;
      traverseContext.context = null;
      traverseContext.count = 0;
      if (traverseContextPool.length < POOL_SIZE) {
        traverseContextPool.push(traverseContext);
      }
    }

    /**
     * @param {?*} children Children tree container.
     * @param {!string} nameSoFar Name of the key path so far.
     * @param {!function} callback Callback to invoke with each child found.
     * @param {?*} traverseContext Used to pass information throughout the traversal
     * process.
     * @return {!number} The number of children in this subtree.
     */
    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
      var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);

      if (type === 'undefined' || type === 'boolean') {
        // All of the above are perceived as null.
        children = null;
      }

      var invokeCallback = false;

      if (children === null) {
        invokeCallback = true;
      } else {
        switch (type) {
          case 'string':
          case 'number':
            invokeCallback = true;
            break;
          case 'object':
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
            }
        }
      }

      if (invokeCallback) {
        callback(traverseContext, children,
        // If it's the only child, treat the name as if it was wrapped in an array
        // so that it's consistent if the number of children grows.
        nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
        return 1;
      }

      var child = void 0;
      var nextName = void 0;
      var subtreeCount = 0; // Count of children found in the current subtree.
      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        var iteratorFn = getIteratorFn(children);
        if (typeof iteratorFn === 'function') {
          {
            // Warn about using Maps as children
            if (iteratorFn === children.entries) {
              !didWarnAboutMaps ? warning$1(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.') : void 0;
              didWarnAboutMaps = true;
            }
          }

          var iterator = iteratorFn.call(children);
          var step = void 0;
          var ii = 0;
          while (!(step = iterator.next()).done) {
            child = step.value;
            nextName = nextNamePrefix + getComponentKey(child, ii++);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        } else if (type === 'object') {
          var addendum = '';
          {
            addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
          }
          var childrenString = '' + children;
          invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
        }
      }

      return subtreeCount;
    }

    /**
     * Traverses children that are typically specified as `props.children`, but
     * might also be specified through attributes:
     *
     * - `traverseAllChildren(this.props.children, ...)`
     * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
     *
     * The `traverseContext` is an optional argument that is passed through the
     * entire traversal. It can be used to store accumulations or anything else that
     * the callback might find relevant.
     *
     * @param {?*} children Children tree object.
     * @param {!function} callback To invoke upon traversing each child.
     * @param {?*} traverseContext Context for traversal.
     * @return {!number} The number of children in this subtree.
     */
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }

      return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }

    /**
     * Generate a key string that identifies a component within a set.
     *
     * @param {*} component A component that could contain a manual key.
     * @param {number} index Index that is used if a manual key is not provided.
     * @return {string}
     */
    function getComponentKey(component, index) {
      // Do some typechecking here since we call this blindly. We want to ensure
      // that we don't block potential future ES APIs.
      if ((typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component !== null && component.key != null) {
        // Explicit key
        return escape(component.key);
      }
      // Implicit key determined by the index in the set
      return index.toString(36);
    }

    function forEachSingleChild(bookKeeping, child, name) {
      var func = bookKeeping.func,
          context = bookKeeping.context;

      func.call(context, child, bookKeeping.count++);
    }

    /**
     * Iterates through children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
     *
     * The provided forEachFunc(child, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} forEachFunc
     * @param {*} forEachContext Context for forEachContext.
     */
    function forEachChildren(children, forEachFunc, forEachContext) {
      if (children == null) {
        return children;
      }
      var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
      traverseAllChildren(children, forEachSingleChild, traverseContext);
      releaseTraverseContext(traverseContext);
    }

    function mapSingleChildIntoContext(bookKeeping, child, childKey) {
      var result = bookKeeping.result,
          keyPrefix = bookKeeping.keyPrefix,
          func = bookKeeping.func,
          context = bookKeeping.context;

      var mappedChild = func.call(context, child, bookKeeping.count++);
      if (Array.isArray(mappedChild)) {
        mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function (c) {
          return c;
        });
      } else if (mappedChild != null) {
        if (isValidElement(mappedChild)) {
          mappedChild = cloneAndReplaceKey(mappedChild,
          // Keep both the (mapped) and old keys if they differ, just as
          // traverseAllChildren used to do for objects as children
          keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
        }
        result.push(mappedChild);
      }
    }

    function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
      var escapedPrefix = '';
      if (prefix != null) {
        escapedPrefix = escapeUserProvidedKey(prefix) + '/';
      }
      var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
      releaseTraverseContext(traverseContext);
    }

    /**
     * Maps children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrenmap
     *
     * The provided mapFunction(child, key, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} func The map function.
     * @param {*} context Context for mapFunction.
     * @return {object} Object containing the ordered map of results.
     */
    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, func, context);
      return result;
    }

    /**
     * Count the number of children that are typically specified as
     * `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrencount
     *
     * @param {?*} children Children tree container.
     * @return {number} The number of children.
     */
    function countChildren(children) {
      return traverseAllChildren(children, function () {
        return null;
      }, null);
    }

    /**
     * Flatten a children object (typically specified as `props.children`) and
     * return an array with appropriately re-keyed children.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
     */
    function toArray(children) {
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, function (child) {
        return child;
      });
      return result;
    }

    /**
     * Returns the first child in a collection of children and verifies that there
     * is only one child in the collection.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrenonly
     *
     * The current implementation of this function assumes that a single child gets
     * passed without a wrapper, but the purpose of this helper function is to
     * abstract away the particular structure of children.
     *
     * @param {?object} children Child collection structure.
     * @return {ReactElement} The first and only `ReactElement` contained in the
     * structure.
     */
    function onlyChild(children) {
      !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
      return children;
    }

    function readContext(context, observedBits) {
      var dispatcher = ReactCurrentOwner.currentDispatcher;
      !(dispatcher !== null) ? invariant(false, 'Context.unstable_read(): Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps.') : void 0;
      return dispatcher.readContext(context, observedBits);
    }

    function createContext(defaultValue, calculateChangedBits) {
      if (calculateChangedBits === undefined) {
        calculateChangedBits = null;
      } else {
        {
          !(calculateChangedBits === null || typeof calculateChangedBits === 'function') ? warningWithoutStack$1(false, 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits) : void 0;
        }
      }

      var context = {
        $$typeof: REACT_CONTEXT_TYPE,
        _calculateChangedBits: calculateChangedBits,
        // As a workaround to support multiple concurrent renderers, we categorize
        // some renderers as primary and others as secondary. We only expect
        // there to be two concurrent renderers at most: React Native (primary) and
        // Fabric (secondary); React DOM (primary) and React ART (secondary).
        // Secondary renderers store their context values on separate fields.
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        // These are circular
        Provider: null,
        Consumer: null,
        unstable_read: null
      };

      context.Provider = {
        $$typeof: REACT_PROVIDER_TYPE,
        _context: context
      };
      context.Consumer = context;
      context.unstable_read = readContext.bind(null, context);

      {
        context._currentRenderer = null;
        context._currentRenderer2 = null;
      }

      return context;
    }

    function lazy(ctor) {
      var thenable = null;
      return {
        then: function then(resolve, reject) {
          if (thenable === null) {
            // Lazily create thenable by wrapping in an extra thenable.
            thenable = ctor();
            ctor = null;
          }
          return thenable.then(resolve, reject);
        },

        // React uses these fields to store the result.
        _reactStatus: -1,
        _reactResult: null
      };
    }

    function forwardRef(render) {
      {
        if (typeof render !== 'function') {
          warningWithoutStack$1(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render === 'undefined' ? 'undefined' : _typeof(render));
        } else {
          !(
          // Do not warn for 0 arguments because it could be due to usage of the 'arguments' object
          render.length === 0 || render.length === 2) ? warningWithoutStack$1(false, 'forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.') : void 0;
        }

        if (render != null) {
          !(render.defaultProps == null && render.propTypes == null) ? warningWithoutStack$1(false, 'forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?') : void 0;
        }
      }

      return {
        $$typeof: REACT_FORWARD_REF_TYPE,
        render: render
      };
    }

    function isValidElementType(type) {
      return typeof type === 'string' || typeof type === 'function' ||
      // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      type === REACT_FRAGMENT_TYPE || type === REACT_ASYNC_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_PLACEHOLDER_TYPE || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && (typeof type.then === 'function' || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
    }

    /**
     * ReactElementValidator provides a wrapper around a element factory
     * which validates the props passed to the element. This is intended to be
     * used only in DEV and could be replaced by a static type checker for languages
     * that support it.
     */

    var propTypesMisspellWarningShown = void 0;

    {
      propTypesMisspellWarningShown = false;
    }

    function getDeclarationErrorAddendum() {
      if (ReactCurrentOwner.current) {
        var name = getComponentName(ReactCurrentOwner.current.type);
        if (name) {
          return '\n\nCheck the render method of `' + name + '`.';
        }
      }
      return '';
    }

    function getSourceInfoErrorAddendum(elementProps) {
      if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
        var source = elementProps.__source;
        var fileName = source.fileName.replace(/^.*[\\\/]/, '');
        var lineNumber = source.lineNumber;
        return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
      }
      return '';
    }

    /**
     * Warn if there's no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */
    var ownerHasKeyUseWarning = {};

    function getCurrentComponentErrorInfo(parentType) {
      var info = getDeclarationErrorAddendum();

      if (!info) {
        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
        if (parentName) {
          info = '\n\nCheck the top-level render call using <' + parentName + '>.';
        }
      }
      return info;
    }

    /**
     * Warn if the element doesn't have an explicit key assigned to it.
     * This element is in an array. The array could grow and shrink or be
     * reordered. All children that haven't already been validated are required to
     * have a "key" property assigned to it. Error statuses are cached so a warning
     * will only be shown once.
     *
     * @internal
     * @param {ReactElement} element Element that requires a key.
     * @param {*} parentType element's parent's type.
     */
    function validateExplicitKey(element, parentType) {
      if (!element._store || element._store.validated || element.key != null) {
        return;
      }
      element._store.validated = true;

      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
        return;
      }
      ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

      // Usually the current owner is the offender, but if it accepts children as a
      // property, it may be the creator of the child that's responsible for
      // assigning it a key.
      var childOwner = '';
      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
        // Give the component that originally created this child.
        childOwner = ' It was passed a child from ' + getComponentName(element._owner.type) + '.';
      }

      setCurrentlyValidatingElement(element);
      {
        warning$1(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);
      }
      setCurrentlyValidatingElement(null);
    }

    /**
     * Ensure that every element either is passed in a static location, in an
     * array with an explicit keys property defined, or in an object literal
     * with valid key property.
     *
     * @internal
     * @param {ReactNode} node Statically passed child of any type.
     * @param {*} parentType node's parent's type.
     */
    function validateChildKeys(node, parentType) {
      if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
        return;
      }
      if (Array.isArray(node)) {
        for (var i = 0; i < node.length; i++) {
          var child = node[i];
          if (isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (isValidElement(node)) {
        // This element was passed in a valid location.
        if (node._store) {
          node._store.validated = true;
        }
      } else if (node) {
        var iteratorFn = getIteratorFn(node);
        if (typeof iteratorFn === 'function') {
          // Entry iterators used to provide implicit keys,
          // but now we print a separate warning for them later.
          if (iteratorFn !== node.entries) {
            var iterator = iteratorFn.call(node);
            var step = void 0;
            while (!(step = iterator.next()).done) {
              if (isValidElement(step.value)) {
                validateExplicitKey(step.value, parentType);
              }
            }
          }
        }
      }
    }

    /**
     * Given an element, validate that its props follow the propTypes definition,
     * provided by the type.
     *
     * @param {ReactElement} element
     */
    function validatePropTypes(element) {
      var type = element.type;
      var name = void 0,
          propTypes = void 0;
      if (typeof type === 'function') {
        // Class or functional component
        name = type.displayName || type.name;
        propTypes = type.propTypes;
      } else if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && type.$$typeof === REACT_FORWARD_REF_TYPE) {
        // ForwardRef
        var functionName = type.render.displayName || type.render.name || '';
        name = type.displayName || (functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef');
        propTypes = type.propTypes;
      } else {
        return;
      }
      if (propTypes) {
        setCurrentlyValidatingElement(element);
        checkPropTypes(propTypes, element.props, 'prop', name, ReactDebugCurrentFrame.getStackAddendum);
        setCurrentlyValidatingElement(null);
      } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
        propTypesMisspellWarningShown = true;
        warningWithoutStack$1(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
      }
      if (typeof type.getDefaultProps === 'function') {
        !type.getDefaultProps.isReactClassApproved ? warningWithoutStack$1(false, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
      }
    }

    /**
     * Given a fragment, validate that it can only be provided with fragment props
     * @param {ReactElement} fragment
     */
    function validateFragmentProps(fragment) {
      setCurrentlyValidatingElement(fragment);

      var keys = Object.keys(fragment.props);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key !== 'children' && key !== 'key') {
          warning$1(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
          break;
        }
      }

      if (fragment.ref !== null) {
        warning$1(false, 'Invalid attribute `ref` supplied to `React.Fragment`.');
      }

      setCurrentlyValidatingElement(null);
    }

    function createElementWithValidation(type, props, children) {
      var validType = isValidElementType(type);

      // We warn in this case but don't throw. We expect the element creation to
      // succeed and there will likely be errors in render.
      if (!validType) {
        var info = '';
        if (type === undefined || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
        }

        var sourceInfo = getSourceInfoErrorAddendum(props);
        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        var typeString = void 0;
        if (type === null) {
          typeString = 'null';
        } else if (Array.isArray(type)) {
          typeString = 'array';
        } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
          typeString = '<' + (getComponentName(type.type) || 'Unknown') + ' />';
          info = ' Did you accidentally export a JSX literal instead of a component?';
        } else {
          typeString = typeof type === 'undefined' ? 'undefined' : _typeof(type);
        }

        warning$1(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
      }

      var element = createElement.apply(this, arguments);

      // The result can be nullish if a mock or a custom function is used.
      // TODO: Drop this when these are no longer allowed as the type argument.
      if (element == null) {
        return element;
      }

      // Skip key warning if the type isn't valid since our key validation logic
      // doesn't expect a non-string/function type and can throw confusing errors.
      // We don't want exception behavior to differ between dev and prod.
      // (Rendering will throw with a helpful message and as soon as the type is
      // fixed, the key warnings will appear.)
      if (validType) {
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
      }

      if (type === REACT_FRAGMENT_TYPE) {
        validateFragmentProps(element);
      } else {
        validatePropTypes(element);
      }

      return element;
    }

    function createFactoryWithValidation(type) {
      var validatedFactory = createElementWithValidation.bind(null, type);
      validatedFactory.type = type;
      // Legacy hook: remove it
      {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function get() {
            lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }

      return validatedFactory;
    }

    function cloneElementWithValidation(element, props, children) {
      var newElement = cloneElement.apply(this, arguments);
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], newElement.type);
      }
      validatePropTypes(newElement);
      return newElement;
    }

    var React = {
      Children: {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray: toArray,
        only: onlyChild
      },

      createRef: createRef,
      Component: Component,
      PureComponent: PureComponent,

      createContext: createContext,
      forwardRef: forwardRef,

      Fragment: REACT_FRAGMENT_TYPE,
      StrictMode: REACT_STRICT_MODE_TYPE,
      unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,
      unstable_Profiler: REACT_PROFILER_TYPE,

      createElement: createElementWithValidation,
      cloneElement: cloneElementWithValidation,
      createFactory: createFactoryWithValidation,
      isValidElement: isValidElement,

      version: ReactVersion,

      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals
    };

    if (enableSuspense) {
      React.Placeholder = REACT_PLACEHOLDER_TYPE;
      React.lazy = lazy;
    }

    var React$2 = Object.freeze({
      default: React
    });

    var React$3 = React$2 && React || React$2;

    // TODO: decide on the top-level export form.
    // This is hacky but makes it work with both Rollup and Jest.
    var react = React$3.default || React$3;

    module.exports = react;
  })();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (process.env.NODE_ENV === 'production') {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(35);
} else {
  module.exports = __webpack_require__(38);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.5.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var aa = __webpack_require__(0),
    n = __webpack_require__(6),
    ba = __webpack_require__(20);function ca(a, b, c, d, e, f, g, h) {
  if (!a) {
    a = void 0;if (void 0 === b) a = Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else {
      var k = [c, d, e, f, g, h],
          l = 0;a = Error(b.replace(/%s/g, function () {
        return k[l++];
      }));a.name = "Invariant Violation";
    }a.framesToPop = 1;throw a;
  }
}
function t(a) {
  for (var b = arguments.length - 1, c = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, d = 0; d < b; d++) {
    c += "&args[]=" + encodeURIComponent(arguments[d + 1]);
  }ca(!1, "Minified React error #" + a + "; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ", c);
}aa ? void 0 : t("227");function da(a, b, c, d, e, f, g, h, k) {
  var l = Array.prototype.slice.call(arguments, 3);try {
    b.apply(c, l);
  } catch (m) {
    this.onError(m);
  }
}
var ea = !1,
    fa = null,
    ha = !1,
    ia = null,
    ja = { onError: function onError(a) {
    ea = !0;fa = a;
  } };function ka(a, b, c, d, e, f, g, h, k) {
  ea = !1;fa = null;da.apply(ja, arguments);
}function la(a, b, c, d, e, f, g, h, k) {
  ka.apply(this, arguments);if (ea) {
    if (ea) {
      var l = fa;ea = !1;fa = null;
    } else t("198"), l = void 0;ha || (ha = !0, ia = l);
  }
}var ma = null,
    na = {};
function oa() {
  if (ma) for (var a in na) {
    var b = na[a],
        c = ma.indexOf(a);-1 < c ? void 0 : t("96", a);if (!pa[c]) {
      b.extractEvents ? void 0 : t("97", a);pa[c] = b;c = b.eventTypes;for (var d in c) {
        var e = void 0;var f = c[d],
            g = b,
            h = d;qa.hasOwnProperty(h) ? t("99", h) : void 0;qa[h] = f;var k = f.phasedRegistrationNames;if (k) {
          for (e in k) {
            k.hasOwnProperty(e) && ra(k[e], g, h);
          }e = !0;
        } else f.registrationName ? (ra(f.registrationName, g, h), e = !0) : e = !1;e ? void 0 : t("98", d, a);
      }
    }
  }
}
function ra(a, b, c) {
  sa[a] ? t("100", a) : void 0;sa[a] = b;ta[a] = b.eventTypes[c].dependencies;
}var pa = [],
    qa = {},
    sa = {},
    ta = {},
    ua = null,
    va = null,
    wa = null;function xa(a, b, c, d) {
  b = a.type || "unknown-event";a.currentTarget = wa(d);la(b, c, void 0, a);a.currentTarget = null;
}function ya(a, b) {
  null == b ? t("30") : void 0;if (null == a) return b;if (Array.isArray(a)) {
    if (Array.isArray(b)) return a.push.apply(a, b), a;a.push(b);return a;
  }return Array.isArray(b) ? [a].concat(b) : [a, b];
}
function za(a, b, c) {
  Array.isArray(a) ? a.forEach(b, c) : a && b.call(c, a);
}var Aa = null;function Ba(a, b) {
  if (a) {
    var c = a._dispatchListeners,
        d = a._dispatchInstances;if (Array.isArray(c)) for (var e = 0; e < c.length && !a.isPropagationStopped(); e++) {
      xa(a, b, c[e], d[e]);
    } else c && xa(a, b, c, d);a._dispatchListeners = null;a._dispatchInstances = null;a.isPersistent() || a.constructor.release(a);
  }
}function Ca(a) {
  return Ba(a, !0);
}function Da(a) {
  return Ba(a, !1);
}
var Ea = { injectEventPluginOrder: function injectEventPluginOrder(a) {
    ma ? t("101") : void 0;ma = Array.prototype.slice.call(a);oa();
  }, injectEventPluginsByName: function injectEventPluginsByName(a) {
    var b = !1,
        c;for (c in a) {
      if (a.hasOwnProperty(c)) {
        var d = a[c];na.hasOwnProperty(c) && na[c] === d || (na[c] ? t("102", c) : void 0, na[c] = d, b = !0);
      }
    }b && oa();
  } };
function Fa(a, b) {
  var c = a.stateNode;if (!c) return null;var d = ua(c);if (!d) return null;c = d[b];a: switch (b) {case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":
      (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));a = !d;break a;default:
      a = !1;}if (a) return null;c && "function" !== typeof c ? t("231", b, typeof c === "undefined" ? "undefined" : _typeof(c)) : void 0;
  return c;
}function Ga(a, b) {
  null !== a && (Aa = ya(Aa, a));a = Aa;Aa = null;if (a && (b ? za(a, Ca) : za(a, Da), Aa ? t("95") : void 0, ha)) throw b = ia, ha = !1, ia = null, b;
}var Ha = Math.random().toString(36).slice(2),
    Ia = "__reactInternalInstance$" + Ha,
    Ja = "__reactEventHandlers$" + Ha;function Ka(a) {
  if (a[Ia]) return a[Ia];for (; !a[Ia];) {
    if (a.parentNode) a = a.parentNode;else return null;
  }a = a[Ia];return 7 === a.tag || 8 === a.tag ? a : null;
}function La(a) {
  a = a[Ia];return !a || 7 !== a.tag && 8 !== a.tag ? null : a;
}
function Ma(a) {
  if (7 === a.tag || 8 === a.tag) return a.stateNode;t("33");
}function Na(a) {
  return a[Ja] || null;
}function Oa(a) {
  do {
    a = a.return;
  } while (a && 7 !== a.tag);return a ? a : null;
}function Pa(a, b, c) {
  if (b = Fa(a, c.dispatchConfig.phasedRegistrationNames[b])) c._dispatchListeners = ya(c._dispatchListeners, b), c._dispatchInstances = ya(c._dispatchInstances, a);
}
function Qa(a) {
  if (a && a.dispatchConfig.phasedRegistrationNames) {
    for (var b = a._targetInst, c = []; b;) {
      c.push(b), b = Oa(b);
    }for (b = c.length; 0 < b--;) {
      Pa(c[b], "captured", a);
    }for (b = 0; b < c.length; b++) {
      Pa(c[b], "bubbled", a);
    }
  }
}function Ra(a, b, c) {
  a && c && c.dispatchConfig.registrationName && (b = Fa(a, c.dispatchConfig.registrationName)) && (c._dispatchListeners = ya(c._dispatchListeners, b), c._dispatchInstances = ya(c._dispatchInstances, a));
}function Ta(a) {
  a && a.dispatchConfig.registrationName && Ra(a._targetInst, null, a);
}
function Ua(a) {
  za(a, Qa);
}var Va = !("undefined" === typeof window || !window.document || !window.document.createElement);function Wa(a, b) {
  var c = {};c[a.toLowerCase()] = b.toLowerCase();c["Webkit" + a] = "webkit" + b;c["Moz" + a] = "moz" + b;return c;
}var Ya = { animationend: Wa("Animation", "AnimationEnd"), animationiteration: Wa("Animation", "AnimationIteration"), animationstart: Wa("Animation", "AnimationStart"), transitionend: Wa("Transition", "TransitionEnd") },
    Za = {},
    $a = {};
Va && ($a = document.createElement("div").style, "AnimationEvent" in window || (delete Ya.animationend.animation, delete Ya.animationiteration.animation, delete Ya.animationstart.animation), "TransitionEvent" in window || delete Ya.transitionend.transition);function ab(a) {
  if (Za[a]) return Za[a];if (!Ya[a]) return a;var b = Ya[a],
      c;for (c in b) {
    if (b.hasOwnProperty(c) && c in $a) return Za[a] = b[c];
  }return a;
}
var bb = ab("animationend"),
    cb = ab("animationiteration"),
    db = ab("animationstart"),
    eb = ab("transitionend"),
    fb = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
    gb = null,
    hb = null,
    ib = null;
function jb() {
  if (ib) return ib;var a,
      b = hb,
      c = b.length,
      d,
      e = "value" in gb ? gb.value : gb.textContent,
      f = e.length;for (a = 0; a < c && b[a] === e[a]; a++) {}var g = c - a;for (d = 1; d <= g && b[c - d] === e[f - d]; d++) {}return ib = e.slice(a, 1 < d ? 1 - d : void 0);
}function kb() {
  return !0;
}function lb() {
  return !1;
}
function z(a, b, c, d) {
  this.dispatchConfig = a;this._targetInst = b;this.nativeEvent = c;a = this.constructor.Interface;for (var e in a) {
    a.hasOwnProperty(e) && ((b = a[e]) ? this[e] = b(c) : "target" === e ? this.target = d : this[e] = c[e]);
  }this.isDefaultPrevented = (null != c.defaultPrevented ? c.defaultPrevented : !1 === c.returnValue) ? kb : lb;this.isPropagationStopped = lb;return this;
}
n(z.prototype, { preventDefault: function preventDefault() {
    this.defaultPrevented = !0;var a = this.nativeEvent;a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), this.isDefaultPrevented = kb);
  }, stopPropagation: function stopPropagation() {
    var a = this.nativeEvent;a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), this.isPropagationStopped = kb);
  }, persist: function persist() {
    this.isPersistent = kb;
  }, isPersistent: lb, destructor: function destructor() {
    var a = this.constructor.Interface,
        b;for (b in a) {
      this[b] = null;
    }this.nativeEvent = this._targetInst = this.dispatchConfig = null;this.isPropagationStopped = this.isDefaultPrevented = lb;this._dispatchInstances = this._dispatchListeners = null;
  } });z.Interface = { type: null, target: null, currentTarget: function currentTarget() {
    return null;
  }, eventPhase: null, bubbles: null, cancelable: null, timeStamp: function timeStamp(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: null, isTrusted: null };
z.extend = function (a) {
  function b() {}function c() {
    return d.apply(this, arguments);
  }var d = this;b.prototype = d.prototype;var e = new b();n(e, c.prototype);c.prototype = e;c.prototype.constructor = c;c.Interface = n({}, d.Interface, a);c.extend = d.extend;mb(c);return c;
};mb(z);function nb(a, b, c, d) {
  if (this.eventPool.length) {
    var e = this.eventPool.pop();this.call(e, a, b, c, d);return e;
  }return new this(a, b, c, d);
}function ob(a) {
  a instanceof this ? void 0 : t("279");a.destructor();10 > this.eventPool.length && this.eventPool.push(a);
}
function mb(a) {
  a.eventPool = [];a.getPooled = nb;a.release = ob;
}var pb = z.extend({ data: null }),
    qb = z.extend({ data: null }),
    rb = [9, 13, 27, 32],
    sb = Va && "CompositionEvent" in window,
    tb = null;Va && "documentMode" in document && (tb = document.documentMode);
var ub = Va && "TextEvent" in window && !tb,
    vb = Va && (!sb || tb && 8 < tb && 11 >= tb),
    wb = String.fromCharCode(32),
    xb = { beforeInput: { phasedRegistrationNames: { bubbled: "onBeforeInput", captured: "onBeforeInputCapture" }, dependencies: ["compositionend", "keypress", "textInput", "paste"] }, compositionEnd: { phasedRegistrationNames: { bubbled: "onCompositionEnd", captured: "onCompositionEndCapture" }, dependencies: "blur compositionend keydown keypress keyup mousedown".split(" ") }, compositionStart: { phasedRegistrationNames: { bubbled: "onCompositionStart",
      captured: "onCompositionStartCapture" }, dependencies: "blur compositionstart keydown keypress keyup mousedown".split(" ") }, compositionUpdate: { phasedRegistrationNames: { bubbled: "onCompositionUpdate", captured: "onCompositionUpdateCapture" }, dependencies: "blur compositionupdate keydown keypress keyup mousedown".split(" ") } },
    yb = !1;
function zb(a, b) {
  switch (a) {case "keyup":
      return -1 !== rb.indexOf(b.keyCode);case "keydown":
      return 229 !== b.keyCode;case "keypress":case "mousedown":case "blur":
      return !0;default:
      return !1;}
}function Ab(a) {
  a = a.detail;return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && "data" in a ? a.data : null;
}var Bb = !1;function Cb(a, b) {
  switch (a) {case "compositionend":
      return Ab(b);case "keypress":
      if (32 !== b.which) return null;yb = !0;return wb;case "textInput":
      return a = b.data, a === wb && yb ? null : a;default:
      return null;}
}
function Db(a, b) {
  if (Bb) return "compositionend" === a || !sb && zb(a, b) ? (a = jb(), ib = hb = gb = null, Bb = !1, a) : null;switch (a) {case "paste":
      return null;case "keypress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length) return b.char;if (b.which) return String.fromCharCode(b.which);
      }return null;case "compositionend":
      return vb && "ko" !== b.locale ? null : b.data;default:
      return null;}
}
var Eb = { eventTypes: xb, extractEvents: function extractEvents(a, b, c, d) {
    var e = void 0;var f = void 0;if (sb) b: {
      switch (a) {case "compositionstart":
          e = xb.compositionStart;break b;case "compositionend":
          e = xb.compositionEnd;break b;case "compositionupdate":
          e = xb.compositionUpdate;break b;}e = void 0;
    } else Bb ? zb(a, c) && (e = xb.compositionEnd) : "keydown" === a && 229 === c.keyCode && (e = xb.compositionStart);e ? (vb && "ko" !== c.locale && (Bb || e !== xb.compositionStart ? e === xb.compositionEnd && Bb && (f = jb()) : (gb = d, hb = "value" in gb ? gb.value : gb.textContent, Bb = !0)), e = pb.getPooled(e, b, c, d), f ? e.data = f : (f = Ab(c), null !== f && (e.data = f)), Ua(e), f = e) : f = null;(a = ub ? Cb(a, c) : Db(a, c)) ? (b = qb.getPooled(xb.beforeInput, b, c, d), b.data = a, Ua(b)) : b = null;return null === f ? b : null === b ? f : [f, b];
  } },
    Fb = null,
    Gb = null,
    Hb = null;function Ib(a) {
  if (a = va(a)) {
    "function" !== typeof Fb ? t("280") : void 0;var b = ua(a.stateNode);Fb(a.stateNode, a.type, b);
  }
}function Jb(a) {
  Gb ? Hb ? Hb.push(a) : Hb = [a] : Gb = a;
}function Kb() {
  if (Gb) {
    var a = Gb,
        b = Hb;Hb = Gb = null;Ib(a);if (b) for (a = 0; a < b.length; a++) {
      Ib(b[a]);
    }
  }
}
function Lb(a, b) {
  return a(b);
}function Mb(a, b, c) {
  return a(b, c);
}function Nb() {}var Ob = !1;function Pb(a, b) {
  if (Ob) return a(b);Ob = !0;try {
    return Lb(a, b);
  } finally {
    if (Ob = !1, null !== Gb || null !== Hb) Nb(), Kb();
  }
}var Qb = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };function Rb(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();return "input" === b ? !!Qb[a.type] : "textarea" === b ? !0 : !1;
}
function Sb(a) {
  a = a.target || a.srcElement || window;a.correspondingUseElement && (a = a.correspondingUseElement);return 3 === a.nodeType ? a.parentNode : a;
}function Tb(a) {
  if (!Va) return !1;a = "on" + a;var b = a in document;b || (b = document.createElement("div"), b.setAttribute(a, "return;"), b = "function" === typeof b[a]);return b;
}function Ub(a) {
  var b = a.type;return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}
function Vb(a) {
  var b = Ub(a) ? "checked" : "value",
      c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
      d = "" + a[b];if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
    var e = c.get,
        f = c.set;Object.defineProperty(a, b, { configurable: !0, get: function get() {
        return e.call(this);
      }, set: function set(a) {
        d = "" + a;f.call(this, a);
      } });Object.defineProperty(a, b, { enumerable: c.enumerable });return { getValue: function getValue() {
        return d;
      }, setValue: function setValue(a) {
        d = "" + a;
      }, stopTracking: function stopTracking() {
        a._valueTracker = null;delete a[b];
      } };
  }
}function Wb(a) {
  a._valueTracker || (a._valueTracker = Vb(a));
}function Xb(a) {
  if (!a) return !1;var b = a._valueTracker;if (!b) return !0;var c = b.getValue();var d = "";a && (d = Ub(a) ? a.checked ? "true" : "false" : a.value);a = d;return a !== c ? (b.setValue(a), !0) : !1;
}
var Yb = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    Zb = /^(.*)[\\\/]/,
    C = "function" === typeof Symbol && Symbol.for,
    $b = C ? Symbol.for("react.element") : 60103,
    ac = C ? Symbol.for("react.portal") : 60106,
    bc = C ? Symbol.for("react.fragment") : 60107,
    cc = C ? Symbol.for("react.strict_mode") : 60108,
    dc = C ? Symbol.for("react.profiler") : 60114,
    ec = C ? Symbol.for("react.provider") : 60109,
    fc = C ? Symbol.for("react.context") : 60110,
    gc = C ? Symbol.for("react.async_mode") : 60111,
    hc = C ? Symbol.for("react.forward_ref") : 60112,
    ic = C ? Symbol.for("react.placeholder") : 60113,
    jc = "function" === typeof Symbol && Symbol.iterator;function kc(a) {
  if (null === a || "object" !== (typeof a === "undefined" ? "undefined" : _typeof(a))) return null;a = jc && a[jc] || a["@@iterator"];return "function" === typeof a ? a : null;
}
function lc(a) {
  if (null == a) return null;if ("function" === typeof a) return a.displayName || a.name || null;if ("string" === typeof a) return a;switch (a) {case gc:
      return "AsyncMode";case bc:
      return "Fragment";case ac:
      return "Portal";case dc:
      return "Profiler";case cc:
      return "StrictMode";case ic:
      return "Placeholder";}if ("object" === (typeof a === "undefined" ? "undefined" : _typeof(a))) {
    switch (a.$$typeof) {case fc:
        return "Context.Consumer";case ec:
        return "Context.Provider";case hc:
        var b = a.render;b = b.displayName || b.name || "";return a.displayName || ("" !== b ? "ForwardRef(" + b + ")" : "ForwardRef");}if ("function" === typeof a.then && (a = 1 === a._reactStatus ? a._reactResult : null)) return lc(a);
  }return null;
}function mc(a) {
  var b = "";do {
    a: switch (a.tag) {case 4:case 0:case 1:case 2:case 3:case 7:case 10:
        var c = a._debugOwner,
            d = a._debugSource,
            e = lc(a.type);var f = null;c && (f = lc(c.type));c = e;e = "";d ? e = " (at " + d.fileName.replace(Zb, "") + ":" + d.lineNumber + ")" : f && (e = " (created by " + f + ")");f = "\n    in " + (c || "Unknown") + e;break a;default:
        f = "";}b += f;a = a.return;
  } while (a);return b;
}
var nc = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    pc = Object.prototype.hasOwnProperty,
    qc = {},
    rc = {};
function sc(a) {
  if (pc.call(rc, a)) return !0;if (pc.call(qc, a)) return !1;if (nc.test(a)) return rc[a] = !0;qc[a] = !0;return !1;
}function tc(a, b, c, d) {
  if (null !== c && 0 === c.type) return !1;switch (typeof b === "undefined" ? "undefined" : _typeof(b)) {case "function":case "symbol":
      return !0;case "boolean":
      if (d) return !1;if (null !== c) return !c.acceptsBooleans;a = a.toLowerCase().slice(0, 5);return "data-" !== a && "aria-" !== a;default:
      return !1;}
}
function uc(a, b, c, d) {
  if (null === b || "undefined" === typeof b || tc(a, b, c, d)) return !0;if (d) return !1;if (null !== c) switch (c.type) {case 3:
      return !b;case 4:
      return !1 === b;case 5:
      return isNaN(b);case 6:
      return isNaN(b) || 1 > b;}return !1;
}function D(a, b, c, d, e) {
  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;this.attributeName = d;this.attributeNamespace = e;this.mustUseProperty = c;this.propertyName = a;this.type = b;
}var E = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (a) {
  E[a] = new D(a, 0, !1, a, null);
});[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (a) {
  var b = a[0];E[b] = new D(b, 1, !1, a[1], null);
});["contentEditable", "draggable", "spellCheck", "value"].forEach(function (a) {
  E[a] = new D(a, 2, !1, a.toLowerCase(), null);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (a) {
  E[a] = new D(a, 2, !1, a, null);
});"allowFullScreen async autoFocus autoPlay controls default defer disabled formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (a) {
  E[a] = new D(a, 3, !1, a.toLowerCase(), null);
});["checked", "multiple", "muted", "selected"].forEach(function (a) {
  E[a] = new D(a, 3, !0, a, null);
});
["capture", "download"].forEach(function (a) {
  E[a] = new D(a, 4, !1, a, null);
});["cols", "rows", "size", "span"].forEach(function (a) {
  E[a] = new D(a, 6, !1, a, null);
});["rowSpan", "start"].forEach(function (a) {
  E[a] = new D(a, 5, !1, a.toLowerCase(), null);
});var vc = /[\-:]([a-z])/g;function wc(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (a) {
  var b = a.replace(vc, wc);E[b] = new D(b, 1, !1, a, null);
});"xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (a) {
  var b = a.replace(vc, wc);E[b] = new D(b, 1, !1, a, "http://www.w3.org/1999/xlink");
});["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
  var b = a.replace(vc, wc);E[b] = new D(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace");
});E.tabIndex = new D("tabIndex", 1, !1, "tabindex", null);
function xc(a, b, c, d) {
  var e = E.hasOwnProperty(b) ? E[b] : null;var f = null !== e ? 0 === e.type : d ? !1 : !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1] ? !1 : !0;f || (uc(b, c, e, d) && (c = null), d || null === e ? sc(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? !1 : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && !0 === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
}
function yc(a) {
  switch (typeof a === "undefined" ? "undefined" : _typeof(a)) {case "boolean":case "number":case "object":case "string":case "undefined":
      return a;default:
      return "";}
}function zc(a, b) {
  var c = b.checked;return n({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
}
function Bc(a, b) {
  var c = null == b.defaultValue ? "" : b.defaultValue,
      d = null != b.checked ? b.checked : b.defaultChecked;c = yc(null != b.value ? b.value : c);a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
}function Cc(a, b) {
  b = b.checked;null != b && xc(a, "checked", b, !1);
}
function Dc(a, b) {
  Cc(a, b);var c = yc(b.value),
      d = b.type;if (null != c) {
    if ("number" === d) {
      if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
  } else if ("submit" === d || "reset" === d) {
    a.removeAttribute("value");return;
  }b.hasOwnProperty("value") ? Ec(a, b.type, c) : b.hasOwnProperty("defaultValue") && Ec(a, b.type, yc(b.defaultValue));null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}
function Fc(a, b, c) {
  if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
    var d = b.type;if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;b = "" + a._wrapperState.initialValue;c || b === a.value || (a.value = b);a.defaultValue = b;
  }c = a.name;"" !== c && (a.name = "");a.defaultChecked = !a.defaultChecked;a.defaultChecked = !!a._wrapperState.initialChecked;"" !== c && (a.name = c);
}
function Ec(a, b, c) {
  if ("number" !== b || a.ownerDocument.activeElement !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}var Gc = { change: { phasedRegistrationNames: { bubbled: "onChange", captured: "onChangeCapture" }, dependencies: "blur change click focus input keydown keyup selectionchange".split(" ") } };function Hc(a, b, c) {
  a = z.getPooled(Gc.change, a, b, c);a.type = "change";Jb(c);Ua(a);return a;
}var Ic = null,
    Jc = null;function Kc(a) {
  Ga(a, !1);
}
function Lc(a) {
  var b = Ma(a);if (Xb(b)) return a;
}function Mc(a, b) {
  if ("change" === a) return b;
}var Nc = !1;Va && (Nc = Tb("input") && (!document.documentMode || 9 < document.documentMode));function Oc() {
  Ic && (Ic.detachEvent("onpropertychange", Pc), Jc = Ic = null);
}function Pc(a) {
  "value" === a.propertyName && Lc(Jc) && (a = Hc(Jc, a, Sb(a)), Pb(Kc, a));
}function Qc(a, b, c) {
  "focus" === a ? (Oc(), Ic = b, Jc = c, Ic.attachEvent("onpropertychange", Pc)) : "blur" === a && Oc();
}function Rc(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a) return Lc(Jc);
}
function Sc(a, b) {
  if ("click" === a) return Lc(b);
}function Tc(a, b) {
  if ("input" === a || "change" === a) return Lc(b);
}
var Uc = { eventTypes: Gc, _isInputEventSupported: Nc, extractEvents: function extractEvents(a, b, c, d) {
    var e = b ? Ma(b) : window,
        f = void 0,
        g = void 0,
        h = e.nodeName && e.nodeName.toLowerCase();"select" === h || "input" === h && "file" === e.type ? f = Mc : Rb(e) ? Nc ? f = Tc : (f = Rc, g = Qc) : (h = e.nodeName) && "input" === h.toLowerCase() && ("checkbox" === e.type || "radio" === e.type) && (f = Sc);if (f && (f = f(a, b))) return Hc(f, c, d);g && g(a, e, b);"blur" === a && (a = e._wrapperState) && a.controlled && "number" === e.type && Ec(e, "number", e.value);
  } },
    Vc = z.extend({ view: null, detail: null }),
    Wc = { Alt: "altKey",
  Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };function Xc(a) {
  var b = this.nativeEvent;return b.getModifierState ? b.getModifierState(a) : (a = Wc[a]) ? !!b[a] : !1;
}function Yc() {
  return Xc;
}
var Zc = 0,
    $c = 0,
    ad = !1,
    bd = !1,
    cd = Vc.extend({ screenX: null, screenY: null, clientX: null, clientY: null, pageX: null, pageY: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, getModifierState: Yc, button: null, buttons: null, relatedTarget: function relatedTarget(a) {
    return a.relatedTarget || (a.fromElement === a.srcElement ? a.toElement : a.fromElement);
  }, movementX: function movementX(a) {
    if ("movementX" in a) return a.movementX;var b = Zc;Zc = a.screenX;return ad ? "mousemove" === a.type ? a.screenX - b : 0 : (ad = !0, 0);
  }, movementY: function movementY(a) {
    if ("movementY" in a) return a.movementY;
    var b = $c;$c = a.screenY;return bd ? "mousemove" === a.type ? a.screenY - b : 0 : (bd = !0, 0);
  } }),
    dd = cd.extend({ pointerId: null, width: null, height: null, pressure: null, tangentialPressure: null, tiltX: null, tiltY: null, twist: null, pointerType: null, isPrimary: null }),
    ed = { mouseEnter: { registrationName: "onMouseEnter", dependencies: ["mouseout", "mouseover"] }, mouseLeave: { registrationName: "onMouseLeave", dependencies: ["mouseout", "mouseover"] }, pointerEnter: { registrationName: "onPointerEnter", dependencies: ["pointerout", "pointerover"] }, pointerLeave: { registrationName: "onPointerLeave",
    dependencies: ["pointerout", "pointerover"] } },
    fd = { eventTypes: ed, extractEvents: function extractEvents(a, b, c, d) {
    var e = "mouseover" === a || "pointerover" === a,
        f = "mouseout" === a || "pointerout" === a;if (e && (c.relatedTarget || c.fromElement) || !f && !e) return null;e = d.window === d ? d : (e = d.ownerDocument) ? e.defaultView || e.parentWindow : window;f ? (f = b, b = (b = c.relatedTarget || c.toElement) ? Ka(b) : null) : f = null;if (f === b) return null;var g = void 0,
        h = void 0,
        k = void 0,
        l = void 0;if ("mouseout" === a || "mouseover" === a) g = cd, h = ed.mouseLeave, k = ed.mouseEnter, l = "mouse";else if ("pointerout" === a || "pointerover" === a) g = dd, h = ed.pointerLeave, k = ed.pointerEnter, l = "pointer";var m = null == f ? e : Ma(f);e = null == b ? e : Ma(b);a = g.getPooled(h, f, c, d);a.type = l + "leave";a.target = m;a.relatedTarget = e;c = g.getPooled(k, b, c, d);c.type = l + "enter";c.target = e;c.relatedTarget = m;d = b;if (f && d) a: {
      b = f;e = d;l = 0;for (g = b; g; g = Oa(g)) {
        l++;
      }g = 0;for (k = e; k; k = Oa(k)) {
        g++;
      }for (; 0 < l - g;) {
        b = Oa(b), l--;
      }for (; 0 < g - l;) {
        e = Oa(e), g--;
      }for (; l--;) {
        if (b === e || b === e.alternate) break a;b = Oa(b);e = Oa(e);
      }b = null;
    } else b = null;e = b;for (b = []; f && f !== e;) {
      l = f.alternate;if (null !== l && l === e) break;b.push(f);f = Oa(f);
    }for (f = []; d && d !== e;) {
      l = d.alternate;if (null !== l && l === e) break;f.push(d);d = Oa(d);
    }for (d = 0; d < b.length; d++) {
      Ra(b[d], "bubbled", a);
    }for (d = f.length; 0 < d--;) {
      Ra(f[d], "captured", c);
    }return [a, c];
  } },
    gd = Object.prototype.hasOwnProperty;function hd(a, b) {
  return a === b ? 0 !== a || 0 !== b || 1 / a === 1 / b : a !== a && b !== b;
}
function id(a, b) {
  if (hd(a, b)) return !0;if ("object" !== (typeof a === "undefined" ? "undefined" : _typeof(a)) || null === a || "object" !== (typeof b === "undefined" ? "undefined" : _typeof(b)) || null === b) return !1;var c = Object.keys(a),
      d = Object.keys(b);if (c.length !== d.length) return !1;for (d = 0; d < c.length; d++) {
    if (!gd.call(b, c[d]) || !hd(a[c[d]], b[c[d]])) return !1;
  }return !0;
}function jd(a) {
  var b = a;if (a.alternate) for (; b.return;) {
    b = b.return;
  } else {
    if (0 !== (b.effectTag & 2)) return 1;for (; b.return;) {
      if (b = b.return, 0 !== (b.effectTag & 2)) return 1;
    }
  }return 5 === b.tag ? 2 : 3;
}function kd(a) {
  2 !== jd(a) ? t("188") : void 0;
}
function ld(a) {
  var b = a.alternate;if (!b) return b = jd(a), 3 === b ? t("188") : void 0, 1 === b ? null : a;for (var c = a, d = b;;) {
    var e = c.return,
        f = e ? e.alternate : null;if (!e || !f) break;if (e.child === f.child) {
      for (var g = e.child; g;) {
        if (g === c) return kd(e), a;if (g === d) return kd(e), b;g = g.sibling;
      }t("188");
    }if (c.return !== d.return) c = e, d = f;else {
      g = !1;for (var h = e.child; h;) {
        if (h === c) {
          g = !0;c = e;d = f;break;
        }if (h === d) {
          g = !0;d = e;c = f;break;
        }h = h.sibling;
      }if (!g) {
        for (h = f.child; h;) {
          if (h === c) {
            g = !0;c = f;d = e;break;
          }if (h === d) {
            g = !0;d = f;c = e;break;
          }h = h.sibling;
        }g ? void 0 : t("189");
      }
    }c.alternate !== d ? t("190") : void 0;
  }5 !== c.tag ? t("188") : void 0;return c.stateNode.current === c ? a : b;
}function md(a) {
  a = ld(a);if (!a) return null;for (var b = a;;) {
    if (7 === b.tag || 8 === b.tag) return b;if (b.child) b.child.return = b, b = b.child;else {
      if (b === a) break;for (; !b.sibling;) {
        if (!b.return || b.return === a) return null;b = b.return;
      }b.sibling.return = b.return;b = b.sibling;
    }
  }return null;
}
var nd = z.extend({ animationName: null, elapsedTime: null, pseudoElement: null }),
    od = z.extend({ clipboardData: function clipboardData(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } }),
    pd = Vc.extend({ relatedTarget: null });function qd(a) {
  var b = a.keyCode;"charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;10 === a && (a = 13);return 32 <= a || 13 === a ? a : 0;
}
var rd = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" },
    sd = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4",
  116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" },
    td = Vc.extend({ key: function key(a) {
    if (a.key) {
      var b = rd[a.key] || a.key;if ("Unidentified" !== b) return b;
    }return "keypress" === a.type ? (a = qd(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? sd[a.keyCode] || "Unidentified" : "";
  }, location: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, repeat: null, locale: null, getModifierState: Yc, charCode: function charCode(a) {
    return "keypress" === a.type ? qd(a) : 0;
  }, keyCode: function keyCode(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }, which: function which(a) {
    return "keypress" === a.type ? qd(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  } }),
    ud = cd.extend({ dataTransfer: null }),
    vd = Vc.extend({ touches: null, targetTouches: null, changedTouches: null, altKey: null, metaKey: null, ctrlKey: null, shiftKey: null, getModifierState: Yc }),
    wd = z.extend({ propertyName: null, elapsedTime: null, pseudoElement: null }),
    xd = cd.extend({ deltaX: function deltaX(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  }, deltaY: function deltaY(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  }, deltaZ: null, deltaMode: null }),
    yd = [["abort", "abort"], [bb, "animationEnd"], [cb, "animationIteration"], [db, "animationStart"], ["canplay", "canPlay"], ["canplaythrough", "canPlayThrough"], ["drag", "drag"], ["dragenter", "dragEnter"], ["dragexit", "dragExit"], ["dragleave", "dragLeave"], ["dragover", "dragOver"], ["durationchange", "durationChange"], ["emptied", "emptied"], ["encrypted", "encrypted"], ["ended", "ended"], ["error", "error"], ["gotpointercapture", "gotPointerCapture"], ["load", "load"], ["loadeddata", "loadedData"], ["loadedmetadata", "loadedMetadata"], ["loadstart", "loadStart"], ["lostpointercapture", "lostPointerCapture"], ["mousemove", "mouseMove"], ["mouseout", "mouseOut"], ["mouseover", "mouseOver"], ["playing", "playing"], ["pointermove", "pointerMove"], ["pointerout", "pointerOut"], ["pointerover", "pointerOver"], ["progress", "progress"], ["scroll", "scroll"], ["seeking", "seeking"], ["stalled", "stalled"], ["suspend", "suspend"], ["timeupdate", "timeUpdate"], ["toggle", "toggle"], ["touchmove", "touchMove"], [eb, "transitionEnd"], ["waiting", "waiting"], ["wheel", "wheel"]],
    zd = {},
    Ad = {};function Bd(a, b) {
  var c = a[0];a = a[1];var d = "on" + (a[0].toUpperCase() + a.slice(1));b = { phasedRegistrationNames: { bubbled: d, captured: d + "Capture" }, dependencies: [c], isInteractive: b };zd[a] = b;Ad[c] = b;
}
[["blur", "blur"], ["cancel", "cancel"], ["click", "click"], ["close", "close"], ["contextmenu", "contextMenu"], ["copy", "copy"], ["cut", "cut"], ["auxclick", "auxClick"], ["dblclick", "doubleClick"], ["dragend", "dragEnd"], ["dragstart", "dragStart"], ["drop", "drop"], ["focus", "focus"], ["input", "input"], ["invalid", "invalid"], ["keydown", "keyDown"], ["keypress", "keyPress"], ["keyup", "keyUp"], ["mousedown", "mouseDown"], ["mouseup", "mouseUp"], ["paste", "paste"], ["pause", "pause"], ["play", "play"], ["pointercancel", "pointerCancel"], ["pointerdown", "pointerDown"], ["pointerup", "pointerUp"], ["ratechange", "rateChange"], ["reset", "reset"], ["seeked", "seeked"], ["submit", "submit"], ["touchcancel", "touchCancel"], ["touchend", "touchEnd"], ["touchstart", "touchStart"], ["volumechange", "volumeChange"]].forEach(function (a) {
  Bd(a, !0);
});yd.forEach(function (a) {
  Bd(a, !1);
});
var Cd = { eventTypes: zd, isInteractiveTopLevelEventType: function isInteractiveTopLevelEventType(a) {
    a = Ad[a];return void 0 !== a && !0 === a.isInteractive;
  }, extractEvents: function extractEvents(a, b, c, d) {
    var e = Ad[a];if (!e) return null;switch (a) {case "keypress":
        if (0 === qd(c)) return null;case "keydown":case "keyup":
        a = td;break;case "blur":case "focus":
        a = pd;break;case "click":
        if (2 === c.button) return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":
        a = cd;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":
        a = ud;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":
        a = vd;break;case bb:case cb:case db:
        a = nd;break;case eb:
        a = wd;break;case "scroll":
        a = Vc;break;case "wheel":
        a = xd;break;case "copy":case "cut":case "paste":
        a = od;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":
        a = dd;break;default:
        a = z;}b = a.getPooled(e, b, c, d);Ua(b);return b;
  } },
    Dd = Cd.isInteractiveTopLevelEventType,
    Ed = [];function Fd(a) {
  var b = a.targetInst,
      c = b;do {
    if (!c) {
      a.ancestors.push(c);break;
    }var d;for (d = c; d.return;) {
      d = d.return;
    }d = 5 !== d.tag ? null : d.stateNode.containerInfo;if (!d) break;a.ancestors.push(c);c = Ka(d);
  } while (c);for (c = 0; c < a.ancestors.length; c++) {
    b = a.ancestors[c];var e = Sb(a.nativeEvent);d = a.topLevelType;for (var f = a.nativeEvent, g = null, h = 0; h < pa.length; h++) {
      var k = pa[h];k && (k = k.extractEvents(d, b, f, e)) && (g = ya(g, k));
    }Ga(g, !1);
  }
}var Gd = !0;
function F(a, b) {
  if (!b) return null;var c = (Dd(a) ? Hd : Id).bind(null, a);b.addEventListener(a, c, !1);
}function Jd(a, b) {
  if (!b) return null;var c = (Dd(a) ? Hd : Id).bind(null, a);b.addEventListener(a, c, !0);
}function Hd(a, b) {
  Mb(Id, a, b);
}
function Id(a, b) {
  if (Gd) {
    var c = Sb(b);c = Ka(c);null === c || "number" !== typeof c.tag || 2 === jd(c) || (c = null);if (Ed.length) {
      var d = Ed.pop();d.topLevelType = a;d.nativeEvent = b;d.targetInst = c;a = d;
    } else a = { topLevelType: a, nativeEvent: b, targetInst: c, ancestors: [] };try {
      Pb(Fd, a);
    } finally {
      a.topLevelType = null, a.nativeEvent = null, a.targetInst = null, a.ancestors.length = 0, 10 > Ed.length && Ed.push(a);
    }
  }
}var Kd = {},
    Ld = 0,
    Md = "_reactListenersID" + ("" + Math.random()).slice(2);
function Nd(a) {
  Object.prototype.hasOwnProperty.call(a, Md) || (a[Md] = Ld++, Kd[a[Md]] = {});return Kd[a[Md]];
}function Od(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);if ("undefined" === typeof a) return null;try {
    return a.activeElement || a.body;
  } catch (b) {
    return a.body;
  }
}function Qd(a) {
  for (; a && a.firstChild;) {
    a = a.firstChild;
  }return a;
}
function Rd(a, b) {
  var c = Qd(a);a = 0;for (var d; c;) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;if (a <= b && d >= b) return { node: c, offset: b - a };a = d;
    }a: {
      for (; c;) {
        if (c.nextSibling) {
          c = c.nextSibling;break a;
        }c = c.parentNode;
      }c = void 0;
    }c = Qd(c);
  }
}function Sd(a, b) {
  return a && b ? a === b ? !0 : a && 3 === a.nodeType ? !1 : b && 3 === b.nodeType ? Sd(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : !1 : !1;
}
function Td() {
  for (var a = window, b = Od(); b instanceof a.HTMLIFrameElement;) {
    try {
      a = b.contentDocument.defaultView;
    } catch (c) {
      break;
    }b = Od(a.document);
  }return b;
}function Ud(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
}
var Vd = Va && "documentMode" in document && 11 >= document.documentMode,
    Wd = { select: { phasedRegistrationNames: { bubbled: "onSelect", captured: "onSelectCapture" }, dependencies: "blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ") } },
    Xd = null,
    Yd = null,
    Zd = null,
    $d = !1;
function ae(a, b) {
  var c = b.window === b ? b.document : 9 === b.nodeType ? b : b.ownerDocument;if ($d || null == Xd || Xd !== Od(c)) return null;c = Xd;"selectionStart" in c && Ud(c) ? c = { start: c.selectionStart, end: c.selectionEnd } : (c = (c.ownerDocument && c.ownerDocument.defaultView || window).getSelection(), c = { anchorNode: c.anchorNode, anchorOffset: c.anchorOffset, focusNode: c.focusNode, focusOffset: c.focusOffset });return Zd && id(Zd, c) ? null : (Zd = c, a = z.getPooled(Wd.select, Yd, a, b), a.type = "select", a.target = Xd, Ua(a), a);
}
var be = { eventTypes: Wd, extractEvents: function extractEvents(a, b, c, d) {
    var e = d.window === d ? d.document : 9 === d.nodeType ? d : d.ownerDocument,
        f;if (!(f = !e)) {
      a: {
        e = Nd(e);f = ta.onSelect;for (var g = 0; g < f.length; g++) {
          var h = f[g];if (!e.hasOwnProperty(h) || !e[h]) {
            e = !1;break a;
          }
        }e = !0;
      }f = !e;
    }if (f) return null;e = b ? Ma(b) : window;switch (a) {case "focus":
        if (Rb(e) || "true" === e.contentEditable) Xd = e, Yd = b, Zd = null;break;case "blur":
        Zd = Yd = Xd = null;break;case "mousedown":
        $d = !0;break;case "contextmenu":case "mouseup":case "dragend":
        return $d = !1, ae(c, d);case "selectionchange":
        if (Vd) break;
      case "keydown":case "keyup":
        return ae(c, d);}return null;
  } };Ea.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));ua = Na;va = La;wa = Ma;Ea.injectEventPluginsByName({ SimpleEventPlugin: Cd, EnterLeaveEventPlugin: fd, ChangeEventPlugin: Uc, SelectEventPlugin: be, BeforeInputEventPlugin: Eb });function ce(a) {
  var b = "";aa.Children.forEach(a, function (a) {
    null != a && (b += a);
  });return b;
}
function de(a, b) {
  a = n({ children: void 0 }, b);if (b = ce(b.children)) a.children = b;return a;
}function ee(a, b, c, d) {
  a = a.options;if (b) {
    b = {};for (var e = 0; e < c.length; e++) {
      b["$" + c[e]] = !0;
    }for (c = 0; c < a.length; c++) {
      e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0);
    }
  } else {
    c = "" + yc(c);b = null;for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = !0;d && (a[e].defaultSelected = !0);return;
      }null !== b || a[e].disabled || (b = a[e]);
    }null !== b && (b.selected = !0);
  }
}
function fe(a, b) {
  null != b.dangerouslySetInnerHTML ? t("91") : void 0;return n({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}function ge(a, b) {
  var c = b.value;null == c && (c = b.defaultValue, b = b.children, null != b && (null != c ? t("92") : void 0, Array.isArray(b) && (1 >= b.length ? void 0 : t("93"), b = b[0]), c = b), null == c && (c = ""));a._wrapperState = { initialValue: yc(c) };
}
function he(a, b) {
  var c = yc(b.value),
      d = yc(b.defaultValue);null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));null != d && (a.defaultValue = "" + d);
}function ie(a) {
  var b = a.textContent;b === a._wrapperState.initialValue && (a.value = b);
}var je = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
function ke(a) {
  switch (a) {case "svg":
      return "http://www.w3.org/2000/svg";case "math":
      return "http://www.w3.org/1998/Math/MathML";default:
      return "http://www.w3.org/1999/xhtml";}
}function le(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? ke(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}
var me = void 0,
    ne = function (a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function () {
      return a(b, c, d, e);
    });
  } : a;
}(function (a, b) {
  if (a.namespaceURI !== je.svg || "innerHTML" in a) a.innerHTML = b;else {
    me = me || document.createElement("div");me.innerHTML = "<svg>" + b + "</svg>";for (b = me.firstChild; a.firstChild;) {
      a.removeChild(a.firstChild);
    }for (; b.firstChild;) {
      a.appendChild(b.firstChild);
    }
  }
});
function oe(a, b) {
  if (b) {
    var c = a.firstChild;if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;return;
    }
  }a.textContent = b;
}
var pe = { animationIterationCount: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0,
  floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 },
    qe = ["Webkit", "ms", "Moz", "O"];Object.keys(pe).forEach(function (a) {
  qe.forEach(function (b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);pe[b] = pe[a];
  });
});
function re(a, b) {
  a = a.style;for (var c in b) {
    if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--");var e = c;var f = b[c];e = null == f || "boolean" === typeof f || "" === f ? "" : d || "number" !== typeof f || 0 === f || pe.hasOwnProperty(e) && pe[e] ? ("" + f).trim() : f + "px";"float" === c && (c = "cssFloat");d ? a.setProperty(c, e) : a[c] = e;
    }
  }
}var se = n({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
function te(a, b) {
  b && (se[a] && (null != b.children || null != b.dangerouslySetInnerHTML ? t("137", a, "") : void 0), null != b.dangerouslySetInnerHTML && (null != b.children ? t("60") : void 0, "object" === _typeof(b.dangerouslySetInnerHTML) && "__html" in b.dangerouslySetInnerHTML ? void 0 : t("61")), null != b.style && "object" !== _typeof(b.style) ? t("62", "") : void 0);
}
function ue(a, b) {
  if (-1 === a.indexOf("-")) return "string" === typeof b.is;switch (a) {case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":
      return !1;default:
      return !0;}
}
function ve(a, b) {
  a = 9 === a.nodeType || 11 === a.nodeType ? a : a.ownerDocument;var c = Nd(a);b = ta[b];for (var d = 0; d < b.length; d++) {
    var e = b[d];if (!c.hasOwnProperty(e) || !c[e]) {
      switch (e) {case "scroll":
          Jd("scroll", a);break;case "focus":case "blur":
          Jd("focus", a);Jd("blur", a);c.blur = !0;c.focus = !0;break;case "cancel":case "close":
          Tb(e) && Jd(e, a);break;case "invalid":case "submit":case "reset":
          break;default:
          -1 === fb.indexOf(e) && F(e, a);}c[e] = !0;
    }
  }
}function we() {}var xe = null,
    ye = null;
function ze(a, b) {
  switch (a) {case "button":case "input":case "select":case "textarea":
      return !!b.autoFocus;}return !1;
}function Ae(a, b) {
  return "textarea" === a || "option" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === _typeof(b.dangerouslySetInnerHTML) && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
}function Be(a) {
  for (a = a.nextSibling; a && 1 !== a.nodeType && 3 !== a.nodeType;) {
    a = a.nextSibling;
  }return a;
}
function Ce(a) {
  for (a = a.firstChild; a && 1 !== a.nodeType && 3 !== a.nodeType;) {
    a = a.nextSibling;
  }return a;
}new Set();var De = [],
    Ee = -1;function G(a) {
  0 > Ee || (a.current = De[Ee], De[Ee] = null, Ee--);
}function H(a, b) {
  Ee++;De[Ee] = a.current;a.current = b;
}var Fe = {},
    I = { current: Fe },
    J = { current: !1 },
    Ge = Fe;
function He(a, b) {
  var c = a.type.contextTypes;if (!c) return Fe;var d = a.stateNode;if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;var e = {},
      f;for (f in c) {
    e[f] = b[f];
  }d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);return e;
}function K(a) {
  a = a.childContextTypes;return null !== a && void 0 !== a;
}function Ie(a) {
  G(J, a);G(I, a);
}function Je(a) {
  G(J, a);G(I, a);
}
function Ke(a, b, c) {
  I.current !== Fe ? t("168") : void 0;H(I, b, a);H(J, c, a);
}function Le(a, b, c) {
  var d = a.stateNode;a = b.childContextTypes;if ("function" !== typeof d.getChildContext) return c;d = d.getChildContext();for (var e in d) {
    e in a ? void 0 : t("108", lc(b) || "Unknown", e);
  }return n({}, c, d);
}function Me(a) {
  var b = a.stateNode;b = b && b.__reactInternalMemoizedMergedChildContext || Fe;Ge = I.current;H(I, b, a);H(J, J.current, a);return !0;
}
function Ne(a, b, c) {
  var d = a.stateNode;d ? void 0 : t("169");c ? (b = Le(a, b, Ge), d.__reactInternalMemoizedMergedChildContext = b, G(J, a), G(I, a), H(I, b, a)) : G(J, a);H(J, c, a);
}var Oe = null,
    Pe = null;function Qe(a) {
  return function (b) {
    try {
      return a(b);
    } catch (c) {}
  };
}
function Re(a) {
  if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;if (b.isDisabled || !b.supportsFiber) return !0;try {
    var c = b.inject(a);Oe = Qe(function (a) {
      return b.onCommitFiberRoot(c, a);
    });Pe = Qe(function (a) {
      return b.onCommitFiberUnmount(c, a);
    });
  } catch (d) {}return !0;
}
function Se(a, b, c, d) {
  this.tag = a;this.key = c;this.sibling = this.child = this.return = this.stateNode = this.type = null;this.index = 0;this.ref = null;this.pendingProps = b;this.firstContextDependency = this.memoizedState = this.updateQueue = this.memoizedProps = null;this.mode = d;this.effectTag = 0;this.lastEffect = this.firstEffect = this.nextEffect = null;this.childExpirationTime = this.expirationTime = 0;this.alternate = null;
}function Te(a) {
  a = a.prototype;return !(!a || !a.isReactComponent);
}
function Ue(a, b, c) {
  var d = a.alternate;null === d ? (d = new Se(a.tag, b, a.key, a.mode), d.type = a.type, d.stateNode = a.stateNode, d.alternate = a, a.alternate = d) : (d.pendingProps = b, d.effectTag = 0, d.nextEffect = null, d.firstEffect = null, d.lastEffect = null);d.childExpirationTime = a.childExpirationTime;d.expirationTime = b !== a.pendingProps ? c : a.expirationTime;d.child = a.child;d.memoizedProps = a.memoizedProps;d.memoizedState = a.memoizedState;d.updateQueue = a.updateQueue;d.firstContextDependency = a.firstContextDependency;d.sibling = a.sibling;
  d.index = a.index;d.ref = a.ref;return d;
}
function Ve(a, b, c) {
  var d = a.type,
      e = a.key;a = a.props;var f = void 0;if ("function" === typeof d) f = Te(d) ? 2 : 4;else if ("string" === typeof d) f = 7;else a: switch (d) {case bc:
      return We(a.children, b, c, e);case gc:
      f = 10;b |= 3;break;case cc:
      f = 10;b |= 2;break;case dc:
      return d = new Se(15, a, e, b | 4), d.type = dc, d.expirationTime = c, d;case ic:
      f = 16;break;default:
      if ("object" === (typeof d === "undefined" ? "undefined" : _typeof(d)) && null !== d) switch (d.$$typeof) {case ec:
          f = 12;break a;case fc:
          f = 11;break a;case hc:
          f = 13;break a;default:
          if ("function" === typeof d.then) {
            f = 4;break a;
          }}t("130", null == d ? d : typeof d === "undefined" ? "undefined" : _typeof(d), "");}b = new Se(f, a, e, b);b.type = d;b.expirationTime = c;return b;
}function We(a, b, c, d) {
  a = new Se(9, a, d, b);a.expirationTime = c;return a;
}function Xe(a, b, c) {
  a = new Se(8, a, null, b);a.expirationTime = c;return a;
}function Ye(a, b, c) {
  b = new Se(6, null !== a.children ? a.children : [], a.key, b);b.expirationTime = c;b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };return b;
}
function Ze(a, b) {
  a.didError = !1;var c = a.earliestPendingTime;0 === c ? a.earliestPendingTime = a.latestPendingTime = b : c > b ? a.earliestPendingTime = b : a.latestPendingTime < b && (a.latestPendingTime = b);$e(b, a);
}function $e(a, b) {
  var c = b.earliestSuspendedTime,
      d = b.latestSuspendedTime,
      e = b.earliestPendingTime,
      f = b.latestPingedTime;e = 0 !== e ? e : f;0 === e && (0 === a || d > a) && (e = d);a = e;0 !== a && 0 !== c && c < a && (a = c);b.nextExpirationTimeToWorkOn = e;b.expirationTime = a;
}var af = !1;
function bf(a) {
  return { baseState: a, firstUpdate: null, lastUpdate: null, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null };
}function cf(a) {
  return { baseState: a.baseState, firstUpdate: a.firstUpdate, lastUpdate: a.lastUpdate, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null };
}
function df(a) {
  return { expirationTime: a, tag: 0, payload: null, callback: null, next: null, nextEffect: null };
}function ef(a, b) {
  null === a.lastUpdate ? a.firstUpdate = a.lastUpdate = b : (a.lastUpdate.next = b, a.lastUpdate = b);
}
function ff(a, b) {
  var c = a.alternate;if (null === c) {
    var d = a.updateQueue;var e = null;null === d && (d = a.updateQueue = bf(a.memoizedState));
  } else d = a.updateQueue, e = c.updateQueue, null === d ? null === e ? (d = a.updateQueue = bf(a.memoizedState), e = c.updateQueue = bf(c.memoizedState)) : d = a.updateQueue = cf(e) : null === e && (e = c.updateQueue = cf(d));null === e || d === e ? ef(d, b) : null === d.lastUpdate || null === e.lastUpdate ? (ef(d, b), ef(e, b)) : (ef(d, b), e.lastUpdate = b);
}
function gf(a, b) {
  var c = a.updateQueue;c = null === c ? a.updateQueue = bf(a.memoizedState) : hf(a, c);null === c.lastCapturedUpdate ? c.firstCapturedUpdate = c.lastCapturedUpdate = b : (c.lastCapturedUpdate.next = b, c.lastCapturedUpdate = b);
}function hf(a, b) {
  var c = a.alternate;null !== c && b === c.updateQueue && (b = a.updateQueue = cf(b));return b;
}
function jf(a, b, c, d, e, f) {
  switch (c.tag) {case 1:
      return a = c.payload, "function" === typeof a ? a.call(f, d, e) : a;case 3:
      a.effectTag = a.effectTag & -1025 | 64;case 0:
      a = c.payload;e = "function" === typeof a ? a.call(f, d, e) : a;if (null === e || void 0 === e) break;return n({}, d, e);case 2:
      af = !0;}return d;
}
function kf(a, b, c, d, e) {
  af = !1;b = hf(a, b);for (var f = b.baseState, g = null, h = 0, k = b.firstUpdate, l = f; null !== k;) {
    var m = k.expirationTime;if (m > e) {
      if (null === g && (g = k, f = l), 0 === h || h > m) h = m;
    } else l = jf(a, b, k, l, c, d), null !== k.callback && (a.effectTag |= 32, k.nextEffect = null, null === b.lastEffect ? b.firstEffect = b.lastEffect = k : (b.lastEffect.nextEffect = k, b.lastEffect = k));k = k.next;
  }m = null;for (k = b.firstCapturedUpdate; null !== k;) {
    var r = k.expirationTime;if (r > e) {
      if (null === m && (m = k, null === g && (f = l)), 0 === h || h > r) h = r;
    } else l = jf(a, b, k, l, c, d), null !== k.callback && (a.effectTag |= 32, k.nextEffect = null, null === b.lastCapturedEffect ? b.firstCapturedEffect = b.lastCapturedEffect = k : (b.lastCapturedEffect.nextEffect = k, b.lastCapturedEffect = k));k = k.next;
  }null === g && (b.lastUpdate = null);null === m ? b.lastCapturedUpdate = null : a.effectTag |= 32;null === g && null === m && (f = l);b.baseState = f;b.firstUpdate = g;b.firstCapturedUpdate = m;a.expirationTime = h;a.memoizedState = l;
}
function lf(a, b, c) {
  null !== b.firstCapturedUpdate && (null !== b.lastUpdate && (b.lastUpdate.next = b.firstCapturedUpdate, b.lastUpdate = b.lastCapturedUpdate), b.firstCapturedUpdate = b.lastCapturedUpdate = null);mf(b.firstEffect, c);b.firstEffect = b.lastEffect = null;mf(b.firstCapturedEffect, c);b.firstCapturedEffect = b.lastCapturedEffect = null;
}function mf(a, b) {
  for (; null !== a;) {
    var c = a.callback;if (null !== c) {
      a.callback = null;var d = b;"function" !== typeof c ? t("191", c) : void 0;c.call(d);
    }a = a.nextEffect;
  }
}
function nf(a, b) {
  return { value: a, source: b, stack: mc(b) };
}var of = { current: null },
    pf = null,
    qf = null,
    rf = null;function sf(a, b) {
  var c = a.type._context;H(of, c._currentValue, a);c._currentValue = b;
}function tf(a) {
  var b = of.current;G(of, a);a.type._context._currentValue = b;
}function uf(a) {
  pf = a;rf = qf = null;a.firstContextDependency = null;
}
function vf(a, b) {
  if (rf !== a && !1 !== b && 0 !== b) {
    if ("number" !== typeof b || 1073741823 === b) rf = a, b = 1073741823;b = { context: a, observedBits: b, next: null };null === qf ? (null === pf ? t("277") : void 0, pf.firstContextDependency = qf = b) : qf = qf.next = b;
  }return a._currentValue;
}var wf = {},
    L = { current: wf },
    xf = { current: wf },
    yf = { current: wf };function zf(a) {
  a === wf ? t("174") : void 0;return a;
}
function Af(a, b) {
  H(yf, b, a);H(xf, a, a);H(L, wf, a);var c = b.nodeType;switch (c) {case 9:case 11:
      b = (b = b.documentElement) ? b.namespaceURI : le(null, "");break;default:
      c = 8 === c ? b.parentNode : b, b = c.namespaceURI || null, c = c.tagName, b = le(b, c);}G(L, a);H(L, b, a);
}function Bf(a) {
  G(L, a);G(xf, a);G(yf, a);
}function Cf(a) {
  zf(yf.current);var b = zf(L.current);var c = le(b, a.type);b !== c && (H(xf, a, a), H(L, c, a));
}function Df(a) {
  xf.current === a && (G(L, a), G(xf, a));
}var Ef = new aa.Component().refs;
function Ff(a, b, c, d) {
  b = a.memoizedState;c = c(d, b);c = null === c || void 0 === c ? b : n({}, b, c);a.memoizedState = c;d = a.updateQueue;null !== d && 0 === a.expirationTime && (d.baseState = c);
}
var Jf = { isMounted: function isMounted(a) {
    return (a = a._reactInternalFiber) ? 2 === jd(a) : !1;
  }, enqueueSetState: function enqueueSetState(a, b, c) {
    a = a._reactInternalFiber;var d = Gf();d = Hf(d, a);var e = df(d);e.payload = b;void 0 !== c && null !== c && (e.callback = c);ff(a, e);If(a, d);
  }, enqueueReplaceState: function enqueueReplaceState(a, b, c) {
    a = a._reactInternalFiber;var d = Gf();d = Hf(d, a);var e = df(d);e.tag = 1;e.payload = b;void 0 !== c && null !== c && (e.callback = c);ff(a, e);If(a, d);
  }, enqueueForceUpdate: function enqueueForceUpdate(a, b) {
    a = a._reactInternalFiber;var c = Gf();c = Hf(c, a);var d = df(c);d.tag = 2;void 0 !== b && null !== b && (d.callback = b);ff(a, d);If(a, c);
  } };function Kf(a, b, c, d, e, f, g) {
  a = a.stateNode;return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !id(c, d) || !id(e, f) : !0;
}function Lf(a, b, c, d) {
  a = b.state;"function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);"function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);b.state !== a && Jf.enqueueReplaceState(b, b.state, null);
}
function Mf(a, b, c, d) {
  var e = a.stateNode,
      f = K(b) ? Ge : I.current;e.props = c;e.state = a.memoizedState;e.refs = Ef;e.context = He(a, f);f = a.updateQueue;null !== f && (kf(a, f, c, e, d), e.state = a.memoizedState);f = b.getDerivedStateFromProps;"function" === typeof f && (Ff(a, b, f, c), e.state = a.memoizedState);"function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Jf.enqueueReplaceState(e, e.state, null), f = a.updateQueue, null !== f && (kf(a, f, c, e, d), e.state = a.memoizedState));"function" === typeof e.componentDidMount && (a.effectTag |= 4);
}var Nf = Array.isArray;
function Of(a, b, c) {
  a = c.ref;if (null !== a && "function" !== typeof a && "object" !== (typeof a === "undefined" ? "undefined" : _typeof(a))) {
    if (c._owner) {
      c = c._owner;var d = void 0;c && (2 !== c.tag && 3 !== c.tag ? t("110") : void 0, d = c.stateNode);d ? void 0 : t("147", a);var e = "" + a;if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === e) return b.ref;b = function b(a) {
        var b = d.refs;b === Ef && (b = d.refs = {});null === a ? delete b[e] : b[e] = a;
      };b._stringRef = e;return b;
    }"string" !== typeof a ? t("284") : void 0;c._owner ? void 0 : t("254", a);
  }return a;
}
function Pf(a, b) {
  "textarea" !== a.type && t("31", "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b, "");
}
function Qf(a) {
  function b(b, c) {
    if (a) {
      var d = b.lastEffect;null !== d ? (d.nextEffect = c, b.lastEffect = c) : b.firstEffect = b.lastEffect = c;c.nextEffect = null;c.effectTag = 8;
    }
  }function c(c, d) {
    if (!a) return null;for (; null !== d;) {
      b(c, d), d = d.sibling;
    }return null;
  }function d(a, b) {
    for (a = new Map(); null !== b;) {
      null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;
    }return a;
  }function e(a, b, c) {
    a = Ue(a, b, c);a.index = 0;a.sibling = null;return a;
  }function f(b, c, d) {
    b.index = d;if (!a) return c;d = b.alternate;if (null !== d) return d = d.index, d < c ? (b.effectTag = 2, c) : d;b.effectTag = 2;return c;
  }function g(b) {
    a && null === b.alternate && (b.effectTag = 2);return b;
  }function h(a, b, c, d) {
    if (null === b || 8 !== b.tag) return b = Xe(c, a.mode, d), b.return = a, b;b = e(b, c, d);b.return = a;return b;
  }function k(a, b, c, d) {
    if (null !== b && b.type === c.type) return d = e(b, c.props, d), d.ref = Of(a, b, c), d.return = a, d;d = Ve(c, a.mode, d);d.ref = Of(a, b, c);d.return = a;return d;
  }function l(a, b, c, d) {
    if (null === b || 6 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = Ye(c, a.mode, d), b.return = a, b;b = e(b, c.children || [], d);b.return = a;return b;
  }function m(a, b, c, d, f) {
    if (null === b || 9 !== b.tag) return b = We(c, a.mode, d, f), b.return = a, b;b = e(b, c, d);b.return = a;return b;
  }function r(a, b, c) {
    if ("string" === typeof b || "number" === typeof b) return b = Xe("" + b, a.mode, c), b.return = a, b;if ("object" === (typeof b === "undefined" ? "undefined" : _typeof(b)) && null !== b) {
      switch (b.$$typeof) {case $b:
          return c = Ve(b, a.mode, c), c.ref = Of(a, null, b), c.return = a, c;case ac:
          return b = Ye(b, a.mode, c), b.return = a, b;}if (Nf(b) || kc(b)) return b = We(b, a.mode, c, null), b.return = a, b;Pf(a, b);
    }return null;
  }function A(a, b, c, d) {
    var e = null !== b ? b.key : null;if ("string" === typeof c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);if ("object" === (typeof c === "undefined" ? "undefined" : _typeof(c)) && null !== c) {
      switch (c.$$typeof) {case $b:
          return c.key === e ? c.type === bc ? m(a, b, c.props.children, d, e) : k(a, b, c, d) : null;case ac:
          return c.key === e ? l(a, b, c, d) : null;}if (Nf(c) || kc(c)) return null !== e ? null : m(a, b, c, d, null);Pf(a, c);
    }return null;
  }function S(a, b, c, d, e) {
    if ("string" === typeof d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);
    if ("object" === (typeof d === "undefined" ? "undefined" : _typeof(d)) && null !== d) {
      switch (d.$$typeof) {case $b:
          return a = a.get(null === d.key ? c : d.key) || null, d.type === bc ? m(b, a, d.props.children, e, d.key) : k(b, a, d, e);case ac:
          return a = a.get(null === d.key ? c : d.key) || null, l(b, a, d, e);}if (Nf(d) || kc(d)) return a = a.get(c) || null, m(b, a, d, e, null);Pf(b, d);
    }return null;
  }function B(e, g, h, k) {
    for (var l = null, m = null, p = g, u = g = 0, q = null; null !== p && u < h.length; u++) {
      p.index > u ? (q = p, p = null) : q = p.sibling;var v = A(e, p, h[u], k);if (null === v) {
        null === p && (p = q);break;
      }a && p && null === v.alternate && b(e, p);g = f(v, g, u);null === m ? l = v : m.sibling = v;m = v;p = q;
    }if (u === h.length) return c(e, p), l;if (null === p) {
      for (; u < h.length; u++) {
        if (p = r(e, h[u], k)) g = f(p, g, u), null === m ? l = p : m.sibling = p, m = p;
      }return l;
    }for (p = d(e, p); u < h.length; u++) {
      if (q = S(p, e, u, h[u], k)) a && null !== q.alternate && p.delete(null === q.key ? u : q.key), g = f(q, g, u), null === m ? l = q : m.sibling = q, m = q;
    }a && p.forEach(function (a) {
      return b(e, a);
    });return l;
  }function P(e, g, h, k) {
    var l = kc(h);"function" !== typeof l ? t("150") : void 0;h = l.call(h);null == h ? t("151") : void 0;for (var m = l = null, p = g, u = g = 0, q = null, v = h.next(); null !== p && !v.done; u++, v = h.next()) {
      p.index > u ? (q = p, p = null) : q = p.sibling;var x = A(e, p, v.value, k);if (null === x) {
        p || (p = q);break;
      }a && p && null === x.alternate && b(e, p);g = f(x, g, u);null === m ? l = x : m.sibling = x;m = x;p = q;
    }if (v.done) return c(e, p), l;if (null === p) {
      for (; !v.done; u++, v = h.next()) {
        v = r(e, v.value, k), null !== v && (g = f(v, g, u), null === m ? l = v : m.sibling = v, m = v);
      }return l;
    }for (p = d(e, p); !v.done; u++, v = h.next()) {
      v = S(p, e, u, v.value, k), null !== v && (a && null !== v.alternate && p.delete(null === v.key ? u : v.key), g = f(v, g, u), null === m ? l = v : m.sibling = v, m = v);
    }a && p.forEach(function (a) {
      return b(e, a);
    });return l;
  }return function (a, d, f, h) {
    var k = "object" === (typeof f === "undefined" ? "undefined" : _typeof(f)) && null !== f && f.type === bc && null === f.key;k && (f = f.props.children);var l = "object" === (typeof f === "undefined" ? "undefined" : _typeof(f)) && null !== f;if (l) switch (f.$$typeof) {case $b:
        a: {
          l = f.key;for (k = d; null !== k;) {
            if (k.key === l) {
              if (9 === k.tag ? f.type === bc : k.type === f.type) {
                c(a, k.sibling);d = e(k, f.type === bc ? f.props.children : f.props, h);d.ref = Of(a, k, f);d.return = a;a = d;break a;
              } else {
                c(a, k);break;
              }
            } else b(a, k);k = k.sibling;
          }f.type === bc ? (d = We(f.props.children, a.mode, h, f.key), d.return = a, a = d) : (h = Ve(f, a.mode, h), h.ref = Of(a, d, f), h.return = a, a = h);
        }return g(a);case ac:
        a: {
          for (k = f.key; null !== d;) {
            if (d.key === k) {
              if (6 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                c(a, d.sibling);d = e(d, f.children || [], h);d.return = a;a = d;break a;
              } else {
                c(a, d);break;
              }
            } else b(a, d);d = d.sibling;
          }d = Ye(f, a.mode, h);d.return = a;a = d;
        }return g(a);}if ("string" === typeof f || "number" === typeof f) return f = "" + f, null !== d && 8 === d.tag ? (c(a, d.sibling), d = e(d, f, h), d.return = a, a = d) : (c(a, d), d = Xe(f, a.mode, h), d.return = a, a = d), g(a);if (Nf(f)) return B(a, d, f, h);if (kc(f)) return P(a, d, f, h);l && Pf(a, f);if ("undefined" === typeof f && !k) switch (a.tag) {case 2:case 3:case 0:
        h = a.type, t("152", h.displayName || h.name || "Component");}return c(a, d);
  };
}var Rf = Qf(!0),
    Sf = Qf(!1),
    Tf = null,
    Uf = null,
    Vf = !1;function Wf(a, b) {
  var c = new Se(7, null, null, 0);c.type = "DELETED";c.stateNode = b;c.return = a;c.effectTag = 8;null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
}
function Xf(a, b) {
  switch (a.tag) {case 7:
      var c = a.type;b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;return null !== b ? (a.stateNode = b, !0) : !1;case 8:
      return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, !0) : !1;default:
      return !1;}
}function Yf(a) {
  if (Vf) {
    var b = Uf;if (b) {
      var c = b;if (!Xf(a, b)) {
        b = Be(c);if (!b || !Xf(a, b)) {
          a.effectTag |= 2;Vf = !1;Tf = a;return;
        }Wf(Tf, c);
      }Tf = a;Uf = Ce(b);
    } else a.effectTag |= 2, Vf = !1, Tf = a;
  }
}
function Zf(a) {
  for (a = a.return; null !== a && 7 !== a.tag && 5 !== a.tag;) {
    a = a.return;
  }Tf = a;
}function $f(a) {
  if (a !== Tf) return !1;if (!Vf) return Zf(a), Vf = !0, !1;var b = a.type;if (7 !== a.tag || "head" !== b && "body" !== b && !Ae(b, a.memoizedProps)) for (b = Uf; b;) {
    Wf(a, b), b = Be(b);
  }Zf(a);Uf = Tf ? Be(a.stateNode) : null;return !0;
}function ag() {
  Uf = Tf = null;Vf = !1;
}
function bg(a) {
  switch (a._reactStatus) {case 1:
      return a._reactResult;case 2:
      throw a._reactResult;case 0:
      throw a;default:
      throw a._reactStatus = 0, a.then(function (b) {
        if (0 === a._reactStatus) {
          a._reactStatus = 1;if ("object" === (typeof b === "undefined" ? "undefined" : _typeof(b)) && null !== b) {
            var c = b.default;b = void 0 !== c && null !== c ? c : b;
          }a._reactResult = b;
        }
      }, function (b) {
        0 === a._reactStatus && (a._reactStatus = 2, a._reactResult = b);
      }), a;}
}var cg = Yb.ReactCurrentOwner;function M(a, b, c, d) {
  b.child = null === a ? Sf(b, null, c, d) : Rf(b, a.child, c, d);
}
function dg(a, b, c, d, e) {
  c = c.render;var f = b.ref;if (!J.current && b.memoizedProps === d && f === (null !== a ? a.ref : null)) return eg(a, b, e);c = c(d, f);M(a, b, c, e);b.memoizedProps = d;return b.child;
}function fg(a, b) {
  var c = b.ref;if (null === a && null !== c || null !== a && a.ref !== c) b.effectTag |= 128;
}function gg(a, b, c, d, e) {
  var f = K(c) ? Ge : I.current;f = He(b, f);uf(b, e);c = c(d, f);b.effectTag |= 1;M(a, b, c, e);b.memoizedProps = d;return b.child;
}
function hg(a, b, c, d, e) {
  if (K(c)) {
    var f = !0;Me(b);
  } else f = !1;uf(b, e);if (null === a) {
    if (null === b.stateNode) {
      var g = K(c) ? Ge : I.current,
          h = c.contextTypes,
          k = null !== h && void 0 !== h;h = k ? He(b, g) : Fe;var l = new c(d, h);b.memoizedState = null !== l.state && void 0 !== l.state ? l.state : null;l.updater = Jf;b.stateNode = l;l._reactInternalFiber = b;k && (k = b.stateNode, k.__reactInternalMemoizedUnmaskedChildContext = g, k.__reactInternalMemoizedMaskedChildContext = h);Mf(b, c, d, e);d = !0;
    } else {
      g = b.stateNode;h = b.memoizedProps;g.props = h;var m = g.context;
      k = K(c) ? Ge : I.current;k = He(b, k);var r = c.getDerivedStateFromProps;(l = "function" === typeof r || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || m !== k) && Lf(b, g, d, k);af = !1;var A = b.memoizedState;m = g.state = A;var S = b.updateQueue;null !== S && (kf(b, S, d, g, e), m = b.memoizedState);h !== d || A !== m || J.current || af ? ("function" === typeof r && (Ff(b, c, r, d), m = b.memoizedState), (h = af || Kf(b, c, h, d, A, m, k)) ? (l || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.effectTag |= 4)) : ("function" === typeof g.componentDidMount && (b.effectTag |= 4), b.memoizedProps = d, b.memoizedState = m), g.props = d, g.state = m, g.context = k, d = h) : ("function" === typeof g.componentDidMount && (b.effectTag |= 4), d = !1);
    }
  } else g = b.stateNode, h = b.memoizedProps, g.props = h, m = g.context, k = K(c) ? Ge : I.current, k = He(b, k), r = c.getDerivedStateFromProps, (l = "function" === typeof r || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || m !== k) && Lf(b, g, d, k), af = !1, m = b.memoizedState, A = g.state = m, S = b.updateQueue, null !== S && (kf(b, S, d, g, e), A = b.memoizedState), h !== d || m !== A || J.current || af ? ("function" === typeof r && (Ff(b, c, r, d), A = b.memoizedState), (r = af || Kf(b, c, h, d, m, A, k)) ? (l || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, A, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, A, k)), "function" === typeof g.componentDidUpdate && (b.effectTag |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.effectTag |= 256)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && m === a.memoizedState || (b.effectTag |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && m === a.memoizedState || (b.effectTag |= 256), b.memoizedProps = d, b.memoizedState = A), g.props = d, g.state = A, g.context = k, d = r) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && m === a.memoizedState || (b.effectTag |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && m === a.memoizedState || (b.effectTag |= 256), d = !1);return ig(a, b, c, d, f, e);
}
function ig(a, b, c, d, e, f) {
  fg(a, b);var g = 0 !== (b.effectTag & 64);if (!d && !g) return e && Ne(b, c, !1), eg(a, b, f);d = b.stateNode;cg.current = b;var h = g ? null : d.render();b.effectTag |= 1;null !== a && g && (M(a, b, null, f), b.child = null);M(a, b, h, f);b.memoizedState = d.state;b.memoizedProps = d.props;e && Ne(b, c, !0);return b.child;
}function jg(a) {
  var b = a.stateNode;b.pendingContext ? Ke(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Ke(a, b.context, !1);Af(a, b.containerInfo);
}
function ng(a, b) {
  if (a && a.defaultProps) {
    b = n({}, b);a = a.defaultProps;for (var c in a) {
      void 0 === b[c] && (b[c] = a[c]);
    }
  }return b;
}
function og(a, b, c, d) {
  null !== a ? t("155") : void 0;var e = b.pendingProps;if ("object" === (typeof c === "undefined" ? "undefined" : _typeof(c)) && null !== c && "function" === typeof c.then) {
    c = bg(c);var f = c;f = "function" === typeof f ? Te(f) ? 3 : 1 : void 0 !== f && null !== f && f.$$typeof ? 14 : 4;f = b.tag = f;var g = ng(c, e);switch (f) {case 1:
        return gg(a, b, c, g, d);case 3:
        return hg(a, b, c, g, d);case 14:
        return dg(a, b, c, g, d);default:
        t("283", c);}
  }f = He(b, I.current);uf(b, d);f = c(e, f);b.effectTag |= 1;if ("object" === (typeof f === "undefined" ? "undefined" : _typeof(f)) && null !== f && "function" === typeof f.render && void 0 === f.$$typeof) {
    b.tag = 2;K(c) ? (g = !0, Me(b)) : g = !1;b.memoizedState = null !== f.state && void 0 !== f.state ? f.state : null;var h = c.getDerivedStateFromProps;"function" === typeof h && Ff(b, c, h, e);f.updater = Jf;b.stateNode = f;f._reactInternalFiber = b;Mf(b, c, e, d);return ig(a, b, c, !0, g, d);
  }b.tag = 0;M(a, b, f, d);b.memoizedProps = e;return b.child;
}
function eg(a, b, c) {
  null !== a && (b.firstContextDependency = a.firstContextDependency);var d = b.childExpirationTime;if (0 === d || d > c) return null;null !== a && b.child !== a.child ? t("153") : void 0;if (null !== b.child) {
    a = b.child;c = Ue(a, a.pendingProps, a.expirationTime);b.child = c;for (c.return = b; null !== a.sibling;) {
      a = a.sibling, c = c.sibling = Ue(a, a.pendingProps, a.expirationTime), c.return = b;
    }c.sibling = null;
  }return b.child;
}
function pg(a, b, c) {
  var d = b.expirationTime;if (!J.current && (0 === d || d > c)) {
    switch (b.tag) {case 5:
        jg(b);ag();break;case 7:
        Cf(b);break;case 2:
        K(b.type) && Me(b);break;case 3:
        K(b.type._reactResult) && Me(b);break;case 6:
        Af(b, b.stateNode.containerInfo);break;case 12:
        sf(b, b.memoizedProps.value);}return eg(a, b, c);
  }b.expirationTime = 0;switch (b.tag) {case 4:
      return og(a, b, b.type, c);case 0:
      return gg(a, b, b.type, b.pendingProps, c);case 1:
      var e = b.type._reactResult;d = b.pendingProps;a = gg(a, b, e, ng(e, d), c);b.memoizedProps = d;return a;
    case 2:
      return hg(a, b, b.type, b.pendingProps, c);case 3:
      return e = b.type._reactResult, d = b.pendingProps, a = hg(a, b, e, ng(e, d), c), b.memoizedProps = d, a;case 5:
      jg(b);d = b.updateQueue;null === d ? t("282") : void 0;e = b.memoizedState;e = null !== e ? e.element : null;kf(b, d, b.pendingProps, null, c);d = b.memoizedState.element;if (d === e) ag(), b = eg(a, b, c);else {
        e = b.stateNode;if (e = (null === a || null === a.child) && e.hydrate) Uf = Ce(b.stateNode.containerInfo), Tf = b, e = Vf = !0;e ? (b.effectTag |= 2, b.child = Sf(b, null, d, c)) : (M(a, b, d, c), ag());b = b.child;
      }return b;
    case 7:
      Cf(b);null === a && Yf(b);d = b.type;e = b.pendingProps;var f = null !== a ? a.memoizedProps : null,
          g = e.children;Ae(d, e) ? g = null : null !== f && Ae(d, f) && (b.effectTag |= 16);fg(a, b);1073741823 !== c && b.mode & 1 && e.hidden ? (b.expirationTime = 1073741823, b.memoizedProps = e, b = null) : (M(a, b, g, c), b.memoizedProps = e, b = b.child);return b;case 8:
      return null === a && Yf(b), b.memoizedProps = b.pendingProps, null;case 16:
      return null;case 6:
      return Af(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Rf(b, null, d, c) : M(a, b, d, c), b.memoizedProps = d, b.child;case 13:
      return dg(a, b, b.type, b.pendingProps, c);case 14:
      return e = b.type._reactResult, d = b.pendingProps, a = dg(a, b, e, ng(e, d), c), b.memoizedProps = d, a;case 9:
      return d = b.pendingProps, M(a, b, d, c), b.memoizedProps = d, b.child;case 10:
      return d = b.pendingProps.children, M(a, b, d, c), b.memoizedProps = d, b.child;case 15:
      return d = b.pendingProps, M(a, b, d.children, c), b.memoizedProps = d, b.child;case 12:
      a: {
        d = b.type._context;e = b.pendingProps;g = b.memoizedProps;f = e.value;b.memoizedProps = e;sf(b, f);if (null !== g) {
          var h = g.value;
          f = h === f && (0 !== h || 1 / h === 1 / f) || h !== h && f !== f ? 0 : ("function" === typeof d._calculateChangedBits ? d._calculateChangedBits(h, f) : 1073741823) | 0;if (0 === f) {
            if (g.children === e.children && !J.current) {
              b = eg(a, b, c);break a;
            }
          } else for (g = b.child, null !== g && (g.return = b); null !== g;) {
            h = g.firstContextDependency;if (null !== h) {
              do {
                if (h.context === d && 0 !== (h.observedBits & f)) {
                  if (2 === g.tag || 3 === g.tag) {
                    var k = df(c);k.tag = 2;ff(g, k);
                  }if (0 === g.expirationTime || g.expirationTime > c) g.expirationTime = c;k = g.alternate;null !== k && (0 === k.expirationTime || k.expirationTime > c) && (k.expirationTime = c);for (var l = g.return; null !== l;) {
                    k = l.alternate;if (0 === l.childExpirationTime || l.childExpirationTime > c) l.childExpirationTime = c, null !== k && (0 === k.childExpirationTime || k.childExpirationTime > c) && (k.childExpirationTime = c);else if (null !== k && (0 === k.childExpirationTime || k.childExpirationTime > c)) k.childExpirationTime = c;else break;l = l.return;
                  }
                }k = g.child;h = h.next;
              } while (null !== h);
            } else k = 12 === g.tag ? g.type === b.type ? null : g.child : g.child;if (null !== k) k.return = g;else for (k = g; null !== k;) {
              if (k === b) {
                k = null;break;
              }g = k.sibling;if (null !== g) {
                g.return = k.return;k = g;break;
              }k = k.return;
            }g = k;
          }
        }M(a, b, e.children, c);b = b.child;
      }return b;case 11:
      return f = b.type, d = b.pendingProps, e = d.children, uf(b, c), f = vf(f, d.unstable_observedBits), e = e(f), b.effectTag |= 1, M(a, b, e, c), b.memoizedProps = d, b.child;default:
      t("156");}
}function qg(a) {
  a.effectTag |= 4;
}var rg = void 0,
    sg = void 0,
    tg = void 0;rg = function rg() {};
sg = function sg(a, b, c, d, e) {
  var f = a.memoizedProps;if (f !== d) {
    var g = b.stateNode;zf(L.current);a = null;switch (c) {case "input":
        f = zc(g, f);d = zc(g, d);a = [];break;case "option":
        f = de(g, f);d = de(g, d);a = [];break;case "select":
        f = n({}, f, { value: void 0 });d = n({}, d, { value: void 0 });a = [];break;case "textarea":
        f = fe(g, f);d = fe(g, d);a = [];break;default:
        "function" !== typeof f.onClick && "function" === typeof d.onClick && (g.onclick = we);}te(c, d);g = c = void 0;var h = null;for (c in f) {
      if (!d.hasOwnProperty(c) && f.hasOwnProperty(c) && null != f[c]) if ("style" === c) {
        var k = f[c];for (g in k) {
          k.hasOwnProperty(g) && (h || (h = {}), h[g] = "");
        }
      } else "dangerouslySetInnerHTML" !== c && "children" !== c && "suppressContentEditableWarning" !== c && "suppressHydrationWarning" !== c && "autoFocus" !== c && (sa.hasOwnProperty(c) ? a || (a = []) : (a = a || []).push(c, null));
    }for (c in d) {
      var l = d[c];k = null != f ? f[c] : void 0;if (d.hasOwnProperty(c) && l !== k && (null != l || null != k)) if ("style" === c) {
        if (k) {
          for (g in k) {
            !k.hasOwnProperty(g) || l && l.hasOwnProperty(g) || (h || (h = {}), h[g] = "");
          }for (g in l) {
            l.hasOwnProperty(g) && k[g] !== l[g] && (h || (h = {}), h[g] = l[g]);
          }
        } else h || (a || (a = []), a.push(c, h)), h = l;
      } else "dangerouslySetInnerHTML" === c ? (l = l ? l.__html : void 0, k = k ? k.__html : void 0, null != l && k !== l && (a = a || []).push(c, "" + l)) : "children" === c ? k === l || "string" !== typeof l && "number" !== typeof l || (a = a || []).push(c, "" + l) : "suppressContentEditableWarning" !== c && "suppressHydrationWarning" !== c && (sa.hasOwnProperty(c) ? (null != l && ve(e, c), a || k === l || (a = [])) : (a = a || []).push(c, l));
    }h && (a = a || []).push("style", h);e = a;(b.updateQueue = e) && qg(b);
  }
};tg = function tg(a, b, c, d) {
  c !== d && qg(b);
};
function ug(a, b) {
  var c = b.source,
      d = b.stack;null === d && null !== c && (d = mc(c));null !== c && lc(c.type);b = b.value;null !== a && 2 === a.tag && lc(a.type);try {
    console.error(b);
  } catch (e) {
    setTimeout(function () {
      throw e;
    });
  }
}function vg(a) {
  var b = a.ref;if (null !== b) if ("function" === typeof b) try {
    b(null);
  } catch (c) {
    wg(a, c);
  } else b.current = null;
}
function xg(a) {
  "function" === typeof Pe && Pe(a);switch (a.tag) {case 2:case 3:
      vg(a);var b = a.stateNode;if ("function" === typeof b.componentWillUnmount) try {
        b.props = a.memoizedProps, b.state = a.memoizedState, b.componentWillUnmount();
      } catch (c) {
        wg(a, c);
      }break;case 7:
      vg(a);break;case 6:
      yg(a);}
}function zg(a) {
  return 7 === a.tag || 5 === a.tag || 6 === a.tag;
}
function Ag(a) {
  a: {
    for (var b = a.return; null !== b;) {
      if (zg(b)) {
        var c = b;break a;
      }b = b.return;
    }t("160");c = void 0;
  }var d = b = void 0;switch (c.tag) {case 7:
      b = c.stateNode;d = !1;break;case 5:
      b = c.stateNode.containerInfo;d = !0;break;case 6:
      b = c.stateNode.containerInfo;d = !0;break;default:
      t("161");}c.effectTag & 16 && (oe(b, ""), c.effectTag &= -17);a: b: for (c = a;;) {
    for (; null === c.sibling;) {
      if (null === c.return || zg(c.return)) {
        c = null;break a;
      }c = c.return;
    }c.sibling.return = c.return;for (c = c.sibling; 7 !== c.tag && 8 !== c.tag;) {
      if (c.effectTag & 2) continue b;
      if (null === c.child || 6 === c.tag) continue b;else c.child.return = c, c = c.child;
    }if (!(c.effectTag & 2)) {
      c = c.stateNode;break a;
    }
  }for (var e = a;;) {
    if (7 === e.tag || 8 === e.tag) {
      if (c) {
        if (d) {
          var f = b,
              g = e.stateNode,
              h = c;8 === f.nodeType ? f.parentNode.insertBefore(g, h) : f.insertBefore(g, h);
        } else b.insertBefore(e.stateNode, c);
      } else d ? (f = b, g = e.stateNode, 8 === f.nodeType ? (h = f.parentNode, h.insertBefore(g, f)) : (h = f, h.appendChild(g)), null === h.onclick && (h.onclick = we)) : b.appendChild(e.stateNode);
    } else if (6 !== e.tag && null !== e.child) {
      e.child.return = e;e = e.child;continue;
    }if (e === a) break;for (; null === e.sibling;) {
      if (null === e.return || e.return === a) return;e = e.return;
    }e.sibling.return = e.return;e = e.sibling;
  }
}
function yg(a) {
  for (var b = a, c = !1, d = void 0, e = void 0;;) {
    if (!c) {
      c = b.return;a: for (;;) {
        null === c ? t("160") : void 0;switch (c.tag) {case 7:
            d = c.stateNode;e = !1;break a;case 5:
            d = c.stateNode.containerInfo;e = !0;break a;case 6:
            d = c.stateNode.containerInfo;e = !0;break a;}c = c.return;
      }c = !0;
    }if (7 === b.tag || 8 === b.tag) {
      a: for (var f = b, g = f;;) {
        if (xg(g), null !== g.child && 6 !== g.tag) g.child.return = g, g = g.child;else {
          if (g === f) break;for (; null === g.sibling;) {
            if (null === g.return || g.return === f) break a;g = g.return;
          }g.sibling.return = g.return;g = g.sibling;
        }
      }e ? (f = d, g = b.stateNode, 8 === f.nodeType ? f.parentNode.removeChild(g) : f.removeChild(g)) : d.removeChild(b.stateNode);
    } else if (6 === b.tag ? (d = b.stateNode.containerInfo, e = !0) : xg(b), null !== b.child) {
      b.child.return = b;b = b.child;continue;
    }if (b === a) break;for (; null === b.sibling;) {
      if (null === b.return || b.return === a) return;b = b.return;6 === b.tag && (c = !1);
    }b.sibling.return = b.return;b = b.sibling;
  }
}
function Bg(a, b) {
  switch (b.tag) {case 2:case 3:
      break;case 7:
      var c = b.stateNode;if (null != c) {
        var d = b.memoizedProps,
            e = null !== a ? a.memoizedProps : d;a = b.type;var f = b.updateQueue;b.updateQueue = null;if (null !== f) {
          c[Ja] = d;"input" === a && "radio" === d.type && null != d.name && Cc(c, d);ue(a, e);b = ue(a, d);for (e = 0; e < f.length; e += 2) {
            var g = f[e],
                h = f[e + 1];"style" === g ? re(c, h) : "dangerouslySetInnerHTML" === g ? ne(c, h) : "children" === g ? oe(c, h) : xc(c, g, h, b);
          }switch (a) {case "input":
              Dc(c, d);break;case "textarea":
              he(c, d);break;case "select":
              a = c._wrapperState.wasMultiple, c._wrapperState.wasMultiple = !!d.multiple, f = d.value, null != f ? ee(c, !!d.multiple, f, !1) : a !== !!d.multiple && (null != d.defaultValue ? ee(c, !!d.multiple, d.defaultValue, !0) : ee(c, !!d.multiple, d.multiple ? [] : "", !1));}
        }
      }break;case 8:
      null === b.stateNode ? t("162") : void 0;b.stateNode.nodeValue = b.memoizedProps;break;case 5:
      break;case 15:
      break;case 16:
      break;default:
      t("163");}
}function Cg(a, b, c) {
  c = df(c);c.tag = 3;c.payload = { element: null };var d = b.value;c.callback = function () {
    Dg(d);ug(a, b);
  };return c;
}
function Eg(a, b, c) {
  c = df(c);c.tag = 3;var d = a.stateNode;null !== d && "function" === typeof d.componentDidCatch && (c.callback = function () {
    null === Fg ? Fg = new Set([this]) : Fg.add(this);var c = b.value,
        d = b.stack;ug(a, b);this.componentDidCatch(c, { componentStack: null !== d ? d : "" });
  });return c;
}
function Gg(a) {
  switch (a.tag) {case 2:
      K(a.type) && Ie(a);var b = a.effectTag;return b & 1024 ? (a.effectTag = b & -1025 | 64, a) : null;case 3:
      return K(a.type._reactResult) && Ie(a), b = a.effectTag, b & 1024 ? (a.effectTag = b & -1025 | 64, a) : null;case 5:
      return Bf(a), Je(a), b = a.effectTag, 0 !== (b & 64) ? t("285") : void 0, a.effectTag = b & -1025 | 64, a;case 7:
      return Df(a), null;case 16:
      return b = a.effectTag, b & 1024 ? (a.effectTag = b & -1025 | 64, a) : null;case 6:
      return Bf(a), null;case 12:
      return tf(a), null;default:
      return null;}
}
var Hg = { readContext: vf },
    Ig = Yb.ReactCurrentOwner,
    Jg = 0,
    Kg = 0,
    Lg = !1,
    N = null,
    Mg = null,
    O = 0,
    Ng = !1,
    Q = null,
    Og = !1,
    Fg = null;function Pg() {
  if (null !== N) for (var a = N.return; null !== a;) {
    var b = a;switch (b.tag) {case 2:
        var c = b.type.childContextTypes;null !== c && void 0 !== c && Ie(b);break;case 3:
        c = b.type._reactResult.childContextTypes;null !== c && void 0 !== c && Ie(b);break;case 5:
        Bf(b);Je(b);break;case 7:
        Df(b);break;case 6:
        Bf(b);break;case 12:
        tf(b);}a = a.return;
  }Mg = null;O = 0;Ng = !1;N = null;
}
function Qg(a) {
  for (;;) {
    var b = a.alternate,
        c = a.return,
        d = a.sibling;if (0 === (a.effectTag & 512)) {
      var e = b;b = a;var f = b.pendingProps;switch (b.tag) {case 0:case 1:
          break;case 2:
          K(b.type) && Ie(b);break;case 3:
          K(b.type._reactResult) && Ie(b);break;case 5:
          Bf(b);Je(b);f = b.stateNode;f.pendingContext && (f.context = f.pendingContext, f.pendingContext = null);if (null === e || null === e.child) $f(b), b.effectTag &= -3;rg(b);break;case 7:
          Df(b);var g = zf(yf.current),
              h = b.type;if (null !== e && null != b.stateNode) sg(e, b, h, f, g), e.ref !== b.ref && (b.effectTag |= 128);else if (f) {
            var k = zf(L.current);if ($f(b)) {
              f = b;e = f.stateNode;var l = f.type,
                  m = f.memoizedProps,
                  r = g;e[Ia] = f;e[Ja] = m;h = void 0;g = l;switch (g) {case "iframe":case "object":
                  F("load", e);break;case "video":case "audio":
                  for (l = 0; l < fb.length; l++) {
                    F(fb[l], e);
                  }break;case "source":
                  F("error", e);break;case "img":case "image":case "link":
                  F("error", e);F("load", e);break;case "form":
                  F("reset", e);F("submit", e);break;case "details":
                  F("toggle", e);break;case "input":
                  Bc(e, m);F("invalid", e);ve(r, "onChange");break;case "select":
                  e._wrapperState = { wasMultiple: !!m.multiple };F("invalid", e);ve(r, "onChange");break;case "textarea":
                  ge(e, m), F("invalid", e), ve(r, "onChange");}te(g, m);l = null;for (h in m) {
                m.hasOwnProperty(h) && (k = m[h], "children" === h ? "string" === typeof k ? e.textContent !== k && (l = ["children", k]) : "number" === typeof k && e.textContent !== "" + k && (l = ["children", "" + k]) : sa.hasOwnProperty(h) && null != k && ve(r, h));
              }switch (g) {case "input":
                  Wb(e);Fc(e, m, !0);break;case "textarea":
                  Wb(e);ie(e, m);break;case "select":case "option":
                  break;default:
                  "function" === typeof m.onClick && (e.onclick = we);}h = l;f.updateQueue = h;f = null !== h ? !0 : !1;f && qg(b);
            } else {
              m = b;e = h;r = f;l = 9 === g.nodeType ? g : g.ownerDocument;k === je.html && (k = ke(e));k === je.html ? "script" === e ? (e = l.createElement("div"), e.innerHTML = "<script>\x3c/script>", l = e.removeChild(e.firstChild)) : "string" === typeof r.is ? l = l.createElement(e, { is: r.is }) : (l = l.createElement(e), "select" === e && r.multiple && (l.multiple = !0)) : l = l.createElementNS(k, e);e = l;e[Ia] = m;e[Ja] = f;a: for (m = e, r = b, l = r.child; null !== l;) {
                if (7 === l.tag || 8 === l.tag) m.appendChild(l.stateNode);else if (6 !== l.tag && null !== l.child) {
                  l.child.return = l;l = l.child;continue;
                }if (l === r) break;for (; null === l.sibling;) {
                  if (null === l.return || l.return === r) break a;l = l.return;
                }l.sibling.return = l.return;l = l.sibling;
              }r = e;l = h;m = f;var A = g,
                  S = ue(l, m);switch (l) {case "iframe":case "object":
                  F("load", r);g = m;break;case "video":case "audio":
                  for (g = 0; g < fb.length; g++) {
                    F(fb[g], r);
                  }g = m;break;case "source":
                  F("error", r);g = m;break;case "img":case "image":case "link":
                  F("error", r);F("load", r);g = m;break;case "form":
                  F("reset", r);F("submit", r);g = m;break;case "details":
                  F("toggle", r);g = m;break;case "input":
                  Bc(r, m);g = zc(r, m);F("invalid", r);ve(A, "onChange");break;case "option":
                  g = de(r, m);break;case "select":
                  r._wrapperState = { wasMultiple: !!m.multiple };g = n({}, m, { value: void 0 });F("invalid", r);ve(A, "onChange");break;case "textarea":
                  ge(r, m);g = fe(r, m);F("invalid", r);ve(A, "onChange");break;default:
                  g = m;}te(l, g);k = void 0;var B = l,
                  P = r,
                  v = g;for (k in v) {
                if (v.hasOwnProperty(k)) {
                  var p = v[k];"style" === k ? re(P, p) : "dangerouslySetInnerHTML" === k ? (p = p ? p.__html : void 0, null != p && ne(P, p)) : "children" === k ? "string" === typeof p ? ("textarea" !== B || "" !== p) && oe(P, p) : "number" === typeof p && oe(P, "" + p) : "suppressContentEditableWarning" !== k && "suppressHydrationWarning" !== k && "autoFocus" !== k && (sa.hasOwnProperty(k) ? null != p && ve(A, k) : null != p && xc(P, k, p, S));
                }
              }switch (l) {case "input":
                  Wb(r);Fc(r, m, !1);break;case "textarea":
                  Wb(r);ie(r, m);break;case "option":
                  null != m.value && r.setAttribute("value", "" + yc(m.value));break;case "select":
                  g = r;g.multiple = !!m.multiple;r = m.value;null != r ? ee(g, !!m.multiple, r, !1) : null != m.defaultValue && ee(g, !!m.multiple, m.defaultValue, !0);break;default:
                  "function" === typeof g.onClick && (r.onclick = we);}(f = ze(h, f)) && qg(b);b.stateNode = e;
            }null !== b.ref && (b.effectTag |= 128);
          } else null === b.stateNode ? t("166") : void 0;break;case 8:
          e && null != b.stateNode ? tg(e, b, e.memoizedProps, f) : ("string" !== typeof f && (null === b.stateNode ? t("166") : void 0), e = zf(yf.current), zf(L.current), $f(b) ? (f = b, h = f.stateNode, e = f.memoizedProps, h[Ia] = f, (f = h.nodeValue !== e) && qg(b)) : (h = b, f = (9 === e.nodeType ? e : e.ownerDocument).createTextNode(f), f[Ia] = h, b.stateNode = f));break;case 13:case 14:
          break;case 16:
          break;case 9:
          break;case 10:
          break;case 15:
          break;case 6:
          Bf(b);rg(b);break;case 12:
          tf(b);break;case 11:
          break;case 4:
          t("167");default:
          t("156");}b = N = null;f = a;if (1073741823 === O || 1073741823 !== f.childExpirationTime) {
        h = 0;for (e = f.child; null !== e;) {
          g = e.expirationTime;m = e.childExpirationTime;if (0 === h || 0 !== g && g < h) h = g;if (0 === h || 0 !== m && m < h) h = m;e = e.sibling;
        }f.childExpirationTime = h;
      }if (null !== b) return b;null !== c && 0 === (c.effectTag & 512) && (null === c.firstEffect && (c.firstEffect = a.firstEffect), null !== a.lastEffect && (null !== c.lastEffect && (c.lastEffect.nextEffect = a.firstEffect), c.lastEffect = a.lastEffect), 1 < a.effectTag && (null !== c.lastEffect ? c.lastEffect.nextEffect = a : c.firstEffect = a, c.lastEffect = a));
    } else {
      a = Gg(a, O);if (null !== a) return a.effectTag &= 511, a;null !== c && (c.firstEffect = c.lastEffect = null, c.effectTag |= 512);
    }if (null !== d) return d;if (null !== c) a = c;else break;
  }return null;
}function Rg(a) {
  var b = pg(a.alternate, a, O);null === b && (b = Qg(a));Ig.current = null;return b;
}
function Sg(a, b, c) {
  Lg ? t("243") : void 0;Lg = !0;Ig.currentDispatcher = Hg;var d = a.nextExpirationTimeToWorkOn;if (d !== O || a !== Mg || null === N) Pg(), Mg = a, O = d, N = Ue(Mg.current, null, O), a.pendingCommitExpirationTime = 0;var e = !1;do {
    try {
      if (b) for (; null !== N && !Tg();) {
        N = Rg(N);
      } else for (; null !== N;) {
        N = Rg(N);
      }
    } catch (r) {
      if (null === N) e = !0, Dg(r);else {
        null === N ? t("271") : void 0;var f = N,
            g = f.return;if (null === g) e = !0, Dg(r);else {
          a: {
            var h = g,
                k = f,
                l = r;g = O;k.effectTag |= 512;k.firstEffect = k.lastEffect = null;Ng = !0;l = nf(l, k);do {
              switch (h.tag) {case 5:
                  h.effectTag |= 1024;h.expirationTime = g;g = Cg(h, l, g);gf(h, g);break a;case 2:case 3:
                  k = l;var m = h.stateNode;if (0 === (h.effectTag & 64) && null !== m && "function" === typeof m.componentDidCatch && (null === Fg || !Fg.has(m))) {
                    h.effectTag |= 1024;h.expirationTime = g;g = Eg(h, k, g);gf(h, g);break a;
                  }}h = h.return;
            } while (null !== h);
          }N = Qg(f);continue;
        }
      }
    }break;
  } while (1);Lg = !1;rf = qf = pf = Ig.currentDispatcher = null;if (e) Mg = null, a.finishedWork = null;else if (null !== N) a.finishedWork = null;else {
    b = a.current.alternate;null === b ? t("281") : void 0;Mg = null;if (Ng) {
      e = a.latestPendingTime;
      f = a.latestSuspendedTime;g = a.latestPingedTime;if (0 !== e && e > d || 0 !== f && f > d || 0 !== g && g > d) {
        a.didError = !1;c = a.latestPingedTime;0 !== c && c <= d && (a.latestPingedTime = 0);c = a.earliestPendingTime;b = a.latestPendingTime;c === d ? a.earliestPendingTime = b === d ? a.latestPendingTime = 0 : b : b === d && (a.latestPendingTime = c);c = a.earliestSuspendedTime;b = a.latestSuspendedTime;0 === c ? a.earliestSuspendedTime = a.latestSuspendedTime = d : c > d ? a.earliestSuspendedTime = d : b < d && (a.latestSuspendedTime = d);$e(d, a);a.expirationTime = a.expirationTime;return;
      }if (!a.didError && !c) {
        a.didError = !0;a.nextExpirationTimeToWorkOn = d;d = a.expirationTime = 1;a.expirationTime = d;return;
      }
    }a.pendingCommitExpirationTime = d;a.finishedWork = b;
  }
}
function wg(a, b) {
  var c;a: {
    Lg && !Og ? t("263") : void 0;for (c = a.return; null !== c;) {
      switch (c.tag) {case 2:case 3:
          var d = c.stateNode;if ("function" === typeof c.type.getDerivedStateFromCatch || "function" === typeof d.componentDidCatch && (null === Fg || !Fg.has(d))) {
            a = nf(b, a);a = Eg(c, a, 1);ff(c, a);If(c, 1);c = void 0;break a;
          }break;case 5:
          a = nf(b, a);a = Cg(c, a, 1);ff(c, a);If(c, 1);c = void 0;break a;}c = c.return;
    }5 === a.tag && (c = nf(b, a), c = Cg(a, c, 1), ff(a, c), If(a, 1));c = void 0;
  }return c;
}
function Hf(a, b) {
  0 !== Kg ? a = Kg : Lg ? a = Og ? 1 : O : b.mode & 1 ? (a = Ug ? 2 + 10 * (((a - 2 + 15) / 10 | 0) + 1) : 2 + 25 * (((a - 2 + 500) / 25 | 0) + 1), null !== Mg && a === O && (a += 1)) : a = 1;Ug && (0 === Vg || a > Vg) && (Vg = a);return a;
}
function If(a, b) {
  a: {
    if (0 === a.expirationTime || a.expirationTime > b) a.expirationTime = b;var c = a.alternate;null !== c && (0 === c.expirationTime || c.expirationTime > b) && (c.expirationTime = b);var d = a.return;if (null === d && 5 === a.tag) a = a.stateNode;else {
      for (; null !== d;) {
        c = d.alternate;if (0 === d.childExpirationTime || d.childExpirationTime > b) d.childExpirationTime = b;null !== c && (0 === c.childExpirationTime || c.childExpirationTime > b) && (c.childExpirationTime = b);if (null === d.return && 5 === d.tag) {
          a = d.stateNode;break a;
        }d = d.return;
      }a = null;
    }
  }if (null !== a) {
    !Lg && 0 !== O && b < O && Pg();Ze(a, b);if (!Lg || Og || Mg !== a) {
      b = a;a = a.expirationTime;if (null === b.nextScheduledRoot) b.expirationTime = a, null === T ? (U = T = b, b.nextScheduledRoot = b) : (T = T.nextScheduledRoot = b, T.nextScheduledRoot = U);else if (c = b.expirationTime, 0 === c || a < c) b.expirationTime = a;V || (W ? Wg && (Y = b, Z = 1, Xg(b, 1, !0)) : 1 === a ? Yg(1, null) : Zg(b, a));
    }$g > ah && ($g = 0, t("185"));
  }
}function bh(a, b, c, d, e) {
  var f = Kg;Kg = 1;try {
    return a(b, c, d, e);
  } finally {
    Kg = f;
  }
}
var U = null,
    T = null,
    ch = 0,
    dh = void 0,
    V = !1,
    Y = null,
    Z = 0,
    Vg = 0,
    eh = !1,
    fh = !1,
    gh = null,
    hh = null,
    W = !1,
    Wg = !1,
    Ug = !1,
    ih = null,
    jh = ba.unstable_now(),
    kh = (jh / 10 | 0) + 2,
    lh = kh,
    ah = 50,
    $g = 0,
    mh = null,
    nh = 1;function oh() {
  kh = ((ba.unstable_now() - jh) / 10 | 0) + 2;
}function Zg(a, b) {
  if (0 !== ch) {
    if (b > ch) return;null !== dh && ba.unstable_cancelScheduledWork(dh);
  }ch = b;a = ba.unstable_now() - jh;dh = ba.unstable_scheduleWork(ph, { timeout: 10 * (b - 2) - a });
}function Gf() {
  if (V) return lh;qh();if (0 === Z || 1073741823 === Z) oh(), lh = kh;return lh;
}
function qh() {
  var a = 0,
      b = null;if (null !== T) for (var c = T, d = U; null !== d;) {
    var e = d.expirationTime;if (0 === e) {
      null === c || null === T ? t("244") : void 0;if (d === d.nextScheduledRoot) {
        U = T = d.nextScheduledRoot = null;break;
      } else if (d === U) U = e = d.nextScheduledRoot, T.nextScheduledRoot = e, d.nextScheduledRoot = null;else if (d === T) {
        T = c;T.nextScheduledRoot = U;d.nextScheduledRoot = null;break;
      } else c.nextScheduledRoot = d.nextScheduledRoot, d.nextScheduledRoot = null;d = c.nextScheduledRoot;
    } else {
      if (0 === a || e < a) a = e, b = d;if (d === T) break;if (1 === a) break;
      c = d;d = d.nextScheduledRoot;
    }
  }Y = b;Z = a;
}function ph(a) {
  if (a.didTimeout && null !== U) {
    oh();var b = U;do {
      var c = b.expirationTime;0 !== c && kh >= c && (b.nextExpirationTimeToWorkOn = kh);b = b.nextScheduledRoot;
    } while (b !== U);
  }Yg(0, a);
}
function Yg(a, b) {
  hh = b;qh();if (null !== hh) for (oh(), lh = kh; null !== Y && 0 !== Z && (0 === a || a >= Z) && (!eh || kh >= Z);) {
    Xg(Y, Z, kh >= Z), qh(), oh(), lh = kh;
  } else for (; null !== Y && 0 !== Z && (0 === a || a >= Z);) {
    Xg(Y, Z, !0), qh();
  }null !== hh && (ch = 0, dh = null);0 !== Z && Zg(Y, Z);hh = null;eh = !1;$g = 0;mh = null;if (null !== ih) for (a = ih, ih = null, b = 0; b < a.length; b++) {
    var c = a[b];try {
      c._onComplete();
    } catch (d) {
      fh || (fh = !0, gh = d);
    }
  }if (fh) throw a = gh, gh = null, fh = !1, a;
}
function Xg(a, b, c) {
  V ? t("245") : void 0;V = !0;if (null === hh || c) {
    var d = a.finishedWork;null !== d ? rh(a, d, b) : (a.finishedWork = null, Sg(a, !1, c), d = a.finishedWork, null !== d && rh(a, d, b));
  } else d = a.finishedWork, null !== d ? rh(a, d, b) : (a.finishedWork = null, Sg(a, !0, c), d = a.finishedWork, null !== d && (Tg() ? a.finishedWork = d : rh(a, d, b)));V = !1;
}
function rh(a, b, c) {
  var d = a.firstBatch;if (null !== d && d._expirationTime <= c && (null === ih ? ih = [d] : ih.push(d), d._defer)) {
    a.finishedWork = b;a.expirationTime = 0;return;
  }a.finishedWork = null;a === mh ? $g++ : (mh = a, $g = 0);Og = Lg = !0;a.current === b ? t("177") : void 0;c = a.pendingCommitExpirationTime;0 === c ? t("261") : void 0;a.pendingCommitExpirationTime = 0;d = b.expirationTime;var e = b.childExpirationTime;d = 0 === d || 0 !== e && e < d ? e : d;a.didError = !1;0 === d ? (a.earliestPendingTime = 0, a.latestPendingTime = 0, a.earliestSuspendedTime = 0, a.latestSuspendedTime = 0, a.latestPingedTime = 0) : (e = a.latestPendingTime, 0 !== e && (e < d ? a.earliestPendingTime = a.latestPendingTime = 0 : a.earliestPendingTime < d && (a.earliestPendingTime = a.latestPendingTime)), e = a.earliestSuspendedTime, 0 === e ? Ze(a, d) : d > a.latestSuspendedTime ? (a.earliestSuspendedTime = 0, a.latestSuspendedTime = 0, a.latestPingedTime = 0, Ze(a, d)) : d < e && Ze(a, d));$e(0, a);Ig.current = null;1 < b.effectTag ? null !== b.lastEffect ? (b.lastEffect.nextEffect = b, d = b.firstEffect) : d = b : d = b.firstEffect;xe = Gd;e = Td();if (Ud(e)) {
    if ("selectionStart" in e) var f = { start: e.selectionStart, end: e.selectionEnd };else a: {
      f = (f = e.ownerDocument) && f.defaultView || window;var g = f.getSelection && f.getSelection();if (g && 0 !== g.rangeCount) {
        f = g.anchorNode;var h = g.anchorOffset,
            k = g.focusNode;g = g.focusOffset;try {
          f.nodeType, k.nodeType;
        } catch (Xa) {
          f = null;break a;
        }var l = 0,
            m = -1,
            r = -1,
            A = 0,
            S = 0,
            B = e,
            P = null;b: for (;;) {
          for (var v;;) {
            B !== f || 0 !== h && 3 !== B.nodeType || (m = l + h);B !== k || 0 !== g && 3 !== B.nodeType || (r = l + g);3 === B.nodeType && (l += B.nodeValue.length);if (null === (v = B.firstChild)) break;P = B;B = v;
          }for (;;) {
            if (B === e) break b;P === f && ++A === h && (m = l);P === k && ++S === g && (r = l);if (null !== (v = B.nextSibling)) break;B = P;P = B.parentNode;
          }B = v;
        }f = -1 === m || -1 === r ? null : { start: m, end: r };
      } else f = null;
    }f = f || { start: 0, end: 0 };
  } else f = null;ye = { focusedElem: e, selectionRange: f };Gd = !1;for (Q = d; null !== Q;) {
    e = !1;f = void 0;try {
      for (; null !== Q;) {
        if (Q.effectTag & 256) {
          var p = Q.alternate;a: switch (h = Q, h.tag) {case 2:case 3:
              if (h.effectTag & 256 && null !== p) {
                var u = p.memoizedProps,
                    x = p.memoizedState,
                    R = h.stateNode;R.props = h.memoizedProps;R.state = h.memoizedState;var yh = R.getSnapshotBeforeUpdate(u, x);R.__reactInternalSnapshotBeforeUpdate = yh;
              }break a;case 5:case 7:case 8:case 6:
              break a;default:
              t("163");}
        }Q = Q.nextEffect;
      }
    } catch (Xa) {
      e = !0, f = Xa;
    }e && (null === Q ? t("178") : void 0, wg(Q, f), null !== Q && (Q = Q.nextEffect));
  }for (Q = d; null !== Q;) {
    p = !1;u = void 0;try {
      for (; null !== Q;) {
        var w = Q.effectTag;w & 16 && oe(Q.stateNode, "");if (w & 128) {
          var y = Q.alternate;if (null !== y) {
            var q = y.ref;null !== q && ("function" === typeof q ? q(null) : q.current = null);
          }
        }switch (w & 14) {case 2:
            Ag(Q);Q.effectTag &= -3;break;case 6:
            Ag(Q);Q.effectTag &= -3;Bg(Q.alternate, Q);break;case 4:
            Bg(Q.alternate, Q);break;case 8:
            x = Q, yg(x), x.return = null, x.child = null, x.alternate && (x.alternate.child = null, x.alternate.return = null);}Q = Q.nextEffect;
      }
    } catch (Xa) {
      p = !0, u = Xa;
    }p && (null === Q ? t("178") : void 0, wg(Q, u), null !== Q && (Q = Q.nextEffect));
  }q = ye;y = Td();w = q.focusedElem;u = q.selectionRange;if (y !== w && w && w.ownerDocument && Sd(w.ownerDocument.documentElement, w)) {
    null !== u && Ud(w) && (y = u.start, q = u.end, void 0 === q && (q = y), "selectionStart" in w ? (w.selectionStart = y, w.selectionEnd = Math.min(q, w.value.length)) : (p = w.ownerDocument || document, y = (p && p.defaultView || window).getSelection(), x = w.textContent.length, q = Math.min(u.start, x), u = void 0 === u.end ? q : Math.min(u.end, x), !y.extend && q > u && (x = u, u = q, q = x), x = Rd(w, q), R = Rd(w, u), x && R && (1 !== y.rangeCount || y.anchorNode !== x.node || y.anchorOffset !== x.offset || y.focusNode !== R.node || y.focusOffset !== R.offset) && (p = p.createRange(), p.setStart(x.node, x.offset), y.removeAllRanges(), q > u ? (y.addRange(p), y.extend(R.node, R.offset)) : (p.setEnd(R.node, R.offset), y.addRange(p)))));y = [];for (q = w; q = q.parentNode;) {
      1 === q.nodeType && y.push({ element: q, left: q.scrollLeft, top: q.scrollTop });
    }"function" === typeof w.focus && w.focus();for (w = 0; w < y.length; w++) {
      q = y[w], q.element.scrollLeft = q.left, q.element.scrollTop = q.top;
    }
  }ye = null;Gd = !!xe;xe = null;a.current = b;for (Q = d; null !== Q;) {
    d = !1;w = void 0;try {
      for (y = c; null !== Q;) {
        var Sa = Q.effectTag;if (Sa & 36) {
          var oc = Q.alternate;q = Q;p = y;switch (q.tag) {case 2:case 3:
              var X = q.stateNode;if (q.effectTag & 4) if (null === oc) X.props = q.memoizedProps, X.state = q.memoizedState, X.componentDidMount();else {
                var Ih = oc.memoizedProps,
                    Jh = oc.memoizedState;X.props = q.memoizedProps;X.state = q.memoizedState;X.componentDidUpdate(Ih, Jh, X.__reactInternalSnapshotBeforeUpdate);
              }var kg = q.updateQueue;null !== kg && (X.props = q.memoizedProps, X.state = q.memoizedState, lf(q, kg, X, p));break;case 5:
              var lg = q.updateQueue;if (null !== lg) {
                u = null;if (null !== q.child) switch (q.child.tag) {case 7:
                    u = q.child.stateNode;break;case 2:case 3:
                    u = q.child.stateNode;}lf(q, lg, u, p);
              }break;case 7:
              var Kh = q.stateNode;null === oc && q.effectTag & 4 && ze(q.type, q.memoizedProps) && Kh.focus();break;case 8:
              break;case 6:
              break;case 15:
              break;case 16:
              break;default:
              t("163");}
        }if (Sa & 128) {
          var Ac = Q.ref;if (null !== Ac) {
            var mg = Q.stateNode;switch (Q.tag) {case 7:
                var Pd = mg;break;default:
                Pd = mg;}"function" === typeof Ac ? Ac(Pd) : Ac.current = Pd;
          }
        }var Lh = Q.nextEffect;Q.nextEffect = null;Q = Lh;
      }
    } catch (Xa) {
      d = !0, w = Xa;
    }d && (null === Q ? t("178") : void 0, wg(Q, w), null !== Q && (Q = Q.nextEffect));
  }Lg = Og = !1;"function" === typeof Oe && Oe(b.stateNode);Sa = b.expirationTime;b = b.childExpirationTime;b = 0 === Sa || 0 !== b && b < Sa ? b : Sa;0 === b && (Fg = null);a.expirationTime = b;a.finishedWork = null;
}function Tg() {
  return eh ? !0 : null === hh || hh.timeRemaining() > nh ? !1 : eh = !0;
}function Dg(a) {
  null === Y ? t("246") : void 0;Y.expirationTime = 0;fh || (fh = !0, gh = a);
}function sh(a, b) {
  var c = W;W = !0;try {
    return a(b);
  } finally {
    (W = c) || V || Yg(1, null);
  }
}function th(a, b) {
  if (W && !Wg) {
    Wg = !0;try {
      return a(b);
    } finally {
      Wg = !1;
    }
  }return a(b);
}function uh(a, b, c) {
  if (Ug) return a(b, c);W || V || 0 === Vg || (Yg(Vg, null), Vg = 0);var d = Ug,
      e = W;W = Ug = !0;try {
    return a(b, c);
  } finally {
    Ug = d, (W = e) || V || Yg(1, null);
  }
}
function vh(a) {
  if (!a) return Fe;a = a._reactInternalFiber;a: {
    2 !== jd(a) || 2 !== a.tag && 3 !== a.tag ? t("170") : void 0;var b = a;do {
      switch (b.tag) {case 5:
          b = b.stateNode.context;break a;case 2:
          if (K(b.type)) {
            b = b.stateNode.__reactInternalMemoizedMergedChildContext;break a;
          }break;case 3:
          if (K(b.type._reactResult)) {
            b = b.stateNode.__reactInternalMemoizedMergedChildContext;break a;
          }}b = b.return;
    } while (null !== b);t("171");b = void 0;
  }if (2 === a.tag) {
    var c = a.type;if (K(c)) return Le(a, c, b);
  } else if (3 === a.tag && (c = a.type._reactResult, K(c))) return Le(a, c, b);return b;
}function wh(a, b, c, d, e) {
  var f = b.current;c = vh(c);null === b.context ? b.context = c : b.pendingContext = c;b = e;e = df(d);e.payload = { element: a };b = void 0 === b ? null : b;null !== b && (e.callback = b);ff(f, e);If(f, d);return d;
}function xh(a, b, c, d) {
  var e = b.current,
      f = Gf();e = Hf(f, e);return wh(a, b, c, e, d);
}function zh(a) {
  a = a.current;if (!a.child) return null;switch (a.child.tag) {case 7:
      return a.child.stateNode;default:
      return a.child.stateNode;}
}
function Ah(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;return { $$typeof: ac, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
}
Fb = function Fb(a, b, c) {
  switch (b) {case "input":
      Dc(a, c);b = c.name;if ("radio" === c.type && null != b) {
        for (c = a; c.parentNode;) {
          c = c.parentNode;
        }c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');for (b = 0; b < c.length; b++) {
          var d = c[b];if (d !== a && d.form === a.form) {
            var e = Na(d);e ? void 0 : t("90");Xb(d);Dc(d, e);
          }
        }
      }break;case "textarea":
      he(a, c);break;case "select":
      b = c.value, null != b && ee(a, !!c.multiple, b, !1);}
};
function Bh(a) {
  var b = 2 + 25 * (((Gf() - 2 + 500) / 25 | 0) + 1);b <= Jg && (b = Jg + 1);this._expirationTime = Jg = b;this._root = a;this._callbacks = this._next = null;this._hasChildren = this._didComplete = !1;this._children = null;this._defer = !0;
}Bh.prototype.render = function (a) {
  this._defer ? void 0 : t("250");this._hasChildren = !0;this._children = a;var b = this._root._internalRoot,
      c = this._expirationTime,
      d = new Ch();wh(a, b, null, c, d._onCommit);return d;
};
Bh.prototype.then = function (a) {
  if (this._didComplete) a();else {
    var b = this._callbacks;null === b && (b = this._callbacks = []);b.push(a);
  }
};
Bh.prototype.commit = function () {
  var a = this._root._internalRoot,
      b = a.firstBatch;this._defer && null !== b ? void 0 : t("251");if (this._hasChildren) {
    var c = this._expirationTime;if (b !== this) {
      this._hasChildren && (c = this._expirationTime = b._expirationTime, this.render(this._children));for (var d = null, e = b; e !== this;) {
        d = e, e = e._next;
      }null === d ? t("251") : void 0;d._next = e._next;this._next = b;a.firstBatch = this;
    }this._defer = !1;b = c;V ? t("253") : void 0;Y = a;Z = b;Xg(a, b, !0);Yg(1, null);b = this._next;this._next = null;b = a.firstBatch = b;null !== b && b._hasChildren && b.render(b._children);
  } else this._next = null, this._defer = !1;
};Bh.prototype._onComplete = function () {
  if (!this._didComplete) {
    this._didComplete = !0;var a = this._callbacks;if (null !== a) for (var b = 0; b < a.length; b++) {
      (0, a[b])();
    }
  }
};function Ch() {
  this._callbacks = null;this._didCommit = !1;this._onCommit = this._onCommit.bind(this);
}Ch.prototype.then = function (a) {
  if (this._didCommit) a();else {
    var b = this._callbacks;null === b && (b = this._callbacks = []);b.push(a);
  }
};
Ch.prototype._onCommit = function () {
  if (!this._didCommit) {
    this._didCommit = !0;var a = this._callbacks;if (null !== a) for (var b = 0; b < a.length; b++) {
      var c = a[b];"function" !== typeof c ? t("191", c) : void 0;c();
    }
  }
};
function Dh(a, b, c) {
  b = new Se(5, null, null, b ? 3 : 0);a = { current: b, containerInfo: a, pendingChildren: null, earliestPendingTime: 0, latestPendingTime: 0, earliestSuspendedTime: 0, latestSuspendedTime: 0, latestPingedTime: 0, didError: !1, pendingCommitExpirationTime: 0, finishedWork: null, timeoutHandle: -1, context: null, pendingContext: null, hydrate: c, nextExpirationTimeToWorkOn: 0, expirationTime: 0, firstBatch: null, nextScheduledRoot: null };this._internalRoot = b.stateNode = a;
}
Dh.prototype.render = function (a, b) {
  var c = this._internalRoot,
      d = new Ch();b = void 0 === b ? null : b;null !== b && d.then(b);xh(a, c, null, d._onCommit);return d;
};Dh.prototype.unmount = function (a) {
  var b = this._internalRoot,
      c = new Ch();a = void 0 === a ? null : a;null !== a && c.then(a);xh(null, b, null, c._onCommit);return c;
};Dh.prototype.legacy_renderSubtreeIntoContainer = function (a, b, c) {
  var d = this._internalRoot,
      e = new Ch();c = void 0 === c ? null : c;null !== c && e.then(c);xh(b, d, a, e._onCommit);return e;
};
Dh.prototype.createBatch = function () {
  var a = new Bh(this),
      b = a._expirationTime,
      c = this._internalRoot,
      d = c.firstBatch;if (null === d) c.firstBatch = a, a._next = null;else {
    for (c = null; null !== d && d._expirationTime <= b;) {
      c = d, d = d._next;
    }a._next = d;null !== c && (c._next = a);
  }return a;
};function Eh(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}Lb = sh;Mb = uh;Nb = function Nb() {
  V || 0 === Vg || (Yg(Vg, null), Vg = 0);
};
function Fh(a, b) {
  b || (b = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null, b = !(!b || 1 !== b.nodeType || !b.hasAttribute("data-reactroot")));if (!b) for (var c; c = a.lastChild;) {
    a.removeChild(c);
  }return new Dh(a, !1, b);
}
function Gh(a, b, c, d, e) {
  Eh(c) ? void 0 : t("200");var f = c._reactRootContainer;if (f) {
    if ("function" === typeof e) {
      var g = e;e = function e() {
        var a = zh(f._internalRoot);g.call(a);
      };
    }null != a ? f.legacy_renderSubtreeIntoContainer(a, b, e) : f.render(b, e);
  } else {
    f = c._reactRootContainer = Fh(c, d);if ("function" === typeof e) {
      var h = e;e = function e() {
        var a = zh(f._internalRoot);h.call(a);
      };
    }th(function () {
      null != a ? f.legacy_renderSubtreeIntoContainer(a, b, e) : f.render(b, e);
    });
  }return zh(f._internalRoot);
}
function Hh(a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;Eh(b) ? void 0 : t("200");return Ah(a, b, null, c);
}
var Mh = { createPortal: Hh, findDOMNode: function findDOMNode(a) {
    if (null == a) return null;if (1 === a.nodeType) return a;var b = a._reactInternalFiber;void 0 === b && ("function" === typeof a.render ? t("188") : t("268", Object.keys(a)));a = md(b);a = null === a ? null : a.stateNode;return a;
  }, hydrate: function hydrate(a, b, c) {
    return Gh(null, a, b, !0, c);
  }, render: function render(a, b, c) {
    return Gh(null, a, b, !1, c);
  }, unstable_renderSubtreeIntoContainer: function unstable_renderSubtreeIntoContainer(a, b, c, d) {
    null == a || void 0 === a._reactInternalFiber ? t("38") : void 0;return Gh(a, b, c, !1, d);
  }, unmountComponentAtNode: function unmountComponentAtNode(a) {
    Eh(a) ? void 0 : t("40");return a._reactRootContainer ? (th(function () {
      Gh(null, null, a, !1, function () {
        a._reactRootContainer = null;
      });
    }), !0) : !1;
  }, unstable_createPortal: function unstable_createPortal() {
    return Hh.apply(void 0, arguments);
  }, unstable_batchedUpdates: sh, unstable_interactiveUpdates: uh, flushSync: function flushSync(a, b) {
    V ? t("187") : void 0;var c = W;W = !0;try {
      return bh(a, b);
    } finally {
      W = c, Yg(1, null);
    }
  }, unstable_flushControlled: function unstable_flushControlled(a) {
    var b = W;W = !0;try {
      bh(a);
    } finally {
      (W = b) || V || Yg(1, null);
    }
  }, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { Events: [La, Ma, Na, Ea.injectEventPluginsByName, qa, Ua, function (a) {
      za(a, Ta);
    }, Jb, Kb, Id, Ga] }, unstable_createRoot: function unstable_createRoot(a, b) {
    Eh(a) ? void 0 : t("278");return new Dh(a, !0, null != b && !0 === b.hydrate);
  } };(function (a) {
  var b = a.findFiberByHostInstance;return Re(n({}, a, { findHostInstanceByFiber: function findHostInstanceByFiber(a) {
      a = md(a);return null === a ? null : a.stateNode;
    }, findFiberByHostInstance: function findFiberByHostInstance(a) {
      return b ? b(a) : null;
    } }));
})({ findFiberByHostInstance: Ka, bundleType: 0, version: "16.5.2", rendererPackageName: "react-dom" });
var Nh = { default: Mh },
    Oh = Nh && Mh || Nh;module.exports = Oh.default || Oh;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.5.2
 * schedule.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", { value: !0 });var c = null,
    e = !1,
    f = !1,
    g = "object" === (typeof performance === "undefined" ? "undefined" : _typeof(performance)) && "function" === typeof performance.now,
    l = { timeRemaining: g ? function () {
    var a = h() - performance.now();return 0 < a ? a : 0;
  } : function () {
    var a = h() - Date.now();return 0 < a ? a : 0;
  }, didTimeout: !1 };function m() {
  if (!e) {
    var a = c.timesOutAt;f ? n() : f = !0;p(q, a);
  }
}function r() {
  var a = c,
      b = c.next;if (c === b) c = null;else {
    var d = c.previous;c = d.next = b;b.previous = d;
  }a.next = a.previous = null;a = a.callback;a(l);
}
function q(a) {
  e = !0;l.didTimeout = a;try {
    if (a) for (; null !== c;) {
      var b = exports.unstable_now();if (c.timesOutAt <= b) {
        do {
          r();
        } while (null !== c && c.timesOutAt <= b);
      } else break;
    } else if (null !== c) {
      do {
        r();
      } while (null !== c && 0 < h() - exports.unstable_now());
    }
  } finally {
    e = !1, null !== c ? m(c) : f = !1;
  }
}
var t = Date,
    u = "function" === typeof setTimeout ? setTimeout : void 0,
    v = "function" === typeof clearTimeout ? clearTimeout : void 0,
    w = "function" === typeof requestAnimationFrame ? requestAnimationFrame : void 0,
    x = "function" === typeof cancelAnimationFrame ? cancelAnimationFrame : void 0,
    y,
    z;function A(a) {
  y = w(function (b) {
    v(z);a(b);
  });z = u(function () {
    x(y);a(exports.unstable_now());
  }, 100);
}if (g) {
  var B = performance;exports.unstable_now = function () {
    return B.now();
  };
} else exports.unstable_now = function () {
  return t.now();
};var p, n, h;
if ("undefined" === typeof window) {
  var C = -1;p = function p(a) {
    C = setTimeout(a, 0, !0);
  };n = function n() {
    clearTimeout(C);
  };h = function h() {
    return 0;
  };
} else if (window._schedMock) {
  var D = window._schedMock;p = D[0];n = D[1];h = D[2];
} else {
  "undefined" !== typeof console && ("function" !== typeof w && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"), "function" !== typeof x && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));
  var E = null,
      F = !1,
      G = -1,
      H = !1,
      I = !1,
      J = 0,
      K = 33,
      L = 33;h = function h() {
    return J;
  };var M = "__reactIdleCallback$" + Math.random().toString(36).slice(2);window.addEventListener("message", function (a) {
    if (a.source === window && a.data === M) {
      F = !1;var b = exports.unstable_now();a = !1;if (0 >= J - b) if (-1 !== G && G <= b) a = !0;else {
        H || (H = !0, A(N));return;
      }G = -1;b = E;E = null;if (null !== b) {
        I = !0;try {
          b(a);
        } finally {
          I = !1;
        }
      }
    }
  }, !1);var N = function N(a) {
    H = !1;var b = a - J + L;b < L && K < L ? (8 > b && (b = 8), L = b < K ? K : b) : K = b;J = a + L;F || (F = !0, window.postMessage(M, "*"));
  };p = function p(a, b) {
    E = a;G = b;I ? window.postMessage(M, "*") : H || (H = !0, A(N));
  };n = function n() {
    E = null;F = !1;G = -1;
  };
}exports.unstable_scheduleWork = function (a, b) {
  var d = exports.unstable_now();b = void 0 !== b && null !== b && null !== b.timeout && void 0 !== b.timeout ? d + b.timeout : d + 5E3;a = { callback: a, timesOutAt: b, next: null, previous: null };if (null === c) c = a.next = a.previous = a, m(c);else {
    d = null;var k = c;do {
      if (k.timesOutAt > b) {
        d = k;break;
      }k = k.next;
    } while (k !== c);null === d ? d = c : d === c && (c = a, m(c));b = d.previous;b.next = d.previous = a;a.next = d;a.previous = b;
  }return a;
};
exports.unstable_cancelScheduledWork = function (a) {
  var b = a.next;if (null !== b) {
    if (b === a) c = null;else {
      a === c && (c = b);var d = a.previous;d.next = b;b.previous = d;
    }a.next = a.previous = null;
  }
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.5.2
 * schedule.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== "production") {
  (function () {
    'use strict';

    Object.defineProperty(exports, '__esModule', { value: true });

    /* eslint-disable no-var */

    // TODO: Currently there's only a single priority level, Deferred. Will add
    // additional priorities.
    var DEFERRED_TIMEOUT = 5000;

    // Callbacks are stored as a circular, doubly linked list.
    var firstCallbackNode = null;

    var isPerformingWork = false;

    var isHostCallbackScheduled = false;

    var hasNativePerformanceNow = (typeof performance === 'undefined' ? 'undefined' : _typeof(performance)) === 'object' && typeof performance.now === 'function';

    var timeRemaining;
    if (hasNativePerformanceNow) {
      timeRemaining = function timeRemaining() {
        // We assume that if we have a performance timer that the rAF callback
        // gets a performance timer value. Not sure if this is always true.
        var remaining = getFrameDeadline() - performance.now();
        return remaining > 0 ? remaining : 0;
      };
    } else {
      timeRemaining = function timeRemaining() {
        // Fallback to Date.now()
        var remaining = getFrameDeadline() - Date.now();
        return remaining > 0 ? remaining : 0;
      };
    }

    var deadlineObject = {
      timeRemaining: timeRemaining,
      didTimeout: false
    };

    function ensureHostCallbackIsScheduled() {
      if (isPerformingWork) {
        // Don't schedule work yet; wait until the next time we yield.
        return;
      }
      // Schedule the host callback using the earliest timeout in the list.
      var timesOutAt = firstCallbackNode.timesOutAt;
      if (!isHostCallbackScheduled) {
        isHostCallbackScheduled = true;
      } else {
        // Cancel the existing host callback.
        cancelCallback();
      }
      requestCallback(flushWork, timesOutAt);
    }

    function flushFirstCallback(node) {
      var flushedNode = firstCallbackNode;

      // Remove the node from the list before calling the callback. That way the
      // list is in a consistent state even if the callback throws.
      var next = firstCallbackNode.next;
      if (firstCallbackNode === next) {
        // This is the last callback in the list.
        firstCallbackNode = null;
        next = null;
      } else {
        var previous = firstCallbackNode.previous;
        firstCallbackNode = previous.next = next;
        next.previous = previous;
      }

      flushedNode.next = flushedNode.previous = null;

      // Now it's safe to call the callback.
      var callback = flushedNode.callback;
      callback(deadlineObject);
    }

    function flushWork(didTimeout) {
      isPerformingWork = true;
      deadlineObject.didTimeout = didTimeout;
      try {
        if (didTimeout) {
          // Flush all the timed out callbacks without yielding.
          while (firstCallbackNode !== null) {
            // Read the current time. Flush all the callbacks that expire at or
            // earlier than that time. Then read the current time again and repeat.
            // This optimizes for as few performance.now calls as possible.
            var currentTime = exports.unstable_now();
            if (firstCallbackNode.timesOutAt <= currentTime) {
              do {
                flushFirstCallback();
              } while (firstCallbackNode !== null && firstCallbackNode.timesOutAt <= currentTime);
              continue;
            }
            break;
          }
        } else {
          // Keep flushing callbacks until we run out of time in the frame.
          if (firstCallbackNode !== null) {
            do {
              flushFirstCallback();
            } while (firstCallbackNode !== null && getFrameDeadline() - exports.unstable_now() > 0);
          }
        }
      } finally {
        isPerformingWork = false;
        if (firstCallbackNode !== null) {
          // There's still work remaining. Request another callback.
          ensureHostCallbackIsScheduled(firstCallbackNode);
        } else {
          isHostCallbackScheduled = false;
        }
      }
    }

    function unstable_scheduleWork(callback, options) {
      var currentTime = exports.unstable_now();

      var timesOutAt;
      if (options !== undefined && options !== null && options.timeout !== null && options.timeout !== undefined) {
        // Check for an explicit timeout
        timesOutAt = currentTime + options.timeout;
      } else {
        // Compute an absolute timeout using the default constant.
        timesOutAt = currentTime + DEFERRED_TIMEOUT;
      }

      var newNode = {
        callback: callback,
        timesOutAt: timesOutAt,
        next: null,
        previous: null
      };

      // Insert the new callback into the list, sorted by its timeout.
      if (firstCallbackNode === null) {
        // This is the first callback in the list.
        firstCallbackNode = newNode.next = newNode.previous = newNode;
        ensureHostCallbackIsScheduled(firstCallbackNode);
      } else {
        var next = null;
        var node = firstCallbackNode;
        do {
          if (node.timesOutAt > timesOutAt) {
            // The new callback times out before this one.
            next = node;
            break;
          }
          node = node.next;
        } while (node !== firstCallbackNode);

        if (next === null) {
          // No callback with a later timeout was found, which means the new
          // callback has the latest timeout in the list.
          next = firstCallbackNode;
        } else if (next === firstCallbackNode) {
          // The new callback has the earliest timeout in the entire list.
          firstCallbackNode = newNode;
          ensureHostCallbackIsScheduled(firstCallbackNode);
        }

        var previous = next.previous;
        previous.next = next.previous = newNode;
        newNode.next = next;
        newNode.previous = previous;
      }

      return newNode;
    }

    function unstable_cancelScheduledWork(callbackNode) {
      var next = callbackNode.next;
      if (next === null) {
        // Already cancelled.
        return;
      }

      if (next === callbackNode) {
        // This is the only scheduled callback. Clear the list.
        firstCallbackNode = null;
      } else {
        // Remove the callback from its position in the list.
        if (callbackNode === firstCallbackNode) {
          firstCallbackNode = next;
        }
        var previous = callbackNode.previous;
        previous.next = next;
        next.previous = previous;
      }

      callbackNode.next = callbackNode.previous = null;
    }

    // The remaining code is essentially a polyfill for requestIdleCallback. It
    // works by scheduling a requestAnimationFrame, storing the time for the start
    // of the frame, then scheduling a postMessage which gets scheduled after paint.
    // Within the postMessage handler do as much work as possible until time + frame
    // rate. By separating the idle call into a separate event tick we ensure that
    // layout, paint and other browser work is counted against the available time.
    // The frame rate is dynamically adjusted.

    // We capture a local reference to any global, in case it gets polyfilled after
    // this module is initially evaluated. We want to be using a
    // consistent implementation.
    var localDate = Date;

    // This initialization code may run even on server environments if a component
    // just imports ReactDOM (e.g. for findDOMNode). Some environments might not
    // have setTimeout or clearTimeout. However, we always expect them to be defined
    // on the client. https://github.com/facebook/react/pull/13088
    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;
    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;

    // We don't expect either of these to necessarily be defined, but we will error
    // later if they are missing on the client.
    var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;
    var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;

    // requestAnimationFrame does not run when the tab is in the background. If
    // we're backgrounded we prefer for that work to happen so that the page
    // continues to load in the background. So we also schedule a 'setTimeout' as
    // a fallback.
    // TODO: Need a better heuristic for backgrounded work.
    var ANIMATION_FRAME_TIMEOUT = 100;
    var rAFID;
    var rAFTimeoutID;
    var requestAnimationFrameWithTimeout = function requestAnimationFrameWithTimeout(callback) {
      // schedule rAF and also a setTimeout
      rAFID = localRequestAnimationFrame(function (timestamp) {
        // cancel the setTimeout
        localClearTimeout(rAFTimeoutID);
        callback(timestamp);
      });
      rAFTimeoutID = localSetTimeout(function () {
        // cancel the requestAnimationFrame
        localCancelAnimationFrame(rAFID);
        callback(exports.unstable_now());
      }, ANIMATION_FRAME_TIMEOUT);
    };

    if (hasNativePerformanceNow) {
      var Performance = performance;
      exports.unstable_now = function () {
        return Performance.now();
      };
    } else {
      exports.unstable_now = function () {
        return localDate.now();
      };
    }

    var requestCallback;
    var cancelCallback;
    var getFrameDeadline;

    if (typeof window === 'undefined') {
      // If this accidentally gets imported in a non-browser environment, fallback
      // to a naive implementation.
      var timeoutID = -1;
      requestCallback = function requestCallback(callback, absoluteTimeout) {
        timeoutID = setTimeout(callback, 0, true);
      };
      cancelCallback = function cancelCallback() {
        clearTimeout(timeoutID);
      };
      getFrameDeadline = function getFrameDeadline() {
        return 0;
      };
    } else if (window._schedMock) {
      // Dynamic injection, only for testing purposes.
      var impl = window._schedMock;
      requestCallback = impl[0];
      cancelCallback = impl[1];
      getFrameDeadline = impl[2];
    } else {
      if (typeof console !== 'undefined') {
        if (typeof localRequestAnimationFrame !== 'function') {
          console.error("This browser doesn't support requestAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
        }
        if (typeof localCancelAnimationFrame !== 'function') {
          console.error("This browser doesn't support cancelAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
        }
      }

      var scheduledCallback = null;
      var isIdleScheduled = false;
      var timeoutTime = -1;

      var isAnimationFrameScheduled = false;

      var isPerformingIdleWork = false;

      var frameDeadline = 0;
      // We start out assuming that we run at 30fps but then the heuristic tracking
      // will adjust this value to a faster fps if we get more frequent animation
      // frames.
      var previousFrameTime = 33;
      var activeFrameTime = 33;

      getFrameDeadline = function getFrameDeadline() {
        return frameDeadline;
      };

      // We use the postMessage trick to defer idle work until after the repaint.
      var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);
      var idleTick = function idleTick(event) {
        if (event.source !== window || event.data !== messageKey) {
          return;
        }

        isIdleScheduled = false;

        var currentTime = exports.unstable_now();

        var didTimeout = false;
        if (frameDeadline - currentTime <= 0) {
          // There's no time left in this idle period. Check if the callback has
          // a timeout and whether it's been exceeded.
          if (timeoutTime !== -1 && timeoutTime <= currentTime) {
            // Exceeded the timeout. Invoke the callback even though there's no
            // time left.
            didTimeout = true;
          } else {
            // No timeout.
            if (!isAnimationFrameScheduled) {
              // Schedule another animation callback so we retry later.
              isAnimationFrameScheduled = true;
              requestAnimationFrameWithTimeout(animationTick);
            }
            // Exit without invoking the callback.
            return;
          }
        }

        timeoutTime = -1;
        var callback = scheduledCallback;
        scheduledCallback = null;
        if (callback !== null) {
          isPerformingIdleWork = true;
          try {
            callback(didTimeout);
          } finally {
            isPerformingIdleWork = false;
          }
        }
      };
      // Assumes that we have addEventListener in this environment. Might need
      // something better for old IE.
      window.addEventListener('message', idleTick, false);

      var animationTick = function animationTick(rafTime) {
        isAnimationFrameScheduled = false;
        var nextFrameTime = rafTime - frameDeadline + activeFrameTime;
        if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {
          if (nextFrameTime < 8) {
            // Defensive coding. We don't support higher frame rates than 120hz.
            // If we get lower than that, it is probably a bug.
            nextFrameTime = 8;
          }
          // If one frame goes long, then the next one can be short to catch up.
          // If two frames are short in a row, then that's an indication that we
          // actually have a higher frame rate than what we're currently optimizing.
          // We adjust our heuristic dynamically accordingly. For example, if we're
          // running on 120hz display or 90hz VR display.
          // Take the max of the two in case one of them was an anomaly due to
          // missed frame deadlines.
          activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;
        } else {
          previousFrameTime = nextFrameTime;
        }
        frameDeadline = rafTime + activeFrameTime;
        if (!isIdleScheduled) {
          isIdleScheduled = true;
          window.postMessage(messageKey, '*');
        }
      };

      requestCallback = function requestCallback(callback, absoluteTimeout) {
        scheduledCallback = callback;
        timeoutTime = absoluteTimeout;
        if (isPerformingIdleWork) {
          // If we're already performing idle work, an error must have been thrown.
          // Don't wait for the next frame. Continue working ASAP, in a new event.
          window.postMessage(messageKey, '*');
        } else if (!isAnimationFrameScheduled) {
          // If rAF didn't already schedule one, we need to schedule a frame.
          // TODO: If this rAF doesn't materialize because the browser throttles, we
          // might want to still have setTimeout trigger rIC as a backup to ensure
          // that we keep performing work.
          isAnimationFrameScheduled = true;
          requestAnimationFrameWithTimeout(animationTick);
        }
      };

      cancelCallback = function cancelCallback() {
        scheduledCallback = null;
        isIdleScheduled = false;
        timeoutTime = -1;
      };
    }

    exports.unstable_scheduleWork = unstable_scheduleWork;
    exports.unstable_cancelScheduledWork = unstable_cancelScheduledWork;
  })();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.5.2
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};if(process.env.NODE_ENV!=="production"){(function(){'use strict';var React=__webpack_require__(0);var _assign=__webpack_require__(6);var checkPropTypes=__webpack_require__(13);var schedule=__webpack_require__(20);var tracing=__webpack_require__(39);/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */var validateFormat=function validateFormat(){};{validateFormat=function validateFormat(format){if(format===undefined){throw new Error('invariant requires an error message argument');}};}function invariant(condition,format,a,b,c,d,e,f){validateFormat(format);if(!condition){var error=void 0;if(format===undefined){error=new Error('Minified exception occurred; use the non-minified dev environment '+'for the full error message and additional helpful warnings.');}else{var args=[a,b,c,d,e,f];var argIndex=0;error=new Error(format.replace(/%s/g,function(){return args[argIndex++];}));error.name='Invariant Violation';}error.framesToPop=1;// we don't care about invariant's own frame
throw error;}}// Relying on the `invariant()` implementation lets us
// preserve the format and params in the www builds.
!React?invariant(false,'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.'):void 0;var invokeGuardedCallbackImpl=function invokeGuardedCallbackImpl(name,func,context,a,b,c,d,e,f){var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){this.onError(error);}};{// In DEV mode, we swap out invokeGuardedCallback for a special version
// that plays more nicely with the browser's DevTools. The idea is to preserve
// "Pause on exceptions" behavior. Because React wraps all user-provided
// functions in invokeGuardedCallback, and the production version of
// invokeGuardedCallback uses a try-catch, all user exceptions are treated
// like caught exceptions, and the DevTools won't pause unless the developer
// takes the extra step of enabling pause on caught exceptions. This is
// untintuitive, though, because even though React has caught the error, from
// the developer's perspective, the error is uncaught.
//
// To preserve the expected "Pause on exceptions" behavior, we don't use a
// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
// DOM node, and call the user-provided callback from inside an event handler
// for that fake event. If the callback throws, the error is "captured" using
// a global event handler. But because the error happens in a different
// event loop context, it does not interrupt the normal program flow.
// Effectively, this gives us try-catch behavior without actually using
// try-catch. Neat!
// Check that the browser supports the APIs we need to implement our special
// DEV version of invokeGuardedCallback
if(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');var invokeGuardedCallbackDev=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// If document doesn't exist we know for sure we will crash in this method
// when we call document.createEvent(). However this can cause confusing
// errors: https://github.com/facebookincubator/create-react-app/issues/3482
// So we preemptively throw with a better message instead.
!(typeof document!=='undefined')?invariant(false,'The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.'):void 0;var evt=document.createEvent('Event');// Keeps track of whether the user-provided callback threw an error. We
// set this to true at the beginning, then set it to false right after
// calling the function. If the function errors, `didError` will never be
// set to false. This strategy works even if the browser is flaky and
// fails to call our global error handler, because it doesn't rely on
// the error event at all.
var didError=true;// Keeps track of the value of window.event so that we can reset it
// during the callback to let user code access window.event in the
// browsers that support it.
var windowEvent=window.event;// Create an event handler for our fake event. We will synchronously
// dispatch our fake event using `dispatchEvent`. Inside the handler, we
// call the user-provided callback.
var funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){// We immediately remove the callback from event listeners so that
// nested `invokeGuardedCallback` calls do not clash. Otherwise, a
// nested call would trigger the fake event handlers of any call higher
// in the stack.
fakeNode.removeEventListener(evtType,callCallback,false);// We check for window.hasOwnProperty('event') to prevent the
// window.event assignment in both IE <= 10 as they throw an error
// "Member not found" in strict mode, and in Firefox which does not
// support window.event.
if(typeof window.event!=='undefined'&&window.hasOwnProperty('event')){window.event=windowEvent;}func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value
// that was thrown. It's possible that this error handler will fire more
// than once; for example, if non-React code also calls `dispatchEvent`
// and a handler for that event throws. We should be resilient to most of
// those cases. Even if our error event handler fires more than once, the
// last error event is always used. If the callback actually does error,
// we know that the last error event is the correct one, because it's not
// possible for anything else to have happened in between our callback
// erroring and the code that follows the `dispatchEvent` call below. If
// the callback doesn't error, but the error event was fired, we know to
// ignore it because `didError` will be false, as described above.
var error=void 0;// Use this to track whether the error event is ever called.
var didSetError=false;var isCrossOriginError=false;function handleWindowError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}if(event.defaultPrevented){// Some other error handler has prevented default.
// Browsers silence the error report if this happens.
// We'll remember this to later decide whether to log it or not.
if(error!=null&&(typeof error==='undefined'?'undefined':_typeof(error))==='object'){try{error._suppressLogging=true;}catch(inner){// Ignore.
}}}}// Create a fake event type.
var evtType='react-'+(name?name:'invokeguardedcallback');// Attach our event handlers
window.addEventListener('error',handleWindowError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function
// errors, it will trigger our global error handler.
evt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(didError){if(!didSetError){// The callback errored, but the error event never fired.
error=new Error('An error was thrown inside one of your components, but React '+"doesn't know what it was. This is likely due to browser "+'flakiness. React does its best to preserve the "Pause on '+'exceptions" behavior of the DevTools, which requires some '+"DEV-mode only tricks. It's possible that these don't work in "+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){error=new Error("A cross-origin error was thrown. React doesn't have access to "+'the actual error object in development. '+'See https://fb.me/react-crossorigin-error for more information.');}this.onError(error);}// Remove our event listeners
window.removeEventListener('error',handleWindowError);};invokeGuardedCallbackImpl=invokeGuardedCallbackDev;}}var invokeGuardedCallbackImpl$1=invokeGuardedCallbackImpl;// Used by Fiber to simulate a try-catch.
var hasError=false;var caughtError=null;// Used by event system to capture/rethrow the first error.
var hasRethrowError=false;var rethrowError=null;var reporter={onError:function onError(error){hasError=true;caughtError=error;}};/**
 * Call a function while guarding against errors that happens within it.
 * Returns an error if it throws, otherwise null.
 *
 * In production, this is implemented using a try-catch. The reason we don't
 * use a try-catch directly is so that we can swap out a different
 * implementation in DEV mode.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){hasError=false;caughtError=null;invokeGuardedCallbackImpl$1.apply(reporter,arguments);}/**
 * Same as invokeGuardedCallback, but instead of returning an error, it stores
 * it in a global so it can be rethrown by `rethrowCaughtError` later.
 * TODO: See if caughtError and rethrowError can be unified.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){invokeGuardedCallback.apply(this,arguments);if(hasError){var error=clearCaughtError();if(!hasRethrowError){hasRethrowError=true;rethrowError=error;}}}/**
 * During execution of guarded functions we will capture the first error which
 * we will rethrow to be handled by the top level error handler.
 */function rethrowCaughtError(){if(hasRethrowError){var error=rethrowError;hasRethrowError=false;rethrowError=null;throw error;}}function hasCaughtError(){return hasError;}function clearCaughtError(){if(hasError){var error=caughtError;hasError=false;caughtError=null;return error;}else{invariant(false,'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');}}/**
 * Injectable ordering of event plugins.
 */var eventPluginOrder=null;/**
 * Injectable mapping from names to event plugin modules.
 */var namesToPlugins={};/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */function recomputePluginOrdering(){if(!eventPluginOrder){// Wait until an `eventPluginOrder` is injected.
return;}for(var pluginName in namesToPlugins){var pluginModule=namesToPlugins[pluginName];var pluginIndex=eventPluginOrder.indexOf(pluginName);!(pluginIndex>-1)?invariant(false,'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.',pluginName):void 0;if(plugins[pluginIndex]){continue;}!pluginModule.extractEvents?invariant(false,'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.',pluginName):void 0;plugins[pluginIndex]=pluginModule;var publishedEvents=pluginModule.eventTypes;for(var eventName in publishedEvents){!publishEventForPlugin(publishedEvents[eventName],pluginModule,eventName)?invariant(false,'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',eventName,pluginName):void 0;}}}/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */function publishEventForPlugin(dispatchConfig,pluginModule,eventName){!!eventNameDispatchConfigs.hasOwnProperty(eventName)?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.',eventName):void 0;eventNameDispatchConfigs[eventName]=dispatchConfig;var phasedRegistrationNames=dispatchConfig.phasedRegistrationNames;if(phasedRegistrationNames){for(var phaseName in phasedRegistrationNames){if(phasedRegistrationNames.hasOwnProperty(phaseName)){var phasedRegistrationName=phasedRegistrationNames[phaseName];publishRegistrationName(phasedRegistrationName,pluginModule,eventName);}}return true;}else if(dispatchConfig.registrationName){publishRegistrationName(dispatchConfig.registrationName,pluginModule,eventName);return true;}return false;}/**
 * Publishes a registration name that is used to identify dispatched events.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */function publishRegistrationName(registrationName,pluginModule,eventName){!!registrationNameModules[registrationName]?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.',registrationName):void 0;registrationNameModules[registrationName]=pluginModule;registrationNameDependencies[registrationName]=pluginModule.eventTypes[eventName].dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}}/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 *//**
 * Ordered list of injected plugins.
 */var plugins=[];/**
 * Mapping from event name to dispatch config
 */var eventNameDispatchConfigs={};/**
 * Mapping from registration name to plugin module
 */var registrationNameModules={};/**
 * Mapping from registration name to event name
 */var registrationNameDependencies={};/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true
/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */function injectEventPluginOrder(injectedEventPluginOrder){!!eventPluginOrder?invariant(false,'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.'):void 0;// Clone the ordering so it cannot be dynamically mutated.
eventPluginOrder=Array.prototype.slice.call(injectedEventPluginOrder);recomputePluginOrdering();}/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */function injectEventPluginsByName(injectedNamesToPlugins){var isOrderingDirty=false;for(var pluginName in injectedNamesToPlugins){if(!injectedNamesToPlugins.hasOwnProperty(pluginName)){continue;}var pluginModule=injectedNamesToPlugins[pluginName];if(!namesToPlugins.hasOwnProperty(pluginName)||namesToPlugins[pluginName]!==pluginModule){!!namesToPlugins[pluginName]?invariant(false,'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.',pluginName):void 0;namesToPlugins[pluginName]=pluginModule;isOrderingDirty=true;}}if(isOrderingDirty){recomputePluginOrdering();}}/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */var warningWithoutStack=function warningWithoutStack(){};{warningWithoutStack=function warningWithoutStack(condition,format){for(var _len=arguments.length,args=Array(_len>2?_len-2:0),_key=2;_key<_len;_key++){args[_key-2]=arguments[_key];}if(format===undefined){throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning '+'message argument');}if(args.length>8){// Check before the condition to catch violations early.
throw new Error('warningWithoutStack() currently supports at most 8 arguments.');}if(condition){return;}if(typeof console!=='undefined'){var _args$map=args.map(function(item){return''+item;}),a=_args$map[0],b=_args$map[1],c=_args$map[2],d=_args$map[3],e=_args$map[4],f=_args$map[5],g=_args$map[6],h=_args$map[7];var message='Warning: '+format;// We intentionally don't use spread (or .apply) because it breaks IE9:
// https://github.com/facebook/react/issues/13610
switch(args.length){case 0:console.error(message);break;case 1:console.error(message,a);break;case 2:console.error(message,a,b);break;case 3:console.error(message,a,b,c);break;case 4:console.error(message,a,b,c,d);break;case 5:console.error(message,a,b,c,d,e);break;case 6:console.error(message,a,b,c,d,e,f);break;case 7:console.error(message,a,b,c,d,e,f,g);break;case 8:console.error(message,a,b,c,d,e,f,g,h);break;default:throw new Error('warningWithoutStack() currently supports at most 8 arguments.');}}try{// --- Welcome to debugging React ---
// This error was thrown as a convenience so that you can use this stack
// to find the callsite that caused this warning to fire.
var argIndex=0;var _message='Warning: '+format.replace(/%s/g,function(){return args[argIndex++];});throw new Error(_message);}catch(x){}};}var warningWithoutStack$1=warningWithoutStack;var getFiberCurrentPropsFromNode=null;var getInstanceFromNode=null;var getNodeFromInstance=null;function setComponentTree(getFiberCurrentPropsFromNodeImpl,getInstanceFromNodeImpl,getNodeFromInstanceImpl){getFiberCurrentPropsFromNode=getFiberCurrentPropsFromNodeImpl;getInstanceFromNode=getInstanceFromNodeImpl;getNodeFromInstance=getNodeFromInstanceImpl;{!(getNodeFromInstance&&getInstanceFromNode)?warningWithoutStack$1(false,'EventPluginUtils.setComponentTree(...): Injected '+'module is missing getNodeFromInstance or getInstanceFromNode.'):void 0;}}var validateEventDispatches=void 0;{validateEventDispatches=function validateEventDispatches(event){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;var listenersIsArr=Array.isArray(dispatchListeners);var listenersLen=listenersIsArr?dispatchListeners.length:dispatchListeners?1:0;var instancesIsArr=Array.isArray(dispatchInstances);var instancesLen=instancesIsArr?dispatchInstances.length:dispatchInstances?1:0;!(instancesIsArr===listenersIsArr&&instancesLen===listenersLen)?warningWithoutStack$1(false,'EventPluginUtils: Invalid `event`.'):void 0;};}/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */function executeDispatch(event,simulated,listener,inst){var type=event.type||'unknown-event';event.currentTarget=getNodeFromInstance(inst);invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}/**
 * Standard/simple iteration through an event's collected dispatches.
 */function executeDispatchesInOrder(event,simulated){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;{validateEventDispatches(event);}if(Array.isArray(dispatchListeners)){for(var i=0;i<dispatchListeners.length;i++){if(event.isPropagationStopped()){break;}// Listeners and Instances are two parallel arrays that are always in sync.
executeDispatch(event,simulated,dispatchListeners[i],dispatchInstances[i]);}}else if(dispatchListeners){executeDispatch(event,simulated,dispatchListeners,dispatchInstances);}event._dispatchListeners=null;event._dispatchInstances=null;}/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 *//**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 *//**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 *//**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */function accumulateInto(current,next){!(next!=null)?invariant(false,'accumulateInto(...): Accumulated items must not be null or undefined.'):void 0;if(current==null){return next;}// Both are not empty. Warning: Never call x.concat(y) when you are not
// certain that x is an Array (x could be a string with concat method).
if(Array.isArray(current)){if(Array.isArray(next)){current.push.apply(current,next);return current;}current.push(next);return current;}if(Array.isArray(next)){// A bit too dangerous to mutate `next`.
return[current].concat(next);}return[current,next];}/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 * @param {function} cb Callback invoked with each element or a collection.
 * @param {?} [scope] Scope used as `this` in a callback.
 */function forEachAccumulated(arr,cb,scope){if(Array.isArray(arr)){arr.forEach(cb,scope);}else if(arr){cb.call(scope,arr);}}/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */var eventQueue=null;/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */var executeDispatchesAndRelease=function executeDispatchesAndRelease(event,simulated){if(event){executeDispatchesInOrder(event,simulated);if(!event.isPersistent()){event.constructor.release(event);}}};var executeDispatchesAndReleaseSimulated=function executeDispatchesAndReleaseSimulated(e){return executeDispatchesAndRelease(e,true);};var executeDispatchesAndReleaseTopLevel=function executeDispatchesAndReleaseTopLevel(e){return executeDispatchesAndRelease(e,false);};function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':return!!(props.disabled&&isInteractive(type));default:return false;}}/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 *//**
 * Methods for injecting dependencies.
 */var injection={/**
   * @param {array} InjectedEventPluginOrder
   * @public
   */injectEventPluginOrder:injectEventPluginOrder,/**
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   */injectEventPluginsByName:injectEventPluginsByName};/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */function getListener(inst,registrationName){var listener=void 0;// TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
// live here; needs to be moved to a better place soon
var stateNode=inst.stateNode;if(!stateNode){// Work in progress (ex: onload events in incremental mode).
return null;}var props=getFiberCurrentPropsFromNode(stateNode);if(!props){// Work in progress.
return null;}listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}!(!listener||typeof listener==='function')?invariant(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener==='undefined'?'undefined':_typeof(listener)):void 0;return listener;}/**
 * Allows registered plugins an opportunity to extract events from top-level
 * native browser events.
 *
 * @return {*} An accumulation of synthetic events.
 * @internal
 */function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events=null;for(var i=0;i<plugins.length;i++){// Not every plugin in the ordering may be loaded at runtime.
var possiblePlugin=plugins[i];if(possiblePlugin){var extractedEvents=possiblePlugin.extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);if(extractedEvents){events=accumulateInto(events,extractedEvents);}}}return events;}function runEventsInBatch(events,simulated){if(events!==null){eventQueue=accumulateInto(eventQueue,events);}// Set `eventQueue` to null before processing it so that we can tell if more
// events get enqueued while processing.
var processingEventQueue=eventQueue;eventQueue=null;if(!processingEventQueue){return;}if(simulated){forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseSimulated);}else{forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseTopLevel);}!!eventQueue?invariant(false,'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.'):void 0;// This would be a good time to rethrow if any of the event handlers threw.
rethrowCaughtError();}function runExtractedEventsInBatch(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events=extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);runEventsInBatch(events,false);}var FunctionalComponent=0;var FunctionalComponentLazy=1;var ClassComponent=2;var ClassComponentLazy=3;var IndeterminateComponent=4;// Before we know whether it is functional or class
var HostRoot=5;// Root of a host tree. Could be nested inside another node.
var HostPortal=6;// A subtree. Could be an entry point to a different renderer.
var HostComponent=7;var HostText=8;var Fragment=9;var Mode=10;var ContextConsumer=11;var ContextProvider=12;var ForwardRef=13;var ForwardRefLazy=14;var Profiler=15;var PlaceholderComponent=16;var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactInternalInstance$'+randomKey;var internalEventHandlersKey='__reactEventHandlers$'+randomKey;function precacheFiberNode(hostInst,node){node[internalInstanceKey]=hostInst;}/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */function getClosestInstanceFromNode(node){if(node[internalInstanceKey]){return node[internalInstanceKey];}while(!node[internalInstanceKey]){if(node.parentNode){node=node.parentNode;}else{// Top of the tree. This node must not be part of a React tree (or is
// unmounted, potentially).
return null;}}var inst=node[internalInstanceKey];if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber, this will always be the deepest root.
return inst;}return null;}/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */function getInstanceFromNode$1(node){var inst=node[internalInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText){return inst;}else{return null;}}return null;}/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */function getNodeFromInstance$1(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be
// a host component or host text.
return inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next
// invariant for a missing parent, which is super confusing.
invariant(false,'getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode$1(node){return node[internalEventHandlersKey]||null;}function updateFiberProps(node,props){node[internalEventHandlersKey]=props;}function getParent(inst){do{inst=inst.return;// TODO: If this is a HostRoot we might want to bail out.
// That is depending on if we want nested subtrees (layers) to bubble
// events to their parent. We could also go through parentNode on the
// host node but that wouldn't work for React Native and doesn't let us
// do the portal feature.
}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */function getLowestCommonAncestor(instA,instB){var depthA=0;for(var tempA=instA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=instB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.
while(depthA-depthB>0){instA=getParent(instA);depthA--;}// If B is deeper, crawl up.
while(depthB-depthA>0){instB=getParent(instB);depthB--;}// Walk in lockstep until we find a match.
var depth=depthA;while(depth--){if(instA===instB||instA===instB.alternate){return instA;}instA=getParent(instA);instB=getParent(instB);}return null;}/**
 * Return if A is an ancestor of B.
 *//**
 * Return the parent instance of the passed-in instance.
 *//**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */function traverseTwoPhase(inst,fn,arg){var path=[];while(inst){path.push(inst);inst=getParent(inst);}var i=void 0;for(i=path.length;i-->0;){fn(path[i],'captured',arg);}for(i=0;i<path.length;i++){fn(path[i],'bubbled',arg);}}/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */function traverseEnterLeave(from,to,fn,argFrom,argTo){var common=from&&to?getLowestCommonAncestor(from,to):null;var pathFrom=[];while(true){if(!from){break;}if(from===common){break;}var alternate=from.alternate;if(alternate!==null&&alternate===common){break;}pathFrom.push(from);from=getParent(from);}var pathTo=[];while(true){if(!to){break;}if(to===common){break;}var _alternate=to.alternate;if(_alternate!==null&&_alternate===common){break;}pathTo.push(to);to=getParent(to);}for(var i=0;i<pathFrom.length;i++){fn(pathFrom[i],'bubbled',argFrom);}for(var _i=pathTo.length;_i-->0;){fn(pathTo[_i],'captured',argTo);}}/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */function listenerAtPhase(inst,event,propagationPhase){var registrationName=event.dispatchConfig.phasedRegistrationNames[propagationPhase];return getListener(inst,registrationName);}/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing even a
 * single one.
 *//**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */function accumulateDirectionalDispatches(inst,phase,event){{!inst?warningWithoutStack$1(false,'Dispatching inst must not be null'):void 0;}var listener=listenerAtPhase(inst,event,phase);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */function accumulateTwoPhaseDispatchesSingle(event){if(event&&event.dispatchConfig.phasedRegistrationNames){traverseTwoPhase(event._targetInst,accumulateDirectionalDispatches,event);}}/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */function accumulateDispatches(inst,ignoredDirection,event){if(inst&&event&&event.dispatchConfig.registrationName){var registrationName=event.dispatchConfig.registrationName;var listener=getListener(inst,registrationName);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}}/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */function accumulateDirectDispatchesSingle(event){if(event&&event.dispatchConfig.registrationName){accumulateDispatches(event._targetInst,null,event);}}function accumulateTwoPhaseDispatches(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingle);}function accumulateEnterLeaveDispatches(leave,enter,from,to){traverseEnterLeave(from,to,accumulateDispatches,leave,enter);}function accumulateDirectDispatches(events){forEachAccumulated(events,accumulateDirectDispatchesSingle);}var canUseDOM=!!(typeof window!=='undefined'&&window.document&&window.document.createElement);// Do not uses the below two methods directly!
// Instead use constants exported from DOMTopLevelEventTypes in ReactDOM.
// (It is the only module that is allowed to access these methods.)
function unsafeCastStringToDOMTopLevelType(topLevelType){return topLevelType;}function unsafeCastDOMTopLevelTypeToString(topLevelType){return topLevelType;}/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;return prefixes;}/**
 * A list of event names to a configurable list of vendor prefixes.
 */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**
 * Event names that have already been detected and prefixed (if applicable).
 */var prefixedEventNames={};/**
 * Element to check for prefixes on.
 */var style={};/**
 * Bootstrap if a DOM exists.
 */if(canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,
// the un-prefixed "animation" and "transition" properties are defined on the
// style object but the events that fire will still be prefixed, so we need
// to check if the un-prefixed events are usable, and if not remove them from the map.
if(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above
if(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return eventName;}/**
 * To identify top level events in ReactDOM, we use constants defined by this
 * module. This is the only module that uses the unsafe* methods to express
 * that the constants actually correspond to the browser event names. This lets
 * us save some bundle size by avoiding a top level type -> event name map.
 * The rest of ReactDOM code should import top level types from this file.
 */var TOP_ABORT=unsafeCastStringToDOMTopLevelType('abort');var TOP_ANIMATION_END=unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationend'));var TOP_ANIMATION_ITERATION=unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationiteration'));var TOP_ANIMATION_START=unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationstart'));var TOP_BLUR=unsafeCastStringToDOMTopLevelType('blur');var TOP_CAN_PLAY=unsafeCastStringToDOMTopLevelType('canplay');var TOP_CAN_PLAY_THROUGH=unsafeCastStringToDOMTopLevelType('canplaythrough');var TOP_CANCEL=unsafeCastStringToDOMTopLevelType('cancel');var TOP_CHANGE=unsafeCastStringToDOMTopLevelType('change');var TOP_CLICK=unsafeCastStringToDOMTopLevelType('click');var TOP_CLOSE=unsafeCastStringToDOMTopLevelType('close');var TOP_COMPOSITION_END=unsafeCastStringToDOMTopLevelType('compositionend');var TOP_COMPOSITION_START=unsafeCastStringToDOMTopLevelType('compositionstart');var TOP_COMPOSITION_UPDATE=unsafeCastStringToDOMTopLevelType('compositionupdate');var TOP_CONTEXT_MENU=unsafeCastStringToDOMTopLevelType('contextmenu');var TOP_COPY=unsafeCastStringToDOMTopLevelType('copy');var TOP_CUT=unsafeCastStringToDOMTopLevelType('cut');var TOP_DOUBLE_CLICK=unsafeCastStringToDOMTopLevelType('dblclick');var TOP_AUX_CLICK=unsafeCastStringToDOMTopLevelType('auxclick');var TOP_DRAG=unsafeCastStringToDOMTopLevelType('drag');var TOP_DRAG_END=unsafeCastStringToDOMTopLevelType('dragend');var TOP_DRAG_ENTER=unsafeCastStringToDOMTopLevelType('dragenter');var TOP_DRAG_EXIT=unsafeCastStringToDOMTopLevelType('dragexit');var TOP_DRAG_LEAVE=unsafeCastStringToDOMTopLevelType('dragleave');var TOP_DRAG_OVER=unsafeCastStringToDOMTopLevelType('dragover');var TOP_DRAG_START=unsafeCastStringToDOMTopLevelType('dragstart');var TOP_DROP=unsafeCastStringToDOMTopLevelType('drop');var TOP_DURATION_CHANGE=unsafeCastStringToDOMTopLevelType('durationchange');var TOP_EMPTIED=unsafeCastStringToDOMTopLevelType('emptied');var TOP_ENCRYPTED=unsafeCastStringToDOMTopLevelType('encrypted');var TOP_ENDED=unsafeCastStringToDOMTopLevelType('ended');var TOP_ERROR=unsafeCastStringToDOMTopLevelType('error');var TOP_FOCUS=unsafeCastStringToDOMTopLevelType('focus');var TOP_GOT_POINTER_CAPTURE=unsafeCastStringToDOMTopLevelType('gotpointercapture');var TOP_INPUT=unsafeCastStringToDOMTopLevelType('input');var TOP_INVALID=unsafeCastStringToDOMTopLevelType('invalid');var TOP_KEY_DOWN=unsafeCastStringToDOMTopLevelType('keydown');var TOP_KEY_PRESS=unsafeCastStringToDOMTopLevelType('keypress');var TOP_KEY_UP=unsafeCastStringToDOMTopLevelType('keyup');var TOP_LOAD=unsafeCastStringToDOMTopLevelType('load');var TOP_LOAD_START=unsafeCastStringToDOMTopLevelType('loadstart');var TOP_LOADED_DATA=unsafeCastStringToDOMTopLevelType('loadeddata');var TOP_LOADED_METADATA=unsafeCastStringToDOMTopLevelType('loadedmetadata');var TOP_LOST_POINTER_CAPTURE=unsafeCastStringToDOMTopLevelType('lostpointercapture');var TOP_MOUSE_DOWN=unsafeCastStringToDOMTopLevelType('mousedown');var TOP_MOUSE_MOVE=unsafeCastStringToDOMTopLevelType('mousemove');var TOP_MOUSE_OUT=unsafeCastStringToDOMTopLevelType('mouseout');var TOP_MOUSE_OVER=unsafeCastStringToDOMTopLevelType('mouseover');var TOP_MOUSE_UP=unsafeCastStringToDOMTopLevelType('mouseup');var TOP_PASTE=unsafeCastStringToDOMTopLevelType('paste');var TOP_PAUSE=unsafeCastStringToDOMTopLevelType('pause');var TOP_PLAY=unsafeCastStringToDOMTopLevelType('play');var TOP_PLAYING=unsafeCastStringToDOMTopLevelType('playing');var TOP_POINTER_CANCEL=unsafeCastStringToDOMTopLevelType('pointercancel');var TOP_POINTER_DOWN=unsafeCastStringToDOMTopLevelType('pointerdown');var TOP_POINTER_MOVE=unsafeCastStringToDOMTopLevelType('pointermove');var TOP_POINTER_OUT=unsafeCastStringToDOMTopLevelType('pointerout');var TOP_POINTER_OVER=unsafeCastStringToDOMTopLevelType('pointerover');var TOP_POINTER_UP=unsafeCastStringToDOMTopLevelType('pointerup');var TOP_PROGRESS=unsafeCastStringToDOMTopLevelType('progress');var TOP_RATE_CHANGE=unsafeCastStringToDOMTopLevelType('ratechange');var TOP_RESET=unsafeCastStringToDOMTopLevelType('reset');var TOP_SCROLL=unsafeCastStringToDOMTopLevelType('scroll');var TOP_SEEKED=unsafeCastStringToDOMTopLevelType('seeked');var TOP_SEEKING=unsafeCastStringToDOMTopLevelType('seeking');var TOP_SELECTION_CHANGE=unsafeCastStringToDOMTopLevelType('selectionchange');var TOP_STALLED=unsafeCastStringToDOMTopLevelType('stalled');var TOP_SUBMIT=unsafeCastStringToDOMTopLevelType('submit');var TOP_SUSPEND=unsafeCastStringToDOMTopLevelType('suspend');var TOP_TEXT_INPUT=unsafeCastStringToDOMTopLevelType('textInput');var TOP_TIME_UPDATE=unsafeCastStringToDOMTopLevelType('timeupdate');var TOP_TOGGLE=unsafeCastStringToDOMTopLevelType('toggle');var TOP_TOUCH_CANCEL=unsafeCastStringToDOMTopLevelType('touchcancel');var TOP_TOUCH_END=unsafeCastStringToDOMTopLevelType('touchend');var TOP_TOUCH_MOVE=unsafeCastStringToDOMTopLevelType('touchmove');var TOP_TOUCH_START=unsafeCastStringToDOMTopLevelType('touchstart');var TOP_TRANSITION_END=unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('transitionend'));var TOP_VOLUME_CHANGE=unsafeCastStringToDOMTopLevelType('volumechange');var TOP_WAITING=unsafeCastStringToDOMTopLevelType('waiting');var TOP_WHEEL=unsafeCastStringToDOMTopLevelType('wheel');// List of events that need to be individually attached to media elements.
// Note that events in this list will *not* be listened to at the top level
// unless they're explicitly whitelisted in `ReactBrowserEventEmitter.listenTo`.
var mediaEventTypes=[TOP_ABORT,TOP_CAN_PLAY,TOP_CAN_PLAY_THROUGH,TOP_DURATION_CHANGE,TOP_EMPTIED,TOP_ENCRYPTED,TOP_ENDED,TOP_ERROR,TOP_LOADED_DATA,TOP_LOADED_METADATA,TOP_LOAD_START,TOP_PAUSE,TOP_PLAY,TOP_PLAYING,TOP_PROGRESS,TOP_RATE_CHANGE,TOP_SEEKED,TOP_SEEKING,TOP_STALLED,TOP_SUSPEND,TOP_TIME_UPDATE,TOP_VOLUME_CHANGE,TOP_WAITING];function getRawEventName(topLevelType){return unsafeCastDOMTopLevelTypeToString(topLevelType);}/**
 * These variables store information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */var root=null;var startText=null;var fallbackText=null;function initialize(nativeEventTarget){root=nativeEventTarget;startText=getText();return true;}function reset(){root=null;startText=null;fallbackText=null;}function getData(){if(fallbackText){return fallbackText;}var start=void 0;var startValue=startText;var startLength=startValue.length;var end=void 0;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;fallbackText=endValue.slice(start,sliceTail);return fallbackText;}function getText(){if('value'in root){return root.value;}return root.textContent;}/* eslint valid-typeof: 0 */var EVENT_POOL_SIZE=10;/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var EventInterface={type:null,target:null,// currentTarget is set when dispatching; no use in copying it here
currentTarget:function currentTarget(){return null;},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function timeStamp(event){return event.timeStamp||Date.now();},defaultPrevented:null,isTrusted:null};function functionThatReturnsTrue(){return true;}function functionThatReturnsFalse(){return false;}/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */function SyntheticEvent(dispatchConfig,targetInst,nativeEvent,nativeEventTarget){{// these have a getter/setter for warnings
delete this.nativeEvent;delete this.preventDefault;delete this.stopPropagation;delete this.isDefaultPrevented;delete this.isPropagationStopped;}this.dispatchConfig=dispatchConfig;this._targetInst=targetInst;this.nativeEvent=nativeEvent;var Interface=this.constructor.Interface;for(var propName in Interface){if(!Interface.hasOwnProperty(propName)){continue;}{delete this[propName];// this has a getter/setter for warnings
}var normalize=Interface[propName];if(normalize){this[propName]=normalize(nativeEvent);}else{if(propName==='target'){this.target=nativeEventTarget;}else{this[propName]=nativeEvent[propName];}}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=functionThatReturnsTrue;}else{this.isDefaultPrevented=functionThatReturnsFalse;}this.isPropagationStopped=functionThatReturnsFalse;return this;}_assign(SyntheticEvent.prototype,{preventDefault:function preventDefault(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=functionThatReturnsTrue;},stopPropagation:function stopPropagation(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a "propertychange" event for
// IE. This event does not support bubbling or cancelling, and
// any references to cancelBubble throw "Member not found".  A
// typeof check of "unknown" circumvents this issue (and is also
// IE specific).
event.cancelBubble=true;}this.isPropagationStopped=functionThatReturnsTrue;},/**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */persist:function persist(){this.isPersistent=functionThatReturnsTrue;},/**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */isPersistent:functionThatReturnsFalse,/**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */destructor:function destructor(){var Interface=this.constructor.Interface;for(var propName in Interface){{Object.defineProperty(this,propName,getPooledWarningPropertyDefinition(propName,Interface[propName]));}}this.dispatchConfig=null;this._targetInst=null;this.nativeEvent=null;this.isDefaultPrevented=functionThatReturnsFalse;this.isPropagationStopped=functionThatReturnsFalse;this._dispatchListeners=null;this._dispatchInstances=null;{Object.defineProperty(this,'nativeEvent',getPooledWarningPropertyDefinition('nativeEvent',null));Object.defineProperty(this,'isDefaultPrevented',getPooledWarningPropertyDefinition('isDefaultPrevented',functionThatReturnsFalse));Object.defineProperty(this,'isPropagationStopped',getPooledWarningPropertyDefinition('isPropagationStopped',functionThatReturnsFalse));Object.defineProperty(this,'preventDefault',getPooledWarningPropertyDefinition('preventDefault',function(){}));Object.defineProperty(this,'stopPropagation',getPooledWarningPropertyDefinition('stopPropagation',function(){}));}}});SyntheticEvent.Interface=EventInterface;/**
 * Helper to reduce boilerplate when creating subclasses.
 */SyntheticEvent.extend=function(Interface){var Super=this;var E=function E(){};E.prototype=Super.prototype;var prototype=new E();function Class(){return Super.apply(this,arguments);}_assign(prototype,Class.prototype);Class.prototype=prototype;Class.prototype.constructor=Class;Class.Interface=_assign({},Super.Interface,Interface);Class.extend=Super.extend;addEventPoolingTo(Class);return Class;};addEventPoolingTo(SyntheticEvent);/**
 * Helper to nullify syntheticEvent instance properties when destructing
 *
 * @param {String} propName
 * @param {?object} getVal
 * @return {object} defineProperty object
 */function getPooledWarningPropertyDefinition(propName,getVal){var isFunction=typeof getVal==='function';return{configurable:true,set:set,get:get};function set(val){var action=isFunction?'setting the method':'setting the property';warn(action,'This is effectively a no-op');return val;}function get(){var action=isFunction?'accessing the method':'accessing the property';var result=isFunction?'This is a no-op function':'This is set to null';warn(action,result);return getVal;}function warn(action,result){var warningCondition=false;!warningCondition?warningWithoutStack$1(false,"This synthetic event is reused for performance reasons. If you're seeing this, "+"you're %s `%s` on a released/nullified synthetic event. %s. "+'If you must keep the original synthetic event around, use event.persist(). '+'See https://fb.me/react-event-pooling for more information.',action,propName,result):void 0;}}function getPooledEvent(dispatchConfig,targetInst,nativeEvent,nativeInst){var EventConstructor=this;if(EventConstructor.eventPool.length){var instance=EventConstructor.eventPool.pop();EventConstructor.call(instance,dispatchConfig,targetInst,nativeEvent,nativeInst);return instance;}return new EventConstructor(dispatchConfig,targetInst,nativeEvent,nativeInst);}function releasePooledEvent(event){var EventConstructor=this;!(event instanceof EventConstructor)?invariant(false,'Trying to release an event instance into a pool of a different type.'):void 0;event.destructor();if(EventConstructor.eventPool.length<EVENT_POOL_SIZE){EventConstructor.eventPool.push(event);}}function addEventPoolingTo(EventConstructor){EventConstructor.eventPool=[];EventConstructor.getPooled=getPooledEvent;EventConstructor.release=releasePooledEvent;}/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */var SyntheticCompositionEvent=SyntheticEvent.extend({data:null});/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */var SyntheticInputEvent=SyntheticEvent.extend({data:null});var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space
var START_KEYCODE=229;var canUseCompositionEvent=canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent=canUseDOM&&'TextEvent'in window&&!documentMode;// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData=canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);// Events and their corresponding property names.
var eventTypes={beforeInput:{phasedRegistrationNames:{bubbled:'onBeforeInput',captured:'onBeforeInputCapture'},dependencies:[TOP_COMPOSITION_END,TOP_KEY_PRESS,TOP_TEXT_INPUT,TOP_PASTE]},compositionEnd:{phasedRegistrationNames:{bubbled:'onCompositionEnd',captured:'onCompositionEndCapture'},dependencies:[TOP_BLUR,TOP_COMPOSITION_END,TOP_KEY_DOWN,TOP_KEY_PRESS,TOP_KEY_UP,TOP_MOUSE_DOWN]},compositionStart:{phasedRegistrationNames:{bubbled:'onCompositionStart',captured:'onCompositionStartCapture'},dependencies:[TOP_BLUR,TOP_COMPOSITION_START,TOP_KEY_DOWN,TOP_KEY_PRESS,TOP_KEY_UP,TOP_MOUSE_DOWN]},compositionUpdate:{phasedRegistrationNames:{bubbled:'onCompositionUpdate',captured:'onCompositionUpdateCapture'},dependencies:[TOP_BLUR,TOP_COMPOSITION_UPDATE,TOP_KEY_DOWN,TOP_KEY_PRESS,TOP_KEY_UP,TOP_MOUSE_DOWN]}};// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress=false;/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.
!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */function getCompositionEventType(topLevelType){switch(topLevelType){case TOP_COMPOSITION_START:return eventTypes.compositionStart;case TOP_COMPOSITION_END:return eventTypes.compositionEnd;case TOP_COMPOSITION_UPDATE:return eventTypes.compositionUpdate;}}/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */function isFallbackCompositionStart(topLevelType,nativeEvent){return topLevelType===TOP_KEY_DOWN&&nativeEvent.keyCode===START_KEYCODE;}/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */function isFallbackCompositionEnd(topLevelType,nativeEvent){switch(topLevelType){case TOP_KEY_UP:// Command keys insert or clear IME input.
return END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case TOP_KEY_DOWN:// Expect IME keyCode on each keydown. If we get any other
// code we must have exited earlier.
return nativeEvent.keyCode!==START_KEYCODE;case TOP_KEY_PRESS:case TOP_MOUSE_DOWN:case TOP_BLUR:// Events are not possible without cancelling IME.
return true;default:return false;}}/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if((typeof detail==='undefined'?'undefined':_typeof(detail))==='object'&&'data'in detail){return detail.data;}return null;}/**
 * Check if a composition event was triggered by Korean IME.
 * Our fallback mode does not work well with IE's Korean IME,
 * so just use native composition events when Korean IME is used.
 * Although CompositionEvent.locale property is deprecated,
 * it is available in IE, where our fallback mode is enabled.
 *
 * @param {object} nativeEvent
 * @return {boolean}
 */function isUsingKoreanIME(nativeEvent){return nativeEvent.locale==='ko';}// Track the current IME composition status, if any.
var isComposing=false;/**
 * @return {?object} A SyntheticCompositionEvent.
 */function extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var eventType=void 0;var fallbackData=void 0;if(canUseCompositionEvent){eventType=getCompositionEventType(topLevelType);}else if(!isComposing){if(isFallbackCompositionStart(topLevelType,nativeEvent)){eventType=eventTypes.compositionStart;}}else if(isFallbackCompositionEnd(topLevelType,nativeEvent)){eventType=eventTypes.compositionEnd;}if(!eventType){return null;}if(useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)){// The current composition is stored statically and must not be
// overwritten while composition continues.
if(!isComposing&&eventType===eventTypes.compositionStart){isComposing=initialize(nativeEventTarget);}else if(eventType===eventTypes.compositionEnd){if(isComposing){fallbackData=getData();}}}var event=SyntheticCompositionEvent.getPooled(eventType,targetInst,nativeEvent,nativeEventTarget);if(fallbackData){// Inject data generated from fallback path into the synthetic event.
// This matches the property of native CompositionEventInterface.
event.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}accumulateTwoPhaseDispatches(event);return event;}/**
 * @param {TopLevelType} topLevelType Number from `TopLevelType`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */function getNativeBeforeInputChars(topLevelType,nativeEvent){switch(topLevelType){case TOP_COMPOSITION_END:return getDataFromCustomEvent(nativeEvent);case TOP_KEY_PRESS:/**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case TOP_TEXT_INPUT:// Record the characters to be added to the DOM.
var chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled
// it at the keypress level and bail immediately. Android Chrome
// doesn't give us keycodes, so we need to ignore it.
if(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.
return null;}}/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {number} topLevelType Number from `TopLevelEventTypes`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */function getFallbackBeforeInputChars(topLevelType,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if(isComposing){if(topLevelType===TOP_COMPOSITION_END||!canUseCompositionEvent&&isFallbackCompositionEnd(topLevelType,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(topLevelType){case TOP_PASTE:// If a paste event occurs after a keypress, throw out the input
// chars. Paste events should not lead to BeforeInput events.
return null;case TOP_KEY_PRESS:/**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via
// Touch keyboard of Windows.  In such a case, the `char` property
// holds an emoji character like `\uD83D\uDE0A`.  Because its length
// is 2, the property `which` does not represent an emoji correctly.
// In such a case, we directly return the `char` property instead of
// using `which`.
if(nativeEvent.char&&nativeEvent.char.length>1){return nativeEvent.char;}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case TOP_COMPOSITION_END:return useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)?null:nativeEvent.data;default:return null;}}/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */function extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var chars=void 0;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(topLevelType,nativeEvent);}else{chars=getFallbackBeforeInputChars(topLevelType,nativeEvent);}// If no characters are being inserted, no BeforeInput event should
// be fired.
if(!chars){return null;}var event=SyntheticInputEvent.getPooled(eventTypes.beforeInput,targetInst,nativeEvent,nativeEventTarget);event.data=chars;accumulateTwoPhaseDispatches(event);return event;}/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */var BeforeInputEventPlugin={eventTypes:eventTypes,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var composition=extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget);var beforeInput=extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget);if(composition===null){return beforeInput;}if(beforeInput===null){return composition;}return[composition,beforeInput];}};// Use to restore controlled state after a change event has fired.
var restoreImpl=null;var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we
// always receive the correct fiber here
var internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted
return;}!(typeof restoreImpl==='function')?invariant(false,'setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.'):void 0;var props=getFiberCurrentPropsFromNode(internalInstance.stateNode);restoreImpl(internalInstance.stateNode,internalInstance.type,props);}function setRestoreImplementation(impl){restoreImpl=impl;}function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function needsStateRestore(){return restoreTarget!==null||restoreQueue!==null;}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}// Used as a way to call batchedUpdates when we don't have a reference to
// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.
// Defaults
var _batchedUpdatesImpl=function _batchedUpdatesImpl(fn,bookkeeping){return fn(bookkeeping);};var _interactiveUpdatesImpl=function _interactiveUpdatesImpl(fn,a,b){return fn(a,b);};var _flushInteractiveUpdatesImpl=function _flushInteractiveUpdatesImpl(){};var isBatching=false;function batchedUpdates(fn,bookkeeping){if(isBatching){// If we are currently inside another batch, we need to wait until it
// fully completes before restoring state.
return fn(bookkeeping);}isBatching=true;try{return _batchedUpdatesImpl(fn,bookkeeping);}finally{// Here we wait until all updates have propagated, which is important
// when using controlled components within layers:
// https://github.com/facebook/react/issues/1698
// Then we restore state of any controlled component.
isBatching=false;var controlledComponentsHavePendingUpdates=needsStateRestore();if(controlledComponentsHavePendingUpdates){// If a controlled event was fired, we may need to restore the state of
// the DOM node back to the controlled value. This is necessary when React
// bails out of the update without touching the DOM.
_flushInteractiveUpdatesImpl();restoreStateIfNeeded();}}}function interactiveUpdates(fn,a,b){return _interactiveUpdatesImpl(fn,a,b);}function setBatchingImplementation(batchedUpdatesImpl,interactiveUpdatesImpl,flushInteractiveUpdatesImpl){_batchedUpdatesImpl=batchedUpdatesImpl;_interactiveUpdatesImpl=interactiveUpdatesImpl;_flushInteractiveUpdatesImpl=flushInteractiveUpdatesImpl;}/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**
 * HTML nodeType values that represent the type of the node
 */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */function getEventTarget(nativeEvent){// Fallback to nativeEvent.srcElement for IE9
// https://github.com/facebook/react/issues/12506
var target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963
if(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).
// @see http://www.quirksmode.org/js/events_properties.html
return target.nodeType===TEXT_NODE?target.parentNode:target;}/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */function isEventSupported(eventNameSuffix){if(!canUseDOM){return false;}var eventName='on'+eventNameSuffix;var isSupported=eventName in document;if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}return isSupported;}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail
// and don't track value will cause over reporting of changes,
// but it's better then a hard failure
// (needed for certain tests that spyOn input values and Safari)
if(node.hasOwnProperty(valueField)||typeof descriptor==='undefined'||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}var _get=descriptor.get,_set=descriptor.set;Object.defineProperty(node,valueField,{configurable:true,get:function get(){return _get.call(this);},set:function set(value){currentValue=''+value;_set.call(this,value);}});// We could've passed this the first time
// but it triggers a bug in IE11 and Edge 14/15.
// Calling defineProperty() again should be equivalent.
// https://github.com/facebook/react/issues/11768
Object.defineProperty(node,valueField,{enumerable:descriptor.enumerable});var tracker={getValue:function getValue(){return currentValue;},setValue:function setValue(value){currentValue=''+value;},stopTracking:function stopTracking(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState
node._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely
// that trying again will succeed
if(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}var ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var BEFORE_SLASH_RE=/^(.*)[\\\/]/;var describeComponentFrame=function describeComponentFrame(name,source,ownerName){var sourceInfo='';if(source){var path=source.fileName;var fileName=path.replace(BEFORE_SLASH_RE,'');{// In DEV, include code for a common special case:
// prefer "folder/index.js" instead of just "index.js".
if(/^index\./.test(fileName)){var match=path.match(BEFORE_SLASH_RE);if(match){var pathBeforeSlash=match[1];if(pathBeforeSlash){var folderName=pathBeforeSlash.replace(BEFORE_SLASH_RE,'');fileName=folderName+'/'+fileName;}}}}sourceInfo=' (at '+fileName+':'+source.lineNumber+')';}else if(ownerName){sourceInfo=' (created by '+ownerName+')';}return'\n    in '+(name||'Unknown')+sourceInfo;};// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol=typeof Symbol==='function'&&Symbol.for;var REACT_ELEMENT_TYPE=hasSymbol?Symbol.for('react.element'):0xeac7;var REACT_PORTAL_TYPE=hasSymbol?Symbol.for('react.portal'):0xeaca;var REACT_FRAGMENT_TYPE=hasSymbol?Symbol.for('react.fragment'):0xeacb;var REACT_STRICT_MODE_TYPE=hasSymbol?Symbol.for('react.strict_mode'):0xeacc;var REACT_PROFILER_TYPE=hasSymbol?Symbol.for('react.profiler'):0xead2;var REACT_PROVIDER_TYPE=hasSymbol?Symbol.for('react.provider'):0xeacd;var REACT_CONTEXT_TYPE=hasSymbol?Symbol.for('react.context'):0xeace;var REACT_ASYNC_MODE_TYPE=hasSymbol?Symbol.for('react.async_mode'):0xeacf;var REACT_FORWARD_REF_TYPE=hasSymbol?Symbol.for('react.forward_ref'):0xead0;var REACT_PLACEHOLDER_TYPE=hasSymbol?Symbol.for('react.placeholder'):0xead1;var MAYBE_ITERATOR_SYMBOL=typeof Symbol==='function'&&Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||(typeof maybeIterable==='undefined'?'undefined':_typeof(maybeIterable))!=='object'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}var Pending=0;var Resolved=1;var Rejected=2;function getResultFromResolvedThenable(thenable){return thenable._reactResult;}function refineResolvedThenable(thenable){return thenable._reactStatus===Resolved?thenable._reactResult:null;}function getComponentName(type){if(type==null){// Host root, text node or just invalid type.
return null;}{if(typeof type.tag==='number'){warningWithoutStack$1(false,'Received an unexpected object in getComponentName(). '+'This is likely a bug in React. Please file an issue.');}}if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}switch(type){case REACT_ASYNC_MODE_TYPE:return'AsyncMode';case REACT_FRAGMENT_TYPE:return'Fragment';case REACT_PORTAL_TYPE:return'Portal';case REACT_PROFILER_TYPE:return'Profiler';case REACT_STRICT_MODE_TYPE:return'StrictMode';case REACT_PLACEHOLDER_TYPE:return'Placeholder';}if((typeof type==='undefined'?'undefined':_typeof(type))==='object'){switch(type.$$typeof){case REACT_CONTEXT_TYPE:return'Context.Consumer';case REACT_PROVIDER_TYPE:return'Context.Provider';case REACT_FORWARD_REF_TYPE:var renderFn=type.render;var functionName=renderFn.displayName||renderFn.name||'';return type.displayName||(functionName!==''?'ForwardRef('+functionName+')':'ForwardRef');}if(typeof type.then==='function'){var thenable=type;var resolvedThenable=refineResolvedThenable(thenable);if(resolvedThenable){return getComponentName(resolvedThenable);}}}return null;}var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;function describeFiber(fiber){switch(fiber.tag){case IndeterminateComponent:case FunctionalComponent:case FunctionalComponentLazy:case ClassComponent:case ClassComponentLazy:case HostComponent:case Mode:var owner=fiber._debugOwner;var source=fiber._debugSource;var name=getComponentName(fiber.type);var ownerName=null;if(owner){ownerName=getComponentName(owner.type);}return describeComponentFrame(name,source,ownerName);default:return'';}}function getStackByFiberInDevAndProd(workInProgress){var info='';var node=workInProgress;do{info+=describeFiber(node);node=node.return;}while(node);return info;}var current=null;var phase=null;function getCurrentFiberOwnerNameInDevOrNull(){{if(current===null){return null;}var owner=current._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentName(owner.type);}}return null;}function getCurrentFiberStackInDev(){{if(current===null){return'';}// Safe because if current fiber exists, we are reconciling,
// and it is guaranteed to be the work-in-progress version.
return getStackByFiberInDevAndProd(current);}return'';}function resetCurrentFiber(){{ReactDebugCurrentFrame.getCurrentStack=null;current=null;phase=null;}}function setCurrentFiber(fiber){{ReactDebugCurrentFrame.getCurrentStack=getCurrentFiberStackInDev;current=fiber;phase=null;}}function setCurrentPhase(lifeCyclePhase){{phase=lifeCyclePhase;}}/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */var warning=warningWithoutStack$1;{warning=function warning(condition,format){if(condition){return;}var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var stack=ReactDebugCurrentFrame.getStackAddendum();// eslint-disable-next-line react-internal/warning-and-invariant-args
for(var _len=arguments.length,args=Array(_len>2?_len-2:0),_key=2;_key<_len;_key++){args[_key-2]=arguments[_key];}warningWithoutStack$1.apply(undefined,[false,format+'%s'].concat(args,[stack]));};}var warning$1=warning;// A reserved attribute.
// It is handled by React separately and shouldn't be written to the DOM.
var RESERVED=0;// A simple string attribute.
// Attributes that aren't in the whitelist are presumed to have this type.
var STRING=1;// A string attribute that accepts booleans in React. In HTML, these are called
// "enumerated" attributes with "true" and "false" as possible values.
// When true, it should be set to a "true" string.
// When false, it should be set to a "false" string.
var BOOLEANISH_STRING=2;// A real boolean attribute.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
var BOOLEAN=3;// An attribute that can be used as a flag as well as with a value.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
// For any other value, should be present with that value.
var OVERLOADED_BOOLEAN=4;// An attribute that must be numeric or parse as a numeric.
// When falsy, it should be removed.
var NUMERIC=5;// An attribute that must be positive numeric or parse as a positive numeric.
// When falsy, it should be removed.
var POSITIVE_NUMERIC=6;/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+'\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040';var ROOT_ATTRIBUTE_NAME='data-reactroot';var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var hasOwnProperty=Object.prototype.hasOwnProperty;var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(hasOwnProperty.call(validatedAttributeNameCache,attributeName)){return true;}if(hasOwnProperty.call(illegalAttributeNameCache,attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{warning$1(false,'Invalid attribute name: `%s`',attributeName);}return false;}function shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag){if(propertyInfo!==null){return propertyInfo.type===RESERVED;}if(isCustomComponentTag){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return true;}return false;}function shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag){if(propertyInfo!==null&&propertyInfo.type===RESERVED){return false;}switch(typeof value==='undefined'?'undefined':_typeof(value)){case'function':// $FlowIssue symbol is perfectly valid here
case'symbol':// eslint-disable-line
return true;case'boolean':{if(isCustomComponentTag){return false;}if(propertyInfo!==null){return!propertyInfo.acceptsBooleans;}else{var prefix=name.toLowerCase().slice(0,5);return prefix!=='data-'&&prefix!=='aria-';}}default:return false;}}function shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag){if(value===null||typeof value==='undefined'){return true;}if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag)){return true;}if(isCustomComponentTag){return false;}if(propertyInfo!==null){switch(propertyInfo.type){case BOOLEAN:return!value;case OVERLOADED_BOOLEAN:return value===false;case NUMERIC:return isNaN(value);case POSITIVE_NUMERIC:return isNaN(value)||value<1;}}return false;}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function PropertyInfoRecord(name,type,mustUseProperty,attributeName,attributeNamespace){this.acceptsBooleans=type===BOOLEANISH_STRING||type===BOOLEAN||type===OVERLOADED_BOOLEAN;this.attributeName=attributeName;this.attributeNamespace=attributeNamespace;this.mustUseProperty=mustUseProperty;this.propertyName=name;this.type=type;}// When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.
var properties={};// These props are reserved by React. They shouldn't be written to the DOM.
['children','dangerouslySetInnerHTML',// TODO: This prevents the assignment of defaultValue to regular
// elements (not just inputs). Now that ReactDOMInput assigns to the
// defaultValue property -- do we need this?
'defaultValue','defaultChecked','innerHTML','suppressContentEditableWarning','suppressHydrationWarning','style'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,RESERVED,false,// mustUseProperty
name,// attributeName
null);}// attributeNamespace
);// A few React string attributes have a different name.
// This is a mapping from React prop names to the attribute names.
[['acceptCharset','accept-charset'],['className','class'],['htmlFor','for'],['httpEquiv','http-equiv']].forEach(function(_ref){var name=_ref[0],attributeName=_ref[1];properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,// attributeName
null);}// attributeNamespace
);// These are "enumerated" HTML attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
['contentEditable','draggable','spellCheck','value'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty
name.toLowerCase(),// attributeName
null);}// attributeNamespace
);// These are "enumerated" SVG attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
// Since these are SVG attributes, their attribute names are case-sensitive.
['autoReverse','externalResourcesRequired','focusable','preserveAlpha'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty
name,// attributeName
null);}// attributeNamespace
);// These are HTML boolean attributes.
['allowFullScreen','async',// Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
'autoFocus','autoPlay','controls','default','defer','disabled','formNoValidate','hidden','loop','noModule','noValidate','open','playsInline','readOnly','required','reversed','scoped','seamless',// Microdata
'itemScope'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,false,// mustUseProperty
name.toLowerCase(),// attributeName
null);}// attributeNamespace
);// These are the few React props that we set as DOM properties
// rather than attributes. These are all booleans.
['checked',// Note: `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`. We have special logic for handling this.
'multiple','muted','selected'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,true,// mustUseProperty
name,// attributeName
null);}// attributeNamespace
);// These are HTML attributes that are "overloaded booleans": they behave like
// booleans, but can also accept a string value.
['capture','download'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,OVERLOADED_BOOLEAN,false,// mustUseProperty
name,// attributeName
null);}// attributeNamespace
);// These are HTML attributes that must be positive numbers.
['cols','rows','size','span'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,POSITIVE_NUMERIC,false,// mustUseProperty
name,// attributeName
null);}// attributeNamespace
);// These are HTML attributes that must be numbers.
['rowSpan','start'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,NUMERIC,false,// mustUseProperty
name.toLowerCase(),// attributeName
null);}// attributeNamespace
);var CAMELIZE=/[\-\:]([a-z])/g;var capitalize=function capitalize(token){return token[1].toUpperCase();};// This is a list of all SVG attributes that need special casing, namespacing,
// or boolean value assignment. Regular attributes that just accept strings
// and have the same names are omitted, just like in the HTML whitelist.
// Some of these attributes can be hard to find. This list was created by
// scrapping the MDN documentation.
['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','xmlns:xlink','x-height'].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,null);}// attributeNamespace
);// String SVG attributes with the xlink namespace.
['xlink:actuate','xlink:arcrole','xlink:href','xlink:role','xlink:show','xlink:title','xlink:type'].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,'http://www.w3.org/1999/xlink');});// String SVG attributes with the xml namespace.
['xml:base','xml:lang','xml:space'].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,'http://www.w3.org/XML/1998/namespace');});// Special case: this attribute exists both in HTML and SVG.
// Its "tabindex" attribute name is case-sensitive in SVG so we can't just use
// its React `tabIndex` name, like we do for attributes that exist only in HTML.
properties.tabIndex=new PropertyInfoRecord('tabIndex',STRING,false,// mustUseProperty
'tabindex',// attributeName
null);/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */function getValueForProperty(node,name,expected,propertyInfo){{if(propertyInfo.mustUseProperty){var propertyName=propertyInfo.propertyName;return node[propertyName];}else{var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.type===OVERLOADED_BOOLEAN){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return value;}if(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldRemoveAttribute(name,expected,propertyInfo,false)){// We had an attribute but shouldn't have had one, so read it
// for the error message.
return node.getAttribute(attributeName);}if(propertyInfo.type===BOOLEAN){// If this was a boolean, it doesn't matter what the value is
// the fact that we have it is the same as the expected.
return expected;}// Even if this property uses a namespace we use getAttribute
// because we assume its namespaced name is the same as our config.
// To use getAttributeNS we need the local name which we don't have
// in our config atm.
stringValue=node.getAttribute(attributeName);}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return stringValue===null?expected:stringValue;}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */function getValueForAttribute(node,name,expected){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);if(value===''+expected){return expected;}return value;}}/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */function setValueForProperty(node,name,value,isCustomComponentTag){var propertyInfo=getPropertyInfo(name);if(shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag)){return;}if(shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag)){value=null;}// If the prop isn't in the special list, treat it as a simple attribute.
if(isCustomComponentTag||propertyInfo===null){if(isAttributeNameSafe(name)){var _attributeName=name;if(value===null){node.removeAttribute(_attributeName);}else{node.setAttribute(_attributeName,''+value);}}return;}var mustUseProperty=propertyInfo.mustUseProperty;if(mustUseProperty){var propertyName=propertyInfo.propertyName;if(value===null){var type=propertyInfo.type;node[propertyName]=type===BOOLEAN?false:'';}else{// Contrary to `setAttribute`, object properties are properly
// `toString`ed by IE8/9.
node[propertyName]=value;}return;}// The rest are treated as attributes with special cases.
var attributeName=propertyInfo.attributeName,attributeNamespace=propertyInfo.attributeNamespace;if(value===null){node.removeAttribute(attributeName);}else{var _type=propertyInfo.type;var attributeValue=void 0;if(_type===BOOLEAN||_type===OVERLOADED_BOOLEAN&&value===true){attributeValue='';}else{// `setAttribute` with objects becomes only `[object]` in IE8/9,
// ('' + value) makes it output the correct toString()-value.
attributeValue=''+value;}if(attributeNamespace){node.setAttributeNS(attributeNamespace,attributeName,attributeValue);}else{node.setAttribute(attributeName,attributeValue);}}}// Flow does not allow string concatenation of most non-string types. To work
// around this limitation, we use an opaque type that can only be obtained by
// passing the value through getToStringValue first.
function toString(value){return''+value;}function getToStringValue(value){switch(typeof value==='undefined'?'undefined':_typeof(value)){case'boolean':case'number':case'object':case'string':case'undefined':return value;default:// function, symbol are assigned as empty strings
return'';}}var ReactDebugCurrentFrame$1=null;var ReactControlledValuePropTypes={checkPropTypes:null};{ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame;var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};var propTypes={value:function value(props,propName,componentName){if(hasReadOnlyValue[props.type]||props.onChange||props.readOnly||props.disabled||props[propName]==null){return null;}return new Error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');},checked:function checked(props,propName,componentName){if(props.onChange||props.readOnly||props.disabled||props[propName]==null){return null;}return new Error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}};/**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */ReactControlledValuePropTypes.checkPropTypes=function(tagName,props){checkPropTypes(propTypes,props,'prop',tagName,ReactDebugCurrentFrame$1.getStackAddendum);};}// Exports ReactDOM.createRoot
var enableUserTimingAPI=true;// Experimental error-boundary API that can recover from errors within a single
// render phase
var enableGetDerivedStateFromCatch=false;// Suspense
var enableSuspense=false;// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
var debugRenderPhaseSideEffects=false;// In some cases, StrictMode should also double-render lifecycles.
// This can be confusing for tests though,
// And it can be bad for performance in production.
// This feature flag can be used to control the behavior:
var debugRenderPhaseSideEffectsForStrictMode=true;// To preserve the "Pause on caught exceptions" behavior of the debugger, we
// replay the begin phase of a failed component inside invokeGuardedCallback.
var replayFailedUnitOfWorkWithInvokeGuardedCallback=true;// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:
var warnAboutDeprecatedLifecycles=false;// Warn about legacy context API
var warnAboutLegacyContextAPI=false;// Gather advanced timing metrics for Profiler subtrees.
var enableProfilerTimer=true;// Trace which interactions trigger each commit.
var enableSchedulerTracing=true;// Only used in www builds.
// Only used in www builds.
// React Fire: prevent the value and checked attributes from syncing
// with their related DOM properties
var disableInputAttributeSyncing=false;// TODO: direct imports like some-package/src/* are bad. Fix me.
var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */function getHostProps(element,props){var node=element;var checked=props.checked;var hostProps=_assign({},props,{defaultChecked:undefined,defaultValue:undefined,value:undefined,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{ReactControlledValuePropTypes.checkPropTypes('input',props);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){warning$1(false,'%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){warning$1(false,'%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnValueDefaultValue=true;}}var node=element;var defaultValue=props.defaultValue==null?'':props.defaultValue;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:getToStringValue(props.value!=null?props.value:defaultValue),controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked,false);}}function updateWrapper(element,props){var node=element;{var _controlled=isControlled(props);if(!node._wrapperState.controlled&&_controlled&&!didWarnUncontrolledToControlled){warning$1(false,'A component is changing an uncontrolled input of type %s to be controlled. '+'Input elements should not switch from uncontrolled to controlled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components',props.type);didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!_controlled&&!didWarnControlledToUncontrolled){warning$1(false,'A component is changing a controlled input of type %s to be uncontrolled. '+'Input elements should not switch from controlled to uncontrolled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components',props.type);didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=getToStringValue(props.value);var type=props.type;if(value!=null){if(type==='number'){if(value===0&&node.value===''||// We explicitly want to coerce to number here if possible.
// eslint-disable-next-line
node.value!=value){node.value=toString(value);}}else if(node.value!==toString(value)){node.value=toString(value);}}else if(type==='submit'||type==='reset'){// Submit/reset inputs need the attribute removed completely to avoid
// blank-text buttons.
node.removeAttribute('value');return;}if(disableInputAttributeSyncing){// When not syncing the value attribute, React only assigns a new value
// whenever the defaultValue React prop has changed. When not present,
// React does nothing
if(props.hasOwnProperty('defaultValue')){setDefaultValue(node,props.type,getToStringValue(props.defaultValue));}}else{// When syncing the value attribute, the value comes from a cascade of
// properties:
//  1. The value React property
//  2. The defaultValue React property
//  3. Otherwise there should be no change
if(props.hasOwnProperty('value')){setDefaultValue(node,props.type,value);}else if(props.hasOwnProperty('defaultValue')){setDefaultValue(node,props.type,getToStringValue(props.defaultValue));}}if(disableInputAttributeSyncing){// When not syncing the checked attribute, the attribute is directly
// controllable from the defaultValue React property. It needs to be
// updated as new props come in.
if(props.defaultChecked==null){node.removeAttribute('checked');}else{node.defaultChecked=!!props.defaultChecked;}}else{// When syncing the checked attribute, it only changes when it needs
// to be removed, such as transitioning from a checkbox into a text input
if(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props,isHydrating){var node=element;// Do not assign value if it is already set. This prevents user text input
// from being lost during SSR hydration.
if(props.hasOwnProperty('value')||props.hasOwnProperty('defaultValue')){var type=props.type;var isButton=type==='submit'||type==='reset';// Avoid setting value attribute on submit/reset inputs as it overrides the
// default value provided by the browser. See: #12872
if(isButton&&(props.value===undefined||props.value===null)){return;}var _initialValue=toString(node._wrapperState.initialValue);// Do not assign value if it is already set. This prevents user text input
// from being lost during SSR hydration.
if(!isHydrating){if(disableInputAttributeSyncing){var value=getToStringValue(props.value);// When not syncing the value attribute, the value property points
// directly to the React prop. Only assign it if it exists.
if(value!=null){// Always assign on buttons so that it is possible to assign an
// empty string to clear button text.
//
// Otherwise, do not re-assign the value property if is empty. This
// potentially avoids a DOM write and prevents Firefox (~60.0.1) from
// prematurely marking required inputs as invalid. Equality is compared
// to the current value in case the browser provided value is not an
// empty string.
if(isButton||value!==node.value){node.value=toString(value);}}}else{// When syncing the value attribute, the value property should use
// the the wrapperState._initialValue property. This uses:
//
//   1. The value React property when present
//   2. The defaultValue React property when present
//   3. An empty string
if(_initialValue!==node.value){node.value=_initialValue;}}}if(disableInputAttributeSyncing){// When not syncing the value attribute, assign the value attribute
// directly from the defaultValue React property (when present)
var defaultValue=getToStringValue(props.defaultValue);if(defaultValue!=null){node.defaultValue=toString(defaultValue);}}else{// Otherwise, the value attribute is synchronized to the property,
// so we assign defaultValue to the same thing as the value property
// assignment step above.
node.defaultValue=_initialValue;}}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
// this is needed to work around a chrome bug where setting defaultChecked
// will sometimes influence the value of checked (even after detachment).
// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
// We need to temporarily unset name to avoid disrupting radio button groups.
var name=node.name;if(name!==''){node.name='';}if(disableInputAttributeSyncing){// When not syncing the checked attribute, the checked property
// never gets assigned. It must be manually set. We don't want
// to do this when hydrating so that existing user input isn't
// modified
if(!isHydrating){updateChecked(element,props);}// Only assign the checked attribute if it is defined. This saves
// a DOM write when controlling the checked attribute isn't needed
// (text inputs, submit/reset)
if(props.hasOwnProperty('defaultChecked')){node.defaultChecked=!node.defaultChecked;node.defaultChecked=!!props.defaultChecked;}}else{// When syncing the checked attribute, both the the checked property and
// attribute are assigned at the same time using defaultChecked. This uses:
//
//   1. The checked React property when present
//   2. The defaultChecked React property when present
//   3. Otherwise, false
node.defaultChecked=!node.defaultChecked;node.defaultChecked=!!node._wrapperState.initialChecked;}if(name!==''){node.name=name;}}function restoreControlledState(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,
// but that sometimes behaves strangely in IE8. We could also try using
// `form.getElementsByName`, but that will only return direct children
// and won't include inputs that use the HTML5 `form=` attribute. Since
// the input might not even be in a form. It might not even be in the
// document. Let's just use the local `querySelectorAll` to ensure we don't
// miss anything.
var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type="radio"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React
// and the same name are rendered into the same form (same as #1939).
// That's probably okay; we don't support it just as we don't support
// mixing React radio buttons with non-React ones.
var otherProps=getFiberCurrentPropsFromNode$1(otherNode);!otherProps?invariant(false,'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.'):void 0;// We need update the tracked value on the named cousin since the value
// was changed but the input saw no event or value set
updateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that
// was previously checked to update will cause it to be come re-checked
// as appropriate.
updateWrapper(otherNode,otherProps);}}}// In Chrome, assigning defaultValue to certain input types triggers input validation.
// For number inputs, the display value loses trailing decimal points. For email inputs,
// Chrome raises "The specified value <x> is not a valid email address".
//
// Here we check to see if the defaultValue has actually changed, avoiding these problems
// when the user is inputting text
//
// https://github.com/facebook/react/issues/7253
function setDefaultValue(node,type,value){if(// Focused number inputs synchronize on blur. See ChangeEventPlugin.js
type!=='number'||node.ownerDocument.activeElement!==node){if(value==null){node.defaultValue=toString(node._wrapperState.initialValue);}else if(node.defaultValue!==toString(value)){node.defaultValue=toString(value);}}}var eventTypes$1={change:{phasedRegistrationNames:{bubbled:'onChange',captured:'onChangeCapture'},dependencies:[TOP_BLUR,TOP_CHANGE,TOP_CLICK,TOP_FOCUS,TOP_INPUT,TOP_KEY_DOWN,TOP_KEY_UP,TOP_SELECTION_CHANGE]}};function createAndAccumulateChangeEvent(inst,nativeEvent,target){var event=SyntheticEvent.getPooled(eventTypes$1.change,inst,nativeEvent,target);event.type='change';// Flag this event loop as needing state restore.
enqueueStateRestore(target);accumulateTwoPhaseDispatches(event);return event;}/**
 * For IE shims
 */var activeElement=null;var activeElementInst=null;/**
 * SECTION: handle `change` event
 */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var event=createAndAccumulateChangeEvent(activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the
// other events and have it go through ReactBrowserEventEmitter. Since it
// doesn't, we manually listen for the events and so we have to enqueue and
// process the abstract event manually.
//
// Batching is necessary here in order to ensure that all event handlers run
// before the next rerender (including event handlers attached to ancestor
// elements instead of directly on the input). Without this, controlled
// components don't work properly in conjunction with event bubbling because
// the component is rerendered and the value reverted before all the event
// handlers can run. See https://github.com/facebook/react/issues/708.
batchedUpdates(runEventInBatch,event);}function runEventInBatch(event){runEventsInBatch(event,false);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance$1(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(topLevelType,targetInst){if(topLevelType===TOP_CHANGE){return targetInst;}}/**
 * SECTION: handle `input` event
 */var isInputEventSupported=false;if(canUseDOM){// IE9 claims to support the input event but fails to trigger it when
// deleting text, so we ignore its input events.
isInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(topLevelType,target,targetInst){if(topLevelType===TOP_FOCUS){// In IE9, propertychange fires for most input events but is buggy and
// doesn't fire when text is deleted, but conveniently, selectionchange
// appears to fire in all of the remaining cases so we catch those and
// forward the event if the value has changed
// In either case, we don't want to call the event handler if the value
// is changed from JS so we redefine a setter for `.value` that updates
// our activeElementValue variable, allowing us to ignore those changes
//
// stopWatching() should be a noop here but we call it just in case we
// missed a blur event somehow.
stopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(topLevelType===TOP_BLUR){stopWatchingForValueChange();}}// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType,targetInst){if(topLevelType===TOP_SELECTION_CHANGE||topLevelType===TOP_KEY_UP||topLevelType===TOP_KEY_DOWN){// On the selectionchange event, the target is just document which isn't
// helpful for us so just check activeElement instead.
//
// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
// propertychange on the first input event after setting `value` from a
// script and fires only keydown, keypress, keyup. Catching keyup usually
// gets it and catching keydown lets us fire an event for the first
// keystroke if user does a key repeat (it'll be a little delayed: right
// before the second keystroke). Other input methods (e.g., paste) seem to
// fire selectionchange normally.
return getInstIfValueChanged(activeElementInst);}}/**
 * SECTION: handle `click` event
 */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.
// This approach works across all browsers, whereas `change` does not fire
// until `blur` in IE8.
var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(topLevelType,targetInst){if(topLevelType===TOP_CLICK){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(topLevelType,targetInst){if(topLevelType===TOP_INPUT||topLevelType===TOP_CHANGE){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(node){var state=node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}if(!disableInputAttributeSyncing){// If controlled, assign the value attribute to the current value on blur
setDefaultValue(node,'number',node.value);}}/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */var ChangeEventPlugin={eventTypes:eventTypes$1,_isInputEventSupported:isInputEventSupported,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;var getTargetInstFunc=void 0,handleEventFunc=void 0;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(topLevelType,targetInst);if(inst){var event=createAndAccumulateChangeEvent(inst,nativeEvent,nativeEventTarget);return event;}}if(handleEventFunc){handleEventFunc(topLevelType,targetNode,targetInst);}// When blurring, set the value attribute for number inputs
if(topLevelType===TOP_BLUR){handleControlledInputBlur(targetNode);}}};/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */var DOMEventPluginOrder=['ResponderEventPlugin','SimpleEventPlugin','EnterLeaveEventPlugin','ChangeEventPlugin','SelectEventPlugin','BeforeInputEventPlugin'];var SyntheticUIEvent=SyntheticEvent.extend({view:null,detail:null});/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}var previousScreenX=0;var previousScreenY=0;// Use flags to signal movementX/Y has already been set
var isMovementXSet=false;var isMovementYSet=false;/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var SyntheticMouseEvent=SyntheticUIEvent.extend({screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:getEventModifierState,button:null,buttons:null,relatedTarget:function relatedTarget(event){return event.relatedTarget||(event.fromElement===event.srcElement?event.toElement:event.fromElement);},movementX:function movementX(event){if('movementX'in event){return event.movementX;}var screenX=previousScreenX;previousScreenX=event.screenX;if(!isMovementXSet){isMovementXSet=true;return 0;}return event.type==='mousemove'?event.screenX-screenX:0;},movementY:function movementY(event){if('movementY'in event){return event.movementY;}var screenY=previousScreenY;previousScreenY=event.screenY;if(!isMovementYSet){isMovementYSet=true;return 0;}return event.type==='mousemove'?event.screenY-screenY:0;}});/**
 * @interface PointerEvent
 * @see http://www.w3.org/TR/pointerevents/
 */var SyntheticPointerEvent=SyntheticMouseEvent.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null});var eventTypes$2={mouseEnter:{registrationName:'onMouseEnter',dependencies:[TOP_MOUSE_OUT,TOP_MOUSE_OVER]},mouseLeave:{registrationName:'onMouseLeave',dependencies:[TOP_MOUSE_OUT,TOP_MOUSE_OVER]},pointerEnter:{registrationName:'onPointerEnter',dependencies:[TOP_POINTER_OUT,TOP_POINTER_OVER]},pointerLeave:{registrationName:'onPointerLeave',dependencies:[TOP_POINTER_OUT,TOP_POINTER_OVER]}};var EnterLeaveEventPlugin={eventTypes:eventTypes$2,/**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var isOverEvent=topLevelType===TOP_MOUSE_OVER||topLevelType===TOP_POINTER_OVER;var isOutEvent=topLevelType===TOP_MOUSE_OUT||topLevelType===TOP_POINTER_OUT;if(isOverEvent&&(nativeEvent.relatedTarget||nativeEvent.fromElement)){return null;}if(!isOutEvent&&!isOverEvent){// Must not be a mouse or pointer in or out - ignoring.
return null;}var win=void 0;if(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.
win=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
var doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from=void 0;var to=void 0;if(isOutEvent){from=targetInst;var related=nativeEvent.relatedTarget||nativeEvent.toElement;to=related?getClosestInstanceFromNode(related):null;}else{// Moving to a node from outside the window.
from=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.
return null;}var eventInterface=void 0,leaveEventType=void 0,enterEventType=void 0,eventTypePrefix=void 0;if(topLevelType===TOP_MOUSE_OUT||topLevelType===TOP_MOUSE_OVER){eventInterface=SyntheticMouseEvent;leaveEventType=eventTypes$2.mouseLeave;enterEventType=eventTypes$2.mouseEnter;eventTypePrefix='mouse';}else if(topLevelType===TOP_POINTER_OUT||topLevelType===TOP_POINTER_OVER){eventInterface=SyntheticPointerEvent;leaveEventType=eventTypes$2.pointerLeave;enterEventType=eventTypes$2.pointerEnter;eventTypePrefix='pointer';}var fromNode=from==null?win:getNodeFromInstance$1(from);var toNode=to==null?win:getNodeFromInstance$1(to);var leave=eventInterface.getPooled(leaveEventType,from,nativeEvent,nativeEventTarget);leave.type=eventTypePrefix+'leave';leave.target=fromNode;leave.relatedTarget=toNode;var enter=eventInterface.getPooled(enterEventType,to,nativeEvent,nativeEventTarget);enter.type=eventTypePrefix+'enter';enter.target=toNode;enter.relatedTarget=fromNode;accumulateEnterLeaveDispatches(leave,enter,from,to);return[leave,enter];}};/*eslint-disable no-self-compare */var hasOwnProperty$1=Object.prototype.hasOwnProperty;/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */function is(x,y){// SameValue algorithm
if(x===y){// Steps 1-5, 7-10
// Steps 6.b-6.e: +0 != -0
// Added the nonzero y check to make Flow happy, but it is redundant
return x!==0||y!==0||1/x===1/y;}else{// Step 6.a: NaN == NaN
return x!==x&&y!==y;}}/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */function shallowEqual(objA,objB){if(is(objA,objB)){return true;}if((typeof objA==='undefined'?'undefined':_typeof(objA))!=='object'||objA===null||(typeof objB==='undefined'?'undefined':_typeof(objB))!=='object'||objB===null){return false;}var keysA=Object.keys(objA);var keysB=Object.keys(objB);if(keysA.length!==keysB.length){return false;}// Test for A's keys different from B.
for(var i=0;i<keysA.length;i++){if(!hasOwnProperty$1.call(objB,keysA[i])||!is(objA[keysA[i]],objB[keysA[i]])){return false;}}return true;}/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 *//**
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 */function get(key){return key._reactInternalFiber;}function has(key){return key._reactInternalFiber!==undefined;}function set(key,value){key._reactInternalFiber=value;}// Don't change these two values. They're used by React Dev Tools.
var NoEffect=/*              */0;var PerformedWork=/*         */1;// You can change the rest (and add more).
var Placement=/*             */2;var Update=/*                */4;var PlacementAndUpdate=/*    */6;var Deletion=/*              */8;var ContentReset=/*          */16;var Callback=/*              */32;var DidCapture=/*            */64;var Ref=/*                   */128;var Snapshot=/*              */256;// Update & Callback & Ref & Snapshot
var LifecycleEffectMask=/*   */420;// Union of all host effects
var HostEffectMask=/*        */511;var Incomplete=/*            */512;var ShouldCapture=/*         */1024;var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner;var MOUNTING=1;var MOUNTED=2;var UNMOUNTED=3;function isFiberMountedImpl(fiber){var node=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted
// yet. If it is, then it will have a pending insertion effect on it.
if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}while(node.return){node=node.return;if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}}}else{while(node.return){node=node.return;}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with
// renderContainerIntoSubtree.
return MOUNTED;}// If we didn't hit the root, that means that we're in an disconnected tree
// that has been unmounted.
return UNMOUNTED;}function isFiberMounted(fiber){return isFiberMountedImpl(fiber)===MOUNTED;}function isMounted(component){{var owner=ReactCurrentOwner$1.current;if(owner!==null&&(owner.tag===ClassComponent||owner.tag===ClassComponentLazy)){var ownerFiber=owner;var instance=ownerFiber.stateNode;!instance._warnedAboutRefsInRender?warningWithoutStack$1(false,'%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(ownerFiber.type)||'A component'):void 0;instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return isFiberMountedImpl(fiber)===MOUNTED;}function assertIsMounted(fiber){!(isFiberMountedImpl(fiber)===MOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.
var state=isFiberMountedImpl(fiber);!(state!==UNMOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(state===MOUNTING){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root
// to see what path the root points to. On the way we may hit one of the
// special cases and we'll deal with them.
var a=fiber;var b=alternate;while(true){var parentA=a.return;var parentB=parentA?parentA.alternate:null;if(!parentA||!parentB){// We're at the root.
break;}// If both copies of the parent fiber point to the same child, we can
// assume that the child is current. This happens when we bailout on low
// priority: the bailed out fiber's child reuses the current child.
if(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.
assertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.
assertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only
// way this could possibly happen is if this was unmounted, if at all.
invariant(false,'Unable to find node on an unmounted component.');}if(a.return!==b.return){// The return pointer of A and the return pointer of B point to different
// fibers. We assume that return pointers never criss-cross, so A must
// belong to the child set of A.return, and B must belong to the child
// set of B.return.
a=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the
// default, slow path: scan the child sets of each parent alternate to see
// which child belongs to which set.
//
// Search parent A's child set
var didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set
_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}!didFindChild?invariant(false,'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.'):void 0;}}!(a.alternate===b)?invariant(false,'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.'):void 0;}// If the root is not a host container, we're in a disconnected tree. I.e.
// unmounted.
!(a.tag===HostRoot)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(a.stateNode.current===a){// We've determined that A is the current branch.
return fiber;}// Otherwise B has to be current branch.
return alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child){node.child.return=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node.return||node.return===currentParent){return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child&&node.tag!==HostPortal){node.child.return=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node.return||node.return===currentParent){return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}function addEventBubbleListener(element,eventType,listener){element.addEventListener(eventType,listener,false);}function addEventCaptureListener(element,eventType,listener){element.addEventListener(eventType,listener,true);}/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */var SyntheticAnimationEvent=SyntheticEvent.extend({animationName:null,elapsedTime:null,pseudoElement:null});/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */var SyntheticClipboardEvent=SyntheticEvent.extend({clipboardData:function clipboardData(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}});/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var SyntheticFocusEvent=SyntheticUIEvent.extend({relatedTarget:null});/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */function getEventCharCode(nativeEvent){var charCode=void 0;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.
if(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.
charCode=keyCode;}// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)
// report Enter as charCode 10 when ctrl is pressed.
if(charCode===10){charCode=13;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
// Must not discard the (non-)printable Enter-key.
if(charCode>=32||charCode===13){return charCode;}return 0;}/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to
// implementations of a working draft specification.
// FireFox implements `key` but returns `MozPrintableKey` for all
// printable characters (normalized to `Unidentified`), ignore it.
var key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.
if(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can
// thus be captured by `keypress`, no other non-printable key should.
return charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each
// `keyCode` value, almost all function keys have a universal value.
return translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var SyntheticKeyboardEvent=SyntheticUIEvent.extend({key:getEventKey,location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:getEventModifierState,// Legacy Interface
charCode:function charCode(event){// `charCode` is the result of a KeyPress event and represents the value of
// the actual printable character.
// KeyPress is deprecated, but its replacement is not yet final and not
// implemented in any major browser. Only KeyPress has charCode.
if(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function keyCode(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of
// physical keyboard key.
// The actual meaning of the value depends on the users' keyboard layout
// which cannot be detected. Assuming that it is a US keyboard layout
// provides a surprisingly accurate mapping for US and European users.
// Due to this, it is left to the user to implement at this time.
if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function which(event){// `which` is an alias for either `keyCode` or `charCode` depending on the
// type of the event.
if(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}});/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var SyntheticDragEvent=SyntheticMouseEvent.extend({dataTransfer:null});/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */var SyntheticTouchEvent=SyntheticUIEvent.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:getEventModifierState});/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */var SyntheticTransitionEvent=SyntheticEvent.extend({propertyName:null,elapsedTime:null,pseudoElement:null});/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var SyntheticWheelEvent=SyntheticMouseEvent.extend({deltaX:function deltaX(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function deltaY(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:null,// Browsers without "deltaMode" is reporting in raw wheel delta where one
// notch on the scroll is always +/- 120, roughly equivalent to pixels.
// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
deltaMode:null});/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: [TOP_ABORT],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = new Map([
 *   [TOP_ABORT, { sameConfig }],
 * ]);
 */var interactiveEventTypeNames=[[TOP_BLUR,'blur'],[TOP_CANCEL,'cancel'],[TOP_CLICK,'click'],[TOP_CLOSE,'close'],[TOP_CONTEXT_MENU,'contextMenu'],[TOP_COPY,'copy'],[TOP_CUT,'cut'],[TOP_AUX_CLICK,'auxClick'],[TOP_DOUBLE_CLICK,'doubleClick'],[TOP_DRAG_END,'dragEnd'],[TOP_DRAG_START,'dragStart'],[TOP_DROP,'drop'],[TOP_FOCUS,'focus'],[TOP_INPUT,'input'],[TOP_INVALID,'invalid'],[TOP_KEY_DOWN,'keyDown'],[TOP_KEY_PRESS,'keyPress'],[TOP_KEY_UP,'keyUp'],[TOP_MOUSE_DOWN,'mouseDown'],[TOP_MOUSE_UP,'mouseUp'],[TOP_PASTE,'paste'],[TOP_PAUSE,'pause'],[TOP_PLAY,'play'],[TOP_POINTER_CANCEL,'pointerCancel'],[TOP_POINTER_DOWN,'pointerDown'],[TOP_POINTER_UP,'pointerUp'],[TOP_RATE_CHANGE,'rateChange'],[TOP_RESET,'reset'],[TOP_SEEKED,'seeked'],[TOP_SUBMIT,'submit'],[TOP_TOUCH_CANCEL,'touchCancel'],[TOP_TOUCH_END,'touchEnd'],[TOP_TOUCH_START,'touchStart'],[TOP_VOLUME_CHANGE,'volumeChange']];var nonInteractiveEventTypeNames=[[TOP_ABORT,'abort'],[TOP_ANIMATION_END,'animationEnd'],[TOP_ANIMATION_ITERATION,'animationIteration'],[TOP_ANIMATION_START,'animationStart'],[TOP_CAN_PLAY,'canPlay'],[TOP_CAN_PLAY_THROUGH,'canPlayThrough'],[TOP_DRAG,'drag'],[TOP_DRAG_ENTER,'dragEnter'],[TOP_DRAG_EXIT,'dragExit'],[TOP_DRAG_LEAVE,'dragLeave'],[TOP_DRAG_OVER,'dragOver'],[TOP_DURATION_CHANGE,'durationChange'],[TOP_EMPTIED,'emptied'],[TOP_ENCRYPTED,'encrypted'],[TOP_ENDED,'ended'],[TOP_ERROR,'error'],[TOP_GOT_POINTER_CAPTURE,'gotPointerCapture'],[TOP_LOAD,'load'],[TOP_LOADED_DATA,'loadedData'],[TOP_LOADED_METADATA,'loadedMetadata'],[TOP_LOAD_START,'loadStart'],[TOP_LOST_POINTER_CAPTURE,'lostPointerCapture'],[TOP_MOUSE_MOVE,'mouseMove'],[TOP_MOUSE_OUT,'mouseOut'],[TOP_MOUSE_OVER,'mouseOver'],[TOP_PLAYING,'playing'],[TOP_POINTER_MOVE,'pointerMove'],[TOP_POINTER_OUT,'pointerOut'],[TOP_POINTER_OVER,'pointerOver'],[TOP_PROGRESS,'progress'],[TOP_SCROLL,'scroll'],[TOP_SEEKING,'seeking'],[TOP_STALLED,'stalled'],[TOP_SUSPEND,'suspend'],[TOP_TIME_UPDATE,'timeUpdate'],[TOP_TOGGLE,'toggle'],[TOP_TOUCH_MOVE,'touchMove'],[TOP_TRANSITION_END,'transitionEnd'],[TOP_WAITING,'waiting'],[TOP_WHEEL,'wheel']];var eventTypes$4={};var topLevelEventsToDispatchConfig={};function addEventTypeNameToConfig(_ref,isInteractive){var topEvent=_ref[0],event=_ref[1];var capitalizedEvent=event[0].toUpperCase()+event.slice(1);var onEvent='on'+capitalizedEvent;var type={phasedRegistrationNames:{bubbled:onEvent,captured:onEvent+'Capture'},dependencies:[topEvent],isInteractive:isInteractive};eventTypes$4[event]=type;topLevelEventsToDispatchConfig[topEvent]=type;}interactiveEventTypeNames.forEach(function(eventTuple){addEventTypeNameToConfig(eventTuple,true);});nonInteractiveEventTypeNames.forEach(function(eventTuple){addEventTypeNameToConfig(eventTuple,false);});// Only used in DEV for exhaustiveness validation.
var knownHTMLTopLevelTypes=[TOP_ABORT,TOP_CANCEL,TOP_CAN_PLAY,TOP_CAN_PLAY_THROUGH,TOP_CLOSE,TOP_DURATION_CHANGE,TOP_EMPTIED,TOP_ENCRYPTED,TOP_ENDED,TOP_ERROR,TOP_INPUT,TOP_INVALID,TOP_LOAD,TOP_LOADED_DATA,TOP_LOADED_METADATA,TOP_LOAD_START,TOP_PAUSE,TOP_PLAY,TOP_PLAYING,TOP_PROGRESS,TOP_RATE_CHANGE,TOP_RESET,TOP_SEEKED,TOP_SEEKING,TOP_STALLED,TOP_SUBMIT,TOP_SUSPEND,TOP_TIME_UPDATE,TOP_TOGGLE,TOP_VOLUME_CHANGE,TOP_WAITING];var SimpleEventPlugin={eventTypes:eventTypes$4,isInteractiveTopLevelEventType:function isInteractiveTopLevelEventType(topLevelType){var config=topLevelEventsToDispatchConfig[topLevelType];return config!==undefined&&config.isInteractive===true;},extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var dispatchConfig=topLevelEventsToDispatchConfig[topLevelType];if(!dispatchConfig){return null;}var EventConstructor=void 0;switch(topLevelType){case TOP_KEY_PRESS:// Firefox creates a keypress event for function keys too. This removes
// the unwanted keypress events. Enter is however both printable and
// non-printable. One would expect Tab to be as well (but it isn't).
if(getEventCharCode(nativeEvent)===0){return null;}/* falls through */case TOP_KEY_DOWN:case TOP_KEY_UP:EventConstructor=SyntheticKeyboardEvent;break;case TOP_BLUR:case TOP_FOCUS:EventConstructor=SyntheticFocusEvent;break;case TOP_CLICK:// Firefox creates a click event on right mouse clicks. This removes the
// unwanted click events.
if(nativeEvent.button===2){return null;}/* falls through */case TOP_AUX_CLICK:case TOP_DOUBLE_CLICK:case TOP_MOUSE_DOWN:case TOP_MOUSE_MOVE:case TOP_MOUSE_UP:// TODO: Disabled elements should not respond to mouse events
/* falls through */case TOP_MOUSE_OUT:case TOP_MOUSE_OVER:case TOP_CONTEXT_MENU:EventConstructor=SyntheticMouseEvent;break;case TOP_DRAG:case TOP_DRAG_END:case TOP_DRAG_ENTER:case TOP_DRAG_EXIT:case TOP_DRAG_LEAVE:case TOP_DRAG_OVER:case TOP_DRAG_START:case TOP_DROP:EventConstructor=SyntheticDragEvent;break;case TOP_TOUCH_CANCEL:case TOP_TOUCH_END:case TOP_TOUCH_MOVE:case TOP_TOUCH_START:EventConstructor=SyntheticTouchEvent;break;case TOP_ANIMATION_END:case TOP_ANIMATION_ITERATION:case TOP_ANIMATION_START:EventConstructor=SyntheticAnimationEvent;break;case TOP_TRANSITION_END:EventConstructor=SyntheticTransitionEvent;break;case TOP_SCROLL:EventConstructor=SyntheticUIEvent;break;case TOP_WHEEL:EventConstructor=SyntheticWheelEvent;break;case TOP_COPY:case TOP_CUT:case TOP_PASTE:EventConstructor=SyntheticClipboardEvent;break;case TOP_GOT_POINTER_CAPTURE:case TOP_LOST_POINTER_CAPTURE:case TOP_POINTER_CANCEL:case TOP_POINTER_DOWN:case TOP_POINTER_MOVE:case TOP_POINTER_OUT:case TOP_POINTER_OVER:case TOP_POINTER_UP:EventConstructor=SyntheticPointerEvent;break;default:{if(knownHTMLTopLevelTypes.indexOf(topLevelType)===-1){warningWithoutStack$1(false,'SimpleEventPlugin: Unhandled event type, `%s`. This warning '+'is likely caused by a bug in React. Please file an issue.',topLevelType);}}// HTML Events
// @see http://www.w3.org/TR/html5/index.html#events-0
EventConstructor=SyntheticEvent;break;}var event=EventConstructor.getPooled(dispatchConfig,targetInst,nativeEvent,nativeEventTarget);accumulateTwoPhaseDispatches(event);return event;}};var isInteractiveTopLevelEventType=SimpleEventPlugin.isInteractiveTopLevelEventType;var CALLBACK_BOOKKEEPING_POOL_SIZE=10;var callbackBookkeepingPool=[];/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */function findRootContainerNode(inst){// TODO: It may be a good idea to cache this to prevent unnecessary DOM
// traversal, but caching is difficult to do correctly without using a
// mutation observer to listen for all DOM changes.
while(inst.return){inst=inst.return;}if(inst.tag!==HostRoot){// This can happen if we're in a detached tree.
return null;}return inst.stateNode.containerInfo;}// Used to store ancestor hierarchy in top level callback
function getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst){if(callbackBookkeepingPool.length){var instance=callbackBookkeepingPool.pop();instance.topLevelType=topLevelType;instance.nativeEvent=nativeEvent;instance.targetInst=targetInst;return instance;}return{topLevelType:topLevelType,nativeEvent:nativeEvent,targetInst:targetInst,ancestors:[]};}function releaseTopLevelCallbackBookKeeping(instance){instance.topLevelType=null;instance.nativeEvent=null;instance.targetInst=null;instance.ancestors.length=0;if(callbackBookkeepingPool.length<CALLBACK_BOOKKEEPING_POOL_SIZE){callbackBookkeepingPool.push(instance);}}function handleTopLevel(bookKeeping){var targetInst=bookKeeping.targetInst;// Loop through the hierarchy, in case there's any nested components.
// It's important that we build the array of ancestors before calling any
// event handlers, because event handlers can modify the DOM, leading to
// inconsistencies with ReactMount's node cache. See #1105.
var ancestor=targetInst;do{if(!ancestor){bookKeeping.ancestors.push(ancestor);break;}var root=findRootContainerNode(ancestor);if(!root){break;}bookKeeping.ancestors.push(ancestor);ancestor=getClosestInstanceFromNode(root);}while(ancestor);for(var i=0;i<bookKeeping.ancestors.length;i++){targetInst=bookKeeping.ancestors[i];runExtractedEventsInBatch(bookKeeping.topLevelType,targetInst,bookKeeping.nativeEvent,getEventTarget(bookKeeping.nativeEvent));}}// TODO: can we stop exporting these?
var _enabled=true;function setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}/**
 * Traps top-level events by using event bubbling.
 *
 * @param {number} topLevelType Number from `TopLevelEventTypes`.
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */function trapBubbledEvent(topLevelType,element){if(!element){return null;}var dispatch=isInteractiveTopLevelEventType(topLevelType)?dispatchInteractiveEvent:dispatchEvent;addEventBubbleListener(element,getRawEventName(topLevelType),// Check if interactive and wrap in interactiveUpdates
dispatch.bind(null,topLevelType));}/**
 * Traps a top-level event by using event capturing.
 *
 * @param {number} topLevelType Number from `TopLevelEventTypes`.
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */function trapCapturedEvent(topLevelType,element){if(!element){return null;}var dispatch=isInteractiveTopLevelEventType(topLevelType)?dispatchInteractiveEvent:dispatchEvent;addEventCaptureListener(element,getRawEventName(topLevelType),// Check if interactive and wrap in interactiveUpdates
dispatch.bind(null,topLevelType));}function dispatchInteractiveEvent(topLevelType,nativeEvent){interactiveUpdates(dispatchEvent,topLevelType,nativeEvent);}function dispatchEvent(topLevelType,nativeEvent){if(!_enabled){return;}var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null&&typeof targetInst.tag==='number'&&!isFiberMounted(targetInst)){// If we get an event (ex: img onload) before committing that
// component's mount, ignore it for now (that is, treat it as if it was an
// event on a non-React tree). We might also consider queueing events and
// dispatching them after the mount.
targetInst=null;}var bookKeeping=getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst);try{// Event queue being processed in the same cycle allows
// `preventDefault`.
batchedUpdates(handleTopLevel,bookKeeping);}finally{releaseTopLevelCallbackBookKeeping(bookKeeping);}}/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactDOMEventListener, which is injected and can therefore support
 *    pluggable event sources. This is the only work that occurs in the main
 *    thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */var alreadyListeningTo={};var reactTopListenersCounter=0;/**
 * To ensure no conflicts with other potential React instances on the page
 */var topListenersIDKey='_reactListenersID'+(''+Math.random()).slice(2);function getListeningForDocument(mountAt){// In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
// directly.
if(!Object.prototype.hasOwnProperty.call(mountAt,topListenersIDKey)){mountAt[topListenersIDKey]=reactTopListenersCounter++;alreadyListeningTo[mountAt[topListenersIDKey]]={};}return alreadyListeningTo[mountAt[topListenersIDKey]];}/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
 * element. The symptoms were that if your mouse is not moving over something
 * contained within that mount point (for example on the background) the
 * top-level listeners for `onmousemove` won't be called. However, if you
 * register the `mousemove` on the document object, then it will of course
 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
 * top-level listeners to the document object only, at least for these
 * movement types of events and possibly all events.
 *
 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
 *
 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
 * they bubble to document.
 *
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @param {object} mountAt Container where to mount the listener
 */function listenTo(registrationName,mountAt){var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){switch(dependency){case TOP_SCROLL:trapCapturedEvent(TOP_SCROLL,mountAt);break;case TOP_FOCUS:case TOP_BLUR:trapCapturedEvent(TOP_FOCUS,mountAt);trapCapturedEvent(TOP_BLUR,mountAt);// We set the flag for a single dependency later in this function,
// but this ensures we mark both as attached rather than just one.
isListening[TOP_BLUR]=true;isListening[TOP_FOCUS]=true;break;case TOP_CANCEL:case TOP_CLOSE:if(isEventSupported(getRawEventName(dependency))){trapCapturedEvent(dependency,mountAt);}break;case TOP_INVALID:case TOP_SUBMIT:case TOP_RESET:// We listen to them on the target DOM elements.
// Some of them bubble so we don't want them to fire twice.
break;default:// By default, listen on the top level to all non-media events.
// Media events don't bubble so adding the listener wouldn't do anything.
var isMediaEvent=mediaEventTypes.indexOf(dependency)!==-1;if(!isMediaEvent){trapBubbledEvent(dependency,mountAt);}break;}isListening[dependency]=true;}}}function isListeningToAllDependencies(registrationName,mountAt){var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){return false;}}return true;}function getActiveElement(doc){doc=doc||(typeof document!=='undefined'?document:undefined);if(typeof doc==='undefined'){return null;}try{return doc.activeElement||doc.body;}catch(e){return doc.body;}}/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */function getOffsets(outerNode){var ownerDocument=outerNode.ownerDocument;var win=ownerDocument&&ownerDocument.defaultView||window;var selection=win.getSelection&&win.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
// up/down buttons on an <input type="number">. Anonymous divs do not seem to
// expose properties, triggering a "Permission denied error" if any of its
// properties are accessed. The only seemingly possible way to avoid erroring
// is to access a property that typically works for non-anonymous divs and
// catch any error that may otherwise arise. See
// https://bugzilla.mozilla.org/show_bug.cgi?id=208427
try{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset);}/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.
parentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting
// it. If it has no children, this is still the first loop, and the only
// valid selection is anchorNode and focusNode both equal to this node
// and both offsets 0, in which case we will have handled above.
break outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.
node=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't
// actually inside the passed-in node.)
return null;}return{start:start,end:end};}/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */function setOffsets(node,offsets){var doc=node.ownerDocument||document;var win=doc&&doc.defaultView||window;var selection=win.getSelection();var length=node.textContent.length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.
// Flip backward selections, so we can set with a single range.
if(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=doc.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isTextNode(node){return node&&node.nodeType===TEXT_NODE;}function containsNode(outerNode,innerNode){if(!outerNode||!innerNode){return false;}else if(outerNode===innerNode){return true;}else if(isTextNode(outerNode)){return false;}else if(isTextNode(innerNode)){return containsNode(outerNode,innerNode.parentNode);}else if('contains'in outerNode){return outerNode.contains(innerNode);}else if(outerNode.compareDocumentPosition){return!!(outerNode.compareDocumentPosition(innerNode)&16);}else{return false;}}function isInDocument(node){return node&&node.ownerDocument&&containsNode(node.ownerDocument.documentElement,node);}function getActiveElementDeep(){var win=window;var element=getActiveElement();while(element instanceof win.HTMLIFrameElement){// Accessing the contentDocument of a HTMLIframeElement can cause the browser
// to throw, e.g. if it has a cross-origin src attribute
try{win=element.contentDocument.defaultView;}catch(e){return element;}element=getActiveElement(win.document);}return element;}/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 *//**
 * @hasSelectionCapabilities: we get the element types that support selection
 * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`
 * and `selectionEnd` rows.
 */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&(elem.type==='text'||elem.type==='search'||elem.type==='tel'||elem.type==='url'||elem.type==='password')||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElementDeep();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection$1(focusedElem):null};}/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElementDeep();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(priorSelectionRange!==null&&hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable
var ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}if(typeof priorFocusedElem.focus==='function'){priorFocusedElem.focus();}for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */function getSelection$1(input){var selection=void 0;if('selectionStart'in input){// Modern browser with input or textarea.
selection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.
selection=getOffsets(input);}return selection||{start:0,end:0};}/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */function setSelection(input,offsets){var start=offsets.start,end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=canUseDOM&&'documentMode'in document&&document.documentMode<=11;var eventTypes$3={select:{phasedRegistrationNames:{bubbled:'onSelect',captured:'onSelectCapture'},dependencies:[TOP_BLUR,TOP_CONTEXT_MENU,TOP_DRAG_END,TOP_FOCUS,TOP_KEY_DOWN,TOP_KEY_UP,TOP_MOUSE_DOWN,TOP_MOUSE_UP,TOP_SELECTION_CHANGE]}};var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */function getSelection(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else{var win=node.ownerDocument&&node.ownerDocument.defaultView||window;var selection=win.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**
 * Get document associated with the event target.
 *
 * @param {object} nativeEventTarget
 * @return {Document}
 */function getEventTargetDocument(eventTarget){return eventTarget.window===eventTarget?eventTarget.document:eventTarget.nodeType===DOCUMENT_NODE?eventTarget:eventTarget.ownerDocument;}/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @param {object} nativeEventTarget
 * @return {?SyntheticEvent}
 */function constructSelectEvent(nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a
// selection (this matches native `select` event behavior). In HTML5, select
// fires only on input and textarea thus if there's no focused element we
// won't dispatch.
var doc=getEventTargetDocument(nativeEventTarget);if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement(doc)){return null;}// Only fire when selection has actually changed.
var currentSelection=getSelection(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var syntheticEvent=SyntheticEvent.getPooled(eventTypes$3.select,activeElementInst$1,nativeEvent,nativeEventTarget);syntheticEvent.type='select';syntheticEvent.target=activeElement$1;accumulateTwoPhaseDispatches(syntheticEvent);return syntheticEvent;}return null;}/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */var SelectEventPlugin={eventTypes:eventTypes$3,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var doc=getEventTargetDocument(nativeEventTarget);// Track whether all listeners exists for this plugin. If none exist, we do
// not extract events. See #3639.
if(!doc||!isListeningToAllDependencies('onSelect',doc)){return null;}var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;switch(topLevelType){// Track the input node that has focus.
case TOP_FOCUS:if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case TOP_BLUR:activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the
// semantics of the native select event.
case TOP_MOUSE_DOWN:mouseDown=true;break;case TOP_CONTEXT_MENU:case TOP_MOUSE_UP:case TOP_DRAG_END:mouseDown=false;return constructSelectEvent(nativeEvent,nativeEventTarget);// Chrome and IE fire non-standard event when selection is changed (and
// sometimes when it hasn't). IE's event fires out of order with respect
// to key and input events on deletion, so we discard it.
//
// Firefox doesn't support selectionchange, so check selection status
// after each key entry. The selection changes after keydown and before
// keyup, but we check on keydown as well in the case of holding down a
// key, when multiple keydown events are fired but only one keyup is.
// This is also our approach for IE handling, for the reason above.
case TOP_SELECTION_CHANGE:if(skipSelectionChangeEvent){break;}// falls through
case TOP_KEY_DOWN:case TOP_KEY_UP:return constructSelectEvent(nativeEvent,nativeEventTarget);}return null;}};/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */injection.injectEventPluginOrder(DOMEventPluginOrder);setComponentTree(getFiberCurrentPropsFromNode$1,getInstanceFromNode$1,getNodeFromInstance$1);/**
 * Some important event plugins included by default (without having to require
 * them).
 */injection.injectEventPluginsByName({SimpleEventPlugin:SimpleEventPlugin,EnterLeaveEventPlugin:EnterLeaveEventPlugin,ChangeEventPlugin:ChangeEventPlugin,SelectEventPlugin:SelectEventPlugin,BeforeInputEventPlugin:BeforeInputEventPlugin});var didWarnSelectedSetOnOption=false;var didWarnInvalidChild=false;function flattenChildren(children){var content='';// Flatten children. We'll warn if they are invalid
// during validateProps() which runs for hydration too.
// Note that this would throw on non-element objects.
// Elements are stringified (which is normally irrelevant
// but matters for <fbt>).
React.Children.forEach(children,function(child){if(child==null){return;}content+=child;// Note: we don't warn about invalid children here.
// Instead, this is done separately below so that
// it happens during the hydration codepath too.
});return content;}/**
 * Implements an <option> host component that warns when `selected` is set.
 */function validateProps(element,props){{// This mirrors the codepath above, but runs for hydration too.
// Warn about invalid children here so that client and hydration are consistent.
// TODO: this seems like it could cause a DEV-only throw for hydration
// if children contains a non-element object. We should try to avoid that.
if(_typeof(props.children)==='object'&&props.children!==null){React.Children.forEach(props.children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){return;}if(typeof child.type!=='string'){return;}if(!didWarnInvalidChild){didWarnInvalidChild=true;warning$1(false,'Only strings and numbers are supported as <option> children.');}});}// TODO: Remove support for `selected` in <option>.
if(props.selected!=null&&!didWarnSelectedSetOnOption){warning$1(false,'Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');didWarnSelectedSetOnOption=true;}}}function postMountWrapper$1(element,props){// value="" should make a value attribute (#6219)
if(props.value!=null){element.setAttribute('value',toString(getToStringValue(props.value)));}}function getHostProps$1(element,props){var hostProps=_assign({children:undefined},props);var content=flattenChildren(props.children);if(content){hostProps.children=content;}return hostProps;}// TODO: direct imports like some-package/src/* are bad. Fix me.
var didWarnValueDefaultValue$1=void 0;{didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){return'\n\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**
 * Validation function for `value` and `defaultValue`.
 */function checkSelectPropTypes(props){ReactControlledValuePropTypes.checkPropTypes('select',props);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var isArray=Array.isArray(props[propName]);if(props.multiple&&!isArray){warning$1(false,'The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&isArray){warning$1(false,'The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.
selectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all
// browsers for all cases.
var _selectedValue=toString(getToStringValue(propValue));var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */function getHostProps$2(element,props){return _assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}node._wrapperState={wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){warning$1(false,'Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.
if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.
updateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$2(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}var didWarnValDefaultVal=false;/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */function getHostProps$3(element,props){var node=element;!(props.dangerouslySetInnerHTML==null)?invariant(false,'`dangerouslySetInnerHTML` does not make sense on <textarea>.'):void 0;// Always set children to the same thing. In IE9, the selection range will
// get reset if `textContent` is mutated.  We could add a check in setTextContent
// to only set the value if/when the value differs from the node value (which would
// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
// solution. The value can be a boolean or object so that's why it's forced
// to be a string.
var hostProps=_assign({},props,{value:undefined,defaultValue:undefined,children:toString(node._wrapperState.initialValue)});return hostProps;}function initWrapperState$2(element,props){var node=element;{ReactControlledValuePropTypes.checkPropTypes('textarea',props);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){warning$1(false,'%s contains a textarea with both value and defaultValue props. '+'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it
if(initialValue==null){var defaultValue=props.defaultValue;// TODO (yungsters): Remove support for children content in <textarea>.
var children=props.children;if(children!=null){{warning$1(false,'Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}!(defaultValue==null)?invariant(false,'If you supply `defaultValue` on a <textarea>, do not pass children.'):void 0;if(Array.isArray(children)){!(children.length<=1)?invariant(false,'<textarea> can only have at most one child.'):void 0;children=children[0];}defaultValue=children;}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:getToStringValue(initialValue)};}function updateWrapper$1(element,props){var node=element;var value=getToStringValue(props.value);var defaultValue=getToStringValue(props.defaultValue);if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
var newValue=toString(value);// To avoid side effects (such as losing text selection), only set value if changed
if(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null&&node.defaultValue!==newValue){node.defaultValue=newValue;}}if(defaultValue!=null){node.defaultValue=toString(defaultValue);}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not
// available until after the component has mounted.
var textContent=node.textContent;// Only set node.value if textContent is equal to the expected
// initial value. In IE10/IE11 there is a bug where the placeholder attribute
// will populate textContent as well.
// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
if(textContent===node._wrapperState.initialValue){node.value=textContent;}}function restoreControlledState$3(element,props){// DOM component is still mounted; update
updateWrapper$1(element,props);}var HTML_NAMESPACE$1='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';var Namespaces={html:HTML_NAMESPACE$1,mathml:MATH_NAMESPACE,svg:SVG_NAMESPACE};// Assumes there is no parent namespace.
function getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE$1;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE$1){// No (or default) parent namespace: potential entry point.
return getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.
return HTML_NAMESPACE$1;}// By default, pass namespace below.
return parentNamespace;}/* globals MSApp *//**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */var createMicrosoftUnsafeLocalFunction=function createMicrosoftUnsafeLocalFunction(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};// SVG temp container for IE lacking innerHTML
var reusableSVGContainer=void 0;/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){// IE does not have innerHTML for SVG nodes, so instead we inject the
// new markup in a temp node and then move the child nodes across into
// the target node
if(node.namespaceURI===Namespaces.svg&&!('innerHTML'in node)){reusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}}else{node.innerHTML=html;}});/**
 * Set the textContent property of a node. For text updates, it's faster
 * to set the `nodeValue` of the Text node directly instead of using
 * `.textContent` which will remove the existing node and create a new one.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */var setTextContent=function setTextContent(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};/**
 * CSS properties which accept numbers but are not in units of "px".
 */var isUnitlessNumber={animationIterationCount:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridArea:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties
fillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the
// whole string will be escaped when the attribute is injected into
// the markup. If you provide unsafe user data here they can inject
// arbitrary CSS which may be problematic (I couldn't repro this):
// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
// This is not an XSS hole but instead a potential CSS injection issue
// which has lead to a greater discussion about how we're going to
// trust URLs moving forward. See #2115901
var isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers
}return(''+value).trim();}var uppercasePattern=/([A-Z])/g;var msPattern=/^ms-/;/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */function hyphenateStyleName(name){return name.replace(uppercasePattern,'-$1').toLowerCase().replace(msPattern,'-ms-');}var warnValidStyle=function warnValidStyle(){};{// 'msTransform' is correct, but the other prefixes should be capitalized
var badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;var msPattern$1=/^-ms-/;var hyphenPattern=/-(.)/g;// style values shouldn't contain a semicolon
var badStyleValueWithSemicolonPattern=/;\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var camelize=function camelize(string){return string.replace(hyphenPattern,function(_,character){return character.toUpperCase();});};var warnHyphenatedStyleName=function warnHyphenatedStyleName(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning$1(false,'Unsupported style property %s. Did you mean %s?',name,// As Andi Smith suggests
// (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
// is converted to lowercase `ms`.
camelize(name.replace(msPattern$1,'ms-')));};var warnBadVendoredStyleName=function warnBadVendoredStyleName(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning$1(false,'Unsupported vendor-prefixed style property %s. Did you mean %s?',name,name.charAt(0).toUpperCase()+name.slice(1));};var warnStyleValueWithSemicolon=function warnStyleValueWithSemicolon(name,value){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;warning$1(false,"Style property values shouldn't contain a semicolon. "+'Try "%s: %s" instead.',name,value.replace(badStyleValueWithSemicolonPattern,''));};var warnStyleValueIsNaN=function warnStyleValueIsNaN(name,value){if(warnedForNaNValue){return;}warnedForNaNValue=true;warning$1(false,'`NaN` is an invalid value for the `%s` css style property.',name);};var warnStyleValueIsInfinity=function warnStyleValueIsInfinity(name,value){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;warning$1(false,'`Infinity` is an invalid value for the `%s` css style property.',name);};warnValidStyle=function warnValidStyle(name,value){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value);}}};}var warnValidStyle$1=warnValidStyle;/**
 * Operations for dealing with CSS properties.
 *//**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+hyphenateStyleName(styleName)+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */function setValueForStyles(node,styles){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName]);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.
var omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true// NOTE: menuitem's close tag should be omitted, but that causes problems.
};// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.
var voidElementTags=_assign({menuitem:true},omittedCloseTags);// TODO: We can remove this if we add invariantWithStack()
// or add stack by default to invariants where possible.
var HTML$1='__html';var ReactDebugCurrentFrame$2=null;{ReactDebugCurrentFrame$2=ReactSharedInternals.ReactDebugCurrentFrame;}function assertValidProps(tag,props){if(!props){return;}// Note the use of `==` which checks for null or undefined.
if(voidElementTags[tag]){!(props.children==null&&props.dangerouslySetInnerHTML==null)?invariant(false,'%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s',tag,ReactDebugCurrentFrame$2.getStackAddendum()):void 0;}if(props.dangerouslySetInnerHTML!=null){!(props.children==null)?invariant(false,'Can only set one of `children` or `props.dangerouslySetInnerHTML`.'):void 0;!(_typeof(props.dangerouslySetInnerHTML)==='object'&&HTML$1 in props.dangerouslySetInnerHTML)?invariant(false,'`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.'):void 0;}{!(props.suppressContentEditableWarning||!props.contentEditable||props.children==null)?warning$1(false,'A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.'):void 0;}!(props.style==null||_typeof(props.style)==='object')?invariant(false,'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s',ReactDebugCurrentFrame$2.getStackAddendum()):void 0;}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.
// We don't mind this whitelist too much because we expect it to never grow.
// The alternative is to track the namespace in a few places which is convoluted.
// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
case'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames={// HTML
accept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite',class:'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime',default:'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',download:'download',draggable:'draggable',enctype:'encType',for:'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nomodule:'noModule',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG
about:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2',in:'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform',typeof:'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};var ariaProperties={'aria-current':0,// state
'aria-details':0,'aria-disabled':0,// state
'aria-hidden':0,// state
'aria-invalid':0,// state
'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes
'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes
'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes
'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes
'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var hasOwnProperty$2=Object.prototype.hasOwnProperty;function validateProperty(tagName,name){if(hasOwnProperty$2.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(correctName==null){warning$1(false,'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',name);warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==correctName){warning$1(false,'Invalid ARIA attribute `%s`. Did you mean `%s`?',name,correctName);warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==standardName){warning$1(false,'Unknown ARIA attribute `%s`. Did you mean `%s`?',name,standardName);warnedProperties[name]=true;return true;}}return true;}function warnInvalidARIAProps(type,props){var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){warning$1(false,'Invalid aria prop %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop',unknownPropString,type);}else if(invalidProps.length>1){warning$1(false,'Invalid aria props %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop',unknownPropString,type);}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function validateProperties$1(type,props){if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){warning$1(false,'`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.',type);}else{warning$1(false,'`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.',type);}}}var validateProperty$1=function validateProperty$1(){};{var warnedProperties$1={};var _hasOwnProperty=Object.prototype.hasOwnProperty;var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');validateProperty$1=function validateProperty$1(tagName,name,value,canUseEventSystem){if(_hasOwnProperty.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){warning$1(false,'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.
if(canUseEventSystem){if(registrationNameModules.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){warning$1(false,'Invalid event handler property `%s`. Did you mean `%s`?',name,registrationName);warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){warning$1(false,'Unknown event handler property `%s`. It will be ignored.',name);warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.
// So we can't tell if the event name is correct for sure, but we can filter
// out known bad ones like `onclick`. We can't suggest a specific replacement though.
if(INVALID_EVENT_NAME_REGEX.test(name)){warning$1(false,'Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.',name);}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes
if(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){warning$1(false,'Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){warning$1(false,'The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){warning$1(false,'Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.',typeof value==='undefined'?'undefined':_typeof(value));warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){warning$1(false,'Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.',name);warnedProperties$1[name]=true;return true;}var propertyInfo=getPropertyInfo(name);var isReserved=propertyInfo!==null&&propertyInfo.type===RESERVED;// Known attributes should match the casing specified in the property config.
if(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){warning$1(false,'Invalid DOM property `%s`. Did you mean `%s`?',name,standardName);warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they
// will be cased anyway with server rendering.
warning$1(false,'React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.',name,lowerCasedName);warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){if(value){warning$1(false,'Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.',value,name,name,value,name);}else{warning$1(false,'Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',value,name,name,value,name,name,name);}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate
// data types for reserved props
if(isReserved){return true;}// Warn when a known attribute is a bad type
if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){warnedProperties$1[name]=true;return false;}// Warn when passing the strings 'false' or 'true' into a boolean prop
if((value==='false'||value==='true')&&propertyInfo!==null&&propertyInfo.type===BOOLEAN){warning$1(false,'Received the string `%s` for the boolean attribute `%s`. '+'%s '+'Did you mean %s={%s}?',value,name,value==='false'?'The browser will interpret it as a truthy value.':'Although this works, it will not work as expected if you pass the string "false".',name,value);warnedProperties$1[name]=true;return true;}return true;};}var warnUnknownProperties=function warnUnknownProperties(type,props,canUseEventSystem){var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],canUseEventSystem);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){warning$1(false,'Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://fb.me/react-attribute-behavior',unknownPropString,type);}else if(unknownProps.length>1){warning$1(false,'Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://fb.me/react-attribute-behavior',unknownPropString,type);}};function validateProperties$2(type,props,canUseEventSystem){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,canUseEventSystem);}// TODO: direct imports like some-package/src/* are bad. Fix me.
var didWarnInvalidHydration=false;var didWarnShadyDOM=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML='__html';var HTML_NAMESPACE=Namespaces.html;var warnedUnknownTags=void 0;var suppressHydrationWarning=void 0;var validatePropertiesInDevelopment=void 0;var warnForTextDifference=void 0;var warnForPropDifference=void 0;var warnForExtraAttributes=void 0;var warnForInvalidEventListener=void 0;var canDiffStyleForHydrationWarning=void 0;var normalizeMarkupForTextOrAttribute=void 0;var normalizeHTML=void 0;{warnedUnknownTags={// Chrome is the only major browser not shipping <time>. But as of July
// 2017 it intends to ship it due to widespread usage. We intentionally
// *don't* warn for <time> even if it's unrecognized by Chrome because
// it soon will be, and many apps have been using it anyway.
time:true,// There are working polyfills for <dialog>. Let people use it.
dialog:true,// Electron ships a custom <webview> tag to display external web content in
// an isolated frame and process.
// This tag is not present in non Electron environments such as JSDom which
// is often used for testing purposes.
// @see https://electronjs.org/docs/api/webview-tag
webview:true};validatePropertiesInDevelopment=function validatePropertiesInDevelopment(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,/* canUseEventSystem */true);};// IE 11 parses & normalizes the style attribute as opposed to other
// browsers. It adds spaces and sorts the properties in some
// non-alphabetical order. Handling that would require sorting CSS
// properties in the client & server versions or applying
// `expectedStyle` to a temporary DOM node to read its `style` attribute
// normalized. Since it only affects IE, we're skipping style warnings
// in that browser completely in favor of doing all that work.
// See https://github.com/facebook/react/issues/11807
canDiffStyleForHydrationWarning=canUseDOM&&!document.documentMode;// HTML parsing normalizes CR and CRLF to LF.
// It also can turn \u0000 into \uFFFD inside attributes.
// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
// If we have a mismatch, it might be caused by that.
// We will still patch up in this case but not fire the warning.
var NORMALIZE_NEWLINES_REGEX=/\r\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\u0000|\uFFFD/g;normalizeMarkupForTextOrAttribute=function normalizeMarkupForTextOrAttribute(markup){var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');};warnForTextDifference=function warnForTextDifference(serverText,clientText){if(didWarnInvalidHydration){return;}var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}didWarnInvalidHydration=true;warningWithoutStack$1(false,'Text content did not match. Server: "%s" Client: "%s"',normalizedServerText,normalizedClientText);};warnForPropDifference=function warnForPropDifference(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;warningWithoutStack$1(false,'Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};warnForExtraAttributes=function warnForExtraAttributes(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});warningWithoutStack$1(false,'Extra attributes from the server: %s',names);};warnForInvalidEventListener=function warnForInvalidEventListener(registrationName,listener){if(listener===false){warning$1(false,'Expected `%s` listener to be a function, instead got `false`.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',registrationName,registrationName,registrationName);}else{warning$1(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener==='undefined'?'undefined':_typeof(listener));}};// Parse the HTML and read it back to normalize the HTML string so that it
// can be used for comparison.
normalizeHTML=function normalizeHTML(parent,html){// We could have created a separate document here to avoid
// re-initializing custom elements if they exist. But this breaks
// how <noscript> is being handled. So we use the same document.
// See the discussion in https://github.com/facebook/react/pull/11157.
var testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}function ensureListeningTo(rootContainerElement,registrationName){var isDocumentOrFragment=rootContainerElement.nodeType===DOCUMENT_NODE||rootContainerElement.nodeType===DOCUMENT_FRAGMENT_NODE;var doc=isDocumentOrFragment?rootContainerElement:rootContainerElement.ownerDocument;listenTo(registrationName,doc);}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}function noop(){}function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on
// non-interactive elements, which means delegated click listeners do not
// fire. The workaround for this bug involves attaching an empty click
// listener on the target node.
// http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
// Just set it using the onclick property so that we don't have to manage any
// bookkeeping for it. Not sure if we need to clear it when the listener is
// removed.
// TODO: Only do this for the relevant Safaris maybe?
node.onclick=noop;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.
setValueForStyles(domElement,nextProp);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting
// textContent on a <textarea> will cause the placeholder to not
// show within the <textarea> until it has been focused and blurred again.
// https://github.com/facebook/react/issues/6731#issuecomment-254874553
var canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(propKey===AUTOFOCUS){// We polyfill it separately on the client during commit.
// We could have excluded it in the property list instead of
// adding a special case here, but then it wouldn't be emitted
// on server rendering (but we *do* want to emit it in SSR).
}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else if(nextProp!=null){setValueForProperty(domElement,propKey,nextProp,isCustomComponentTag);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag
for(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else{setValueForProperty(domElement,propKey,propValue,isCustomComponentTag);}}}function createElement(type,props,rootContainerElement,parentNamespace){var isCustomComponentTag=void 0;// We create tags in the namespace of their parent container, except HTML
// tags get no namespace.
var ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement=void 0;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to
// allow <SVG> or <mATH>.
!(isCustomComponentTag||type===type.toLowerCase())?warning$1(false,'<%s /> is using incorrect casing. '+'Use PascalCase for React components, '+'or lowercase for HTML elements.',type):void 0;}if(type==='script'){// Create the script via .innerHTML so its "parser-inserted" flag is
// set to true and it does not execute
var div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line
// This is guaranteed to yield a script element.
var firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components
domElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
// See discussion in https://github.com/facebook/react/pull/6896
// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
domElement=ownerDocument.createElement(type);// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple`
// attribute on `select`s needs to be added before `option`s are inserted. This prevents
// a bug where the `select` does not scroll to the correct option because singular
// `select` elements automatically pick the first item.
// See https://github.com/facebook/react/issues/13222
if(type==='select'&&props.multiple){var node=domElement;node.multiple=true;}}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!Object.prototype.hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;warning$1(false,'The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning$1(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerNameInDevOrNull()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.
var props=void 0;switch(tag){case'iframe':case'object':trapBubbledEvent(TOP_LOAD,domElement);props=rawProps;break;case'video':case'audio':// Create listener for each media event
for(var i=0;i<mediaEventTypes.length;i++){trapBubbledEvent(mediaEventTypes[i],domElement);}props=rawProps;break;case'source':trapBubbledEvent(TOP_ERROR,domElement);props=rawProps;break;case'img':case'image':case'link':trapBubbledEvent(TOP_ERROR,domElement);trapBubbledEvent(TOP_LOAD,domElement);props=rawProps;break;case'form':trapBubbledEvent(TOP_RESET,domElement);trapBubbledEvent(TOP_SUBMIT,domElement);props=rawProps;break;case'details':trapBubbledEvent(TOP_TOGGLE,domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);props=getHostProps$1(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$2(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$3(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;default:props=rawProps;}assertValidProps(tag,props);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps,false);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement,rawProps);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.
function diffProperties(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps=void 0;var nextProps=void 0;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'option':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$3(domElement,lastRawProps);nextProps=getHostProps$3(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps);var propKey=void 0;var styleName=void 0;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN){// Noop. This is handled by the clear text mechanism.
}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(propKey===AUTOFOCUS){// Noop. It doesn't work on updates anyway.
}else if(registrationNameModules.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure
// that the "current" fiber pointer gets updated so we need a commit
// to update this element.
if(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use
// the whitelist in the commit phase instead.
(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.
for(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.
for(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.
if(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;var lastHtml=lastProp?lastProp[HTML]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,''+nextHtml);}}else{// TODO: It might be too late to clear this if we have children
// inserted already.
}}else if(propKey===CHILDREN){if(lastProp!==nextProp&&(typeof nextProp==='string'||typeof nextProp==='number')){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.
if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure
// that the "current" props pointer gets updated so we need a commit
// to update this element.
updatePayload=[];}}else{// For any other property we always add it to the queue and then we
// filter it out using the whitelist during the commit.
(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.
function updateProperties(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.
// In the middle of an update, it is possible to have multiple checked.
// When a checked radio tries to change name, browser makes another radio's checked false.
if(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.
updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props
// changed.
switch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to
// happen after `updateDOMProperties`. Otherwise HTML5 input validations
// raise warnings and prevent the new value from being assigned.
updateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children
// reconciliation
postUpdateWrapper(domElement,nextRawProps);break;}}function getPossibleStandardName(propName){{var lowerCasedName=propName.toLowerCase();if(!possibleStandardNames.hasOwnProperty(lowerCasedName)){return null;}return possibleStandardNames[lowerCasedName]||null;}return null;}function diffHydratedProperties(domElement,tag,rawProps,parentNamespace,rootContainerElement){var isCustomComponentTag=void 0;var extraAttributeNames=void 0;{suppressHydrationWarning=rawProps[SUPPRESS_HYDRATION_WARNING$1]===true;isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning$1(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerNameInDevOrNull()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.
switch(tag){case'iframe':case'object':trapBubbledEvent(TOP_LOAD,domElement);break;case'video':case'audio':// Create listener for each media event
for(var i=0;i<mediaEventTypes.length;i++){trapBubbledEvent(mediaEventTypes[i],domElement);}break;case'source':trapBubbledEvent(TOP_ERROR,domElement);break;case'img':case'image':case'link':trapBubbledEvent(TOP_ERROR,domElement);trapBubbledEvent(TOP_LOAD,domElement);break;case'form':trapBubbledEvent(TOP_RESET,domElement);trapBubbledEvent(TOP_SUBMIT,domElement);break;case'details':trapBubbledEvent(TOP_TOGGLE,domElement);break;case'input':initWrapperState(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;}assertValidProps(tag,rawProps);{extraAttributeNames=new Set();var attributes=domElement.attributes;for(var _i=0;_i<attributes.length;_i++){var name=attributes[_i].name.toLowerCase();switch(name){// Built-in SSR attribute is whitelisted
case'data-reactroot':break;// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
case'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.
// See discussion in https://github.com/facebook/react/pull/10676.
extraAttributeNames.add(attributes[_i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This
// might match additional HTML that is hidden when we read it using
// textContent. E.g. "foo" will match "f<span>oo</span>" but that still
// satisfies our requirement. Our requirement is not to produce perfect
// HTML and attributes. Ideally we should preserve structure but it's
// ok not to if the visible content is still enough to indicate what
// even listeners these nodes might be wired up to.
// TODO: Warn if there is more than a single textNode as a child.
// TODO: Should we use domElement.firstChild.nodeValue to compare?
if(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else if(true&&// Convince Flow we've calculated it (it's DEV-only in this method.)
typeof isCustomComponentTag==='boolean'){// Validate that the properties correspond to their expected values.
var serverValue=void 0;var propertyInfo=getPropertyInfo(propKey);if(suppressHydrationWarning){// Don't bother comparing. We're ignoring all these warnings.
}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1||// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
propKey==='value'||propKey==='checked'||propKey==='selected'){// Noop
}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var serverHTML=domElement.innerHTML;var nextHtml=nextProp?nextProp[HTML]:undefined;var expectedHTML=normalizeHTML(domElement,nextHtml!=null?nextHtml:'');if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey);if(canDiffStyleForHydrationWarning){var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}}else if(isCustomComponentTag){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(!shouldIgnoreAttribute(propKey,propertyInfo,isCustomComponentTag)&&!shouldRemoveAttribute(propKey,nextProp,propertyInfo,isCustomComponentTag)){var isMismatchDueToBadCasing=false;if(propertyInfo!==null){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp,propertyInfo);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey.toLowerCase());}else{var standardName=getPossibleStandardName(propKey);if(standardName!==null&&standardName!==propKey){// If an SVG prop is supplied with bad casing, it will
// be successfully parsed from HTML, but will produce a mismatch
// (and would be incorrectly rendered on the client).
// However, we already warn about bad casing elsewhere.
// So we'll skip the misleading extra mismatch warning in this case.
isMismatchDueToBadCasing=true;// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(standardName);}// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}if(nextProp!==serverValue&&!isMismatchDueToBadCasing){warnForPropDifference(propKey,serverValue,nextProp);}}}}{// $FlowFixMe - Should be inferred as not undefined.
if(extraAttributeNames.size>0&&!suppressHydrationWarning){// $FlowFixMe - Should be inferred as not undefined.
warnForExtraAttributes(extraAttributeNames);}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps,true);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement,rawProps);break;case'select':case'option':// For input and textarea we current always set the value property at
// post mount to force it to diverge from attributes. However, for
// option and select we don't quite do the same thing and select
// is not resilient to the DOM state changing so we don't do that here.
// TODO: Consider not doing this for input and textarea.
break;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText(textNode,text){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForUnmatchedText(textNode,text){{warnForTextDifference(textNode.nodeValue,text);}}function warnForDeletedHydratableElement(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warningWithoutStack$1(false,'Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warningWithoutStack$1(false,'Did not expect server HTML to contain the text node "%s" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warningWithoutStack$1(false,'Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in
// the HTML.
// TODO: Remove this special case if we can just avoid inserting empty
// text nodes.
return;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warningWithoutStack$1(false,'Expected server HTML to contain a matching text node for "%s" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState$1(domElement,tag,props){switch(tag){case'input':restoreControlledState(domElement,props);return;case'textarea':restoreControlledState$3(domElement,props);return;case'select':restoreControlledState$2(domElement,props);return;}}// TODO: direct imports like some-package/src/* are bad. Fix me.
var validateDOMNesting=function validateDOMNesting(){};var updatedAncestorInfo=function updatedAncestorInfo(){};{// This validation code was written based on the HTML5 parsing spec:
// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
//
// Note: this does not catch all invalid nesting, nor does it try to (as it's
// not clear what practical benefit doing so provides); instead, we warn only
// for cases where the parser will give a parse tree differing from what React
// intended. For example, <b><div></div></b> is invalid but we don't warn
// because it still parses correctly; we do warn for other cases like nested
// <p> tags where the beginning of the second element implicitly closes the
// first, causing a confusing mess.
// https://html.spec.whatwg.org/multipage/syntax.html#special
var specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
var inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
// TODO: Distinguish by namespace here -- for <title>, including it here
// errs on the side of fewer warnings
'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
var buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
var impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};updatedAncestorInfo=function updatedAncestorInfo(oldInfo,tag){var ancestorInfo=_assign({},oldInfo||emptyAncestorInfo);var info={tag:tag};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
if(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**
   * Returns whether
   */var isTagValidWithParent=function isTagValidWithParent(tag,parentTag){// First, let's check if we're in an unusual parsing mode...
switch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
case'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>
// but
case'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
// No special behavior since these rules fall back to "in body" mode for
// all except special table nodes which cause bad parsing behavior anyway.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
case'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
case'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
case'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
case'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
case'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
case'html':return tag==='head'||tag==='body';case'#document':return tag==='html';}// Probably in the "in body" parsing mode, so we outlaw only tag combos
// where the parsing rules cause implicit opens or closes to be added.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
switch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child
// parsing rules -- if we're down here, then none of those matched and
// so we allow it only if we don't know what the parent is, as all other
// cases are invalid.
return parentTag==null;}return true;};/**
   * Returns whether
   */var findInvalidAncestorForTag=function findInvalidAncestorForTag(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds
// equivalent to this check.
return ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn={};validateDOMNesting=function validateDOMNesting(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){!(childTag==null)?warningWithoutStack$1(false,'validateDOMNesting: when childText is passed, childTag should be null'):void 0;childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var addendum=getCurrentFiberStackInDev();var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag+'|'+addendum;if(didWarn[warnKey]){return;}didWarn[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=" Make sure you don't have any extra whitespace between tags on "+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody> to your code to match the DOM tree generated by '+'the browser.';}warningWithoutStack$1(false,'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info,addendum);}else{warningWithoutStack$1(false,'validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.%s',tagDisplayName,ancestorTag,addendum);}};}// Renderers that don't support persistence
// can re-export everything from this module.
function shim(){invariant(false,'The current renderer does not support persistence. This error is likely caused by a bug in React. Please file an issue.');}// Persistence (when unsupported)
var supportsPersistence=false;var cloneInstance=shim;var createContainerChildSet=shim;var appendChildToContainerChildSet=shim;var finalizeContainerChildren=shim;var replaceContainerChildren=shim;var SUPPRESS_HYDRATION_WARNING=void 0;{SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';}var eventsEnabled=null;var selectionInformation=null;function shouldAutoFocusHostComponent(type,props){switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;}return false;}function getRootHostContext(rootContainerInstance){var type=void 0;var namespace=void 0;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var _ancestorInfo=updatedAncestorInfo(null,validatedTag);return{namespace:namespace,ancestorInfo:_ancestorInfo};}return namespace;}function getChildHostContext(parentHostContext,type,rootContainerInstance){{var parentHostContextDev=parentHostContext;var _namespace=getChildNamespace(parentHostContextDev.namespace,type);var _ancestorInfo2=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type);return{namespace:_namespace,ancestorInfo:_ancestorInfo2};}var parentNamespace=parentHostContext;return getChildNamespace(parentNamespace,type);}function getPublicInstance(instance){return instance;}function prepareForCommit(containerInfo){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();setEnabled(false);}function resetAfterCommit(containerInfo){restoreSelection(selectionInformation);selectionInformation=null;setEnabled(eventsEnabled);eventsEnabled=null;}function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace=void 0;{// TODO: take namespace into account when validating.
var hostContextDev=hostContext;validateDOMNesting(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;}function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);}function finalizeInitialChildren(domElement,type,props,rootContainerInstance,hostContext){setInitialProperties(domElement,type,props,rootContainerInstance);return shouldAutoFocusHostComponent(type,props);}function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(_typeof(newProps.children)!==_typeof(oldProps.children)&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps,rootContainerInstance);}function shouldSetTextContent(type,props){return type==='textarea'||type==='option'||type==='noscript'||typeof props.children==='string'||typeof props.children==='number'||_typeof(props.dangerouslySetInnerHTML)==='object'&&props.dangerouslySetInnerHTML!==null&&props.dangerouslySetInnerHTML.__html!=null;}function shouldDeprioritizeSubtree(type,props){return!!props.hidden;}function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;}var isPrimaryRenderer=true;var scheduleTimeout=setTimeout;var cancelTimeout=clearTimeout;var noTimeout=-1;// -------------------
//     Mutation
// -------------------
var supportsMutation=true;function commitMount(domElement,type,newProps,internalInstanceHandle){// Despite the naming that might imply otherwise, this method only
// fires if there is an `Update` effect scheduled during mounting.
// This happens if `finalizeInitialChildren` returns `true` (which it
// does to implement the `autoFocus` attribute on the client). But
// there are also other cases when this might happen (such as patching
// up text content during hydration mismatch). So we'll check this again.
if(shouldAutoFocusHostComponent(type,newProps)){domElement.focus();}}function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Update the props handle so that we know which props are the ones with
// with current event handlers.
updateFiberProps(domElement,newProps);// Apply the diff to the DOM node.
updateProperties(domElement,updatePayload,type,oldProps,newProps);}function resetTextContent(domElement){setTextContent(domElement,'');}function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;}function appendChild(parentInstance,child){parentInstance.appendChild(child);}function appendChildToContainer(container,child){var parentNode=void 0;if(container.nodeType===COMMENT_NODE){parentNode=container.parentNode;parentNode.insertBefore(child,container);}else{parentNode=container;parentNode.appendChild(child);}// This container might be used for a portal.
// If something inside a portal is clicked, that click should bubble
// through the React tree. However, on Mobile Safari the click would
// never bubble through the *DOM* tree unless an ancestor with onclick
// event exists. So we wouldn't see it and dispatch it.
// This is why we ensure that containers have inline onclick defined.
// https://github.com/facebook/react/issues/11918
if(parentNode.onclick===null){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(parentNode);}}function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);}function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}}function removeChild(parentInstance,child){parentInstance.removeChild(child);}function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}// -------------------
//     Hydration
// -------------------
var supportsHydration=true;function canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.
return instance;}function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.
return null;}// This has now been refined to a text node.
return instance;}function getNextHydratableSibling(instance){var node=instance.nextSibling;// Skip non-hydratable nodes.
while(node&&node.nodeType!==ELEMENT_NODE&&node.nodeType!==TEXT_NODE){node=node.nextSibling;}return node;}function getFirstHydratableChild(parentInstance){var next=parentInstance.firstChild;// Skip non-hydratable nodes.
while(next&&next.nodeType!==ELEMENT_NODE&&next.nodeType!==TEXT_NODE){next=next.nextSibling;}return next;}function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events
// get attached.
updateFiberProps(instance,props);var parentNamespace=void 0;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance);}function hydrateTextInstance(textInstance,text,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,textInstance);return diffHydratedText(textInstance,text);}function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text){{warnForUnmatchedText(textInstance,text);}}function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForUnmatchedText(textInstance,text);}}function didNotHydrateContainerInstance(parentContainer,instance){{if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentContainer,instance);}else{warnForDeletedHydratableText(parentContainer,instance);}}}function didNotHydrateInstance(parentType,parentProps,parentInstance,instance){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentInstance,instance);}else{warnForDeletedHydratableText(parentInstance,instance);}}}function didNotFindHydratableContainerInstance(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type,props);}}function didNotFindHydratableContainerTextInstance(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}}function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedElement(parentInstance,type,props);}}function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedText(parentInstance,text);}}// Prefix measurements so that it's possible to filter them.
// Longer prefixes are hard to read in DevTools.
var reactEmoji='\u269B';var warningEmoji='\u26D4';var supportsUserTiming=typeof performance!=='undefined'&&typeof performance.mark==='function'&&typeof performance.clearMarks==='function'&&typeof performance.measure==='function'&&typeof performance.clearMeasures==='function';// Keep track of current fiber so that we know the path to unwind on pause.
// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
var currentFiber=null;// If we're in the middle of user code, which fiber and method is it?
// Reusing `currentFiber` would be confusing for this because user code fiber
// can change during commit phase too, but we don't need to unwind it (since
// lifecycles in the commit phase don't resemble a tree).
var currentPhase=null;var currentPhaseFiber=null;// Did lifecycle hook schedule an update? This is often a performance problem,
// so we will keep track of it, and include it in the report.
// Track commits caused by cascading updates.
var isCommitting=false;var hasScheduledUpdateInCurrentCommit=false;var hasScheduledUpdateInCurrentPhase=false;var commitCountInCurrentWorkLoop=0;var effectCountInCurrentCommit=0;var isWaitingForCallback=false;// During commits, we only show a measurement once per method name
// to avoid stretch the commit phase with measurement overhead.
var labelsInCurrentCommit=new Set();var formatMarkName=function formatMarkName(markName){return reactEmoji+' '+markName;};var formatLabel=function formatLabel(label,warning){var prefix=warning?warningEmoji+' ':reactEmoji+' ';var suffix=warning?' Warning: '+warning:'';return''+prefix+label+suffix;};var beginMark=function beginMark(markName){performance.mark(formatMarkName(markName));};var clearMark=function clearMark(markName){performance.clearMarks(formatMarkName(markName));};var endMark=function endMark(label,markName,warning){var formattedMarkName=formatMarkName(markName);var formattedLabel=formatLabel(label,warning);try{performance.measure(formattedLabel,formattedMarkName);}catch(err){}// If previous mark was missing for some reason, this will throw.
// This could only happen if React crashed in an unexpected place earlier.
// Don't pile on with more errors.
// Clear marks immediately to avoid growing buffer.
performance.clearMarks(formattedMarkName);performance.clearMeasures(formattedLabel);};var getFiberMarkName=function getFiberMarkName(label,debugID){return label+' (#'+debugID+')';};var getFiberLabel=function getFiberLabel(componentName,isMounted,phase){if(phase===null){// These are composite component total time measurements.
return componentName+' ['+(isMounted?'update':'mount')+']';}else{// Composite component methods.
return componentName+'.'+phase;}};var beginFiberMark=function beginFiberMark(fiber,phase){var componentName=getComponentName(fiber.type)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);if(isCommitting&&labelsInCurrentCommit.has(label)){// During the commit phase, we don't show duplicate labels because
// there is a fixed overhead for every measurement, and we don't
// want to stretch the commit phase beyond necessary.
return false;}labelsInCurrentCommit.add(label);var markName=getFiberMarkName(label,debugID);beginMark(markName);return true;};var clearFiberMark=function clearFiberMark(fiber,phase){var componentName=getComponentName(fiber.type)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);clearMark(markName);};var endFiberMark=function endFiberMark(fiber,phase,warning){var componentName=getComponentName(fiber.type)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);endMark(label,markName,warning);};var shouldIgnoreFiber=function shouldIgnoreFiber(fiber){// Host components should be skipped in the timeline.
// We could check typeof fiber.type, but does this work with RN?
switch(fiber.tag){case HostRoot:case HostComponent:case HostText:case HostPortal:case Fragment:case ContextProvider:case ContextConsumer:case Mode:return true;default:return false;}};var clearPendingPhaseMeasurement=function clearPendingPhaseMeasurement(){if(currentPhase!==null&&currentPhaseFiber!==null){clearFiberMark(currentPhaseFiber,currentPhase);}currentPhaseFiber=null;currentPhase=null;hasScheduledUpdateInCurrentPhase=false;};var pauseTimers=function pauseTimers(){// Stops all currently active measurements so that they can be resumed
// if we continue in a later deferred loop from the same unit of work.
var fiber=currentFiber;while(fiber){if(fiber._debugIsCurrentlyTiming){endFiberMark(fiber,null,null);}fiber=fiber.return;}};var resumeTimersRecursively=function resumeTimersRecursively(fiber){if(fiber.return!==null){resumeTimersRecursively(fiber.return);}if(fiber._debugIsCurrentlyTiming){beginFiberMark(fiber,null);}};var resumeTimers=function resumeTimers(){// Resumes all measurements that were active during the last deferred loop.
if(currentFiber!==null){resumeTimersRecursively(currentFiber);}};function recordEffect(){if(enableUserTimingAPI){effectCountInCurrentCommit++;}}function recordScheduleUpdate(){if(enableUserTimingAPI){if(isCommitting){hasScheduledUpdateInCurrentCommit=true;}if(currentPhase!==null&&currentPhase!=='componentWillMount'&&currentPhase!=='componentWillReceiveProps'){hasScheduledUpdateInCurrentPhase=true;}}}function startRequestCallbackTimer(){if(enableUserTimingAPI){if(supportsUserTiming&&!isWaitingForCallback){isWaitingForCallback=true;beginMark('(Waiting for async callback...)');}}}function stopRequestCallbackTimer(didExpire,expirationTime){if(enableUserTimingAPI){if(supportsUserTiming){isWaitingForCallback=false;var warning=didExpire?'React was blocked by main thread':null;endMark('(Waiting for async callback... will force flush in '+expirationTime+' ms)','(Waiting for async callback...)',warning);}}}function startWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, this is the fiber to unwind from.
currentFiber=fiber;if(!beginFiberMark(fiber,null)){return;}fiber._debugIsCurrentlyTiming=true;}}function cancelWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// Remember we shouldn't complete measurement for this fiber.
// Otherwise flamechart will be deep even for small updates.
fiber._debugIsCurrentlyTiming=false;clearFiberMark(fiber,null);}}function stopWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
currentFiber=fiber.return;if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;endFiberMark(fiber,null,null);}}function stopFailedWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
currentFiber=fiber.return;if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;var warning='An error was thrown inside this error boundary';endFiberMark(fiber,null,warning);}}function startPhaseTimer(fiber,phase){if(enableUserTimingAPI){if(!supportsUserTiming){return;}clearPendingPhaseMeasurement();if(!beginFiberMark(fiber,phase)){return;}currentPhaseFiber=fiber;currentPhase=phase;}}function stopPhaseTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}if(currentPhase!==null&&currentPhaseFiber!==null){var warning=hasScheduledUpdateInCurrentPhase?'Scheduled a cascading update':null;endFiberMark(currentPhaseFiber,currentPhase,warning);}currentPhase=null;currentPhaseFiber=null;}}function startWorkLoopTimer(nextUnitOfWork){if(enableUserTimingAPI){currentFiber=nextUnitOfWork;if(!supportsUserTiming){return;}commitCountInCurrentWorkLoop=0;// This is top level call.
// Any other measurements are performed within.
beginMark('(React Tree Reconciliation)');// Resume any measurements that were in progress during the last loop.
resumeTimers();}}function stopWorkLoopTimer(interruptedBy,didCompleteRoot){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning=null;if(interruptedBy!==null){if(interruptedBy.tag===HostRoot){warning='A top-level update interrupted the previous render';}else{var componentName=getComponentName(interruptedBy.type)||'Unknown';warning='An update to '+componentName+' interrupted the previous render';}}else if(commitCountInCurrentWorkLoop>1){warning='There were cascading updates';}commitCountInCurrentWorkLoop=0;var label=didCompleteRoot?'(React Tree Reconciliation: Completed Root)':'(React Tree Reconciliation: Yielded)';// Pause any measurements until the next loop.
pauseTimers();endMark(label,'(React Tree Reconciliation)',warning);}}function startCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}isCommitting=true;hasScheduledUpdateInCurrentCommit=false;labelsInCurrentCommit.clear();beginMark('(Committing Changes)');}}function stopCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning=null;if(hasScheduledUpdateInCurrentCommit){warning='Lifecycle hook scheduled a cascading update';}else if(commitCountInCurrentWorkLoop>0){warning='Caused by a cascading update in earlier commit';}hasScheduledUpdateInCurrentCommit=false;commitCountInCurrentWorkLoop++;isCommitting=false;labelsInCurrentCommit.clear();endMark('(Committing Changes)','(Committing Changes)',warning);}}function startCommitSnapshotEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Committing Snapshot Effects)');}}function stopCommitSnapshotEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Committing Snapshot Effects: '+count+' Total)','(Committing Snapshot Effects)',null);}}function startCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Committing Host Effects)');}}function stopCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Committing Host Effects: '+count+' Total)','(Committing Host Effects)',null);}}function startCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Calling Lifecycle Methods)');}}function stopCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Calling Lifecycle Methods: '+count+' Total)','(Calling Lifecycle Methods)',null);}}var valueStack=[];var fiberStack=void 0;{fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{warningWithoutStack$1(false,'Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){warningWithoutStack$1(false,'Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}function checkThatStackIsEmpty(){{if(index!==-1){warningWithoutStack$1(false,'Expected an empty stack. Something was not reset properly.');}}}function resetStackAfterFatalErrorInDev(){{index=-1;valueStack.length=0;fiberStack.length=0;}}var warnedAboutMissingGetChildContext=void 0;{warnedAboutMissingGetChildContext={};}var emptyContextObject={};{Object.freeze(emptyContextObject);}// A cursor to the current merged context object on the stack.
var contextStackCursor=createCursor(emptyContextObject);// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext=emptyContextObject;function getUnmaskedContext(workInProgress,Component,didPushOwnContextIfProvider){if(didPushOwnContextIfProvider&&isContextProvider(Component)){// If the fiber is a context provider itself, when we read its context
// we may have already pushed its own child context on the stack. A context
// provider should not "see" its own child context. Therefore we read the
// previous (parent) context instead for a context provider.
return previousContext;}return contextStackCursor.current;}function cacheContext(workInProgress,unmaskedContext,maskedContext){var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}function getMaskedContext(workInProgress,unmaskedContext){var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyContextObject;}// Avoid recreating masked context unless unmasked context has changed.
// Failing to do this will result in unnecessary calls to componentWillReceiveProps.
// This may trigger infinite loops if componentWillReceiveProps calls setState.
var instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentName(type)||'Unknown';checkPropTypes(contextTypes,context,'context',name,getCurrentFiberStackInDev);}// Cache unmasked context so we can avoid recreating masked context unless necessary.
// Context is created before the class component is instantiated so check for instance.
if(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}function hasContextChanged(){return didPerformWorkStackCursor.current;}function isContextProvider(type){var childContextTypes=type.childContextTypes;return childContextTypes!==null&&childContextTypes!==undefined;}function popContext(fiber){pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function popTopLevelContextObject(fiber){pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function pushTopLevelContextObject(fiber,context,didChange){!(contextStackCursor.current===emptyContextObject)?invariant(false,'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.'):void 0;push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}function processChildContext(fiber,type,parentContext){var instance=fiber.stateNode;var childContextTypes=type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.
// It has only been added in Fiber to match the (unintentional) behavior in Stack.
if(typeof instance.getChildContext!=='function'){{var componentName=getComponentName(type)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;warningWithoutStack$1(false,'%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=void 0;{setCurrentPhase('getChildContext');}startPhaseTimer(fiber,'getChildContext');childContext=instance.getChildContext();stopPhaseTimer();{setCurrentPhase(null);}for(var contextKey in childContext){!(contextKey in childContextTypes)?invariant(false,'%s.getChildContext(): key "%s" is not defined in childContextTypes.',getComponentName(type)||'Unknown',contextKey):void 0;}{var name=getComponentName(type)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name,// In practice, there is one case in which we won't get a stack. It's when
// somebody calls unstable_renderSubtreeIntoContainer() and we process
// context from the parent component instance. The stack will be missing
// because it's outside of the reconciliation, and so the pointer has not
// been set. This is rare and doesn't matter. We'll also remove that API.
getCurrentFiberStackInDev);}return _assign({},parentContext,childContext);}function pushContextProvider(workInProgress){var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.
// If the instance does not exist yet, we will push null at first,
// and replace it on the stack later when invalidating the context.
var memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyContextObject;// Remember the parent context so we can merge with it later.
// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
previousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}function invalidateContextProvider(workInProgress,type,didChange){var instance=workInProgress.stateNode;!instance?invariant(false,'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(didChange){// Merge parent and own context.
// Skip this if we're not updating due to sCU.
// This avoids unnecessarily recomputing memoized values.
var mergedContext=processChildContext(workInProgress,type,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.
// It is important to unwind the context in the reverse order.
pop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.
push(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}function findCurrentUnmaskedContext(fiber){// Currently this is only used with renderSubtreeIntoContainer; not sure if it
// makes sense elsewhere
!(isFiberMounted(fiber)&&(fiber.tag===ClassComponent||fiber.tag===ClassComponentLazy))?invariant(false,'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.'):void 0;var node=fiber;do{switch(node.tag){case HostRoot:return node.stateNode.context;case ClassComponent:{var Component=node.type;if(isContextProvider(Component)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}break;}case ClassComponentLazy:{var _Component=getResultFromResolvedThenable(node.type);if(isContextProvider(_Component)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}break;}}node=node.return;}while(node!==null);invariant(false,'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.');}var onCommitFiberRoot=null;var onCommitFiberUnmount=null;var hasLoggedError=false;function catchErrors(fn){return function(arg){try{return fn(arg);}catch(err){if(true&&!hasLoggedError){hasLoggedError=true;warningWithoutStack$1(false,'React DevTools encountered an error: %s',err);}}};}var isDevToolsPresent=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined';function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools
return false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out
// of DevTools integration and associated warnings and logs.
// https://github.com/facebook/react/issues/3877
return true;}if(!hook.supportsFiber){{warningWithoutStack$1(false,'The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://fb.me/react-devtools');}// DevTools exists, even though it doesn't support Fiber.
return true;}try{var rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.
onCommitFiberRoot=catchErrors(function(root){return hook.onCommitFiberRoot(rendererID,root);});onCommitFiberUnmount=catchErrors(function(fiber){return hook.onCommitFiberUnmount(rendererID,fiber);});}catch(err){// Catch all errors because it is unsafe to throw during initialization.
{warningWithoutStack$1(false,'React DevTools encountered an error: %s.',err);}}// DevTools exists
return true;}function onCommitRoot(root){if(typeof onCommitFiberRoot==='function'){onCommitFiberRoot(root);}}function onCommitUnmount(fiber){if(typeof onCommitFiberUnmount==='function'){onCommitFiberUnmount(fiber);}}// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
// Math.pow(2, 30) - 1
// 0b111111111111111111111111111111
var maxSigned31BitInt=1073741823;var NoWork=0;var Sync=1;var Never=maxSigned31BitInt;var UNIT_SIZE=10;var MAGIC_NUMBER_OFFSET=2;// 1 unit of expiration time represents 10ms.
function msToExpirationTime(ms){// Always add an offset so that we don't clash with the magic number for NoWork.
return(ms/UNIT_SIZE|0)+MAGIC_NUMBER_OFFSET;}function expirationTimeToMs(expirationTime){return(expirationTime-MAGIC_NUMBER_OFFSET)*UNIT_SIZE;}function ceiling(num,precision){return((num/precision|0)+1)*precision;}function computeExpirationBucket(currentTime,expirationInMs,bucketSizeMs){return MAGIC_NUMBER_OFFSET+ceiling(currentTime-MAGIC_NUMBER_OFFSET+expirationInMs/UNIT_SIZE,bucketSizeMs/UNIT_SIZE);}var LOW_PRIORITY_EXPIRATION=5000;var LOW_PRIORITY_BATCH_SIZE=250;function computeAsyncExpiration(currentTime){return computeExpirationBucket(currentTime,LOW_PRIORITY_EXPIRATION,LOW_PRIORITY_BATCH_SIZE);}// We intentionally set a higher expiration time for interactive updates in
// dev than in production.
//
// If the main thread is being blocked so long that you hit the expiration,
// it's a problem that could be solved with better scheduling.
//
// People will be more likely to notice this and fix it with the long
// expiration time in development.
//
// In production we opt for better UX at the risk of masking scheduling
// problems, by expiring fast.
var HIGH_PRIORITY_EXPIRATION=500;var HIGH_PRIORITY_BATCH_SIZE=100;function computeInteractiveExpiration(currentTime){return computeExpirationBucket(currentTime,HIGH_PRIORITY_EXPIRATION,HIGH_PRIORITY_BATCH_SIZE);}var NoContext=0;var AsyncMode=1;var StrictMode=2;var ProfileMode=4;var hasBadMapPolyfill=void 0;{hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});var testMap=new Map([[nonExtensibleObject,null]]);var testSet=new Set([nonExtensibleObject]);// This is necessary for Rollup to not consider these unused.
// https://github.com/rollup/rollup/issues/1771
// TODO: we can remove these if Rollup fixes the bug.
testMap.set(0,0);testSet.add(0);}catch(e){// TODO: Consider warning about bad polyfills
hasBadMapPolyfill=true;}}// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.
var debugCounter=void 0;{debugCounter=1;}function FiberNode(tag,pendingProps,key,mode){// Instance
this.tag=tag;this.key=key;this.type=null;this.stateNode=null;// Fiber
this.return=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=pendingProps;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.firstContextDependency=null;this.mode=mode;// Effects
this.effectTag=NoEffect;this.nextEffect=null;this.firstEffect=null;this.lastEffect=null;this.expirationTime=NoWork;this.childExpirationTime=NoWork;this.alternate=null;if(enableProfilerTimer){this.actualDuration=0;this.actualStartTime=-1;this.selfBaseDuration=0;this.treeBaseDuration=0;}{this._debugID=debugCounter++;this._debugSource=null;this._debugOwner=null;this._debugIsCurrentlyTiming=false;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber=function createFiber(tag,pendingProps,key,mode){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
return new FiberNode(tag,pendingProps,key,mode);};function shouldConstruct(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function resolveLazyComponentTag(fiber,Component){if(typeof Component==='function'){return shouldConstruct(Component)?ClassComponentLazy:FunctionalComponentLazy;}else if(Component!==undefined&&Component!==null&&Component.$$typeof){return ForwardRefLazy;}return IndeterminateComponent;}// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current,pendingProps,expirationTime){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll
// only ever need at most two versions of a tree. We pool the "other" unused
// node that we're free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
workInProgress=createFiber(current.tag,pendingProps,current.key,current.mode);workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields
workInProgress._debugID=current._debugID;workInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;}workInProgress.alternate=current;current.alternate=workInProgress;}else{workInProgress.pendingProps=pendingProps;// We already have an alternate.
// Reset the effect tag.
workInProgress.effectTag=NoEffect;// The effect list is no longer valid.
workInProgress.nextEffect=null;workInProgress.firstEffect=null;workInProgress.lastEffect=null;if(enableProfilerTimer){// We intentionally reset, rather than copy, actualDuration & actualStartTime.
// This prevents time from endlessly accumulating in new commits.
// This has the downside of resetting values for different priority renders,
// But works for yielding (the common case) and should support resuming.
workInProgress.actualDuration=0;workInProgress.actualStartTime=-1;}}// Don't touching the subtree's expiration time, which has not changed.
workInProgress.childExpirationTime=current.childExpirationTime;if(pendingProps!==current.pendingProps){// This fiber has new props.
workInProgress.expirationTime=expirationTime;}else{// This fiber's props have not changed.
workInProgress.expirationTime=current.expirationTime;}workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;workInProgress.firstContextDependency=current.firstContextDependency;// These will be overridden during the parent's reconciliation
workInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;if(enableProfilerTimer){workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}return workInProgress;}function createHostRootFiber(isAsync){var mode=isAsync?AsyncMode|StrictMode:NoContext;if(enableProfilerTimer&&isDevToolsPresent){// Always collect profile timings when DevTools are present.
// This enables DevTools to start capturing timing at any point–
// Without some nodes in the tree having empty base times.
mode|=ProfileMode;}return createFiber(HostRoot,null,null,mode);}function createFiberFromElement(element,mode,expirationTime){var owner=null;{owner=element._owner;}var fiber=void 0;var type=element.type;var key=element.key;var pendingProps=element.props;var fiberTag=void 0;if(typeof type==='function'){fiberTag=shouldConstruct(type)?ClassComponent:IndeterminateComponent;}else if(typeof type==='string'){fiberTag=HostComponent;}else{getTag:switch(type){case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,mode,expirationTime,key);case REACT_ASYNC_MODE_TYPE:fiberTag=Mode;mode|=AsyncMode|StrictMode;break;case REACT_STRICT_MODE_TYPE:fiberTag=Mode;mode|=StrictMode;break;case REACT_PROFILER_TYPE:return createFiberFromProfiler(pendingProps,mode,expirationTime,key);case REACT_PLACEHOLDER_TYPE:fiberTag=PlaceholderComponent;break;default:{if((typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null){switch(type.$$typeof){case REACT_PROVIDER_TYPE:fiberTag=ContextProvider;break getTag;case REACT_CONTEXT_TYPE:// This is a consumer
fiberTag=ContextConsumer;break getTag;case REACT_FORWARD_REF_TYPE:fiberTag=ForwardRef;break getTag;default:{if(typeof type.then==='function'){fiberTag=IndeterminateComponent;break getTag;}}}}var info='';{if(type===undefined||(typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+"it's defined in, or you might have mixed up default and "+'named imports.';}var ownerName=owner?getComponentName(owner.type):null;if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}}invariant(false,'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',type==null?type:typeof type==='undefined'?'undefined':_typeof(type),info);}}}fiber=createFiber(fiberTag,pendingProps,key,mode);fiber.type=type;fiber.expirationTime=expirationTime;{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}return fiber;}function createFiberFromFragment(elements,mode,expirationTime,key){var fiber=createFiber(Fragment,elements,key,mode);fiber.expirationTime=expirationTime;return fiber;}function createFiberFromProfiler(pendingProps,mode,expirationTime,key){{if(typeof pendingProps.id!=='string'||typeof pendingProps.onRender!=='function'){warningWithoutStack$1(false,'Profiler must specify an "id" string and "onRender" function as props');}}var fiber=createFiber(Profiler,pendingProps,key,mode|ProfileMode);fiber.type=REACT_PROFILER_TYPE;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromText(content,mode,expirationTime){var fiber=createFiber(HostText,content,null,mode);fiber.expirationTime=expirationTime;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,null,NoContext);fiber.type='DELETED';return fiber;}function createFiberFromPortal(portal,mode,expirationTime){var pendingProps=portal.children!==null?portal.children:[];var fiber=createFiber(HostPortal,pendingProps,portal.key,mode);fiber.expirationTime=expirationTime;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates
implementation:portal.implementation};return fiber;}// Used for stashing WIP properties to replay failed work in DEV.
function assignFiberPropertiesInDEV(target,source){if(target===null){// This Fiber's initial properties will always be overwritten.
// We only use a Fiber to ensure the same hidden class so DEV isn't slow.
target=createFiber(IndeterminateComponent,null,null,NoContext);}// This is intentionally written as a list of all properties.
// We tried to use Object.assign() instead but this is called in
// the hottest path, and Object.assign() was too slow:
// https://github.com/facebook/react/issues/12502
// This code is DEV-only so size is not a concern.
target.tag=source.tag;target.key=source.key;target.type=source.type;target.stateNode=source.stateNode;target.return=source.return;target.child=source.child;target.sibling=source.sibling;target.index=source.index;target.ref=source.ref;target.pendingProps=source.pendingProps;target.memoizedProps=source.memoizedProps;target.updateQueue=source.updateQueue;target.memoizedState=source.memoizedState;target.firstContextDependency=source.firstContextDependency;target.mode=source.mode;target.effectTag=source.effectTag;target.nextEffect=source.nextEffect;target.firstEffect=source.firstEffect;target.lastEffect=source.lastEffect;target.expirationTime=source.expirationTime;target.childExpirationTime=source.childExpirationTime;target.alternate=source.alternate;if(enableProfilerTimer){target.actualDuration=source.actualDuration;target.actualStartTime=source.actualStartTime;target.selfBaseDuration=source.selfBaseDuration;target.treeBaseDuration=source.treeBaseDuration;}target._debugID=source._debugID;target._debugSource=source._debugSource;target._debugOwner=source._debugOwner;target._debugIsCurrentlyTiming=source._debugIsCurrentlyTiming;return target;}/* eslint-disable no-use-before-define */// TODO: This should be lifted into the renderer.
// The following attributes are only used by interaction tracing builds.
// They enable interactions to be associated with their async work,
// And expose interaction metadata to the React DevTools Profiler plugin.
// Note that these attributes are only defined when the enableSchedulerTracing flag is enabled.
// Exported FiberRoot type includes all properties,
// To avoid requiring potentially error-prone :any casts throughout the project.
// Profiling properties are only safe to access in profiling builds (when enableSchedulerTracing is true).
// The types are defined separately within this file to ensure they stay in sync.
// (We don't have to use an inline :any cast when enableSchedulerTracing is disabled.)
/* eslint-enable no-use-before-define */function createFiberRoot(containerInfo,isAsync,hydrate){// Cyclic construction. This cheats the type system right now because
// stateNode is any.
var uninitializedFiber=createHostRootFiber(isAsync);var root=void 0;if(enableSchedulerTracing){root={current:uninitializedFiber,containerInfo:containerInfo,pendingChildren:null,earliestPendingTime:NoWork,latestPendingTime:NoWork,earliestSuspendedTime:NoWork,latestSuspendedTime:NoWork,latestPingedTime:NoWork,didError:false,pendingCommitExpirationTime:NoWork,finishedWork:null,timeoutHandle:noTimeout,context:null,pendingContext:null,hydrate:hydrate,nextExpirationTimeToWorkOn:NoWork,expirationTime:NoWork,firstBatch:null,nextScheduledRoot:null,interactionThreadID:tracing.unstable_getThreadID(),memoizedInteractions:new Set(),pendingInteractionMap:new Map()};}else{root={current:uninitializedFiber,containerInfo:containerInfo,pendingChildren:null,earliestPendingTime:NoWork,latestPendingTime:NoWork,earliestSuspendedTime:NoWork,latestSuspendedTime:NoWork,latestPingedTime:NoWork,didError:false,pendingCommitExpirationTime:NoWork,finishedWork:null,timeoutHandle:noTimeout,context:null,pendingContext:null,hydrate:hydrate,nextExpirationTimeToWorkOn:NoWork,expirationTime:NoWork,firstBatch:null,nextScheduledRoot:null};}uninitializedFiber.stateNode=root;// The reason for the way the Flow types are structured in this file,
// Is to avoid needing :any casts everywhere interaction tracing fields are used.
// Unfortunately that requires an :any cast for non-interaction tracing capable builds.
// $FlowFixMe Remove this :any cast and replace it with something better.
return root;}/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */var lowPriorityWarning=function lowPriorityWarning(){};{var printWarning=function printWarning(format){for(var _len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}var argIndex=0;var message='Warning: '+format.replace(/%s/g,function(){return args[argIndex++];});if(typeof console!=='undefined'){console.warn(message);}try{// --- Welcome to debugging React ---
// This error was thrown as a convenience so that you can use this stack
// to find the callsite that caused this warning to fire.
throw new Error(message);}catch(x){}};lowPriorityWarning=function lowPriorityWarning(condition,format){if(format===undefined){throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning '+'message argument');}if(!condition){for(var _len2=arguments.length,args=Array(_len2>2?_len2-2:0),_key2=2;_key2<_len2;_key2++){args[_key2-2]=arguments[_key2];}printWarning.apply(undefined,[format].concat(args));}};}var lowPriorityWarning$1=lowPriorityWarning;var ReactStrictModeWarnings={discardPendingWarnings:function discardPendingWarnings(){},flushPendingDeprecationWarnings:function flushPendingDeprecationWarnings(){},flushPendingUnsafeLifecycleWarnings:function flushPendingUnsafeLifecycleWarnings(){},recordDeprecationWarnings:function recordDeprecationWarnings(fiber,instance){},recordUnsafeLifecycleWarnings:function recordUnsafeLifecycleWarnings(fiber,instance){},recordLegacyContextWarning:function recordLegacyContextWarning(fiber,instance){},flushLegacyContextWarning:function flushLegacyContextWarning(){}};{var LIFECYCLE_SUGGESTIONS={UNSAFE_componentWillMount:'componentDidMount',UNSAFE_componentWillReceiveProps:'static getDerivedStateFromProps',UNSAFE_componentWillUpdate:'componentDidUpdate'};var pendingComponentWillMountWarnings=[];var pendingComponentWillReceivePropsWarnings=[];var pendingComponentWillUpdateWarnings=[];var pendingUnsafeLifecycleWarnings=new Map();var pendingLegacyContextWarning=new Map();// Tracks components we have already warned about.
var didWarnAboutDeprecatedLifecycles=new Set();var didWarnAboutUnsafeLifecycles=new Set();var didWarnAboutLegacyContext=new Set();var setToSortedString=function setToSortedString(set){var array=[];set.forEach(function(value){array.push(value);});return array.sort().join(', ');};ReactStrictModeWarnings.discardPendingWarnings=function(){pendingComponentWillMountWarnings=[];pendingComponentWillReceivePropsWarnings=[];pendingComponentWillUpdateWarnings=[];pendingUnsafeLifecycleWarnings=new Map();pendingLegacyContextWarning=new Map();};ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function(){pendingUnsafeLifecycleWarnings.forEach(function(lifecycleWarningsMap,strictRoot){var lifecyclesWarningMesages=[];Object.keys(lifecycleWarningsMap).forEach(function(lifecycle){var lifecycleWarnings=lifecycleWarningsMap[lifecycle];if(lifecycleWarnings.length>0){var componentNames=new Set();lifecycleWarnings.forEach(function(fiber){componentNames.add(getComponentName(fiber.type)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});var formatted=lifecycle.replace('UNSAFE_','');var suggestion=LIFECYCLE_SUGGESTIONS[lifecycle];var sortedComponentNames=setToSortedString(componentNames);lifecyclesWarningMesages.push(formatted+': Please update the following components to use '+(suggestion+' instead: '+sortedComponentNames));}});if(lifecyclesWarningMesages.length>0){var strictRootComponentStack=getStackByFiberInDevAndProd(strictRoot);warningWithoutStack$1(false,'Unsafe lifecycle methods were found within a strict-mode tree:%s'+'\n\n%s'+'\n\nLearn more about this warning here:'+'\nhttps://fb.me/react-strict-mode-warnings',strictRootComponentStack,lifecyclesWarningMesages.join('\n\n'));}});pendingUnsafeLifecycleWarnings=new Map();};var findStrictRoot=function findStrictRoot(fiber){var maybeStrictRoot=null;var node=fiber;while(node!==null){if(node.mode&StrictMode){maybeStrictRoot=node;}node=node.return;}return maybeStrictRoot;};ReactStrictModeWarnings.flushPendingDeprecationWarnings=function(){if(pendingComponentWillMountWarnings.length>0){var uniqueNames=new Set();pendingComponentWillMountWarnings.forEach(function(fiber){uniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutDeprecatedLifecycles.add(fiber.type);});var sortedNames=setToSortedString(uniqueNames);lowPriorityWarning$1(false,'componentWillMount is deprecated and will be removed in the next major version. '+'Use componentDidMount instead. As a temporary workaround, '+'you can rename to UNSAFE_componentWillMount.'+'\n\nPlease update the following components: %s'+'\n\nLearn more about this warning here:'+'\nhttps://fb.me/react-async-component-lifecycle-hooks',sortedNames);pendingComponentWillMountWarnings=[];}if(pendingComponentWillReceivePropsWarnings.length>0){var _uniqueNames=new Set();pendingComponentWillReceivePropsWarnings.forEach(function(fiber){_uniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutDeprecatedLifecycles.add(fiber.type);});var _sortedNames=setToSortedString(_uniqueNames);lowPriorityWarning$1(false,'componentWillReceiveProps is deprecated and will be removed in the next major version. '+'Use static getDerivedStateFromProps instead.'+'\n\nPlease update the following components: %s'+'\n\nLearn more about this warning here:'+'\nhttps://fb.me/react-async-component-lifecycle-hooks',_sortedNames);pendingComponentWillReceivePropsWarnings=[];}if(pendingComponentWillUpdateWarnings.length>0){var _uniqueNames2=new Set();pendingComponentWillUpdateWarnings.forEach(function(fiber){_uniqueNames2.add(getComponentName(fiber.type)||'Component');didWarnAboutDeprecatedLifecycles.add(fiber.type);});var _sortedNames2=setToSortedString(_uniqueNames2);lowPriorityWarning$1(false,'componentWillUpdate is deprecated and will be removed in the next major version. '+'Use componentDidUpdate instead. As a temporary workaround, '+'you can rename to UNSAFE_componentWillUpdate.'+'\n\nPlease update the following components: %s'+'\n\nLearn more about this warning here:'+'\nhttps://fb.me/react-async-component-lifecycle-hooks',_sortedNames2);pendingComponentWillUpdateWarnings=[];}};ReactStrictModeWarnings.recordDeprecationWarnings=function(fiber,instance){// Dedup strategy: Warn once per component.
if(didWarnAboutDeprecatedLifecycles.has(fiber.type)){return;}// Don't warn about react-lifecycles-compat polyfilled components.
if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true){pendingComponentWillMountWarnings.push(fiber);}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){pendingComponentWillReceivePropsWarnings.push(fiber);}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){pendingComponentWillUpdateWarnings.push(fiber);}};ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){warningWithoutStack$1(false,'Expected to find a StrictMode component in a strict mode tree. '+'This error is likely caused by a bug in React. Please file an issue.');return;}// Dedup strategy: Warn once per component.
// This is difficult to track any other way since component names
// are often vague and are likely to collide between 3rd party libraries.
// An expand property is probably okay to use here since it's DEV-only,
// and will only be set in the event of serious warnings.
if(didWarnAboutUnsafeLifecycles.has(fiber.type)){return;}var warningsForRoot=void 0;if(!pendingUnsafeLifecycleWarnings.has(strictRoot)){warningsForRoot={UNSAFE_componentWillMount:[],UNSAFE_componentWillReceiveProps:[],UNSAFE_componentWillUpdate:[]};pendingUnsafeLifecycleWarnings.set(strictRoot,warningsForRoot);}else{warningsForRoot=pendingUnsafeLifecycleWarnings.get(strictRoot);}var unsafeLifecycles=[];if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true||typeof instance.UNSAFE_componentWillMount==='function'){unsafeLifecycles.push('UNSAFE_componentWillMount');}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true||typeof instance.UNSAFE_componentWillReceiveProps==='function'){unsafeLifecycles.push('UNSAFE_componentWillReceiveProps');}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true||typeof instance.UNSAFE_componentWillUpdate==='function'){unsafeLifecycles.push('UNSAFE_componentWillUpdate');}if(unsafeLifecycles.length>0){unsafeLifecycles.forEach(function(lifecycle){warningsForRoot[lifecycle].push(fiber);});}};ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){warningWithoutStack$1(false,'Expected to find a StrictMode component in a strict mode tree. '+'This error is likely caused by a bug in React. Please file an issue.');return;}// Dedup strategy: Warn once per component.
if(didWarnAboutLegacyContext.has(fiber.type)){return;}var warningsForRoot=pendingLegacyContextWarning.get(strictRoot);if(fiber.type.contextTypes!=null||fiber.type.childContextTypes!=null||instance!==null&&typeof instance.getChildContext==='function'){if(warningsForRoot===undefined){warningsForRoot=[];pendingLegacyContextWarning.set(strictRoot,warningsForRoot);}warningsForRoot.push(fiber);}};ReactStrictModeWarnings.flushLegacyContextWarning=function(){pendingLegacyContextWarning.forEach(function(fiberArray,strictRoot){var uniqueNames=new Set();fiberArray.forEach(function(fiber){uniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutLegacyContext.add(fiber.type);});var sortedNames=setToSortedString(uniqueNames);var strictRootComponentStack=getStackByFiberInDevAndProd(strictRoot);warningWithoutStack$1(false,'Legacy context API has been detected within a strict-mode tree: %s'+'\n\nPlease update the following components: %s'+'\n\nLearn more about this warning here:'+'\nhttps://fb.me/react-strict-mode-warnings',strictRootComponentStack,sortedNames);});};}// This lets us hook into Fiber to debug what it's doing.
// See https://github.com/facebook/react/pull/8033.
// This is not part of the public API, not even for React DevTools.
// You may only inject a debugTool if you work on React Fiber itself.
var ReactFiberInstrumentation={debugTool:null};var ReactFiberInstrumentation_1=ReactFiberInstrumentation;// TODO: Offscreen updates should never suspend. However, a promise that
// suspended inside an offscreen subtree should be able to ping at the priority
// of the outer render.
function markPendingPriorityLevel(root,expirationTime){// If there's a gap between completing a failed root and retrying it,
// additional updates may be scheduled. Clear `didError`, in case the update
// is sufficient to fix the error.
root.didError=false;// Update the latest and earliest pending times
var earliestPendingTime=root.earliestPendingTime;if(earliestPendingTime===NoWork){// No other pending updates.
root.earliestPendingTime=root.latestPendingTime=expirationTime;}else{if(earliestPendingTime>expirationTime){// This is the earliest pending update.
root.earliestPendingTime=expirationTime;}else{var latestPendingTime=root.latestPendingTime;if(latestPendingTime<expirationTime){// This is the latest pending update
root.latestPendingTime=expirationTime;}}}findNextExpirationTimeToWorkOn(expirationTime,root);}function markCommittedPriorityLevels(root,earliestRemainingTime){root.didError=false;if(earliestRemainingTime===NoWork){// Fast path. There's no remaining work. Clear everything.
root.earliestPendingTime=NoWork;root.latestPendingTime=NoWork;root.earliestSuspendedTime=NoWork;root.latestSuspendedTime=NoWork;root.latestPingedTime=NoWork;findNextExpirationTimeToWorkOn(NoWork,root);return;}// Let's see if the previous latest known pending level was just flushed.
var latestPendingTime=root.latestPendingTime;if(latestPendingTime!==NoWork){if(latestPendingTime<earliestRemainingTime){// We've flushed all the known pending levels.
root.earliestPendingTime=root.latestPendingTime=NoWork;}else{var earliestPendingTime=root.earliestPendingTime;if(earliestPendingTime<earliestRemainingTime){// We've flushed the earliest known pending level. Set this to the
// latest pending time.
root.earliestPendingTime=root.latestPendingTime;}}}// Now let's handle the earliest remaining level in the whole tree. We need to
// decide whether to treat it as a pending level or as suspended. Check
// it falls within the range of known suspended levels.
var earliestSuspendedTime=root.earliestSuspendedTime;if(earliestSuspendedTime===NoWork){// There's no suspended work. Treat the earliest remaining level as a
// pending level.
markPendingPriorityLevel(root,earliestRemainingTime);findNextExpirationTimeToWorkOn(NoWork,root);return;}var latestSuspendedTime=root.latestSuspendedTime;if(earliestRemainingTime>latestSuspendedTime){// The earliest remaining level is later than all the suspended work. That
// means we've flushed all the suspended work.
root.earliestSuspendedTime=NoWork;root.latestSuspendedTime=NoWork;root.latestPingedTime=NoWork;// There's no suspended work. Treat the earliest remaining level as a
// pending level.
markPendingPriorityLevel(root,earliestRemainingTime);findNextExpirationTimeToWorkOn(NoWork,root);return;}if(earliestRemainingTime<earliestSuspendedTime){// The earliest remaining time is earlier than all the suspended work.
// Treat it as a pending update.
markPendingPriorityLevel(root,earliestRemainingTime);findNextExpirationTimeToWorkOn(NoWork,root);return;}// The earliest remaining time falls within the range of known suspended
// levels. We should treat this as suspended work.
findNextExpirationTimeToWorkOn(NoWork,root);}function hasLowerPriorityWork(root,erroredExpirationTime){var latestPendingTime=root.latestPendingTime;var latestSuspendedTime=root.latestSuspendedTime;var latestPingedTime=root.latestPingedTime;return latestPendingTime!==NoWork&&latestPendingTime>erroredExpirationTime||latestSuspendedTime!==NoWork&&latestSuspendedTime>erroredExpirationTime||latestPingedTime!==NoWork&&latestPingedTime>erroredExpirationTime;}function isPriorityLevelSuspended(root,expirationTime){var earliestSuspendedTime=root.earliestSuspendedTime;var latestSuspendedTime=root.latestSuspendedTime;return earliestSuspendedTime!==NoWork&&expirationTime>=earliestSuspendedTime&&expirationTime<=latestSuspendedTime;}function markSuspendedPriorityLevel(root,suspendedTime){root.didError=false;clearPing(root,suspendedTime);// First, check the known pending levels and update them if needed.
var earliestPendingTime=root.earliestPendingTime;var latestPendingTime=root.latestPendingTime;if(earliestPendingTime===suspendedTime){if(latestPendingTime===suspendedTime){// Both known pending levels were suspended. Clear them.
root.earliestPendingTime=root.latestPendingTime=NoWork;}else{// The earliest pending level was suspended. Clear by setting it to the
// latest pending level.
root.earliestPendingTime=latestPendingTime;}}else if(latestPendingTime===suspendedTime){// The latest pending level was suspended. Clear by setting it to the
// latest pending level.
root.latestPendingTime=earliestPendingTime;}// Finally, update the known suspended levels.
var earliestSuspendedTime=root.earliestSuspendedTime;var latestSuspendedTime=root.latestSuspendedTime;if(earliestSuspendedTime===NoWork){// No other suspended levels.
root.earliestSuspendedTime=root.latestSuspendedTime=suspendedTime;}else{if(earliestSuspendedTime>suspendedTime){// This is the earliest suspended level.
root.earliestSuspendedTime=suspendedTime;}else if(latestSuspendedTime<suspendedTime){// This is the latest suspended level
root.latestSuspendedTime=suspendedTime;}}findNextExpirationTimeToWorkOn(suspendedTime,root);}function markPingedPriorityLevel(root,pingedTime){root.didError=false;// TODO: When we add back resuming, we need to ensure the progressed work
// is thrown out and not reused during the restarted render. One way to
// invalidate the progressed work is to restart at expirationTime + 1.
var latestPingedTime=root.latestPingedTime;if(latestPingedTime===NoWork||latestPingedTime<pingedTime){root.latestPingedTime=pingedTime;}findNextExpirationTimeToWorkOn(pingedTime,root);}function clearPing(root,completedTime){// TODO: Track whether the root was pinged during the render phase. If so,
// we need to make sure we don't lose track of it.
var latestPingedTime=root.latestPingedTime;if(latestPingedTime!==NoWork&&latestPingedTime<=completedTime){root.latestPingedTime=NoWork;}}function findEarliestOutstandingPriorityLevel(root,renderExpirationTime){var earliestExpirationTime=renderExpirationTime;var earliestPendingTime=root.earliestPendingTime;var earliestSuspendedTime=root.earliestSuspendedTime;if(earliestExpirationTime===NoWork||earliestPendingTime!==NoWork&&earliestPendingTime<earliestExpirationTime){earliestExpirationTime=earliestPendingTime;}if(earliestExpirationTime===NoWork||earliestSuspendedTime!==NoWork&&earliestSuspendedTime<earliestExpirationTime){earliestExpirationTime=earliestSuspendedTime;}return earliestExpirationTime;}function didExpireAtExpirationTime(root,currentTime){var expirationTime=root.expirationTime;if(expirationTime!==NoWork&&currentTime>=expirationTime){// The root has expired. Flush all work up to the current time.
root.nextExpirationTimeToWorkOn=currentTime;}}function findNextExpirationTimeToWorkOn(completedExpirationTime,root){var earliestSuspendedTime=root.earliestSuspendedTime;var latestSuspendedTime=root.latestSuspendedTime;var earliestPendingTime=root.earliestPendingTime;var latestPingedTime=root.latestPingedTime;// Work on the earliest pending time. Failing that, work on the latest
// pinged time.
var nextExpirationTimeToWorkOn=earliestPendingTime!==NoWork?earliestPendingTime:latestPingedTime;// If there is no pending or pinged work, check if there's suspended work
// that's lower priority than what we just completed.
if(nextExpirationTimeToWorkOn===NoWork&&(completedExpirationTime===NoWork||latestSuspendedTime>completedExpirationTime)){// The lowest priority suspended work is the work most likely to be
// committed next. Let's start rendering it again, so that if it times out,
// it's ready to commit.
nextExpirationTimeToWorkOn=latestSuspendedTime;}var expirationTime=nextExpirationTimeToWorkOn;if(expirationTime!==NoWork&&earliestSuspendedTime!==NoWork&&earliestSuspendedTime<expirationTime){// Expire using the earliest known expiration time.
expirationTime=earliestSuspendedTime;}root.nextExpirationTimeToWorkOn=nextExpirationTimeToWorkOn;root.expirationTime=expirationTime;}// UpdateQueue is a linked list of prioritized updates.
//
// Like fibers, update queues come in pairs: a current queue, which represents
// the visible state of the screen, and a work-in-progress queue, which is
// can be mutated and processed asynchronously before it is committed — a form
// of double buffering. If a work-in-progress render is discarded before
// finishing, we create a new work-in-progress by cloning the current queue.
//
// Both queues share a persistent, singly-linked list structure. To schedule an
// update, we append it to the end of both queues. Each queue maintains a
// pointer to first update in the persistent list that hasn't been processed.
// The work-in-progress pointer always has a position equal to or greater than
// the current queue, since we always work on that one. The current queue's
// pointer is only updated during the commit phase, when we swap in the
// work-in-progress.
//
// For example:
//
//   Current pointer:           A - B - C - D - E - F
//   Work-in-progress pointer:              D - E - F
//                                          ^
//                                          The work-in-progress queue has
//                                          processed more updates than current.
//
// The reason we append to both queues is because otherwise we might drop
// updates without ever processing them. For example, if we only add updates to
// the work-in-progress queue, some updates could be lost whenever a work-in
// -progress render restarts by cloning from current. Similarly, if we only add
// updates to the current queue, the updates will be lost whenever an already
// in-progress queue commits and swaps with the current queue. However, by
// adding to both queues, we guarantee that the update will be part of the next
// work-in-progress. (And because the work-in-progress queue becomes the
// current queue once it commits, there's no danger of applying the same
// update twice.)
//
// Prioritization
// --------------
//
// Updates are not sorted by priority, but by insertion; new updates are always
// appended to the end of the list.
//
// The priority is still important, though. When processing the update queue
// during the render phase, only the updates with sufficient priority are
// included in the result. If we skip an update because it has insufficient
// priority, it remains in the queue to be processed later, during a lower
// priority render. Crucially, all updates subsequent to a skipped update also
// remain in the queue *regardless of their priority*. That means high priority
// updates are sometimes processed twice, at two separate priorities. We also
// keep track of a base state, that represents the state before the first
// update in the queue is applied.
//
// For example:
//
//   Given a base state of '', and the following queue of updates
//
//     A1 - B2 - C1 - D2
//
//   where the number indicates the priority, and the update is applied to the
//   previous state by appending a letter, React will process these updates as
//   two separate renders, one per distinct priority level:
//
//   First render, at priority 1:
//     Base state: ''
//     Updates: [A1, C1]
//     Result state: 'AC'
//
//   Second render, at priority 2:
//     Base state: 'A'            <-  The base state does not include C1,
//                                    because B2 was skipped.
//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2
//     Result state: 'ABCD'
//
// Because we process updates in insertion order, and rebase high priority
// updates when preceding updates are skipped, the final result is deterministic
// regardless of priority. Intermediate state may vary according to system
// resources, but the final state is always the same.
var UpdateState=0;var ReplaceState=1;var ForceUpdate=2;var CaptureUpdate=3;// Global state that is reset at the beginning of calling `processUpdateQueue`.
// It should only be read right after calling `processUpdateQueue`, via
// `checkHasForceUpdateAfterProcessing`.
var hasForceUpdate=false;var didWarnUpdateInsideUpdate=void 0;var currentlyProcessingQueue=void 0;var resetCurrentlyProcessingQueue=void 0;{didWarnUpdateInsideUpdate=false;currentlyProcessingQueue=null;resetCurrentlyProcessingQueue=function resetCurrentlyProcessingQueue(){currentlyProcessingQueue=null;};}function createUpdateQueue(baseState){var queue={baseState:baseState,firstUpdate:null,lastUpdate:null,firstCapturedUpdate:null,lastCapturedUpdate:null,firstEffect:null,lastEffect:null,firstCapturedEffect:null,lastCapturedEffect:null};return queue;}function cloneUpdateQueue(currentQueue){var queue={baseState:currentQueue.baseState,firstUpdate:currentQueue.firstUpdate,lastUpdate:currentQueue.lastUpdate,// TODO: With resuming, if we bail out and resuse the child tree, we should
// keep these effects.
firstCapturedUpdate:null,lastCapturedUpdate:null,firstEffect:null,lastEffect:null,firstCapturedEffect:null,lastCapturedEffect:null};return queue;}function createUpdate(expirationTime){return{expirationTime:expirationTime,tag:UpdateState,payload:null,callback:null,next:null,nextEffect:null};}function appendUpdateToQueue(queue,update){// Append the update to the end of the list.
if(queue.lastUpdate===null){// Queue is empty
queue.firstUpdate=queue.lastUpdate=update;}else{queue.lastUpdate.next=update;queue.lastUpdate=update;}}function enqueueUpdate(fiber,update){// Update queues are created lazily.
var alternate=fiber.alternate;var queue1=void 0;var queue2=void 0;if(alternate===null){// There's only one fiber.
queue1=fiber.updateQueue;queue2=null;if(queue1===null){queue1=fiber.updateQueue=createUpdateQueue(fiber.memoizedState);}}else{// There are two owners.
queue1=fiber.updateQueue;queue2=alternate.updateQueue;if(queue1===null){if(queue2===null){// Neither fiber has an update queue. Create new ones.
queue1=fiber.updateQueue=createUpdateQueue(fiber.memoizedState);queue2=alternate.updateQueue=createUpdateQueue(alternate.memoizedState);}else{// Only one fiber has an update queue. Clone to create a new one.
queue1=fiber.updateQueue=cloneUpdateQueue(queue2);}}else{if(queue2===null){// Only one fiber has an update queue. Clone to create a new one.
queue2=alternate.updateQueue=cloneUpdateQueue(queue1);}else{// Both owners have an update queue.
}}}if(queue2===null||queue1===queue2){// There's only a single queue.
appendUpdateToQueue(queue1,update);}else{// There are two queues. We need to append the update to both queues,
// while accounting for the persistent structure of the list — we don't
// want the same update to be added multiple times.
if(queue1.lastUpdate===null||queue2.lastUpdate===null){// One of the queues is not empty. We must add the update to both queues.
appendUpdateToQueue(queue1,update);appendUpdateToQueue(queue2,update);}else{// Both queues are non-empty. The last update is the same in both lists,
// because of structural sharing. So, only append to one of the lists.
appendUpdateToQueue(queue1,update);// But we still need to update the `lastUpdate` pointer of queue2.
queue2.lastUpdate=update;}}{if((fiber.tag===ClassComponent||fiber.tag===ClassComponentLazy)&&(currentlyProcessingQueue===queue1||queue2!==null&&currentlyProcessingQueue===queue2)&&!didWarnUpdateInsideUpdate){warningWithoutStack$1(false,'An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}}function enqueueCapturedUpdate(workInProgress,update){// Captured updates go into a separate list, and only on the work-in-
// progress queue.
var workInProgressQueue=workInProgress.updateQueue;if(workInProgressQueue===null){workInProgressQueue=workInProgress.updateQueue=createUpdateQueue(workInProgress.memoizedState);}else{// TODO: I put this here rather than createWorkInProgress so that we don't
// clone the queue unnecessarily. There's probably a better way to
// structure this.
workInProgressQueue=ensureWorkInProgressQueueIsAClone(workInProgress,workInProgressQueue);}// Append the update to the end of the list.
if(workInProgressQueue.lastCapturedUpdate===null){// This is the first render phase update
workInProgressQueue.firstCapturedUpdate=workInProgressQueue.lastCapturedUpdate=update;}else{workInProgressQueue.lastCapturedUpdate.next=update;workInProgressQueue.lastCapturedUpdate=update;}}function ensureWorkInProgressQueueIsAClone(workInProgress,queue){var current=workInProgress.alternate;if(current!==null){// If the work-in-progress queue is equal to the current queue,
// we need to clone it first.
if(queue===current.updateQueue){queue=workInProgress.updateQueue=cloneUpdateQueue(queue);}}return queue;}function getStateFromUpdate(workInProgress,queue,update,prevState,nextProps,instance){switch(update.tag){case ReplaceState:{var _payload=update.payload;if(typeof _payload==='function'){// Updater function
{if(debugRenderPhaseSideEffects||debugRenderPhaseSideEffectsForStrictMode&&workInProgress.mode&StrictMode){_payload.call(instance,prevState,nextProps);}}return _payload.call(instance,prevState,nextProps);}// State object
return _payload;}case CaptureUpdate:{workInProgress.effectTag=workInProgress.effectTag&~ShouldCapture|DidCapture;}// Intentional fallthrough
case UpdateState:{var _payload2=update.payload;var partialState=void 0;if(typeof _payload2==='function'){// Updater function
{if(debugRenderPhaseSideEffects||debugRenderPhaseSideEffectsForStrictMode&&workInProgress.mode&StrictMode){_payload2.call(instance,prevState,nextProps);}}partialState=_payload2.call(instance,prevState,nextProps);}else{// Partial state object
partialState=_payload2;}if(partialState===null||partialState===undefined){// Null and undefined are treated as no-ops.
return prevState;}// Merge the partial state and the previous state.
return _assign({},prevState,partialState);}case ForceUpdate:{hasForceUpdate=true;return prevState;}}return prevState;}function processUpdateQueue(workInProgress,queue,props,instance,renderExpirationTime){hasForceUpdate=false;queue=ensureWorkInProgressQueueIsAClone(workInProgress,queue);{currentlyProcessingQueue=queue;}// These values may change as we process the queue.
var newBaseState=queue.baseState;var newFirstUpdate=null;var newExpirationTime=NoWork;// Iterate through the list of updates to compute the result.
var update=queue.firstUpdate;var resultState=newBaseState;while(update!==null){var updateExpirationTime=update.expirationTime;if(updateExpirationTime>renderExpirationTime){// This update does not have sufficient priority. Skip it.
if(newFirstUpdate===null){// This is the first skipped update. It will be the first update in
// the new list.
newFirstUpdate=update;// Since this is the first update that was skipped, the current result
// is the new base state.
newBaseState=resultState;}// Since this update will remain in the list, update the remaining
// expiration time.
if(newExpirationTime===NoWork||newExpirationTime>updateExpirationTime){newExpirationTime=updateExpirationTime;}}else{// This update does have sufficient priority. Process it and compute
// a new result.
resultState=getStateFromUpdate(workInProgress,queue,update,resultState,props,instance);var _callback=update.callback;if(_callback!==null){workInProgress.effectTag|=Callback;// Set this to null, in case it was mutated during an aborted render.
update.nextEffect=null;if(queue.lastEffect===null){queue.firstEffect=queue.lastEffect=update;}else{queue.lastEffect.nextEffect=update;queue.lastEffect=update;}}}// Continue to the next update.
update=update.next;}// Separately, iterate though the list of captured updates.
var newFirstCapturedUpdate=null;update=queue.firstCapturedUpdate;while(update!==null){var _updateExpirationTime=update.expirationTime;if(_updateExpirationTime>renderExpirationTime){// This update does not have sufficient priority. Skip it.
if(newFirstCapturedUpdate===null){// This is the first skipped captured update. It will be the first
// update in the new list.
newFirstCapturedUpdate=update;// If this is the first update that was skipped, the current result is
// the new base state.
if(newFirstUpdate===null){newBaseState=resultState;}}// Since this update will remain in the list, update the remaining
// expiration time.
if(newExpirationTime===NoWork||newExpirationTime>_updateExpirationTime){newExpirationTime=_updateExpirationTime;}}else{// This update does have sufficient priority. Process it and compute
// a new result.
resultState=getStateFromUpdate(workInProgress,queue,update,resultState,props,instance);var _callback2=update.callback;if(_callback2!==null){workInProgress.effectTag|=Callback;// Set this to null, in case it was mutated during an aborted render.
update.nextEffect=null;if(queue.lastCapturedEffect===null){queue.firstCapturedEffect=queue.lastCapturedEffect=update;}else{queue.lastCapturedEffect.nextEffect=update;queue.lastCapturedEffect=update;}}}update=update.next;}if(newFirstUpdate===null){queue.lastUpdate=null;}if(newFirstCapturedUpdate===null){queue.lastCapturedUpdate=null;}else{workInProgress.effectTag|=Callback;}if(newFirstUpdate===null&&newFirstCapturedUpdate===null){// We processed every update, without skipping. That means the new base
// state is the same as the result state.
newBaseState=resultState;}queue.baseState=newBaseState;queue.firstUpdate=newFirstUpdate;queue.firstCapturedUpdate=newFirstCapturedUpdate;// Set the remaining expiration time to be whatever is remaining in the queue.
// This should be fine because the only two other things that contribute to
// expiration time are props and context. We're already in the middle of the
// begin phase by the time we start processing the queue, so we've already
// dealt with the props. Context in components that specify
// shouldComponentUpdate is tricky; but we'll have to account for
// that regardless.
workInProgress.expirationTime=newExpirationTime;workInProgress.memoizedState=resultState;{currentlyProcessingQueue=null;}}function callCallback(callback,context){!(typeof callback==='function')?invariant(false,'Invalid argument passed as callback. Expected a function. Instead received: %s',callback):void 0;callback.call(context);}function resetHasForceUpdateBeforeProcessing(){hasForceUpdate=false;}function checkHasForceUpdateAfterProcessing(){return hasForceUpdate;}function commitUpdateQueue(finishedWork,finishedQueue,instance,renderExpirationTime){// If the finished render included captured updates, and there are still
// lower priority updates left over, we need to keep the captured updates
// in the queue so that they are rebased and not dropped once we process the
// queue again at the lower priority.
if(finishedQueue.firstCapturedUpdate!==null){// Join the captured update list to the end of the normal list.
if(finishedQueue.lastUpdate!==null){finishedQueue.lastUpdate.next=finishedQueue.firstCapturedUpdate;finishedQueue.lastUpdate=finishedQueue.lastCapturedUpdate;}// Clear the list of captured updates.
finishedQueue.firstCapturedUpdate=finishedQueue.lastCapturedUpdate=null;}// Commit the effects
commitUpdateEffects(finishedQueue.firstEffect,instance);finishedQueue.firstEffect=finishedQueue.lastEffect=null;commitUpdateEffects(finishedQueue.firstCapturedEffect,instance);finishedQueue.firstCapturedEffect=finishedQueue.lastCapturedEffect=null;}function commitUpdateEffects(effect,instance){while(effect!==null){var _callback3=effect.callback;if(_callback3!==null){effect.callback=null;callCallback(_callback3,instance);}effect=effect.nextEffect;}}function createCapturedValue(value,source){// If the value is an error, call this function immediately after it is thrown
// so the stack is accurate.
return{value:value,source:source,stack:getStackByFiberInDevAndProd(source)};}var valueCursor=createCursor(null);var rendererSigil=void 0;{// Use this to detect multiple renderers using the same context
rendererSigil={};}var currentlyRenderingFiber=null;var lastContextDependency=null;var lastContextWithAllBitsObserved=null;function resetContextDependences(){// This is called right before React yields execution, to ensure `readContext`
// cannot be called outside the render phase.
currentlyRenderingFiber=null;lastContextDependency=null;lastContextWithAllBitsObserved=null;}function pushProvider(providerFiber,nextValue){var context=providerFiber.type._context;if(isPrimaryRenderer){push(valueCursor,context._currentValue,providerFiber);context._currentValue=nextValue;{!(context._currentRenderer===undefined||context._currentRenderer===null||context._currentRenderer===rendererSigil)?warningWithoutStack$1(false,'Detected multiple renderers concurrently rendering the '+'same context provider. This is currently unsupported.'):void 0;context._currentRenderer=rendererSigil;}}else{push(valueCursor,context._currentValue2,providerFiber);context._currentValue2=nextValue;{!(context._currentRenderer2===undefined||context._currentRenderer2===null||context._currentRenderer2===rendererSigil)?warningWithoutStack$1(false,'Detected multiple renderers concurrently rendering the '+'same context provider. This is currently unsupported.'):void 0;context._currentRenderer2=rendererSigil;}}}function popProvider(providerFiber){var currentValue=valueCursor.current;pop(valueCursor,providerFiber);var context=providerFiber.type._context;if(isPrimaryRenderer){context._currentValue=currentValue;}else{context._currentValue2=currentValue;}}function calculateChangedBits(context,newValue,oldValue){// Use Object.is to compare the new context value to the old value. Inlined
// Object.is polyfill.
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
if(oldValue===newValue&&(oldValue!==0||1/oldValue===1/newValue)||oldValue!==oldValue&&newValue!==newValue// eslint-disable-line no-self-compare
){// No change
return 0;}else{var changedBits=typeof context._calculateChangedBits==='function'?context._calculateChangedBits(oldValue,newValue):maxSigned31BitInt;{!((changedBits&maxSigned31BitInt)===changedBits)?warning$1(false,'calculateChangedBits: Expected the return value to be a '+'31-bit integer. Instead received: %s',changedBits):void 0;}return changedBits|0;}}function propagateContextChange(workInProgress,context,changedBits,renderExpirationTime){var fiber=workInProgress.child;if(fiber!==null){// Set the return pointer of the child to the work-in-progress fiber.
fiber.return=workInProgress;}while(fiber!==null){var nextFiber=void 0;// Visit this fiber.
var dependency=fiber.firstContextDependency;if(dependency!==null){do{// Check if the context matches.
if(dependency.context===context&&(dependency.observedBits&changedBits)!==0){// Match! Schedule an update on this fiber.
if(fiber.tag===ClassComponent||fiber.tag===ClassComponentLazy){// Schedule a force update on the work-in-progress.
var update=createUpdate(renderExpirationTime);update.tag=ForceUpdate;// TODO: Because we don't have a work-in-progress, this will add the
// update to the current fiber, too, which means it will persist even if
// this render is thrown away. Since it's a race condition, not sure it's
// worth fixing.
enqueueUpdate(fiber,update);}if(fiber.expirationTime===NoWork||fiber.expirationTime>renderExpirationTime){fiber.expirationTime=renderExpirationTime;}var alternate=fiber.alternate;if(alternate!==null&&(alternate.expirationTime===NoWork||alternate.expirationTime>renderExpirationTime)){alternate.expirationTime=renderExpirationTime;}// Update the child expiration time of all the ancestors, including
// the alternates.
var node=fiber.return;while(node!==null){alternate=node.alternate;if(node.childExpirationTime===NoWork||node.childExpirationTime>renderExpirationTime){node.childExpirationTime=renderExpirationTime;if(alternate!==null&&(alternate.childExpirationTime===NoWork||alternate.childExpirationTime>renderExpirationTime)){alternate.childExpirationTime=renderExpirationTime;}}else if(alternate!==null&&(alternate.childExpirationTime===NoWork||alternate.childExpirationTime>renderExpirationTime)){alternate.childExpirationTime=renderExpirationTime;}else{// Neither alternate was updated, which means the rest of the
// ancestor path already has sufficient priority.
break;}node=node.return;}}nextFiber=fiber.child;dependency=dependency.next;}while(dependency!==null);}else if(fiber.tag===ContextProvider){// Don't scan deeper if this is a matching provider
nextFiber=fiber.type===workInProgress.type?null:fiber.child;}else{// Traverse down.
nextFiber=fiber.child;}if(nextFiber!==null){// Set the return pointer of the child to the work-in-progress fiber.
nextFiber.return=fiber;}else{// No child. Traverse to next sibling.
nextFiber=fiber;while(nextFiber!==null){if(nextFiber===workInProgress){// We're back to the root of this subtree. Exit.
nextFiber=null;break;}var sibling=nextFiber.sibling;if(sibling!==null){// Set the return pointer of the sibling to the work-in-progress fiber.
sibling.return=nextFiber.return;nextFiber=sibling;break;}// No more siblings. Traverse up.
nextFiber=nextFiber.return;}}fiber=nextFiber;}}function prepareToReadContext(workInProgress,renderExpirationTime){currentlyRenderingFiber=workInProgress;lastContextDependency=null;lastContextWithAllBitsObserved=null;// Reset the work-in-progress list
workInProgress.firstContextDependency=null;}function readContext(context,observedBits){if(lastContextWithAllBitsObserved===context){// Nothing to do. We already observe everything in this context.
}else if(observedBits===false||observedBits===0){// Do not observe any updates.
}else{var resolvedObservedBits=void 0;// Avoid deopting on observable arguments or heterogeneous types.
if(typeof observedBits!=='number'||observedBits===maxSigned31BitInt){// Observe all updates.
lastContextWithAllBitsObserved=context;resolvedObservedBits=maxSigned31BitInt;}else{resolvedObservedBits=observedBits;}var contextItem={context:context,observedBits:resolvedObservedBits,next:null};if(lastContextDependency===null){!(currentlyRenderingFiber!==null)?invariant(false,'Context.unstable_read(): Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps.'):void 0;// This is the first dependency in the list
currentlyRenderingFiber.firstContextDependency=lastContextDependency=contextItem;}else{// Append a new context item.
lastContextDependency=lastContextDependency.next=contextItem;}}return isPrimaryRenderer?context._currentValue:context._currentValue2;}var NO_CONTEXT={};var contextStackCursor$1=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){!(c!==NO_CONTEXT)?invariant(false,'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.'):void 0;return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;
// This allows us to reset root when portals are popped.
push(rootInstanceStackCursor,nextRootInstance,fiber);// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);// Finally, we need to push the host context to the stack.
// However, we can't just call getRootHostContext() and push it because
// we'd have a different number of entries on the stack depending on
// whether getRootHostContext() throws somewhere in renderer code or not.
// So we push an empty value first. This lets us safely unwind on errors.
push(contextStackCursor$1,NO_CONTEXT,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Now that we know this function doesn't throw, replace it.
pop(contextStackCursor$1,fiber);push(contextStackCursor$1,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor$1.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor$1.current);var nextContext=getChildHostContext(context,fiber.type,rootInstance);// Don't push this Fiber's context unless it's unique.
if(context===nextContext){return;}// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor$1,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.
// pushHostContext() only pushes Fibers that provide unique contexts.
if(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);}var commitTime=0;var profilerStartTime=-1;function getCommitTime(){return commitTime;}function recordCommitTime(){if(!enableProfilerTimer){return;}commitTime=schedule.unstable_now();}function startProfilerTimer(fiber){if(!enableProfilerTimer){return;}profilerStartTime=schedule.unstable_now();if(fiber.actualStartTime<0){fiber.actualStartTime=schedule.unstable_now();}}function stopProfilerTimerIfRunning(fiber){if(!enableProfilerTimer){return;}profilerStartTime=-1;}function stopProfilerTimerIfRunningAndRecordDelta(fiber,overrideBaseTime){if(!enableProfilerTimer){return;}if(profilerStartTime>=0){var elapsedTime=schedule.unstable_now()-profilerStartTime;fiber.actualDuration+=elapsedTime;if(overrideBaseTime){fiber.selfBaseDuration=elapsedTime;}profilerStartTime=-1;}}var fakeInternalInstance={};var isArray=Array.isArray;// React.Component uses a shared frozen object by default.
// We'll use it to determine whether we need to initialize legacy refs.
var emptyRefsObject=new React.Component().refs;var didWarnAboutStateAssignmentForComponent=void 0;var didWarnAboutUninitializedState=void 0;var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=void 0;var didWarnAboutLegacyLifecyclesAndDerivedState=void 0;var didWarnAboutUndefinedDerivedState=void 0;var warnOnUndefinedDerivedState=void 0;var warnOnInvalidCallback$1=void 0;var didWarnAboutDirectlyAssigningPropsToState=void 0;{didWarnAboutStateAssignmentForComponent=new Set();didWarnAboutUninitializedState=new Set();didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=new Set();didWarnAboutLegacyLifecyclesAndDerivedState=new Set();didWarnAboutDirectlyAssigningPropsToState=new Set();didWarnAboutUndefinedDerivedState=new Set();var didWarnOnInvalidCallback=new Set();warnOnInvalidCallback$1=function warnOnInvalidCallback$1(callback,callerName){if(callback===null||typeof callback==='function'){return;}var key=callerName+'_'+callback;if(!didWarnOnInvalidCallback.has(key)){didWarnOnInvalidCallback.add(key);warningWithoutStack$1(false,'%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}};warnOnUndefinedDerivedState=function warnOnUndefinedDerivedState(type,partialState){if(partialState===undefined){var componentName=getComponentName(type)||'Component';if(!didWarnAboutUndefinedDerivedState.has(componentName)){didWarnAboutUndefinedDerivedState.add(componentName);warningWithoutStack$1(false,'%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. '+'You have returned undefined.',componentName);}}};// This is so gross but it's at least non-critical and can be removed if
// it causes problems. This is meant to give a nicer error message for
// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
// ...)) which otherwise throws a "_processChildContext is not a function"
// exception.
Object.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function value(){invariant(false,'_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}function applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,nextProps){var prevState=workInProgress.memoizedState;{if(debugRenderPhaseSideEffects||debugRenderPhaseSideEffectsForStrictMode&&workInProgress.mode&StrictMode){// Invoke the function an extra time to help detect side-effects.
getDerivedStateFromProps(nextProps,prevState);}}var partialState=getDerivedStateFromProps(nextProps,prevState);{warnOnUndefinedDerivedState(ctor,partialState);}// Merge the partial state and the previous state.
var memoizedState=partialState===null||partialState===undefined?prevState:_assign({},prevState,partialState);workInProgress.memoizedState=memoizedState;// Once the update queue is empty, persist the derived state onto the
// base state.
var updateQueue=workInProgress.updateQueue;if(updateQueue!==null&&workInProgress.expirationTime===NoWork){updateQueue.baseState=memoizedState;}}var classComponentUpdater={isMounted:isMounted,enqueueSetState:function enqueueSetState(inst,payload,callback){var fiber=get(inst);var currentTime=requestCurrentTime();var expirationTime=computeExpirationForFiber(currentTime,fiber);var update=createUpdate(expirationTime);update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback$1(callback,'setState');}update.callback=callback;}enqueueUpdate(fiber,update);scheduleWork(fiber,expirationTime);},enqueueReplaceState:function enqueueReplaceState(inst,payload,callback){var fiber=get(inst);var currentTime=requestCurrentTime();var expirationTime=computeExpirationForFiber(currentTime,fiber);var update=createUpdate(expirationTime);update.tag=ReplaceState;update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback$1(callback,'replaceState');}update.callback=callback;}enqueueUpdate(fiber,update);scheduleWork(fiber,expirationTime);},enqueueForceUpdate:function enqueueForceUpdate(inst,callback){var fiber=get(inst);var currentTime=requestCurrentTime();var expirationTime=computeExpirationForFiber(currentTime,fiber);var update=createUpdate(expirationTime);update.tag=ForceUpdate;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback$1(callback,'forceUpdate');}update.callback=callback;}enqueueUpdate(fiber,update);scheduleWork(fiber,expirationTime);}};function checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextLegacyContext){var instance=workInProgress.stateNode;if(typeof instance.shouldComponentUpdate==='function'){startPhaseTimer(workInProgress,'shouldComponentUpdate');var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextLegacyContext);stopPhaseTimer();{!(shouldUpdate!==undefined)?warningWithoutStack$1(false,'%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentName(ctor)||'Component'):void 0;}return shouldUpdate;}if(ctor.prototype&&ctor.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress,ctor,newProps){var instance=workInProgress.stateNode;{var name=getComponentName(ctor)||'Component';var renderPresent=instance.render;if(!renderPresent){if(ctor.prototype&&typeof ctor.prototype.render==='function'){warningWithoutStack$1(false,'%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{warningWithoutStack$1(false,'%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}var noGetInitialStateOnES6=!instance.getInitialState||instance.getInitialState.isReactClassApproved||instance.state;!noGetInitialStateOnES6?warningWithoutStack$1(false,'getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name):void 0;var noGetDefaultPropsOnES6=!instance.getDefaultProps||instance.getDefaultProps.isReactClassApproved;!noGetDefaultPropsOnES6?warningWithoutStack$1(false,'getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name):void 0;var noInstancePropTypes=!instance.propTypes;!noInstancePropTypes?warningWithoutStack$1(false,'propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name):void 0;var noInstanceContextTypes=!instance.contextTypes;!noInstanceContextTypes?warningWithoutStack$1(false,'contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name):void 0;var noComponentShouldUpdate=typeof instance.componentShouldUpdate!=='function';!noComponentShouldUpdate?warningWithoutStack$1(false,'%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name):void 0;if(ctor.prototype&&ctor.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){warningWithoutStack$1(false,'%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentName(ctor)||'A pure component');}var noComponentDidUnmount=typeof instance.componentDidUnmount!=='function';!noComponentDidUnmount?warningWithoutStack$1(false,'%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name):void 0;var noComponentDidReceiveProps=typeof instance.componentDidReceiveProps!=='function';!noComponentDidReceiveProps?warningWithoutStack$1(false,'%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name):void 0;var noComponentWillRecieveProps=typeof instance.componentWillRecieveProps!=='function';!noComponentWillRecieveProps?warningWithoutStack$1(false,'%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name):void 0;var noUnsafeComponentWillRecieveProps=typeof instance.UNSAFE_componentWillRecieveProps!=='function';!noUnsafeComponentWillRecieveProps?warningWithoutStack$1(false,'%s has a method called '+'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',name):void 0;var hasMutatedProps=instance.props!==newProps;!(instance.props===undefined||!hasMutatedProps)?warningWithoutStack$1(false,'%s(...): When calling super() in `%s`, make sure to pass '+"up the same props that your component's constructor was passed.",name,name):void 0;var noInstanceDefaultProps=!instance.defaultProps;!noInstanceDefaultProps?warningWithoutStack$1(false,'Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name):void 0;if(typeof instance.getSnapshotBeforeUpdate==='function'&&typeof instance.componentDidUpdate!=='function'&&!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)){didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);warningWithoutStack$1(false,'%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). '+'This component defines getSnapshotBeforeUpdate() only.',getComponentName(ctor));}var noInstanceGetDerivedStateFromProps=typeof instance.getDerivedStateFromProps!=='function';!noInstanceGetDerivedStateFromProps?warningWithoutStack$1(false,'%s: getDerivedStateFromProps() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name):void 0;var noInstanceGetDerivedStateFromCatch=typeof instance.getDerivedStateFromCatch!=='function';!noInstanceGetDerivedStateFromCatch?warningWithoutStack$1(false,'%s: getDerivedStateFromCatch() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name):void 0;var noStaticGetSnapshotBeforeUpdate=typeof ctor.getSnapshotBeforeUpdate!=='function';!noStaticGetSnapshotBeforeUpdate?warningWithoutStack$1(false,'%s: getSnapshotBeforeUpdate() is defined as a static method '+'and will be ignored. Instead, declare it as an instance method.',name):void 0;var _state=instance.state;if(_state&&((typeof _state==='undefined'?'undefined':_typeof(_state))!=='object'||isArray(_state))){warningWithoutStack$1(false,'%s.state: must be set to an object or null',name);}if(typeof instance.getChildContext==='function'){!(_typeof(ctor.childContextTypes)==='object')?warningWithoutStack$1(false,'%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',name):void 0;}}}function adoptClassInstance(workInProgress,instance){instance.updater=classComponentUpdater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates
set(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,ctor,props,renderExpirationTime){var unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);var contextTypes=ctor.contextTypes;var isContextConsumer=contextTypes!==null&&contextTypes!==undefined;var context=isContextConsumer?getMaskedContext(workInProgress,unmaskedContext):emptyContextObject;// Instantiate twice to help detect side-effects.
{if(debugRenderPhaseSideEffects||debugRenderPhaseSideEffectsForStrictMode&&workInProgress.mode&StrictMode){new ctor(props,context);// eslint-disable-line no-new
}}var instance=new ctor(props,context);var state=workInProgress.memoizedState=instance.state!==null&&instance.state!==undefined?instance.state:null;adoptClassInstance(workInProgress,instance);{if(typeof ctor.getDerivedStateFromProps==='function'&&state===null){var componentName=getComponentName(ctor)||'Component';if(!didWarnAboutUninitializedState.has(componentName)){didWarnAboutUninitializedState.add(componentName);warningWithoutStack$1(false,'`%s` uses `getDerivedStateFromProps` but its initial state is '+'%s. This is not recommended. Instead, define the initial state by '+'assigning an object to `this.state` in the constructor of `%s`. '+'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',componentName,instance.state===null?'null':'undefined',componentName);}}// If new component APIs are defined, "unsafe" lifecycles won't be called.
// Warn about these lifecycles if they are present.
// Don't warn about react-lifecycles-compat polyfilled methods though.
if(typeof ctor.getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function'){var foundWillMountName=null;var foundWillReceivePropsName=null;var foundWillUpdateName=null;if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true){foundWillMountName='componentWillMount';}else if(typeof instance.UNSAFE_componentWillMount==='function'){foundWillMountName='UNSAFE_componentWillMount';}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){foundWillReceivePropsName='componentWillReceiveProps';}else if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){foundWillReceivePropsName='UNSAFE_componentWillReceiveProps';}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){foundWillUpdateName='componentWillUpdate';}else if(typeof instance.UNSAFE_componentWillUpdate==='function'){foundWillUpdateName='UNSAFE_componentWillUpdate';}if(foundWillMountName!==null||foundWillReceivePropsName!==null||foundWillUpdateName!==null){var _componentName=getComponentName(ctor)||'Component';var newApiName=typeof ctor.getDerivedStateFromProps==='function'?'getDerivedStateFromProps()':'getSnapshotBeforeUpdate()';if(!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)){didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);warningWithoutStack$1(false,'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n'+'%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n'+'The above lifecycles should be removed. Learn more about this warning here:\n'+'https://fb.me/react-async-component-lifecycle-hooks',_componentName,newApiName,foundWillMountName!==null?'\n  '+foundWillMountName:'',foundWillReceivePropsName!==null?'\n  '+foundWillReceivePropsName:'',foundWillUpdateName!==null?'\n  '+foundWillUpdateName:'');}}}}// Cache unmasked context so we can avoid recreating masked context unless necessary.
// ReactFiberContext usually updates this cache but can't for newly-created instances.
if(isContextConsumer){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){startPhaseTimer(workInProgress,'componentWillMount');var oldState=instance.state;if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}stopPhaseTimer();if(oldState!==instance.state){{warningWithoutStack$1(false,'%s.componentWillMount(): Assigning directly to this.state is '+"deprecated (except inside a component's "+'constructor). Use setState instead.',getComponentName(workInProgress.type)||'Component');}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,nextLegacyContext){var oldState=instance.state;startPhaseTimer(workInProgress,'componentWillReceiveProps');if(typeof instance.componentWillReceiveProps==='function'){instance.componentWillReceiveProps(newProps,nextLegacyContext);}if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){instance.UNSAFE_componentWillReceiveProps(newProps,nextLegacyContext);}stopPhaseTimer();if(instance.state!==oldState){{var componentName=getComponentName(workInProgress.type)||'Component';if(!didWarnAboutStateAssignmentForComponent.has(componentName)){didWarnAboutStateAssignmentForComponent.add(componentName);warningWithoutStack$1(false,'%s.componentWillReceiveProps(): Assigning directly to '+"this.state is deprecated (except inside a component's "+'constructor). Use setState instead.',componentName);}}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.
function mountClassInstance(workInProgress,ctor,newProps,renderExpirationTime){{checkClassInstance(workInProgress,ctor,newProps);}var instance=workInProgress.stateNode;var unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);instance.props=newProps;instance.state=workInProgress.memoizedState;instance.refs=emptyRefsObject;instance.context=getMaskedContext(workInProgress,unmaskedContext);{if(instance.state===newProps){var componentName=getComponentName(ctor)||'Component';if(!didWarnAboutDirectlyAssigningPropsToState.has(componentName)){didWarnAboutDirectlyAssigningPropsToState.add(componentName);warningWithoutStack$1(false,'%s: It is not recommended to assign props directly to state '+"because updates to props won't be reflected in state. "+'In most cases, it is better to use props directly.',componentName);}}if(workInProgress.mode&StrictMode){ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress,instance);ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,instance);}if(warnAboutDeprecatedLifecycles){ReactStrictModeWarnings.recordDeprecationWarnings(workInProgress,instance);}}var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){processUpdateQueue(workInProgress,updateQueue,newProps,instance,renderExpirationTime);instance.state=workInProgress.memoizedState;}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);instance.state=workInProgress.memoizedState;}// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(typeof ctor.getDerivedStateFromProps!=='function'&&typeof instance.getSnapshotBeforeUpdate!=='function'&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's
// process them now.
updateQueue=workInProgress.updateQueue;if(updateQueue!==null){processUpdateQueue(workInProgress,updateQueue,newProps,instance,renderExpirationTime);instance.state=workInProgress.memoizedState;}}if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}}function resumeMountClassInstance(workInProgress,ctor,newProps,renderExpirationTime){var instance=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;instance.props=oldProps;var oldContext=instance.context;var nextLegacyUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);var nextLegacyContext=getMaskedContext(workInProgress,nextLegacyUnmaskedContext);var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what
// ever the previously attempted to render - not the "current". However,
// during componentDidUpdate we pass the "current" props.
// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==nextLegacyContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextLegacyContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){processUpdateQueue(workInProgress,updateQueue,newProps,instance,renderExpirationTime);newState=workInProgress.memoizedState;}if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextLegacyContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){startPhaseTimer(workInProgress,'componentWillMount');if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}stopPhaseTimer();}if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}}else{// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}// If shouldComponentUpdate returned false, we should still update the
// memoized state to indicate that this work can be reused.
workInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even
// if shouldComponentUpdate returns false.
instance.props=newProps;instance.state=newState;instance.context=nextLegacyContext;return shouldUpdate;}// Invokes the update life-cycles and returns false if it shouldn't rerender.
function updateClassInstance(current,workInProgress,ctor,newProps,renderExpirationTime){var instance=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;instance.props=oldProps;var oldContext=instance.context;var nextLegacyUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);var nextLegacyContext=getMaskedContext(workInProgress,nextLegacyUnmaskedContext);var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what
// ever the previously attempted to render - not the "current". However,
// during componentDidUpdate we pass the "current" props.
// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==nextLegacyContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextLegacyContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){processUpdateQueue(workInProgress,updateQueue,newProps,instance,renderExpirationTime);newState=workInProgress.memoizedState;}if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Snapshot;}}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextLegacyContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillUpdate==='function'||typeof instance.componentWillUpdate==='function')){startPhaseTimer(workInProgress,'componentWillUpdate');if(typeof instance.componentWillUpdate==='function'){instance.componentWillUpdate(newProps,newState,nextLegacyContext);}if(typeof instance.UNSAFE_componentWillUpdate==='function'){instance.UNSAFE_componentWillUpdate(newProps,newState,nextLegacyContext);}stopPhaseTimer();}if(typeof instance.componentDidUpdate==='function'){workInProgress.effectTag|=Update;}if(typeof instance.getSnapshotBeforeUpdate==='function'){workInProgress.effectTag|=Snapshot;}}else{// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Snapshot;}}// If shouldComponentUpdate returned false, we should still update the
// memoized props/state to indicate that this work can be reused.
workInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even
// if shouldComponentUpdate returns false.
instance.props=newProps;instance.state=newState;instance.context=nextLegacyContext;return shouldUpdate;}var didWarnAboutMaps=void 0;var didWarnAboutGenerators=void 0;var didWarnAboutStringRefInStrictMode=void 0;var ownerHasKeyUseWarning=void 0;var ownerHasFunctionTypeWarning=void 0;var warnForMissingKey=function warnForMissingKey(child){};{didWarnAboutMaps=false;didWarnAboutGenerators=false;didWarnAboutStringRefInStrictMode={};/**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */ownerHasKeyUseWarning={};ownerHasFunctionTypeWarning={};warnForMissingKey=function warnForMissingKey(child){if(child===null||(typeof child==='undefined'?'undefined':_typeof(child))!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}!(_typeof(child._store)==='object')?invariant(false,'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.'):void 0;child._store.validated=true;var currentComponentErrorInfo='Each child in an array or iterator should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.'+getCurrentFiberStackInDev();if(ownerHasKeyUseWarning[currentComponentErrorInfo]){return;}ownerHasKeyUseWarning[currentComponentErrorInfo]=true;warning$1(false,'Each child in an array or iterator should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.');};}var isArray$1=Array.isArray;function coerceRef(returnFiber,current$$1,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'&&(typeof mixedRef==='undefined'?'undefined':_typeof(mixedRef))!=='object'){{if(returnFiber.mode&StrictMode){var componentName=getComponentName(returnFiber.type)||'Component';if(!didWarnAboutStringRefInStrictMode[componentName]){warningWithoutStack$1(false,'A string ref, "%s", has been found within a strict mode tree. '+'String refs are a source of potential bugs and should be avoided. '+'We recommend using createRef() instead.'+'\n%s'+'\n\nLearn more about using refs safely here:'+'\nhttps://fb.me/react-strict-mode-string-ref',mixedRef,getStackByFiberInDevAndProd(returnFiber));didWarnAboutStringRefInStrictMode[componentName]=true;}}}if(element._owner){var owner=element._owner;var inst=void 0;if(owner){var ownerFiber=owner;!(ownerFiber.tag===ClassComponent||ownerFiber.tag===ClassComponentLazy)?invariant(false,'Stateless function components cannot have refs.'):void 0;inst=ownerFiber.stateNode;}!inst?invariant(false,'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.',mixedRef):void 0;var stringRef=''+mixedRef;// Check if previous string ref matches new string ref
if(current$$1!==null&&current$$1.ref!==null&&typeof current$$1.ref==='function'&&current$$1.ref._stringRef===stringRef){return current$$1.ref;}var ref=function ref(value){var refs=inst.refs;if(refs===emptyRefsObject){// This is a lazy pooled frozen object, so we need to initialize.
refs=inst.refs={};}if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{!(typeof mixedRef==='string')?invariant(false,'Expected ref to be a function, a string, an object returned by React.createRef(), or null.'):void 0;!element._owner?invariant(false,'Element ref was specified as a string (%s) but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a functional component\n2. You may be adding a ref to a component that was not created inside a component\'s render method\n3. You have multiple copies of React loaded\nSee https://fb.me/react-refs-must-have-owner for more information.',mixedRef):void 0;}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){if(returnFiber.type!=='textarea'){var addendum='';{addendum=' If you meant to render a collection of children, use an array '+'instead.'+getCurrentFiberStackInDev();}invariant(false,'Objects are not valid as a React child (found: %s).%s',Object.prototype.toString.call(newChild)==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':newChild,addendum);}}function warnOnFunctionType(){var currentComponentErrorInfo='Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.'+getCurrentFiberStackInDev();if(ownerHasFunctionTypeWarning[currentComponentErrorInfo]){return;}ownerHasFunctionTypeWarning[currentComponentErrorInfo]=true;warning$1(false,'Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.');}// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.
return;}// Deletions are added in reversed order so we add it to the front.
// At this point, the return fiber's effect list is empty except for
// deletions, so we can just append the deletion to the list. The remaining
// effects aren't added until the complete phase. Once we implement
// resuming, this may not be true.
var last=returnFiber.lastEffect;if(last!==null){last.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}childToDelete.nextEffect=null;childToDelete.effectTag=Deletion;}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.
return null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by
// assuming that after the first child we've already added everything.
var childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by
// keys quickly. Implicit (null) keys get added to this set with their index
var existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps,expirationTime){// We currently set sibling to null and index to 0 here because it is easy
// to forget to do before returning it. E.g. for the single child case.
var clone=createWorkInProgress(fiber,pendingProps,expirationTime);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// Noop.
return lastPlacedIndex;}var current$$1=newFiber.alternate;if(current$$1!==null){var oldIndex=current$$1.index;if(oldIndex<lastPlacedIndex){// This is a move.
newFiber.effectTag=Placement;return lastPlacedIndex;}else{// This item can stay in place.
return oldIndex;}}else{// This is an insertion.
newFiber.effectTag=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a
// placement for inserting new children.
if(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.effectTag=Placement;}return newFiber;}function updateTextNode(returnFiber,current$$1,textContent,expirationTime){if(current$$1===null||current$$1.tag!==HostText){// Insert
var created=createFiberFromText(textContent,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}else{// Update
var existing=useFiber(current$$1,textContent,expirationTime);existing.return=returnFiber;return existing;}}function updateElement(returnFiber,current$$1,element,expirationTime){if(current$$1!==null&&current$$1.type===element.type){// Move based on index
var existing=useFiber(current$$1,element.props,expirationTime);existing.ref=coerceRef(returnFiber,current$$1,element);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{// Insert
var created=createFiberFromElement(element,returnFiber.mode,expirationTime);created.ref=coerceRef(returnFiber,current$$1,element);created.return=returnFiber;return created;}}function updatePortal(returnFiber,current$$1,portal,expirationTime){if(current$$1===null||current$$1.tag!==HostPortal||current$$1.stateNode.containerInfo!==portal.containerInfo||current$$1.stateNode.implementation!==portal.implementation){// Insert
var created=createFiberFromPortal(portal,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}else{// Update
var existing=useFiber(current$$1,portal.children||[],expirationTime);existing.return=returnFiber;return existing;}}function updateFragment(returnFiber,current$$1,fragment,expirationTime,key){if(current$$1===null||current$$1.tag!==Fragment){// Insert
var created=createFiberFromFragment(fragment,returnFiber.mode,expirationTime,key);created.return=returnFiber;return created;}else{// Update
var existing=useFiber(current$$1,fragment,expirationTime);existing.return=returnFiber;return existing;}}function createChild(returnFiber,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
var created=createFiberFromText(''+newChild,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _created=createFiberFromElement(newChild,returnFiber.mode,expirationTime);_created.ref=coerceRef(returnFiber,null,newChild);_created.return=returnFiber;return _created;}case REACT_PORTAL_TYPE:{var _created2=createFiberFromPortal(newChild,returnFiber.mode,expirationTime);_created2.return=returnFiber;return _created2;}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _created3=createFiberFromFragment(newChild,returnFiber.mode,expirationTime,null);_created3.return=returnFiber;return _created3;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateSlot(returnFiber,oldFiber,newChild,expirationTime){// Update the fiber if the keys match, otherwise return null.
var key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
if(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,expirationTime);}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,oldFiber,newChild.props.children,expirationTime,key);}return updateElement(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}}if(isArray$1(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor
// new node for the key. If both are text nodes, they match.
var matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,expirationTime);}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,_matchedFiber,newChild.props.children,expirationTime,newChild.key);}return updateElement(returnFiber,_matchedFiber,newChild,expirationTime);}case REACT_PORTAL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber2,newChild,expirationTime);}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _matchedFiber3=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber3,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}/**
   * Warns if there is a duplicate or missing key
   */function warnOnInvalidKey(child,knownKeys){{if((typeof child==='undefined'?'undefined':_typeof(child))!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}warning$1(false,'Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted — the behavior is unsupported and '+'could change in a future version.',key);break;default:break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,expirationTime){// This algorithm can't optimize by searching from boths ends since we
// don't have backpointers on fibers. I'm trying to see how far we can get
// with that model. If it ends up not being worth the tradeoffs, we can
// add it later.
// Even with a two ended optimization, we'd want to optimize for the case
// where there are few changes and brute force the comparison instead of
// going for the Map. It'd like to explore hitting that path first in
// forward-only mode and only go for the Map once we notice that we need
// lots of look ahead. This doesn't handle reversal as well as two ended
// search but that's unusual. Besides, for the two ended optimization to
// work on Iterables, we'd need to copy the whole set.
// In this first iteration, we'll just live with hitting the bad case
// (adding everything to a Map) in for every insert/move.
// If you change this code, also update reconcileChildrenIterator() which
// uses the same algorithm.
{// First, validate keys.
var knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],expirationTime);if(!_newFiber){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],expirationTime);if(_newFiber2){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren.delete(_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,expirationTime){// This is the same implementation as reconcileChildrenArray(),
// but using the iterator instead.
var iteratorFn=getIteratorFn(newChildrenIterable);!(typeof iteratorFn==='function')?invariant(false,'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.'):void 0;{// We don't support rendering Generators because it's a mutation.
// See https://github.com/facebook/react/issues/12995
if(typeof Symbol==='function'&&// $FlowFixMe Flow doesn't know about toStringTag
newChildrenIterable[Symbol.toStringTag]==='Generator'){!didWarnAboutGenerators?warning$1(false,'Using Generators as children is unsupported and will likely yield '+'unexpected results because enumerating a generator mutates it. '+'You may convert it to an array with `Array.from()` or the '+'`[...spread]` operator before rendering. Keep in mind '+'you might need to polyfill these features for older browsers.'):void 0;didWarnAboutGenerators=true;}// Warn about using Maps as children
if(newChildrenIterable.entries===iteratorFn){!didWarnAboutMaps?warning$1(false,'Using Maps as children is unsupported and will likely yield '+'unexpected results. Convert it to a sequence/iterable of keyed '+'ReactElements instead.'):void 0;didWarnAboutMaps=true;}// First, validate keys.
// We'll get a different iterator later for the main pass.
var _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys);}}}var newChildren=iteratorFn.call(newChildrenIterable);!(newChildren!=null)?invariant(false,'An iterable object provided no iterator.'):void 0;var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(!oldFiber){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,expirationTime);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,expirationTime);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren.delete(_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,expirationTime){// There's no need to check for keys on text nodes since we don't have a
// way to define them.
if(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete
// the rest.
deleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent,expirationTime);existing.return=returnFiber;return existing;}// The existing first child is not a text node so we need to create one
// and delete the existing ones.
deleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,expirationTime){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===Fragment?element.type===REACT_FRAGMENT_TYPE:child.type===element.type){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.type===REACT_FRAGMENT_TYPE?element.props.children:element.props,expirationTime);existing.ref=coerceRef(returnFiber,child,element);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.mode,expirationTime,element.key);created.return=returnFiber;return created;}else{var _created4=createFiberFromElement(element,returnFiber.mode,expirationTime);_created4.ref=coerceRef(returnFiber,currentFirstChild,element);_created4.return=returnFiber;return _created4;}}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,expirationTime){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[],expirationTime);existing.return=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation
// itself. They will be added to the side-effect list as we pass through the
// children and the parent.
function reconcileChildFibers(returnFiber,currentFirstChild,newChild,expirationTime){// This function is not recursive.
// If the top level item is an array, we treat it as a set of children,
// not as a fragment. Nested arrays on the other hand will be treated as
// fragment nodes. Recursion happens at the normal flow.
// Handle top level unkeyed fragments as if they were arrays.
// This leads to an ambiguity between <>{[...]}</> and <>...</>.
// We treat the ambiguous cases above the same.
var isUnkeyedTopLevelFragment=(typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null;if(isUnkeyedTopLevelFragment){newChild=newChild.props.children;}// Handle object types
var isObject=(typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null;if(isObject){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,expirationTime));}}if(typeof newChild==='string'||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,expirationTime));}if(isArray$1(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,expirationTime);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,expirationTime);}if(isObject){throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}if(typeof newChild==='undefined'&&!isUnkeyedTopLevelFragment){// If the new child is undefined, and the return fiber is a composite
// component, throw an error. If Fiber return types are disabled,
// we already threw above.
switch(returnFiber.tag){case ClassComponent:case ClassComponentLazy:{{var instance=returnFiber.stateNode;if(instance.render._isMockFunction){// We allow auto-mocks to proceed as if they're returning null.
break;}}}// Intentionally fall through to the next case, which handles both
// functions and classes
// eslint-disable-next-lined no-fallthrough
case FunctionalComponent:{var Component=returnFiber.type;invariant(false,'%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.',Component.displayName||Component.name||'Component');}}}// Remaining cases are all treated as empty.
return deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current$$1,workInProgress){!(current$$1===null||workInProgress.child===current$$1.child)?invariant(false,'Resuming work not yet implemented.'):void 0;if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);workInProgress.child=newChild;newChild.return=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);newChild.return=workInProgress;}newChild.sibling=null;}// The deepest Fiber on the stack involved in a hydration context.
// This may have been an insertion or a hydration.
var hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;function enterHydrationState(fiber){if(!supportsHydration){return false;}var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChild(parentInstance);hydrationParentFiber=fiber;isHydrating=true;return true;}function deleteHydratableInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo,instance);break;case HostComponent:didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance);break;}}var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete.return=returnFiber;childToDelete.effectTag=Deletion;// This might seem like it belongs on progressedFirstDeletion. However,
// these children are not part of the reconciliation list of children.
// Even if we abort and rereconcile the children, that will try to hydrate
// again and the nodes are still in the host tree so these will be
// recreated.
if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}}function insertNonHydratedInstance(returnFiber,fiber){fiber.effectTag|=Placement;{switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableContainerInstance(parentContainer,type,props);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableContainerTextInstance(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:var _type=fiber.type;var _props=fiber.pendingProps;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props);break;case HostText:var _text=fiber.pendingProps;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text);break;}break;}default:return;}}}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type,props);if(instance!==null){fiber.stateNode=instance;return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;return true;}return false;}default:return false;}}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}var firstAttemptedInstance=nextInstance;if(!tryHydrate(fiber,nextInstance)){// If we can't hydrate this instance let's try the next one.
// We use this as a heuristic. It's based on intuition and not data so it
// might be flawed or unnecessary.
nextInstance=getNextHydratableSibling(firstAttemptedInstance);if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was
// superfluous and we'll delete it. Since we can't eagerly delete it
// we'll have to schedule a deletion. To do that, this node needs a dummy
// fiber associated with it.
deleteHydratableInstance(hydrationParentFiber,firstAttemptedInstance);}hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(nextInstance);}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){if(!supportsHydration){invariant(false,'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');}var instance=fiber.stateNode;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber);// TODO: Type this specific to this type of component.
fiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update.
if(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){if(!supportsHydration){invariant(false,'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');}var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);{if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the
// hydration parent is the parent host component of this host text.
var returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent);break;}}}}}return shouldUpdate;}function popToNextHostParent(fiber){var parent=fiber.return;while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot){parent=parent.return;}hydrationParentFiber=parent;}function popHydrationState(fiber){if(!supportsHydration){return false;}if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted
// tree.
return false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then
// we were an insertion and now need to pop up reenter hydration of our
// siblings.
popToNextHostParent(fiber);isHydrating=true;return false;}var type=fiber.type;// If we have any remaining hydratable nodes, we need to delete them now.
// We only do this deeper than head and body since they tend to have random
// other nodes in them. We also ignore components with pure text content in
// side of them.
// TODO: Better heuristic.
if(fiber.tag!==HostComponent||type!=='head'&&type!=='body'&&!shouldSetTextContent(type,fiber.memoizedProps)){var nextInstance=nextHydratableInstance;while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}popToNextHostParent(fiber);nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;return true;}function resetHydrationState(){if(!supportsHydration){return;}hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;}function readLazyComponentType(thenable){var status=thenable._reactStatus;switch(status){case Resolved:var Component=thenable._reactResult;return Component;case Rejected:throw thenable._reactResult;case Pending:throw thenable;default:{thenable._reactStatus=Pending;thenable.then(function(resolvedValue){if(thenable._reactStatus===Pending){thenable._reactStatus=Resolved;if((typeof resolvedValue==='undefined'?'undefined':_typeof(resolvedValue))==='object'&&resolvedValue!==null){// If the `default` property is not empty, assume it's the result
// of an async import() and use that. Otherwise, use the
// resolved value itself.
var defaultExport=resolvedValue.default;resolvedValue=defaultExport!==undefined&&defaultExport!==null?defaultExport:resolvedValue;}else{resolvedValue=resolvedValue;}thenable._reactResult=resolvedValue;}},function(error){if(thenable._reactStatus===Pending){thenable._reactStatus=Rejected;thenable._reactResult=error;}});throw thenable;}}}var ReactCurrentOwner$3=ReactSharedInternals.ReactCurrentOwner;var didWarnAboutBadClass=void 0;var didWarnAboutGetDerivedStateOnFunctionalComponent=void 0;var didWarnAboutStatelessRefs=void 0;{didWarnAboutBadClass={};didWarnAboutGetDerivedStateOnFunctionalComponent={};didWarnAboutStatelessRefs={};}function reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime){if(current$$1===null){// If this is a fresh new component that hasn't been rendered yet, we
// won't update its child set by applying minimal side-effects. Instead,
// we will add them all to the child before it gets rendered. That means
// we can optimize this reconciliation pass by not tracking side-effects.
workInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderExpirationTime);}else{// If the current child is the same as the work in progress, it means that
// we haven't yet started any work on these children. Therefore, we use
// the clone algorithm to create a copy of all the current children.
// If we had any progressed work already, that is invalid at this point so
// let's throw it out.
workInProgress.child=reconcileChildFibers(workInProgress,current$$1.child,nextChildren,renderExpirationTime);}}function updateForwardRef(current$$1,workInProgress,type,nextProps,renderExpirationTime){var render=type.render;var ref=workInProgress.ref;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
}else if(workInProgress.memoizedProps===nextProps){var currentRef=current$$1!==null?current$$1.ref:null;if(ref===currentRef){return bailoutOnAlreadyFinishedWork(current$$1,workInProgress,renderExpirationTime);}}var nextChildren=void 0;{ReactCurrentOwner$3.current=workInProgress;setCurrentPhase('render');nextChildren=render(nextProps,ref);setCurrentPhase(null);}reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateFragment(current$$1,workInProgress,renderExpirationTime){var nextChildren=workInProgress.pendingProps;reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);memoizeProps(workInProgress,nextChildren);return workInProgress.child;}function updateMode(current$$1,workInProgress,renderExpirationTime){var nextChildren=workInProgress.pendingProps.children;reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);memoizeProps(workInProgress,nextChildren);return workInProgress.child;}function updateProfiler(current$$1,workInProgress,renderExpirationTime){if(enableProfilerTimer){workInProgress.effectTag|=Update;}var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function markRef(current$$1,workInProgress){var ref=workInProgress.ref;if(current$$1===null&&ref!==null||current$$1!==null&&current$$1.ref!==ref){// Schedule a Ref effect
workInProgress.effectTag|=Ref;}}function updateFunctionalComponent(current$$1,workInProgress,Component,nextProps,renderExpirationTime){var unmaskedContext=getUnmaskedContext(workInProgress,Component,true);var context=getMaskedContext(workInProgress,unmaskedContext);var nextChildren=void 0;prepareToReadContext(workInProgress,renderExpirationTime);{ReactCurrentOwner$3.current=workInProgress;setCurrentPhase('render');nextChildren=Component(nextProps,context);setCurrentPhase(null);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateClassComponent(current$$1,workInProgress,Component,nextProps,renderExpirationTime){// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=void 0;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderExpirationTime);var shouldUpdate=void 0;if(current$$1===null){if(workInProgress.stateNode===null){// In the initial pass we might need to construct the instance.
constructClassInstance(workInProgress,Component,nextProps,renderExpirationTime);mountClassInstance(workInProgress,Component,nextProps,renderExpirationTime);shouldUpdate=true;}else{// In a resume, we'll already have an instance we can reuse.
shouldUpdate=resumeMountClassInstance(workInProgress,Component,nextProps,renderExpirationTime);}}else{shouldUpdate=updateClassInstance(current$$1,workInProgress,Component,nextProps,renderExpirationTime);}return finishClassComponent(current$$1,workInProgress,Component,shouldUpdate,hasContext,renderExpirationTime);}function finishClassComponent(current$$1,workInProgress,Component,shouldUpdate,hasContext,renderExpirationTime){// Refs should update even if shouldComponentUpdate returns false
markRef(current$$1,workInProgress);var didCaptureError=(workInProgress.effectTag&DidCapture)!==NoEffect;if(!shouldUpdate&&!didCaptureError){// Context providers should defer to sCU for rendering
if(hasContext){invalidateContextProvider(workInProgress,Component,false);}return bailoutOnAlreadyFinishedWork(current$$1,workInProgress,renderExpirationTime);}var instance=workInProgress.stateNode;// Rerender
ReactCurrentOwner$3.current=workInProgress;var nextChildren=void 0;if(didCaptureError&&(!enableGetDerivedStateFromCatch||typeof Component.getDerivedStateFromCatch!=='function')){// If we captured an error, but getDerivedStateFrom catch is not defined,
// unmount all the children. componentDidCatch will schedule an update to
// re-render a fallback. This is temporary until we migrate everyone to
// the new API.
// TODO: Warn in a future release.
nextChildren=null;if(enableProfilerTimer){stopProfilerTimerIfRunning(workInProgress);}}else{{setCurrentPhase('render');nextChildren=instance.render();if(debugRenderPhaseSideEffects||debugRenderPhaseSideEffectsForStrictMode&&workInProgress.mode&StrictMode){instance.render();}setCurrentPhase(null);}}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;if(current$$1!==null&&didCaptureError){// If we're recovering from an error, reconcile twice: first to delete
// all the existing children.
reconcileChildren(current$$1,workInProgress,null,renderExpirationTime);workInProgress.child=null;// Now we can continue reconciling like normal. This has the effect of
// remounting all children regardless of whether their their
// identity matches.
}reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);// Memoize props and state using the values we just used to render.
// TODO: Restructure so we never read values from the instance.
memoizeState(workInProgress,instance.state);memoizeProps(workInProgress,instance.props);// The context might have changed so we need to recalculate it.
if(hasContext){invalidateContextProvider(workInProgress,Component,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set
pushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current$$1,workInProgress,renderExpirationTime){pushHostRootContext(workInProgress);var updateQueue=workInProgress.updateQueue;!(updateQueue!==null)?invariant(false,'If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.'):void 0;var nextProps=workInProgress.pendingProps;var prevState=workInProgress.memoizedState;var prevChildren=prevState!==null?prevState.element:null;processUpdateQueue(workInProgress,updateQueue,nextProps,null,renderExpirationTime);var nextState=workInProgress.memoizedState;// Caution: React DevTools currently depends on this property
// being called "element".
var nextChildren=nextState.element;if(nextChildren===prevChildren){// If the state is the same as before, that's a bailout because we had
// no work that expires at this time.
resetHydrationState();return bailoutOnAlreadyFinishedWork(current$$1,workInProgress,renderExpirationTime);}var root=workInProgress.stateNode;if((current$$1===null||current$$1.child===null)&&root.hydrate&&enterHydrationState(workInProgress)){// If we don't have any current children this might be the first pass.
// We always try to hydrate. If this isn't a hydration pass there won't
// be any children to hydrate which is effectively the same thing as
// not hydrating.
// This is a bit of a hack. We track the host root as a placement to
// know that we're currently in a mounting state. That way isMounted
// works as expected. We must reset this before committing.
// TODO: Delete this when we delete isMounted and findDOMNode.
workInProgress.effectTag|=Placement;// Ensure that children mount into this root without tracking
// side-effects. This ensures that we don't store Placement effects on
// nodes that will be hydrated.
workInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderExpirationTime);}else{// Otherwise reset hydration state in case we aborted and resumed another
// root.
reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);resetHydrationState();}return workInProgress.child;}function updateHostComponent(current$$1,workInProgress,renderExpirationTime){pushHostContext(workInProgress);if(current$$1===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var nextProps=workInProgress.pendingProps;var prevProps=current$$1!==null?current$$1.memoizedProps:null;var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common
// case. We won't handle it as a reified child. We will instead handle
// this in the host environment that also have access to this prop. That
// avoids allocating another HostText fiber and traversing it.
nextChildren=null;}else if(prevProps!==null&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to
// empty, we need to schedule the text content to be reset.
workInProgress.effectTag|=ContentReset;}markRef(current$$1,workInProgress);// Check the host config to see if the children are offscreen/hidden.
if(renderExpirationTime!==Never&&workInProgress.mode&AsyncMode&&shouldDeprioritizeSubtree(type,nextProps)){// Schedule this fiber to re-render at offscreen priority. Then bailout.
workInProgress.expirationTime=Never;workInProgress.memoizedProps=nextProps;return null;}reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateHostText(current$$1,workInProgress){if(current$$1===null){tryToClaimNextHydratableInstance(workInProgress);}var nextProps=workInProgress.pendingProps;memoizeProps(workInProgress,nextProps);// Nothing to do here. This is terminal. We'll do the completion step
// immediately after.
return null;}function resolveDefaultProps(Component,baseProps){if(Component&&Component.defaultProps){// Resolve default props. Taken from ReactElement
var props=_assign({},baseProps);var defaultProps=Component.defaultProps;for(var propName in defaultProps){if(props[propName]===undefined){props[propName]=defaultProps[propName];}}return props;}return baseProps;}function mountIndeterminateComponent(current$$1,workInProgress,Component,renderExpirationTime){!(current$$1===null)?invariant(false,'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.'):void 0;var props=workInProgress.pendingProps;if((typeof Component==='undefined'?'undefined':_typeof(Component))==='object'&&Component!==null&&typeof Component.then==='function'){Component=readLazyComponentType(Component);var resolvedTag=workInProgress.tag=resolveLazyComponentTag(workInProgress,Component);var resolvedProps=resolveDefaultProps(Component,props);switch(resolvedTag){case FunctionalComponentLazy:{return updateFunctionalComponent(current$$1,workInProgress,Component,resolvedProps,renderExpirationTime);}case ClassComponentLazy:{return updateClassComponent(current$$1,workInProgress,Component,resolvedProps,renderExpirationTime);}case ForwardRefLazy:{return updateForwardRef(current$$1,workInProgress,Component,resolvedProps,renderExpirationTime);}default:{// This message intentionally doesn't metion ForwardRef because the
// fact that it's a separate type of work is an implementation detail.
invariant(false,'Element type is invalid. Received a promise that resolves to: %s. Promise elements must resolve to a class or function.',Component);}}}var unmaskedContext=getUnmaskedContext(workInProgress,Component,false);var context=getMaskedContext(workInProgress,unmaskedContext);prepareToReadContext(workInProgress,renderExpirationTime);var value=void 0;{if(Component.prototype&&typeof Component.prototype.render==='function'){var componentName=getComponentName(Component)||'Unknown';if(!didWarnAboutBadClass[componentName]){warningWithoutStack$1(false,"The <%s /> component appears to have a render method, but doesn't extend React.Component. "+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);didWarnAboutBadClass[componentName]=true;}}if(workInProgress.mode&StrictMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,null);}ReactCurrentOwner$3.current=workInProgress;value=Component(props,context);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;if((typeof value==='undefined'?'undefined':_typeof(value))==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){// Proceed under the assumption that this is a class instance
workInProgress.tag=ClassComponent;// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=false;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}workInProgress.memoizedState=value.state!==null&&value.state!==undefined?value.state:null;var getDerivedStateFromProps=Component.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,Component,getDerivedStateFromProps,props);}adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,Component,props,renderExpirationTime);return finishClassComponent(current$$1,workInProgress,Component,true,hasContext,renderExpirationTime);}else{// Proceed under the assumption that this is a functional component
workInProgress.tag=FunctionalComponent;{if(Component){!!Component.childContextTypes?warningWithoutStack$1(false,'%s(...): childContextTypes cannot be defined on a functional component.',Component.displayName||Component.name||'Component'):void 0;}if(workInProgress.ref!==null){var info='';var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||workInProgress._debugID||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!didWarnAboutStatelessRefs[warningKey]){didWarnAboutStatelessRefs[warningKey]=true;warning$1(false,'Stateless function components cannot be given refs. '+'Attempts to access this ref will fail.%s',info);}}if(typeof Component.getDerivedStateFromProps==='function'){var _componentName=getComponentName(Component)||'Unknown';if(!didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName]){warningWithoutStack$1(false,'%s: Stateless functional components do not support getDerivedStateFromProps.',_componentName);didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName]=true;}}}reconcileChildren(current$$1,workInProgress,value,renderExpirationTime);memoizeProps(workInProgress,props);return workInProgress.child;}}function updatePlaceholderComponent(current$$1,workInProgress,renderExpirationTime){if(enableSuspense){var nextProps=workInProgress.pendingProps;// Check if we already attempted to render the normal state. If we did,
// and we timed out, render the placeholder state.
var alreadyCaptured=(workInProgress.effectTag&DidCapture)===NoEffect;var nextDidTimeout=void 0;if(current$$1!==null&&workInProgress.updateQueue!==null){// We're outside strict mode. Something inside this Placeholder boundary
// suspended during the last commit. Switch to the placholder.
workInProgress.updateQueue=null;nextDidTimeout=true;// If we're recovering from an error, reconcile twice: first to delete
// all the existing children.
reconcileChildren(current$$1,workInProgress,null,renderExpirationTime);current$$1.child=null;// Now we can continue reconciling like normal. This has the effect of
// remounting all children regardless of whether their their
// identity matches.
}else{nextDidTimeout=!alreadyCaptured;}if((workInProgress.mode&StrictMode)!==NoEffect){if(nextDidTimeout){// If the timed-out view commits, schedule an update effect to record
// the committed time.
workInProgress.effectTag|=Update;}else{// The state node points to the time at which placeholder timed out.
// We can clear it once we switch back to the normal children.
workInProgress.stateNode=null;}}// If the `children` prop is a function, treat it like a render prop.
// TODO: This is temporary until we finalize a lower level API.
var children=nextProps.children;var nextChildren=void 0;if(typeof children==='function'){nextChildren=children(nextDidTimeout);}else{nextChildren=nextDidTimeout?nextProps.fallback:children;}workInProgress.memoizedProps=nextProps;workInProgress.memoizedState=nextDidTimeout;reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);return workInProgress.child;}else{return null;}}function updatePortalComponent(current$$1,workInProgress,renderExpirationTime){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(current$$1===null){// Portals are special because we don't append the children during mount
// but at commit. Therefore we need to track insertions which the normal
// flow doesn't do during mount. This doesn't happen at the root because
// the root always starts with a "current" with a null child.
// TODO: Consider unifying this with how the root works.
workInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderExpirationTime);memoizeProps(workInProgress,nextChildren);}else{reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);memoizeProps(workInProgress,nextChildren);}return workInProgress.child;}function updateContextProvider(current$$1,workInProgress,renderExpirationTime){var providerType=workInProgress.type;var context=providerType._context;var newProps=workInProgress.pendingProps;var oldProps=workInProgress.memoizedProps;var newValue=newProps.value;workInProgress.memoizedProps=newProps;{var providerPropTypes=workInProgress.type.propTypes;if(providerPropTypes){checkPropTypes(providerPropTypes,newProps,'prop','Context.Provider',getCurrentFiberStackInDev);}}pushProvider(workInProgress,newValue);if(oldProps!==null){var oldValue=oldProps.value;var changedBits=calculateChangedBits(context,newValue,oldValue);if(changedBits===0){// No change. Bailout early if children are the same.
if(oldProps.children===newProps.children&&!hasContextChanged()){return bailoutOnAlreadyFinishedWork(current$$1,workInProgress,renderExpirationTime);}}else{// The context value changed. Search for matching consumers and schedule
// them to update.
propagateContextChange(workInProgress,context,changedBits,renderExpirationTime);}}var newChildren=newProps.children;reconcileChildren(current$$1,workInProgress,newChildren,renderExpirationTime);return workInProgress.child;}function updateContextConsumer(current$$1,workInProgress,renderExpirationTime){var context=workInProgress.type;var newProps=workInProgress.pendingProps;var render=newProps.children;{!(typeof render==='function')?warningWithoutStack$1(false,'A context consumer was rendered with multiple children, or a child '+"that isn't a function. A context consumer expects a single child "+'that is a function. If you did pass a function, make sure there '+'is no trailing or leading whitespace around it.'):void 0;}prepareToReadContext(workInProgress,renderExpirationTime);var newValue=readContext(context,newProps.unstable_observedBits);var newChildren=void 0;{ReactCurrentOwner$3.current=workInProgress;setCurrentPhase('render');newChildren=render(newValue);setCurrentPhase(null);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current$$1,workInProgress,newChildren,renderExpirationTime);workInProgress.memoizedProps=newProps;return workInProgress.child;}/*
  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
    let child = firstChild;
    do {
      // Ensure that the first and last effect of the parent corresponds
      // to the children's first and last effect.
      if (!returnFiber.firstEffect) {
        returnFiber.firstEffect = child.firstEffect;
      }
      if (child.lastEffect) {
        if (returnFiber.lastEffect) {
          returnFiber.lastEffect.nextEffect = child.firstEffect;
        }
        returnFiber.lastEffect = child.lastEffect;
      }
    } while (child = child.sibling);
  }
  */function bailoutOnAlreadyFinishedWork(current$$1,workInProgress,renderExpirationTime){cancelWorkTimer(workInProgress);if(current$$1!==null){// Reuse previous context list
workInProgress.firstContextDependency=current$$1.firstContextDependency;}if(enableProfilerTimer){// Don't update "base" render times for bailouts.
stopProfilerTimerIfRunning(workInProgress);}// Check if the children have any pending work.
var childExpirationTime=workInProgress.childExpirationTime;if(childExpirationTime===NoWork||childExpirationTime>renderExpirationTime){// The children don't have any work either. We can skip them.
// TODO: Once we add back resuming, we should check if the children are
// a work-in-progress set. If so, we need to transfer their effects.
return null;}else{// This fiber doesn't have work, but its subtree does. Clone the child
// fibers and continue.
cloneChildFibers(current$$1,workInProgress);return workInProgress.child;}}// TODO: Delete memoizeProps/State and move to reconcile/bailout instead
function memoizeProps(workInProgress,nextProps){workInProgress.memoizedProps=nextProps;}function memoizeState(workInProgress,nextState){workInProgress.memoizedState=nextState;// Don't reset the updateQueue, in case there are pending updates. Resetting
// is handled by processUpdateQueue.
}function beginWork(current$$1,workInProgress,renderExpirationTime){var updateExpirationTime=workInProgress.expirationTime;if(!hasContextChanged()&&(updateExpirationTime===NoWork||updateExpirationTime>renderExpirationTime)){// This fiber does not have any pending work. Bailout without entering
// the begin phase. There's still some bookkeeping we that needs to be done
// in this optimized path, mostly pushing stuff onto the stack.
switch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);resetHydrationState();break;case HostComponent:pushHostContext(workInProgress);break;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){pushContextProvider(workInProgress);}break;}case ClassComponentLazy:{var thenable=workInProgress.type;var _Component=getResultFromResolvedThenable(thenable);if(isContextProvider(_Component)){pushContextProvider(workInProgress);}break;}case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;case ContextProvider:{var newValue=workInProgress.memoizedProps.value;pushProvider(workInProgress,newValue);break;}case Profiler:if(enableProfilerTimer){workInProgress.effectTag|=Update;}break;}return bailoutOnAlreadyFinishedWork(current$$1,workInProgress,renderExpirationTime);}// Before entering the begin phase, clear the expiration time.
workInProgress.expirationTime=NoWork;switch(workInProgress.tag){case IndeterminateComponent:{var _Component3=workInProgress.type;return mountIndeterminateComponent(current$$1,workInProgress,_Component3,renderExpirationTime);}case FunctionalComponent:{var _Component4=workInProgress.type;var _unresolvedProps=workInProgress.pendingProps;return updateFunctionalComponent(current$$1,workInProgress,_Component4,_unresolvedProps,renderExpirationTime);}case FunctionalComponentLazy:{var _thenable2=workInProgress.type;var _Component5=getResultFromResolvedThenable(_thenable2);var _unresolvedProps2=workInProgress.pendingProps;var _child=updateFunctionalComponent(current$$1,workInProgress,_Component5,resolveDefaultProps(_Component5,_unresolvedProps2),renderExpirationTime);workInProgress.memoizedProps=_unresolvedProps2;return _child;}case ClassComponent:{var _Component6=workInProgress.type;var _unresolvedProps3=workInProgress.pendingProps;return updateClassComponent(current$$1,workInProgress,_Component6,_unresolvedProps3,renderExpirationTime);}case ClassComponentLazy:{var _thenable3=workInProgress.type;var _Component7=getResultFromResolvedThenable(_thenable3);var _unresolvedProps4=workInProgress.pendingProps;var _child2=updateClassComponent(current$$1,workInProgress,_Component7,resolveDefaultProps(_Component7,_unresolvedProps4),renderExpirationTime);workInProgress.memoizedProps=_unresolvedProps4;return _child2;}case HostRoot:return updateHostRoot(current$$1,workInProgress,renderExpirationTime);case HostComponent:return updateHostComponent(current$$1,workInProgress,renderExpirationTime);case HostText:return updateHostText(current$$1,workInProgress);case PlaceholderComponent:return updatePlaceholderComponent(current$$1,workInProgress,renderExpirationTime);case HostPortal:return updatePortalComponent(current$$1,workInProgress,renderExpirationTime);case ForwardRef:{var type=workInProgress.type;return updateForwardRef(current$$1,workInProgress,type,workInProgress.pendingProps,renderExpirationTime);}case ForwardRefLazy:var _thenable=workInProgress.type;var _Component2=getResultFromResolvedThenable(_thenable);var unresolvedProps=workInProgress.pendingProps;var child=updateForwardRef(current$$1,workInProgress,_Component2,resolveDefaultProps(_Component2,unresolvedProps),renderExpirationTime);workInProgress.memoizedProps=unresolvedProps;return child;case Fragment:return updateFragment(current$$1,workInProgress,renderExpirationTime);case Mode:return updateMode(current$$1,workInProgress,renderExpirationTime);case Profiler:return updateProfiler(current$$1,workInProgress,renderExpirationTime);case ContextProvider:return updateContextProvider(current$$1,workInProgress,renderExpirationTime);case ContextConsumer:return updateContextConsumer(current$$1,workInProgress,renderExpirationTime);default:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}}function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into
// a PlacementAndUpdate.
workInProgress.effectTag|=Update;}function markRef$1(workInProgress){workInProgress.effectTag|=Ref;}function appendAllChildren(parent,workInProgress){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}var updateHostContainer=void 0;var updateHostComponent$1=void 0;var updateHostText$1=void 0;if(supportsMutation){// Mutation mode
updateHostContainer=function updateHostContainer(workInProgress){// Noop
};updateHostComponent$1=function updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance){// If we have an alternate, that means this is an update and we need to
// schedule a side-effect to do the updates.
var oldProps=current.memoizedProps;if(oldProps===newProps){// In mutation mode, this is sufficient for a bailout because
// we won't touch this node even if children changed.
return;}// If we get updated because one of our children updated, we don't
// have newProps so we'll have to reuse them.
// TODO: Split the update API as separate for the props vs. children.
// Even better would be if children weren't special cased at all tho.
var instance=workInProgress.stateNode;var currentHostContext=getHostContext();// TODO: Experiencing an error where oldProps is null. Suggests a host
// component is hitting the resume path. Figure out why. Possibly
// related to `hidden`.
var updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);// TODO: Type this specific to this type of component.
workInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update. All the work is done in commitWork.
if(updatePayload){markUpdate(workInProgress);}};updateHostText$1=function updateHostText$1(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.
if(oldText!==newText){markUpdate(workInProgress);}};}else if(supportsPersistence){// Persistent host tree mode
// An unfortunate fork of appendAllChildren because we have two different parent types.
var appendAllChildrenToContainer=function appendAllChildrenToContainer(containerChildSet,workInProgress){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendChildToContainerChildSet(containerChildSet,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}};updateHostContainer=function updateHostContainer(workInProgress){var portalOrRoot=workInProgress.stateNode;var childrenUnchanged=workInProgress.firstEffect===null;if(childrenUnchanged){// No changes, just reuse the existing instance.
}else{var container=portalOrRoot.containerInfo;var newChildSet=createContainerChildSet(container);// If children might have changed, we have to add them all to the set.
appendAllChildrenToContainer(newChildSet,workInProgress);portalOrRoot.pendingChildren=newChildSet;// Schedule an update on the container to swap out the container.
markUpdate(workInProgress);finalizeContainerChildren(container,newChildSet);}};updateHostComponent$1=function updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance){var currentInstance=current.stateNode;var oldProps=current.memoizedProps;// If there are no effects associated with this node, then none of our children had any updates.
// This guarantees that we can reuse all of them.
var childrenUnchanged=workInProgress.firstEffect===null;if(childrenUnchanged&&oldProps===newProps){// No changes, just reuse the existing instance.
// Note that this might release a previous clone.
workInProgress.stateNode=currentInstance;return;}var recyclableInstance=workInProgress.stateNode;var currentHostContext=getHostContext();var updatePayload=null;if(oldProps!==newProps){updatePayload=prepareUpdate(recyclableInstance,type,oldProps,newProps,rootContainerInstance,currentHostContext);}if(childrenUnchanged&&updatePayload===null){// No changes, just reuse the existing instance.
// Note that this might release a previous clone.
workInProgress.stateNode=currentInstance;return;}var newInstance=cloneInstance(currentInstance,updatePayload,type,oldProps,newProps,workInProgress,childrenUnchanged,recyclableInstance);if(finalizeInitialChildren(newInstance,type,newProps,rootContainerInstance,currentHostContext)){markUpdate(workInProgress);}workInProgress.stateNode=newInstance;if(childrenUnchanged){// If there are no other effects in this tree, we need to flag this node as having one.
// Even though we're not going to use it for anything.
// Otherwise parents won't know that there are new children to propagate upwards.
markUpdate(workInProgress);}else{// If children might have changed, we have to add them all to the set.
appendAllChildren(newInstance,workInProgress);}};updateHostText$1=function updateHostText$1(current,workInProgress,oldText,newText){if(oldText!==newText){// If the text content differs, we'll create a new text instance for it.
var rootContainerInstance=getRootHostContainer();var currentHostContext=getHostContext();workInProgress.stateNode=createTextInstance(newText,rootContainerInstance,currentHostContext,workInProgress);// We'll have to mark it as having an effect, even though we won't use the effect for anything.
// This lets the parents know that at least one of their children has changed.
markUpdate(workInProgress);}};}else{// No host operations
updateHostContainer=function updateHostContainer(workInProgress){// Noop
};updateHostComponent$1=function updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance){// Noop
};updateHostText$1=function updateHostText$1(current,workInProgress,oldText,newText){// Noop
};}function completeWork(current,workInProgress,renderExpirationTime){var newProps=workInProgress.pendingProps;switch(workInProgress.tag){case FunctionalComponent:case FunctionalComponentLazy:break;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}break;}case ClassComponentLazy:{var _Component=getResultFromResolvedThenable(workInProgress.type);if(isContextProvider(_Component)){popContext(workInProgress);}break;}case HostRoot:{popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);var fiberRoot=workInProgress.stateNode;if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children
// that weren't hydrated.
popHydrationState(workInProgress);// This resets the hacky state to fix isMounted before committing.
// TODO: Delete this when we delete isMounted and findDOMNode.
workInProgress.effectTag&=~Placement;}updateHostContainer(workInProgress);break;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef$1(workInProgress);}}else{if(!newProps){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.
break;}var currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context
// "stack" as the parent. Then append children as we go in beginWork
// or completeWork depending on we want to add then top->down or
// bottom->up. Top->down is faster in IE11.
var wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// TODO: Move this and createInstance step into the beginPhase
// to consolidate.
if(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,currentHostContext)){// If changes to the hydrated node needs to be applied at the
// commit-phase we mark this as such.
markUpdate(workInProgress);}}else{var instance=createInstance(type,newProps,rootContainerInstance,currentHostContext,workInProgress);appendAllChildren(instance,workInProgress);// Certain renderers require commit-time effects for initial mount.
// (eg DOM renderer supports auto-focus for certain elements).
// Make sure such renderers get scheduled for later work.
if(finalizeInitialChildren(instance,type,newProps,rootContainerInstance,currentHostContext)){markUpdate(workInProgress);}workInProgress.stateNode=instance;}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback
markRef$1(workInProgress);}}break;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need
// to schedule a side-effect to do the updates.
updateHostText$1(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.
}var _rootContainerInstance=getRootHostContainer();var _currentHostContext=getHostContext();var _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext,workInProgress);}}break;}case ForwardRef:case ForwardRefLazy:break;case PlaceholderComponent:break;case Fragment:break;case Mode:break;case Profiler:break;case HostPortal:popHostContainer(workInProgress);updateHostContainer(workInProgress);break;case ContextProvider:// Pop provider fiber
popProvider(workInProgress);break;case ContextConsumer:break;// Error cases
case IndeterminateComponent:invariant(false,'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');// eslint-disable-next-line no-fallthrough
default:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}return null;}// This module is forked in different environments.
// By default, return `true` to log errors to the console.
// Forks can return `false` if this isn't desirable.
function showErrorDialog(capturedError){return true;}function logCapturedError(capturedError){var logError=showErrorDialog(capturedError);// Allow injected showErrorDialog() to prevent default console.error logging.
// This enables renderers like ReactNative to better manage redbox behavior.
if(logError===false){return;}var error=capturedError.error;{var componentName=capturedError.componentName,componentStack=capturedError.componentStack,errorBoundaryName=capturedError.errorBoundaryName,errorBoundaryFound=capturedError.errorBoundaryFound,willRetry=capturedError.willRetry;// Browsers support silencing uncaught errors by calling
// `preventDefault()` in window `error` handler.
// We record this information as an expando on the error.
if(error!=null&&error._suppressLogging){if(errorBoundaryFound&&willRetry){// The error is recoverable and was silenced.
// Ignore it and don't print the stack addendum.
// This is handy for testing error boundaries without noise.
return;}// The error is fatal. Since the silencing might have
// been accidental, we'll surface it anyway.
// However, the browser would have silenced the original error
// so we'll print it first, and then print the stack addendum.
console.error(error);// For a more detailed description of this block, see:
// https://github.com/facebook/react/pull/13384
}var componentNameMessage=componentName?'The above error occurred in the <'+componentName+'> component:':'The above error occurred in one of your React components:';var errorBoundaryMessage=void 0;// errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
if(errorBoundaryFound&&errorBoundaryName){if(willRetry){errorBoundaryMessage='React will try to recreate this component tree from scratch '+('using the error boundary you provided, '+errorBoundaryName+'.');}else{errorBoundaryMessage='This error was initially handled by the error boundary '+errorBoundaryName+'.\n'+'Recreating the tree from scratch failed so React will unmount the tree.';}}else{errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\n'+'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';}var combinedMessage=''+componentNameMessage+componentStack+'\n\n'+(''+errorBoundaryMessage);// In development, we provide our own message with just the component stack.
// We don't include the original error message and JS stack because the browser
// has already printed it. Even if the application swallows the error, it is still
// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
console.error(combinedMessage);}}var emptyObject={};var didWarnAboutUndefinedSnapshotBeforeUpdate=null;{didWarnAboutUndefinedSnapshotBeforeUpdate=new Set();}function logError(boundary,errorInfo){var source=errorInfo.source;var stack=errorInfo.stack;if(stack===null&&source!==null){stack=getStackByFiberInDevAndProd(source);}var capturedError={componentName:source!==null?getComponentName(source.type):null,componentStack:stack!==null?stack:'',error:errorInfo.value,errorBoundary:null,errorBoundaryName:null,errorBoundaryFound:false,willRetry:false};if(boundary!==null&&boundary.tag===ClassComponent){capturedError.errorBoundary=boundary.stateNode;capturedError.errorBoundaryName=getComponentName(boundary.type);capturedError.errorBoundaryFound=true;capturedError.willRetry=true;}try{logCapturedError(capturedError);}catch(e){// This method must not throw, or React internal state will get messed up.
// If console.error is overridden, or logCapturedError() shows a dialog that throws,
// we want to report this error outside of the normal stack as a last resort.
// https://github.com/facebook/react/issues/13188
setTimeout(function(){throw e;});}}var callComponentWillUnmountWithTimer=function callComponentWillUnmountWithTimer(current$$1,instance){startPhaseTimer(current$$1,'componentWillUnmount');instance.props=current$$1.memoizedProps;instance.state=current$$1.memoizedState;instance.componentWillUnmount();stopPhaseTimer();};// Capture errors so they don't interrupt unmounting.
function safelyCallComponentWillUnmount(current$$1,instance){{invokeGuardedCallback(null,callComponentWillUnmountWithTimer,null,current$$1,instance);if(hasCaughtError()){var unmountError=clearCaughtError();captureCommitPhaseError(current$$1,unmountError);}}}function safelyDetachRef(current$$1){var ref=current$$1.ref;if(ref!==null){if(typeof ref==='function'){{invokeGuardedCallback(null,ref,null,null);if(hasCaughtError()){var refError=clearCaughtError();captureCommitPhaseError(current$$1,refError);}}}else{ref.current=null;}}}function commitBeforeMutationLifeCycles(current$$1,finishedWork){switch(finishedWork.tag){case ClassComponent:case ClassComponentLazy:{if(finishedWork.effectTag&Snapshot){if(current$$1!==null){var prevProps=current$$1.memoizedProps;var prevState=current$$1.memoizedState;startPhaseTimer(finishedWork,'getSnapshotBeforeUpdate');var instance=finishedWork.stateNode;instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;var snapshot=instance.getSnapshotBeforeUpdate(prevProps,prevState);{var didWarnSet=didWarnAboutUndefinedSnapshotBeforeUpdate;if(snapshot===undefined&&!didWarnSet.has(finishedWork.type)){didWarnSet.add(finishedWork.type);warningWithoutStack$1(false,'%s.getSnapshotBeforeUpdate(): A snapshot value (or null) '+'must be returned. You have returned undefined.',getComponentName(finishedWork.type));}}instance.__reactInternalSnapshotBeforeUpdate=snapshot;stopPhaseTimer();}}return;}case HostRoot:case HostComponent:case HostText:case HostPortal:// Nothing to do for these component types
return;default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitLifeCycles(finishedRoot,current$$1,finishedWork,committedExpirationTime){switch(finishedWork.tag){case ClassComponent:case ClassComponentLazy:{var instance=finishedWork.stateNode;if(finishedWork.effectTag&Update){if(current$$1===null){startPhaseTimer(finishedWork,'componentDidMount');instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;instance.componentDidMount();stopPhaseTimer();}else{var prevProps=current$$1.memoizedProps;var prevState=current$$1.memoizedState;startPhaseTimer(finishedWork,'componentDidUpdate');instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);stopPhaseTimer();}}var updateQueue=finishedWork.updateQueue;if(updateQueue!==null){instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;commitUpdateQueue(finishedWork,updateQueue,instance,committedExpirationTime);}return;}case HostRoot:{var _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=null;if(finishedWork.child!==null){switch(finishedWork.child.tag){case HostComponent:_instance=getPublicInstance(finishedWork.child.stateNode);break;case ClassComponent:case ClassComponentLazy:_instance=finishedWork.child.stateNode;break;}}commitUpdateQueue(finishedWork,_updateQueue,_instance,committedExpirationTime);}return;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted
// (eg DOM renderer may schedule auto-focus for inputs and form controls).
// These effects should only be committed when components are first mounted,
// aka when there is no current/alternate.
if(current$$1===null&&finishedWork.effectTag&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props,finishedWork);}return;}case HostText:{// We have no life-cycles associated with text.
return;}case HostPortal:{// We have no life-cycles associated with portals.
return;}case Profiler:{if(enableProfilerTimer){var onRender=finishedWork.memoizedProps.onRender;if(enableSchedulerTracing){onRender(finishedWork.memoizedProps.id,current$$1===null?'mount':'update',finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,getCommitTime(),finishedRoot.memoizedInteractions);}else{onRender(finishedWork.memoizedProps.id,current$$1===null?'mount':'update',finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,getCommitTime());}}return;}case PlaceholderComponent:{if(enableSuspense){if((finishedWork.mode&StrictMode)===NoEffect){// In loose mode, a placeholder times out by scheduling a synchronous
// update in the commit phase. Use `updateQueue` field to signal that
// the Timeout needs to switch to the placeholder. We don't need an
// entire queue. Any non-null value works.
// $FlowFixMe - Intentionally using a value other than an UpdateQueue.
finishedWork.updateQueue=emptyObject;scheduleWork(finishedWork,Sync);}else{// In strict mode, the Update effect is used to record the time at
// which the placeholder timed out.
var currentTime=requestCurrentTime();finishedWork.stateNode={timedOutAt:currentTime};}}return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;var instanceToUse=void 0;switch(finishedWork.tag){case HostComponent:instanceToUse=getPublicInstance(instance);break;default:instanceToUse=instance;}if(typeof ref==='function'){ref(instanceToUse);}else{{if(!ref.hasOwnProperty('current')){warningWithoutStack$1(false,'Unexpected ref object provided for %s. '+'Use either a ref-setter function or React.createRef().%s',getComponentName(finishedWork.type),getStackByFiberInDevAndProd(finishedWork));}}ref.current=instanceToUse;}}}function commitDetachRef(current$$1){var currentRef=current$$1.ref;if(currentRef!==null){if(typeof currentRef==='function'){currentRef(null);}else{currentRef.current=null;}}}// User-originating errors (lifecycles and refs) should not interrupt
// deletion, so don't let them throw. Host-originating errors should
// interrupt deletion, so it's okay
function commitUnmount(current$$1){onCommitUnmount(current$$1);switch(current$$1.tag){case ClassComponent:case ClassComponentLazy:{safelyDetachRef(current$$1);var instance=current$$1.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(current$$1,instance);}return;}case HostComponent:{safelyDetachRef(current$$1);return;}case HostPortal:{// TODO: this is recursive.
// We are also not using this parent because
// the portal will get pushed immediately.
if(supportsMutation){unmountHostComponents(current$$1);}else if(supportsPersistence){emptyPortalContainer(current$$1);}return;}}}function commitNestedUnmounts(root){// While we're inside a removed host node we don't want to call
// removeChild on the inner nodes because they're removed by the top
// call anyway. We also want to call componentWillUnmount on all
// composites before this host node is removed from the tree. Therefore
var node=root;while(true){commitUnmount(node);// Visit children because they may contain more composite or host nodes.
// Skip portals because commitUnmount() currently visits them recursively.
if(node.child!==null&&(// If we use mutation we drill down into portals using commitUnmount above.
// If we don't use mutation we drill down into portals here instead.
!supportsMutation||node.tag!==HostPortal)){node.child.return=node;node=node.child;continue;}if(node===root){return;}while(node.sibling===null){if(node.return===null||node.return===root){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}function detachFiber(current$$1){// Cut off the return pointers to disconnect it from the tree. Ideally, we
// should clear the child pointer of the parent alternate to let this
// get GC:ed but we don't know which for sure which parent is the current
// one so we'll settle for GC:ing the subtree of this child. This child
// itself will be GC:ed when the parent updates the next time.
current$$1.return=null;current$$1.child=null;if(current$$1.alternate){current$$1.alternate.child=null;current$$1.alternate.return=null;}}function emptyPortalContainer(current$$1){if(!supportsPersistence){return;}var portal=current$$1.stateNode;var containerInfo=portal.containerInfo;var emptyChildSet=createContainerChildSet(containerInfo);replaceContainerChildren(containerInfo,emptyChildSet);}function commitContainer(finishedWork){if(!supportsPersistence){return;}switch(finishedWork.tag){case ClassComponent:case ClassComponentLazy:{return;}case HostComponent:{return;}case HostText:{return;}case HostRoot:case HostPortal:{var portalOrRoot=finishedWork.stateNode;var containerInfo=portalOrRoot.containerInfo,_pendingChildren=portalOrRoot.pendingChildren;replaceContainerChildren(containerInfo,_pendingChildren);return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function getHostParentFiber(fiber){var parent=fiber.return;while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent.return;}invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host
// node. Unfortunately, if multiple insertions are done in a row we have to
// search past them. This leads to exponential search for the next sibling.
var node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.
while(node.sibling===null){if(node.return===null||isHostParent(node.return)){// If we pop out of the root or hit the parent the fiber we are the
// last sibling.
return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText){// If it is not host node and, we might have a host node inside it.
// Try to search down until we find one.
if(node.effectTag&Placement){// If we don't have a child, try the siblings instead.
continue siblings;}// If we don't have a child, try the siblings instead.
// We also skip portals because they are not part of this host tree.
if(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child.return=node;node=node.child;}}// Check if this host node is stable or about to be placed.
if(!(node.effectTag&Placement)){// Found it!
return node.stateNode;}}}function commitPlacement(finishedWork){if(!supportsMutation){return;}// Recursively insert all host nodes into the parent.
var parentFiber=getHostParentFiber(finishedWork);// Note: these two variables *must* always be updated together.
var parent=void 0;var isContainer=void 0;switch(parentFiber.tag){case HostComponent:parent=parentFiber.stateNode;isContainer=false;break;case HostRoot:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;case HostPortal:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;default:invariant(false,'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');}if(parentFiber.effectTag&ContentReset){// Reset the text content of the parent before doing any insertions
resetTextContent(parent);// Clear ContentReset from the effect tag
parentFiber.effectTag&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need recurse down its
// children to find all the terminal nodes.
var node=finishedWork;while(true){if(node.tag===HostComponent||node.tag===HostText){if(before){if(isContainer){insertInContainerBefore(parent,node.stateNode,before);}else{insertBefore(parent,node.stateNode,before);}}else{if(isContainer){appendChildToContainer(parent,node.stateNode);}else{appendChild(parent,node.stateNode);}}}else if(node.tag===HostPortal){// If the insertion itself is a portal, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node.return===null||node.return===finishedWork){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}function unmountHostComponents(current$$1){// We only have the top Fiber that was deleted but we need recurse down its
var node=current$$1;// Each iteration, currentParent is populated with node's host parent if not
// currentParentIsValid.
var currentParentIsValid=false;// Note: these two variables *must* always be updated together.
var currentParent=void 0;var currentParentIsContainer=void 0;while(true){if(!currentParentIsValid){var parent=node.return;findParent:while(true){!(parent!==null)?invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'):void 0;switch(parent.tag){case HostComponent:currentParent=parent.stateNode;currentParentIsContainer=false;break findParent;case HostRoot:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;case HostPortal:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;}parent=parent.return;}currentParentIsValid=true;}if(node.tag===HostComponent||node.tag===HostText){commitNestedUnmounts(node);// After all the children have unmounted, it is now safe to remove the
// node from the tree.
if(currentParentIsContainer){removeChildFromContainer(currentParent,node.stateNode);}else{removeChild(currentParent,node.stateNode);}// Don't visit children because we already visited them.
}else if(node.tag===HostPortal){// When we go into a portal, it becomes the parent to remove from.
// We will reassign it back when we pop the portal on the way up.
currentParent=node.stateNode.containerInfo;currentParentIsContainer=true;// Visit children because portals might contain host components.
if(node.child!==null){node.child.return=node;node=node.child;continue;}}else{commitUnmount(node);// Visit children because we may find more host components below.
if(node.child!==null){node.child.return=node;node=node.child;continue;}}if(node===current$$1){return;}while(node.sibling===null){if(node.return===null||node.return===current$$1){return;}node=node.return;if(node.tag===HostPortal){// When we go out of the portal, we need to restore the parent.
// Since we don't keep a stack of them, we will search for it.
currentParentIsValid=false;}}node.sibling.return=node.return;node=node.sibling;}}function commitDeletion(current$$1){if(supportsMutation){// Recursively delete all host nodes from the parent.
// Detach refs and call componentWillUnmount() on the whole subtree.
unmountHostComponents(current$$1);}else{// Detach refs and call componentWillUnmount() on the whole subtree.
commitNestedUnmounts(current$$1);}detachFiber(current$$1);}function commitWork(current$$1,finishedWork){if(!supportsMutation){commitContainer(finishedWork);return;}switch(finishedWork.tag){case ClassComponent:case ClassComponentLazy:{return;}case HostComponent:{var instance=finishedWork.stateNode;if(instance!=null){// Commit the work prepared earlier.
var newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldProps=current$$1!==null?current$$1.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.
var updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){commitUpdate(instance,updatePayload,type,oldProps,newProps,finishedWork);}}return;}case HostText:{!(finishedWork.stateNode!==null)?invariant(false,'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.'):void 0;var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldText=current$$1!==null?current$$1.memoizedProps:newText;commitTextUpdate(textInstance,oldText,newText);return;}case HostRoot:{return;}case Profiler:{return;}case PlaceholderComponent:{return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitResetTextContent(current$$1){if(!supportsMutation){return;}resetTextContent(current$$1.stateNode);}function NoopComponent(){return null;}function createRootErrorUpdate(fiber,errorInfo,expirationTime){var update=createUpdate(expirationTime);// Unmount the root by rendering null.
update.tag=CaptureUpdate;// Caution: React DevTools currently depends on this property
// being called "element".
update.payload={element:null};var error=errorInfo.value;update.callback=function(){onUncaughtError(error);logError(fiber,errorInfo);};return update;}function createClassErrorUpdate(fiber,errorInfo,expirationTime){var update=createUpdate(expirationTime);update.tag=CaptureUpdate;var getDerivedStateFromCatch=fiber.type.getDerivedStateFromCatch;if(enableGetDerivedStateFromCatch&&typeof getDerivedStateFromCatch==='function'){var error=errorInfo.value;update.payload=function(){return getDerivedStateFromCatch(error);};}var inst=fiber.stateNode;if(inst!==null&&typeof inst.componentDidCatch==='function'){update.callback=function callback(){if(!enableGetDerivedStateFromCatch||getDerivedStateFromCatch!=='function'){// To preserve the preexisting retry behavior of error boundaries,
// we keep track of which ones already failed during this batch.
// This gets reset before we yield back to the browser.
// TODO: Warn in strict mode if getDerivedStateFromCatch is
// not defined.
markLegacyErrorBoundaryAsFailed(this);}var error=errorInfo.value;var stack=errorInfo.stack;logError(fiber,errorInfo);this.componentDidCatch(error,{componentStack:stack!==null?stack:''});};}return update;}function throwException(root,returnFiber,sourceFiber,value,renderExpirationTime){// The source fiber did not complete.
sourceFiber.effectTag|=Incomplete;// Its effect list is no longer valid.
sourceFiber.firstEffect=sourceFiber.lastEffect=null;if(enableSuspense&&value!==null&&(typeof value==='undefined'?'undefined':_typeof(value))==='object'&&typeof value.then==='function'){// This is a thenable.
var thenable=value;// Find the earliest timeout threshold of all the placeholders in the
// ancestor path. We could avoid this traversal by storing the thresholds on
// the stack, but we choose not to because we only hit this path if we're
// IO-bound (i.e. if something suspends). Whereas the stack is used even in
// the non-IO- bound case.
var _workInProgress=returnFiber;var earliestTimeoutMs=-1;var startTimeMs=-1;do{if(_workInProgress.tag===PlaceholderComponent){var current=_workInProgress.alternate;if(current!==null&&current.memoizedState===true&&current.stateNode!==null){// Reached a placeholder that already timed out. Each timed out
// placeholder acts as the root of a new suspense boundary.
// Use the time at which the placeholder timed out as the start time
// for the current render.
var timedOutAt=current.stateNode.timedOutAt;startTimeMs=expirationTimeToMs(timedOutAt);// Do not search any further.
break;}var timeoutPropMs=_workInProgress.pendingProps.delayMs;if(typeof timeoutPropMs==='number'){if(timeoutPropMs<=0){earliestTimeoutMs=0;}else if(earliestTimeoutMs===-1||timeoutPropMs<earliestTimeoutMs){earliestTimeoutMs=timeoutPropMs;}}}_workInProgress=_workInProgress.return;}while(_workInProgress!==null);// Schedule the nearest Placeholder to re-render the timed out view.
_workInProgress=returnFiber;do{if(_workInProgress.tag===PlaceholderComponent){var didTimeout=_workInProgress.memoizedState;if(!didTimeout){// Found the nearest boundary.
// If the boundary is not in async mode, we should not suspend, and
// likewise, when the promise resolves, we should ping synchronously.
var pingTime=(_workInProgress.mode&AsyncMode)===NoEffect?Sync:renderExpirationTime;// Attach a listener to the promise to "ping" the root and retry.
var onResolveOrReject=retrySuspendedRoot.bind(null,root,_workInProgress,pingTime);thenable.then(onResolveOrReject,onResolveOrReject);// If the boundary is outside of strict mode, we should *not* suspend
// the commit. Pretend as if the suspended component rendered null and
// keep rendering. In the commit phase, we'll schedule a subsequent
// synchronous update to re-render the Placeholder.
//
// Note: It doesn't matter whether the component that suspended was
// inside a strict mode tree. If the Placeholder is outside of it, we
// should *not* suspend the commit.
if((_workInProgress.mode&StrictMode)===NoEffect){_workInProgress.effectTag|=Update;// Unmount the source fiber's children
var nextChildren=null;reconcileChildren(sourceFiber.alternate,sourceFiber,nextChildren,renderExpirationTime);sourceFiber.effectTag&=~Incomplete;if(sourceFiber.tag===IndeterminateComponent){// Let's just assume it's a functional component. This fiber will
// be unmounted in the immediate next commit, anyway.
sourceFiber.tag=FunctionalComponent;}if(sourceFiber.tag===ClassComponent||sourceFiber.tag===ClassComponentLazy){// We're going to commit this fiber even though it didn't
// complete. But we shouldn't call any lifecycle methods or
// callbacks. Remove all lifecycle effect tags.
sourceFiber.effectTag&=~LifecycleEffectMask;if(sourceFiber.alternate===null){// We're about to mount a class component that doesn't have an
// instance. Turn this into a dummy functional component instead,
// to prevent type errors. This is a bit weird but it's an edge
// case and we're about to synchronously delete this
// component, anyway.
sourceFiber.tag=FunctionalComponent;sourceFiber.type=NoopComponent;}}// Exit without suspending.
return;}// Confirmed that the boundary is in a strict mode tree. Continue with
// the normal suspend path.
var absoluteTimeoutMs=void 0;if(earliestTimeoutMs===-1){// If no explicit threshold is given, default to an abitrarily large
// value. The actual size doesn't matter because the threshold for the
// whole tree will be clamped to the expiration time.
absoluteTimeoutMs=maxSigned31BitInt;}else{if(startTimeMs===-1){// This suspend happened outside of any already timed-out
// placeholders. We don't know exactly when the update was scheduled,
// but we can infer an approximate start time from the expiration
// time. First, find the earliest uncommitted expiration time in the
// tree, including work that is suspended. Then subtract the offset
// used to compute an async update's expiration time. This will cause
// high priority (interactive) work to expire earlier than necessary,
// but we can account for this by adjusting for the Just Noticeable
// Difference.
var earliestExpirationTime=findEarliestOutstandingPriorityLevel(root,renderExpirationTime);var earliestExpirationTimeMs=expirationTimeToMs(earliestExpirationTime);startTimeMs=earliestExpirationTimeMs-LOW_PRIORITY_EXPIRATION;}absoluteTimeoutMs=startTimeMs+earliestTimeoutMs;}// Mark the earliest timeout in the suspended fiber's ancestor path.
// After completing the root, we'll take the largest of all the
// suspended fiber's timeouts and use it to compute a timeout for the
// whole tree.
renderDidSuspend(root,absoluteTimeoutMs,renderExpirationTime);_workInProgress.effectTag|=ShouldCapture;_workInProgress.expirationTime=renderExpirationTime;return;}// This boundary already captured during this render. Continue to the
// next boundary.
}_workInProgress=_workInProgress.return;}while(_workInProgress!==null);// No boundary was found. Fallthrough to error mode.
value=new Error('An update was suspended, but no placeholder UI was provided.');}// We didn't find a boundary that could handle this type of exception. Start
// over and traverse parent path again, this time treating the exception
// as an error.
renderDidError();value=createCapturedValue(value,sourceFiber);var workInProgress=returnFiber;do{switch(workInProgress.tag){case HostRoot:{var _errorInfo=value;workInProgress.effectTag|=ShouldCapture;workInProgress.expirationTime=renderExpirationTime;var update=createRootErrorUpdate(workInProgress,_errorInfo,renderExpirationTime);enqueueCapturedUpdate(workInProgress,update);return;}case ClassComponent:case ClassComponentLazy:// Capture and retry
var errorInfo=value;var ctor=workInProgress.type;var instance=workInProgress.stateNode;if((workInProgress.effectTag&DidCapture)===NoEffect&&(typeof ctor.getDerivedStateFromCatch==='function'&&enableGetDerivedStateFromCatch||instance!==null&&typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance))){workInProgress.effectTag|=ShouldCapture;workInProgress.expirationTime=renderExpirationTime;// Schedule the error boundary to re-render using updated state
var _update=createClassErrorUpdate(workInProgress,errorInfo,renderExpirationTime);enqueueCapturedUpdate(workInProgress,_update);return;}break;default:break;}workInProgress=workInProgress.return;}while(workInProgress!==null);}function unwindWork(workInProgress,renderExpirationTime){switch(workInProgress.tag){case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}var effectTag=workInProgress.effectTag;if(effectTag&ShouldCapture){workInProgress.effectTag=effectTag&~ShouldCapture|DidCapture;return workInProgress;}return null;}case ClassComponentLazy:{var _Component=workInProgress.type._reactResult;if(isContextProvider(_Component)){popContext(workInProgress);}var _effectTag=workInProgress.effectTag;if(_effectTag&ShouldCapture){workInProgress.effectTag=_effectTag&~ShouldCapture|DidCapture;return workInProgress;}return null;}case HostRoot:{popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);var _effectTag2=workInProgress.effectTag;!((_effectTag2&DidCapture)===NoEffect)?invariant(false,'The root failed to unmount after an error. This is likely a bug in React. Please file an issue.'):void 0;workInProgress.effectTag=_effectTag2&~ShouldCapture|DidCapture;return workInProgress;}case HostComponent:{popHostContext(workInProgress);return null;}case PlaceholderComponent:{var _effectTag3=workInProgress.effectTag;if(_effectTag3&ShouldCapture){workInProgress.effectTag=_effectTag3&~ShouldCapture|DidCapture;return workInProgress;}return null;}case HostPortal:popHostContainer(workInProgress);return null;case ContextProvider:popProvider(workInProgress);return null;default:return null;}}function unwindInterruptedWork(interruptedWork){switch(interruptedWork.tag){case ClassComponent:{var childContextTypes=interruptedWork.type.childContextTypes;if(childContextTypes!==null&&childContextTypes!==undefined){popContext(interruptedWork);}break;}case ClassComponentLazy:{var _childContextTypes=interruptedWork.type._reactResult.childContextTypes;if(_childContextTypes!==null&&_childContextTypes!==undefined){popContext(interruptedWork);}break;}case HostRoot:{popHostContainer(interruptedWork);popTopLevelContextObject(interruptedWork);break;}case HostComponent:{popHostContext(interruptedWork);break;}case HostPortal:popHostContainer(interruptedWork);break;case ContextProvider:popProvider(interruptedWork);break;default:break;}}var Dispatcher={readContext:readContext};var ReactCurrentOwner$2=ReactSharedInternals.ReactCurrentOwner;var didWarnAboutStateTransition=void 0;var didWarnSetStateChildContext=void 0;var warnAboutUpdateOnUnmounted=void 0;var warnAboutInvalidUpdates=void 0;if(enableSchedulerTracing){// Provide explicit error message when production+profiling bundle of e.g. react-dom
// is used with production (non-profiling) bundle of schedule/tracing
!(tracing.__interactionsRef!=null&&tracing.__interactionsRef.current!=null)?invariant(false,'It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `schedule/tracing` module with `schedule/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at http://fb.me/react-profiling'):void 0;}{didWarnAboutStateTransition=false;didWarnSetStateChildContext=false;var didWarnStateUpdateForUnmountedComponent={};warnAboutUpdateOnUnmounted=function warnAboutUpdateOnUnmounted(fiber){// We show the whole stack but dedupe on the top component's name because
// the problematic code almost always lies inside that component.
var componentName=getComponentName(fiber.type)||'ReactClass';if(didWarnStateUpdateForUnmountedComponent[componentName]){return;}warningWithoutStack$1(false,"Can't call setState (or forceUpdate) on an unmounted component. This "+'is a no-op, but it indicates a memory leak in your application. To '+'fix, cancel all subscriptions and asynchronous tasks in the '+'componentWillUnmount method.%s',getStackByFiberInDevAndProd(fiber));didWarnStateUpdateForUnmountedComponent[componentName]=true;};warnAboutInvalidUpdates=function warnAboutInvalidUpdates(instance){switch(phase){case'getChildContext':if(didWarnSetStateChildContext){return;}warningWithoutStack$1(false,'setState(...): Cannot call setState() inside getChildContext()');didWarnSetStateChildContext=true;break;case'render':if(didWarnAboutStateTransition){return;}warningWithoutStack$1(false,'Cannot update during an existing state transition (such as within '+'`render`). Render methods should be a pure function of props and state.');didWarnAboutStateTransition=true;break;}};}// Used to ensure computeUniqueAsyncExpiration is monotonically increasing.
var lastUniqueAsyncExpiration=0;// Represents the expiration time that incoming updates should use. (If this
// is NoWork, use the default strategy: async updates in async mode, sync
// updates in sync mode.)
var expirationContext=NoWork;var isWorking=false;// The next work in progress fiber that we're currently working on.
var nextUnitOfWork=null;var nextRoot=null;// The time at which we're currently rendering work.
var nextRenderExpirationTime=NoWork;var nextLatestAbsoluteTimeoutMs=-1;var nextRenderDidError=false;// The next fiber with an effect that we're currently committing.
var nextEffect=null;var isCommitting$1=false;var legacyErrorBoundariesThatAlreadyFailed=null;// Used for performance tracking.
var interruptedBy=null;// Do not decrement interaction counts in the event of suspense timeouts.
// This would lead to prematurely calling the interaction-complete hook.
var suspenseDidTimeout=false;var stashedWorkInProgressProperties=void 0;var replayUnitOfWork=void 0;var isReplayingFailedUnitOfWork=void 0;var originalReplayError=void 0;var rethrowOriginalError=void 0;if(true&&replayFailedUnitOfWorkWithInvokeGuardedCallback){stashedWorkInProgressProperties=null;isReplayingFailedUnitOfWork=false;originalReplayError=null;replayUnitOfWork=function replayUnitOfWork(failedUnitOfWork,thrownValue,isYieldy){if(thrownValue!==null&&(typeof thrownValue==='undefined'?'undefined':_typeof(thrownValue))==='object'&&typeof thrownValue.then==='function'){// Don't replay promises. Treat everything else like an error.
// TODO: Need to figure out a different strategy if/when we add
// support for catching other types.
return;}// Restore the original state of the work-in-progress
if(stashedWorkInProgressProperties===null){// This should never happen. Don't throw because this code is DEV-only.
warningWithoutStack$1(false,'Could not replay rendering after an error. This is likely a bug in React. '+'Please file an issue.');return;}assignFiberPropertiesInDEV(failedUnitOfWork,stashedWorkInProgressProperties);switch(failedUnitOfWork.tag){case HostRoot:popHostContainer(failedUnitOfWork);popTopLevelContextObject(failedUnitOfWork);break;case HostComponent:popHostContext(failedUnitOfWork);break;case ClassComponent:{var Component=failedUnitOfWork.type;if(isContextProvider(Component)){popContext(failedUnitOfWork);}break;}case ClassComponentLazy:{var _Component=getResultFromResolvedThenable(failedUnitOfWork.type);if(isContextProvider(_Component)){popContext(failedUnitOfWork);}break;}case HostPortal:popHostContainer(failedUnitOfWork);break;case ContextProvider:popProvider(failedUnitOfWork);break;}// Replay the begin phase.
isReplayingFailedUnitOfWork=true;originalReplayError=thrownValue;invokeGuardedCallback(null,workLoop,null,isYieldy);isReplayingFailedUnitOfWork=false;originalReplayError=null;if(hasCaughtError()){var replayError=clearCaughtError();if(replayError!=null&&thrownValue!=null){try{// Reading the expando property is intentionally
// inside `try` because it might be a getter or Proxy.
if(replayError._suppressLogging){// Also suppress logging for the original error.
thrownValue._suppressLogging=true;}}catch(inner){// Ignore.
}}}else{// If the begin phase did not fail the second time, set this pointer
// back to the original value.
nextUnitOfWork=failedUnitOfWork;}};rethrowOriginalError=function rethrowOriginalError(){throw originalReplayError;};}function resetStack(){if(nextUnitOfWork!==null){var interruptedWork=nextUnitOfWork.return;while(interruptedWork!==null){unwindInterruptedWork(interruptedWork);interruptedWork=interruptedWork.return;}}{ReactStrictModeWarnings.discardPendingWarnings();checkThatStackIsEmpty();}nextRoot=null;nextRenderExpirationTime=NoWork;nextLatestAbsoluteTimeoutMs=-1;nextRenderDidError=false;nextUnitOfWork=null;}function commitAllHostEffects(){while(nextEffect!==null){{setCurrentFiber(nextEffect);}recordEffect();var effectTag=nextEffect.effectTag;if(effectTag&ContentReset){commitResetTextContent(nextEffect);}if(effectTag&Ref){var current$$1=nextEffect.alternate;if(current$$1!==null){commitDetachRef(current$$1);}}// The following switch statement is only concerned about placement,
// updates, and deletions. To avoid needing to add a case for every
// possible bitmap value, we remove the secondary effects from the
// effect tag and switch on that value.
var primaryEffectTag=effectTag&(Placement|Update|Deletion);switch(primaryEffectTag){case Placement:{commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is inserted, before
// any life-cycles like componentDidMount gets called.
// TODO: findDOMNode doesn't rely on this any more but isMounted
// does and isMounted is deprecated anyway so we should be able
// to kill this.
nextEffect.effectTag&=~Placement;break;}case PlacementAndUpdate:{// Placement
commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is inserted, before
// any life-cycles like componentDidMount gets called.
nextEffect.effectTag&=~Placement;// Update
var _current=nextEffect.alternate;commitWork(_current,nextEffect);break;}case Update:{var _current2=nextEffect.alternate;commitWork(_current2,nextEffect);break;}case Deletion:{commitDeletion(nextEffect);break;}}nextEffect=nextEffect.nextEffect;}{resetCurrentFiber();}}function commitBeforeMutationLifecycles(){while(nextEffect!==null){{setCurrentFiber(nextEffect);}var effectTag=nextEffect.effectTag;if(effectTag&Snapshot){recordEffect();var current$$1=nextEffect.alternate;commitBeforeMutationLifeCycles(current$$1,nextEffect);}// Don't cleanup effects yet;
// This will be done by commitAllLifeCycles()
nextEffect=nextEffect.nextEffect;}{resetCurrentFiber();}}function commitAllLifeCycles(finishedRoot,committedExpirationTime){{ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();if(warnAboutDeprecatedLifecycles){ReactStrictModeWarnings.flushPendingDeprecationWarnings();}if(warnAboutLegacyContextAPI){ReactStrictModeWarnings.flushLegacyContextWarning();}}while(nextEffect!==null){var effectTag=nextEffect.effectTag;if(effectTag&(Update|Callback)){recordEffect();var current$$1=nextEffect.alternate;commitLifeCycles(finishedRoot,current$$1,nextEffect,committedExpirationTime);}if(effectTag&Ref){recordEffect();commitAttachRef(nextEffect);}var next=nextEffect.nextEffect;// Ensure that we clean these up so that we don't accidentally keep them.
// I'm not actually sure this matters because we can't reset firstEffect
// and lastEffect since they're on every node, not just the effectful
// ones. So we have to clean everything as we reuse nodes anyway.
nextEffect.nextEffect=null;// Ensure that we reset the effectTag here so that we can rely on effect
// tags to reason about the current life-cycle.
nextEffect=next;}}function isAlreadyFailedLegacyErrorBoundary(instance){return legacyErrorBoundariesThatAlreadyFailed!==null&&legacyErrorBoundariesThatAlreadyFailed.has(instance);}function markLegacyErrorBoundaryAsFailed(instance){if(legacyErrorBoundariesThatAlreadyFailed===null){legacyErrorBoundariesThatAlreadyFailed=new Set([instance]);}else{legacyErrorBoundariesThatAlreadyFailed.add(instance);}}function commitRoot(root,finishedWork){isWorking=true;isCommitting$1=true;startCommitTimer();!(root.current!==finishedWork)?invariant(false,'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.'):void 0;var committedExpirationTime=root.pendingCommitExpirationTime;!(committedExpirationTime!==NoWork)?invariant(false,'Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.'):void 0;root.pendingCommitExpirationTime=NoWork;// Update the pending priority levels to account for the work that we are
// about to commit. This needs to happen before calling the lifecycles, since
// they may schedule additional updates.
var updateExpirationTimeBeforeCommit=finishedWork.expirationTime;var childExpirationTimeBeforeCommit=finishedWork.childExpirationTime;var earliestRemainingTimeBeforeCommit=updateExpirationTimeBeforeCommit===NoWork||childExpirationTimeBeforeCommit!==NoWork&&childExpirationTimeBeforeCommit<updateExpirationTimeBeforeCommit?childExpirationTimeBeforeCommit:updateExpirationTimeBeforeCommit;markCommittedPriorityLevels(root,earliestRemainingTimeBeforeCommit);var prevInteractions=null;var committedInteractions=enableSchedulerTracing?[]:null;if(enableSchedulerTracing){// Restore any pending interactions at this point,
// So that cascading work triggered during the render phase will be accounted for.
prevInteractions=tracing.__interactionsRef.current;tracing.__interactionsRef.current=root.memoizedInteractions;// We are potentially finished with the current batch of interactions.
// So we should clear them out of the pending interaction map.
// We do this at the start of commit in case cascading work is scheduled by commit phase lifecycles.
// In that event, interaction data may be added back into the pending map for a future commit.
// We also store the interactions we are about to commit so that we can notify subscribers after we're done.
// These are stored as an Array rather than a Set,
// Because the same interaction may be pending for multiple expiration times,
// In which case it's important that we decrement the count the right number of times after finishing.
root.pendingInteractionMap.forEach(function(scheduledInteractions,scheduledExpirationTime){if(scheduledExpirationTime<=committedExpirationTime){committedInteractions.push.apply(committedInteractions,Array.from(scheduledInteractions));root.pendingInteractionMap.delete(scheduledExpirationTime);}});}// Reset this to null before calling lifecycles
ReactCurrentOwner$2.current=null;var firstEffect=void 0;if(finishedWork.effectTag>PerformedWork){// A fiber's effect list consists only of its children, not itself. So if
// the root has an effect, we need to add it to the end of the list. The
// resulting list is the set that would belong to the root's parent, if
// it had one; that is, all the effects in the tree including the root.
if(finishedWork.lastEffect!==null){finishedWork.lastEffect.nextEffect=finishedWork;firstEffect=finishedWork.firstEffect;}else{firstEffect=finishedWork;}}else{// There is no effect on the root.
firstEffect=finishedWork.firstEffect;}prepareForCommit(root.containerInfo);// Invoke instances of getSnapshotBeforeUpdate before mutation.
nextEffect=firstEffect;startCommitSnapshotEffectsTimer();while(nextEffect!==null){var didError=false;var error=void 0;{invokeGuardedCallback(null,commitBeforeMutationLifecycles,null);if(hasCaughtError()){didError=true;error=clearCaughtError();}}if(didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureCommitPhaseError(nextEffect,error);// Clean-up
if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}stopCommitSnapshotEffectsTimer();if(enableProfilerTimer){// Mark the current commit time to be shared by all Profilers in this batch.
// This enables them to be grouped later.
recordCommitTime();}// Commit all the side-effects within a tree. We'll do this in two passes.
// The first pass performs all the host insertions, updates, deletions and
// ref unmounts.
nextEffect=firstEffect;startCommitHostEffectsTimer();while(nextEffect!==null){var _didError=false;var _error=void 0;{invokeGuardedCallback(null,commitAllHostEffects,null);if(hasCaughtError()){_didError=true;_error=clearCaughtError();}}if(_didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureCommitPhaseError(nextEffect,_error);// Clean-up
if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}stopCommitHostEffectsTimer();resetAfterCommit(root.containerInfo);// The work-in-progress tree is now the current tree. This must come after
// the first pass of the commit phase, so that the previous tree is still
// current during componentWillUnmount, but before the second pass, so that
// the finished work is current during componentDidMount/Update.
root.current=finishedWork;// In the second pass we'll perform all life-cycles and ref callbacks.
// Life-cycles happen as a separate pass so that all placements, updates,
// and deletions in the entire tree have already been invoked.
// This pass also triggers any renderer-specific initial effects.
nextEffect=firstEffect;startCommitLifeCyclesTimer();while(nextEffect!==null){var _didError2=false;var _error2=void 0;{invokeGuardedCallback(null,commitAllLifeCycles,null,root,committedExpirationTime);if(hasCaughtError()){_didError2=true;_error2=clearCaughtError();}}if(_didError2){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureCommitPhaseError(nextEffect,_error2);if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}isCommitting$1=false;isWorking=false;stopCommitLifeCyclesTimer();stopCommitTimer();onCommitRoot(finishedWork.stateNode);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);}var updateExpirationTimeAfterCommit=finishedWork.expirationTime;var childExpirationTimeAfterCommit=finishedWork.childExpirationTime;var earliestRemainingTimeAfterCommit=updateExpirationTimeAfterCommit===NoWork||childExpirationTimeAfterCommit!==NoWork&&childExpirationTimeAfterCommit<updateExpirationTimeAfterCommit?childExpirationTimeAfterCommit:updateExpirationTimeAfterCommit;if(earliestRemainingTimeAfterCommit===NoWork){// If there's no remaining work, we can clear the set of already failed
// error boundaries.
legacyErrorBoundariesThatAlreadyFailed=null;}onCommit(root,earliestRemainingTimeAfterCommit);if(enableSchedulerTracing){tracing.__interactionsRef.current=prevInteractions;var subscriber=void 0;try{subscriber=tracing.__subscriberRef.current;if(subscriber!==null&&root.memoizedInteractions.size>0){var threadID=computeThreadID(committedExpirationTime,root.interactionThreadID);subscriber.onWorkStopped(root.memoizedInteractions,threadID);}}catch(error){// It's not safe for commitRoot() to throw.
// Store the error for now and we'll re-throw in finishRendering().
if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}finally{// Don't update interaction counts if we're frozen due to suspense.
// In this case, we can skip the completed-work check entirely.
if(!suspenseDidTimeout){// Now that we're done, check the completed batch of interactions.
// If no more work is outstanding for a given interaction,
// We need to notify the subscribers that it's finished.
committedInteractions.forEach(function(interaction){interaction.__count--;if(subscriber!==null&&interaction.__count===0){try{subscriber.onInteractionScheduledWorkCompleted(interaction);}catch(error){// It's not safe for commitRoot() to throw.
// Store the error for now and we'll re-throw in finishRendering().
if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}}});}}}}function resetChildExpirationTime(workInProgress,renderTime){if(renderTime!==Never&&workInProgress.childExpirationTime===Never){// The children of this component are hidden. Don't bubble their
// expiration times.
return;}var newChildExpirationTime=NoWork;// Bubble up the earliest expiration time.
if(enableProfilerTimer&&workInProgress.mode&ProfileMode){// We're in profiling mode.
// Let's use this same traversal to update the render durations.
var actualDuration=workInProgress.actualDuration;var treeBaseDuration=workInProgress.selfBaseDuration;// When a fiber is cloned, its actualDuration is reset to 0.
// This value will only be updated if work is done on the fiber (i.e. it doesn't bailout).
// When work is done, it should bubble to the parent's actualDuration.
// If the fiber has not been cloned though, (meaning no work was done),
// Then this value will reflect the amount of time spent working on a previous render.
// In that case it should not bubble.
// We determine whether it was cloned by comparing the child pointer.
var shouldBubbleActualDurations=workInProgress.alternate===null||workInProgress.child!==workInProgress.alternate.child;var child=workInProgress.child;while(child!==null){var childUpdateExpirationTime=child.expirationTime;var childChildExpirationTime=child.childExpirationTime;if(newChildExpirationTime===NoWork||childUpdateExpirationTime!==NoWork&&childUpdateExpirationTime<newChildExpirationTime){newChildExpirationTime=childUpdateExpirationTime;}if(newChildExpirationTime===NoWork||childChildExpirationTime!==NoWork&&childChildExpirationTime<newChildExpirationTime){newChildExpirationTime=childChildExpirationTime;}if(shouldBubbleActualDurations){actualDuration+=child.actualDuration;}treeBaseDuration+=child.treeBaseDuration;child=child.sibling;}workInProgress.actualDuration=actualDuration;workInProgress.treeBaseDuration=treeBaseDuration;}else{var _child=workInProgress.child;while(_child!==null){var _childUpdateExpirationTime=_child.expirationTime;var _childChildExpirationTime=_child.childExpirationTime;if(newChildExpirationTime===NoWork||_childUpdateExpirationTime!==NoWork&&_childUpdateExpirationTime<newChildExpirationTime){newChildExpirationTime=_childUpdateExpirationTime;}if(newChildExpirationTime===NoWork||_childChildExpirationTime!==NoWork&&_childChildExpirationTime<newChildExpirationTime){newChildExpirationTime=_childChildExpirationTime;}_child=_child.sibling;}}workInProgress.childExpirationTime=newChildExpirationTime;}function completeUnitOfWork(workInProgress){// Attempt to complete the current unit of work, then move to the
// next sibling. If there are no more siblings, return to the
// parent fiber.
while(true){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current$$1=workInProgress.alternate;{setCurrentFiber(workInProgress);}var returnFiber=workInProgress.return;var siblingFiber=workInProgress.sibling;if((workInProgress.effectTag&Incomplete)===NoEffect){// This fiber completed.
if(enableProfilerTimer){if(workInProgress.mode&ProfileMode){startProfilerTimer(workInProgress);}nextUnitOfWork=completeWork(current$$1,workInProgress,nextRenderExpirationTime);if(workInProgress.mode&ProfileMode){// Update render duration assuming we didn't error.
stopProfilerTimerIfRunningAndRecordDelta(workInProgress,false);}}else{nextUnitOfWork=completeWork(current$$1,workInProgress,nextRenderExpirationTime);}var next=nextUnitOfWork;stopWorkTimer(workInProgress);resetChildExpirationTime(workInProgress,nextRenderExpirationTime);{resetCurrentFiber();}if(next!==null){stopWorkTimer(workInProgress);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}// If completing this work spawned new work, do that next. We'll come
// back here again.
return next;}if(returnFiber!==null&&// Do not append effects to parents if a sibling failed to complete
(returnFiber.effectTag&Incomplete)===NoEffect){// Append all the effects of the subtree and this fiber onto the effect
// list of the parent. The completion order of the children affects the
// side-effect order.
if(returnFiber.firstEffect===null){returnFiber.firstEffect=workInProgress.firstEffect;}if(workInProgress.lastEffect!==null){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress.firstEffect;}returnFiber.lastEffect=workInProgress.lastEffect;}// If this fiber had side-effects, we append it AFTER the children's
// side-effects. We can perform certain side-effects earlier if
// needed, by doing multiple passes over the effect list. We don't want
// to schedule our own side-effect on our own list because if end up
// reusing children we'll schedule this effect onto itself since we're
// at the end.
var effectTag=workInProgress.effectTag;// Skip both NoWork and PerformedWork tags when creating the effect list.
// PerformedWork effect is read by React DevTools but shouldn't be committed.
if(effectTag>PerformedWork){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress;}else{returnFiber.firstEffect=workInProgress;}returnFiber.lastEffect=workInProgress;}}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.
return siblingFiber;}else if(returnFiber!==null){// If there's no more work in this returnFiber. Complete the returnFiber.
workInProgress=returnFiber;continue;}else{// We've reached the root.
return null;}}else{if(workInProgress.mode&ProfileMode){// Record the render duration for the fiber that errored.
stopProfilerTimerIfRunningAndRecordDelta(workInProgress,false);}// This fiber did not complete because something threw. Pop values off
// the stack without entering the complete phase. If this is a boundary,
// capture values if possible.
var _next=unwindWork(workInProgress,nextRenderExpirationTime);// Because this fiber did not complete, don't reset its expiration time.
if(workInProgress.effectTag&DidCapture){// Restarting an error boundary
stopFailedWorkTimer(workInProgress);}else{stopWorkTimer(workInProgress);}{resetCurrentFiber();}if(_next!==null){stopWorkTimer(workInProgress);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}if(enableProfilerTimer){// Include the time spent working on failed children before continuing.
if(_next.mode&ProfileMode){var actualDuration=_next.actualDuration;var child=_next.child;while(child!==null){actualDuration+=child.actualDuration;child=child.sibling;}_next.actualDuration=actualDuration;}}// If completing this work spawned new work, do that next. We'll come
// back here again.
// Since we're restarting, remove anything that is not a host effect
// from the effect tag.
_next.effectTag&=HostEffectMask;return _next;}if(returnFiber!==null){// Mark the parent fiber as incomplete and clear its effect list.
returnFiber.firstEffect=returnFiber.lastEffect=null;returnFiber.effectTag|=Incomplete;}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.
return siblingFiber;}else if(returnFiber!==null){// If there's no more work in this returnFiber. Complete the returnFiber.
workInProgress=returnFiber;continue;}else{return null;}}}// Without this explicit null return Flow complains of invalid return type
// TODO Remove the above while(true) loop
// eslint-disable-next-line no-unreachable
return null;}function performUnitOfWork(workInProgress){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current$$1=workInProgress.alternate;// See if beginning this work spawns more work.
startWorkTimer(workInProgress);{setCurrentFiber(workInProgress);}if(true&&replayFailedUnitOfWorkWithInvokeGuardedCallback){stashedWorkInProgressProperties=assignFiberPropertiesInDEV(stashedWorkInProgressProperties,workInProgress);}var next=void 0;if(enableProfilerTimer){if(workInProgress.mode&ProfileMode){startProfilerTimer(workInProgress);}next=beginWork(current$$1,workInProgress,nextRenderExpirationTime);if(workInProgress.mode&ProfileMode){// Record the render duration assuming we didn't bailout (or error).
stopProfilerTimerIfRunningAndRecordDelta(workInProgress,true);}}else{next=beginWork(current$$1,workInProgress,nextRenderExpirationTime);}{resetCurrentFiber();if(isReplayingFailedUnitOfWork){// Currently replaying a failed unit of work. This should be unreachable,
// because the render phase is meant to be idempotent, and it should
// have thrown again. Since it didn't, rethrow the original error, so
// React's internal stack is not misaligned.
rethrowOriginalError();}}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);}if(next===null){// If this doesn't spawn new work, complete the current work.
next=completeUnitOfWork(workInProgress);}ReactCurrentOwner$2.current=null;return next;}function workLoop(isYieldy){if(!isYieldy){// Flush work without yielding
while(nextUnitOfWork!==null){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}else{// Flush asynchronous work until the deadline runs out of time.
while(nextUnitOfWork!==null&&!shouldYield()){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}function renderRoot(root,isYieldy,isExpired){!!isWorking?invariant(false,'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isWorking=true;ReactCurrentOwner$2.currentDispatcher=Dispatcher;var expirationTime=root.nextExpirationTimeToWorkOn;var prevInteractions=null;if(enableSchedulerTracing){// We're about to start new traced work.
// Restore pending interactions so cascading work triggered during the render phase will be accounted for.
prevInteractions=tracing.__interactionsRef.current;tracing.__interactionsRef.current=root.memoizedInteractions;}// Check if we're starting from a fresh stack, or if we're resuming from
// previously yielded work.
if(expirationTime!==nextRenderExpirationTime||root!==nextRoot||nextUnitOfWork===null){// Reset the stack and start working from the root.
resetStack();nextRoot=root;nextRenderExpirationTime=expirationTime;nextUnitOfWork=createWorkInProgress(nextRoot.current,null,nextRenderExpirationTime);root.pendingCommitExpirationTime=NoWork;if(enableSchedulerTracing){// Determine which interactions this batch of work currently includes,
// So that we can accurately attribute time spent working on it,
var interactions=new Set();root.pendingInteractionMap.forEach(function(scheduledInteractions,scheduledExpirationTime){if(scheduledExpirationTime<=expirationTime){scheduledInteractions.forEach(function(interaction){return interactions.add(interaction);});}});// Store the current set of interactions on the FiberRoot for a few reasons:
// We can re-use it in hot functions like renderRoot() without having to recalculate it.
// We will also use it in commitWork() to pass to any Profiler onRender() hooks.
// This also provides DevTools with a way to access it when the onCommitRoot() hook is called.
root.memoizedInteractions=interactions;if(interactions.size>0){var subscriber=tracing.__subscriberRef.current;if(subscriber!==null){var threadID=computeThreadID(expirationTime,root.interactionThreadID);try{subscriber.onWorkStarted(interactions,threadID);}catch(error){// Work thrown by an interaction tracing subscriber should be rethrown,
// But only once it's safe (to avoid leaveing the scheduler in an invalid state).
// Store the error for now and we'll re-throw in finishRendering().
if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}}}}}var didFatal=false;startWorkLoopTimer(nextUnitOfWork);do{try{workLoop(isYieldy);}catch(thrownValue){if(nextUnitOfWork===null){// This is a fatal error.
didFatal=true;onUncaughtError(thrownValue);}else{{// Reset global debug state
// We assume this is defined in DEV
resetCurrentlyProcessingQueue();}var failedUnitOfWork=nextUnitOfWork;if(true&&replayFailedUnitOfWorkWithInvokeGuardedCallback){replayUnitOfWork(failedUnitOfWork,thrownValue,isYieldy);}// TODO: we already know this isn't true in some cases.
// At least this shows a nicer error message until we figure out the cause.
// https://github.com/facebook/react/issues/12449#issuecomment-386727431
!(nextUnitOfWork!==null)?invariant(false,'Failed to replay rendering after an error. This is likely caused by a bug in React. Please file an issue with a reproducing case to help us find it.'):void 0;var sourceFiber=nextUnitOfWork;var returnFiber=sourceFiber.return;if(returnFiber===null){// This is the root. The root could capture its own errors. However,
// we don't know if it errors before or after we pushed the host
// context. This information is needed to avoid a stack mismatch.
// Because we're not sure, treat this as a fatal error. We could track
// which phase it fails in, but doesn't seem worth it. At least
// for now.
didFatal=true;onUncaughtError(thrownValue);}else{throwException(root,returnFiber,sourceFiber,thrownValue,nextRenderExpirationTime);nextUnitOfWork=completeUnitOfWork(sourceFiber);continue;}}}break;}while(true);if(enableSchedulerTracing){// Traced work is done for now; restore the previous interactions.
tracing.__interactionsRef.current=prevInteractions;}// We're done performing work. Time to clean up.
isWorking=false;ReactCurrentOwner$2.currentDispatcher=null;resetContextDependences();// Yield back to main thread.
if(didFatal){var _didCompleteRoot=false;stopWorkLoopTimer(interruptedBy,_didCompleteRoot);interruptedBy=null;// There was a fatal error.
{resetStackAfterFatalErrorInDev();}// `nextRoot` points to the in-progress root. A non-null value indicates
// that we're in the middle of an async render. Set it to null to indicate
// there's no more work to be done in the current batch.
nextRoot=null;onFatal(root);return;}if(nextUnitOfWork!==null){// There's still remaining async work in this tree, but we ran out of time
// in the current frame. Yield back to the renderer. Unless we're
// interrupted by a higher priority update, we'll continue later from where
// we left off.
var _didCompleteRoot2=false;stopWorkLoopTimer(interruptedBy,_didCompleteRoot2);interruptedBy=null;onYield(root);return;}// We completed the whole tree.
var didCompleteRoot=true;stopWorkLoopTimer(interruptedBy,didCompleteRoot);var rootWorkInProgress=root.current.alternate;!(rootWorkInProgress!==null)?invariant(false,'Finished root should have a work-in-progress. This error is likely caused by a bug in React. Please file an issue.'):void 0;// `nextRoot` points to the in-progress root. A non-null value indicates
// that we're in the middle of an async render. Set it to null to indicate
// there's no more work to be done in the current batch.
nextRoot=null;interruptedBy=null;if(nextRenderDidError){// There was an error
if(hasLowerPriorityWork(root,expirationTime)){// There's lower priority work. If so, it may have the effect of fixing
// the exception that was just thrown. Exit without committing. This is
// similar to a suspend, but without a timeout because we're not waiting
// for a promise to resolve. React will restart at the lower
// priority level.
markSuspendedPriorityLevel(root,expirationTime);var suspendedExpirationTime=expirationTime;var rootExpirationTime=root.expirationTime;onSuspend(root,rootWorkInProgress,suspendedExpirationTime,rootExpirationTime,-1// Indicates no timeout
);return;}else if(// There's no lower priority work, but we're rendering asynchronously.
// Synchronsouly attempt to render the same level one more time. This is
// similar to a suspend, but without a timeout because we're not waiting
// for a promise to resolve.
!root.didError&&!isExpired){root.didError=true;var _suspendedExpirationTime=root.nextExpirationTimeToWorkOn=expirationTime;var _rootExpirationTime=root.expirationTime=Sync;onSuspend(root,rootWorkInProgress,_suspendedExpirationTime,_rootExpirationTime,-1// Indicates no timeout
);return;}}if(enableSuspense&&!isExpired&&nextLatestAbsoluteTimeoutMs!==-1){// The tree was suspended.
var _suspendedExpirationTime2=expirationTime;markSuspendedPriorityLevel(root,_suspendedExpirationTime2);// Find the earliest uncommitted expiration time in the tree, including
// work that is suspended. The timeout threshold cannot be longer than
// the overall expiration.
var earliestExpirationTime=findEarliestOutstandingPriorityLevel(root,expirationTime);var earliestExpirationTimeMs=expirationTimeToMs(earliestExpirationTime);if(earliestExpirationTimeMs<nextLatestAbsoluteTimeoutMs){nextLatestAbsoluteTimeoutMs=earliestExpirationTimeMs;}// Subtract the current time from the absolute timeout to get the number
// of milliseconds until the timeout. In other words, convert an absolute
// timestamp to a relative time. This is the value that is passed
// to `setTimeout`.
var currentTimeMs=expirationTimeToMs(requestCurrentTime());var msUntilTimeout=nextLatestAbsoluteTimeoutMs-currentTimeMs;msUntilTimeout=msUntilTimeout<0?0:msUntilTimeout;// TODO: Account for the Just Noticeable Difference
var _rootExpirationTime2=root.expirationTime;onSuspend(root,rootWorkInProgress,_suspendedExpirationTime2,_rootExpirationTime2,msUntilTimeout);return;}// Ready to commit.
onComplete(root,rootWorkInProgress,expirationTime);}function dispatch(sourceFiber,value,expirationTime){!(!isWorking||isCommitting$1)?invariant(false,'dispatch: Cannot dispatch during the render phase.'):void 0;var fiber=sourceFiber.return;while(fiber!==null){switch(fiber.tag){case ClassComponent:case ClassComponentLazy:var ctor=fiber.type;var instance=fiber.stateNode;if(typeof ctor.getDerivedStateFromCatch==='function'||typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance)){var errorInfo=createCapturedValue(value,sourceFiber);var update=createClassErrorUpdate(fiber,errorInfo,expirationTime);enqueueUpdate(fiber,update);scheduleWork(fiber,expirationTime);return;}break;case HostRoot:{var _errorInfo=createCapturedValue(value,sourceFiber);var _update=createRootErrorUpdate(fiber,_errorInfo,expirationTime);enqueueUpdate(fiber,_update);scheduleWork(fiber,expirationTime);return;}}fiber=fiber.return;}if(sourceFiber.tag===HostRoot){// Error was thrown at the root. There is no parent, so the root
// itself should capture it.
var rootFiber=sourceFiber;var _errorInfo2=createCapturedValue(value,rootFiber);var _update2=createRootErrorUpdate(rootFiber,_errorInfo2,expirationTime);enqueueUpdate(rootFiber,_update2);scheduleWork(rootFiber,expirationTime);}}function captureCommitPhaseError(fiber,error){return dispatch(fiber,error,Sync);}function computeThreadID(expirationTime,interactionThreadID){// Interaction threads are unique per root and expiration time.
return expirationTime*1000+interactionThreadID;}// Creates a unique async expiration time.
function computeUniqueAsyncExpiration(){var currentTime=requestCurrentTime();var result=computeAsyncExpiration(currentTime);if(result<=lastUniqueAsyncExpiration){// Since we assume the current time monotonically increases, we only hit
// this branch when computeUniqueAsyncExpiration is fired multiple times
// within a 200ms window (or whatever the async bucket size is).
result=lastUniqueAsyncExpiration+1;}lastUniqueAsyncExpiration=result;return lastUniqueAsyncExpiration;}function computeExpirationForFiber(currentTime,fiber){var expirationTime=void 0;if(expirationContext!==NoWork){// An explicit expiration context was set;
expirationTime=expirationContext;}else if(isWorking){if(isCommitting$1){// Updates that occur during the commit phase should have sync priority
// by default.
expirationTime=Sync;}else{// Updates during the render phase should expire at the same time as
// the work that is being rendered.
expirationTime=nextRenderExpirationTime;}}else{// No explicit expiration context was set, and we're not currently
// performing work. Calculate a new expiration time.
if(fiber.mode&AsyncMode){if(isBatchingInteractiveUpdates){// This is an interactive update
expirationTime=computeInteractiveExpiration(currentTime);}else{// This is an async update
expirationTime=computeAsyncExpiration(currentTime);}// If we're in the middle of rendering a tree, do not update at the same
// expiration time that is already rendering.
if(nextRoot!==null&&expirationTime===nextRenderExpirationTime){expirationTime+=1;}}else{// This is a sync update
expirationTime=Sync;}}if(isBatchingInteractiveUpdates){// This is an interactive update. Keep track of the lowest pending
// interactive expiration time. This allows us to synchronously flush
// all interactive updates when needed.
if(lowestPriorityPendingInteractiveExpirationTime===NoWork||expirationTime>lowestPriorityPendingInteractiveExpirationTime){lowestPriorityPendingInteractiveExpirationTime=expirationTime;}}return expirationTime;}function renderDidSuspend(root,absoluteTimeoutMs,suspendedTime){// Schedule the timeout.
if(absoluteTimeoutMs>=0&&nextLatestAbsoluteTimeoutMs<absoluteTimeoutMs){nextLatestAbsoluteTimeoutMs=absoluteTimeoutMs;}}function renderDidError(){nextRenderDidError=true;}function retrySuspendedRoot(root,fiber,suspendedTime){if(enableSuspense){var retryTime=void 0;if(isPriorityLevelSuspended(root,suspendedTime)){// Ping at the original level
retryTime=suspendedTime;markPingedPriorityLevel(root,retryTime);}else{// Placeholder already timed out. Compute a new expiration time
var currentTime=requestCurrentTime();retryTime=computeExpirationForFiber(currentTime,fiber);markPendingPriorityLevel(root,retryTime);}scheduleWorkToRoot(fiber,retryTime);var rootExpirationTime=root.expirationTime;if(rootExpirationTime!==NoWork){if(enableSchedulerTracing){// Restore previous interactions so that new work is associated with them.
var prevInteractions=tracing.__interactionsRef.current;tracing.__interactionsRef.current=root.memoizedInteractions;// Because suspense timeouts do not decrement the interaction count,
// Continued suspense work should also not increment the count.
storeInteractionsForExpirationTime(root,rootExpirationTime,false);requestWork(root,rootExpirationTime);tracing.__interactionsRef.current=prevInteractions;}else{requestWork(root,rootExpirationTime);}}}}function scheduleWorkToRoot(fiber,expirationTime){// Update the source fiber's expiration time
if(fiber.expirationTime===NoWork||fiber.expirationTime>expirationTime){fiber.expirationTime=expirationTime;}var alternate=fiber.alternate;if(alternate!==null&&(alternate.expirationTime===NoWork||alternate.expirationTime>expirationTime)){alternate.expirationTime=expirationTime;}// Walk the parent path to the root and update the child expiration time.
var node=fiber.return;if(node===null&&fiber.tag===HostRoot){return fiber.stateNode;}while(node!==null){alternate=node.alternate;if(node.childExpirationTime===NoWork||node.childExpirationTime>expirationTime){node.childExpirationTime=expirationTime;if(alternate!==null&&(alternate.childExpirationTime===NoWork||alternate.childExpirationTime>expirationTime)){alternate.childExpirationTime=expirationTime;}}else if(alternate!==null&&(alternate.childExpirationTime===NoWork||alternate.childExpirationTime>expirationTime)){alternate.childExpirationTime=expirationTime;}if(node.return===null&&node.tag===HostRoot){return node.stateNode;}node=node.return;}return null;}function storeInteractionsForExpirationTime(root,expirationTime,updateInteractionCounts){if(!enableSchedulerTracing){return;}var interactions=tracing.__interactionsRef.current;if(interactions.size>0){var pendingInteractions=root.pendingInteractionMap.get(expirationTime);if(pendingInteractions!=null){interactions.forEach(function(interaction){if(updateInteractionCounts&&!pendingInteractions.has(interaction)){// Update the pending async work count for previously unscheduled interaction.
interaction.__count++;}pendingInteractions.add(interaction);});}else{root.pendingInteractionMap.set(expirationTime,new Set(interactions));// Update the pending async work count for the current interactions.
if(updateInteractionCounts){interactions.forEach(function(interaction){interaction.__count++;});}}var subscriber=tracing.__subscriberRef.current;if(subscriber!==null){var threadID=computeThreadID(expirationTime,root.interactionThreadID);subscriber.onWorkScheduled(interactions,threadID);}}}function scheduleWork(fiber,expirationTime){recordScheduleUpdate();{if(fiber.tag===ClassComponent||fiber.tag===ClassComponentLazy){var instance=fiber.stateNode;warnAboutInvalidUpdates(instance);}}var root=scheduleWorkToRoot(fiber,expirationTime);if(root===null){if(true&&(fiber.tag===ClassComponent||fiber.tag===ClassComponentLazy)){warnAboutUpdateOnUnmounted(fiber);}return;}if(enableSchedulerTracing){storeInteractionsForExpirationTime(root,expirationTime,true);}if(!isWorking&&nextRenderExpirationTime!==NoWork&&expirationTime<nextRenderExpirationTime){// This is an interruption. (Used for performance tracking.)
interruptedBy=fiber;resetStack();}markPendingPriorityLevel(root,expirationTime);if(// If we're in the render phase, we don't need to schedule this root
// for an update, because we'll do it before we exit...
!isWorking||isCommitting$1||// ...unless this is a different root than the one we're rendering.
nextRoot!==root){var rootExpirationTime=root.expirationTime;requestWork(root,rootExpirationTime);}if(nestedUpdateCount>NESTED_UPDATE_LIMIT){// Reset this back to zero so subsequent updates don't throw.
nestedUpdateCount=0;invariant(false,'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');}}function syncUpdates(fn,a,b,c,d){var previousExpirationContext=expirationContext;expirationContext=Sync;try{return fn(a,b,c,d);}finally{expirationContext=previousExpirationContext;}}// TODO: Everything below this is written as if it has been lifted to the
// renderers. I'll do this in a follow-up.
// Linked-list of roots
var firstScheduledRoot=null;var lastScheduledRoot=null;var callbackExpirationTime=NoWork;var callbackID=void 0;var isRendering=false;var nextFlushedRoot=null;var nextFlushedExpirationTime=NoWork;var lowestPriorityPendingInteractiveExpirationTime=NoWork;var deadlineDidExpire=false;var hasUnhandledError=false;var unhandledError=null;var deadline=null;var isBatchingUpdates=false;var isUnbatchingUpdates=false;var isBatchingInteractiveUpdates=false;var completedBatches=null;var originalStartTimeMs=schedule.unstable_now();var currentRendererTime=msToExpirationTime(originalStartTimeMs);var currentSchedulerTime=currentRendererTime;// Use these to prevent an infinite loop of nested updates
var NESTED_UPDATE_LIMIT=50;var nestedUpdateCount=0;var lastCommittedRootDuringThisBatch=null;var timeHeuristicForUnitOfWork=1;function recomputeCurrentRendererTime(){var currentTimeMs=schedule.unstable_now()-originalStartTimeMs;currentRendererTime=msToExpirationTime(currentTimeMs);}function scheduleCallbackWithExpirationTime(root,expirationTime){if(callbackExpirationTime!==NoWork){// A callback is already scheduled. Check its expiration time (timeout).
if(expirationTime>callbackExpirationTime){// Existing callback has sufficient timeout. Exit.
return;}else{if(callbackID!==null){// Existing callback has insufficient timeout. Cancel and schedule a
// new one.
schedule.unstable_cancelScheduledWork(callbackID);}}// The request callback timer is already running. Don't start a new one.
}else{startRequestCallbackTimer();}callbackExpirationTime=expirationTime;var currentMs=schedule.unstable_now()-originalStartTimeMs;var expirationTimeMs=expirationTimeToMs(expirationTime);var timeout=expirationTimeMs-currentMs;callbackID=schedule.unstable_scheduleWork(performAsyncWork,{timeout:timeout});}// For every call to renderRoot, one of onFatal, onComplete, onSuspend, and
// onYield is called upon exiting. We use these in lieu of returning a tuple.
// I've also chosen not to inline them into renderRoot because these will
// eventually be lifted into the renderer.
function onFatal(root){root.finishedWork=null;}function onComplete(root,finishedWork,expirationTime){root.pendingCommitExpirationTime=expirationTime;root.finishedWork=finishedWork;}function onSuspend(root,finishedWork,suspendedExpirationTime,rootExpirationTime,msUntilTimeout){root.expirationTime=rootExpirationTime;if(enableSuspense&&msUntilTimeout===0&&!shouldYield()){// Don't wait an additional tick. Commit the tree immediately.
root.pendingCommitExpirationTime=suspendedExpirationTime;root.finishedWork=finishedWork;}else if(msUntilTimeout>0){// Wait `msUntilTimeout` milliseconds before committing.
root.timeoutHandle=scheduleTimeout(onTimeout.bind(null,root,finishedWork,suspendedExpirationTime),msUntilTimeout);}}function onYield(root){root.finishedWork=null;}function onTimeout(root,finishedWork,suspendedExpirationTime){if(enableSuspense){// The root timed out. Commit it.
root.pendingCommitExpirationTime=suspendedExpirationTime;root.finishedWork=finishedWork;// Read the current time before entering the commit phase. We can be
// certain this won't cause tearing related to batching of event updates
// because we're at the top of a timer event.
recomputeCurrentRendererTime();currentSchedulerTime=currentRendererTime;if(enableSchedulerTracing){// Don't update pending interaction counts for suspense timeouts,
// Because we know we still need to do more work in this case.
suspenseDidTimeout=true;flushRoot(root,suspendedExpirationTime);suspenseDidTimeout=false;}else{flushRoot(root,suspendedExpirationTime);}}}function onCommit(root,expirationTime){root.expirationTime=expirationTime;root.finishedWork=null;}function requestCurrentTime(){// requestCurrentTime is called by the scheduler to compute an expiration
// time.
//
// Expiration times are computed by adding to the current time (the start
// time). However, if two updates are scheduled within the same event, we
// should treat their start times as simultaneous, even if the actual clock
// time has advanced between the first and second call.
// In other words, because expiration times determine how updates are batched,
// we want all updates of like priority that occur within the same event to
// receive the same expiration time. Otherwise we get tearing.
//
// We keep track of two separate times: the current "renderer" time and the
// current "scheduler" time. The renderer time can be updated whenever; it
// only exists to minimize the calls performance.now.
//
// But the scheduler time can only be updated if there's no pending work, or
// if we know for certain that we're not in the middle of an event.
if(isRendering){// We're already rendering. Return the most recently read time.
return currentSchedulerTime;}// Check if there's pending work.
findHighestPriorityRoot();if(nextFlushedExpirationTime===NoWork||nextFlushedExpirationTime===Never){// If there's no pending work, or if the pending work is offscreen, we can
// read the current time without risk of tearing.
recomputeCurrentRendererTime();currentSchedulerTime=currentRendererTime;return currentSchedulerTime;}// There's already pending work. We might be in the middle of a browser
// event. If we were to read the current time, it could cause multiple updates
// within the same event to receive different expiration times, leading to
// tearing. Return the last read time. During the next idle callback, the
// time will be updated.
return currentSchedulerTime;}// requestWork is called by the scheduler whenever a root receives an update.
// It's up to the renderer to call renderRoot at some point in the future.
function requestWork(root,expirationTime){addRootToSchedule(root,expirationTime);if(isRendering){// Prevent reentrancy. Remaining work will be scheduled at the end of
// the currently rendering batch.
return;}if(isBatchingUpdates){// Flush work at the end of the batch.
if(isUnbatchingUpdates){// ...unless we're inside unbatchedUpdates, in which case we should
// flush it now.
nextFlushedRoot=root;nextFlushedExpirationTime=Sync;performWorkOnRoot(root,Sync,true);}return;}// TODO: Get rid of Sync and use current time?
if(expirationTime===Sync){performSyncWork();}else{scheduleCallbackWithExpirationTime(root,expirationTime);}}function addRootToSchedule(root,expirationTime){// Add the root to the schedule.
// Check if this root is already part of the schedule.
if(root.nextScheduledRoot===null){// This root is not already scheduled. Add it.
root.expirationTime=expirationTime;if(lastScheduledRoot===null){firstScheduledRoot=lastScheduledRoot=root;root.nextScheduledRoot=root;}else{lastScheduledRoot.nextScheduledRoot=root;lastScheduledRoot=root;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;}}else{// This root is already scheduled, but its priority may have increased.
var remainingExpirationTime=root.expirationTime;if(remainingExpirationTime===NoWork||expirationTime<remainingExpirationTime){// Update the priority.
root.expirationTime=expirationTime;}}}function findHighestPriorityRoot(){var highestPriorityWork=NoWork;var highestPriorityRoot=null;if(lastScheduledRoot!==null){var previousScheduledRoot=lastScheduledRoot;var root=firstScheduledRoot;while(root!==null){var remainingExpirationTime=root.expirationTime;if(remainingExpirationTime===NoWork){// This root no longer has work. Remove it from the scheduler.
// TODO: This check is redudant, but Flow is confused by the branch
// below where we set lastScheduledRoot to null, even though we break
// from the loop right after.
!(previousScheduledRoot!==null&&lastScheduledRoot!==null)?invariant(false,'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(root===root.nextScheduledRoot){// This is the only root in the list.
root.nextScheduledRoot=null;firstScheduledRoot=lastScheduledRoot=null;break;}else if(root===firstScheduledRoot){// This is the first root in the list.
var next=root.nextScheduledRoot;firstScheduledRoot=next;lastScheduledRoot.nextScheduledRoot=next;root.nextScheduledRoot=null;}else if(root===lastScheduledRoot){// This is the last root in the list.
lastScheduledRoot=previousScheduledRoot;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;root.nextScheduledRoot=null;break;}else{previousScheduledRoot.nextScheduledRoot=root.nextScheduledRoot;root.nextScheduledRoot=null;}root=previousScheduledRoot.nextScheduledRoot;}else{if(highestPriorityWork===NoWork||remainingExpirationTime<highestPriorityWork){// Update the priority, if it's higher
highestPriorityWork=remainingExpirationTime;highestPriorityRoot=root;}if(root===lastScheduledRoot){break;}if(highestPriorityWork===Sync){// Sync is highest priority by definition so
// we can stop searching.
break;}previousScheduledRoot=root;root=root.nextScheduledRoot;}}}nextFlushedRoot=highestPriorityRoot;nextFlushedExpirationTime=highestPriorityWork;}function performAsyncWork(dl){if(dl.didTimeout){// The callback timed out. That means at least one update has expired.
// Iterate through the root schedule. If they contain expired work, set
// the next render expiration time to the current time. This has the effect
// of flushing all expired work in a single batch, instead of flushing each
// level one at a time.
if(firstScheduledRoot!==null){recomputeCurrentRendererTime();var root=firstScheduledRoot;do{didExpireAtExpirationTime(root,currentRendererTime);// The root schedule is circular, so this is never null.
root=root.nextScheduledRoot;}while(root!==firstScheduledRoot);}}performWork(NoWork,dl);}function performSyncWork(){performWork(Sync,null);}function performWork(minExpirationTime,dl){deadline=dl;// Keep working on roots until there's no more work, or until we reach
// the deadline.
findHighestPriorityRoot();if(deadline!==null){recomputeCurrentRendererTime();currentSchedulerTime=currentRendererTime;if(enableUserTimingAPI){var didExpire=nextFlushedExpirationTime<currentRendererTime;var timeout=expirationTimeToMs(nextFlushedExpirationTime);stopRequestCallbackTimer(didExpire,timeout);}while(nextFlushedRoot!==null&&nextFlushedExpirationTime!==NoWork&&(minExpirationTime===NoWork||minExpirationTime>=nextFlushedExpirationTime)&&(!deadlineDidExpire||currentRendererTime>=nextFlushedExpirationTime)){performWorkOnRoot(nextFlushedRoot,nextFlushedExpirationTime,currentRendererTime>=nextFlushedExpirationTime);findHighestPriorityRoot();recomputeCurrentRendererTime();currentSchedulerTime=currentRendererTime;}}else{while(nextFlushedRoot!==null&&nextFlushedExpirationTime!==NoWork&&(minExpirationTime===NoWork||minExpirationTime>=nextFlushedExpirationTime)){performWorkOnRoot(nextFlushedRoot,nextFlushedExpirationTime,true);findHighestPriorityRoot();}}// We're done flushing work. Either we ran out of time in this callback,
// or there's no more work left with sufficient priority.
// If we're inside a callback, set this to false since we just completed it.
if(deadline!==null){callbackExpirationTime=NoWork;callbackID=null;}// If there's work left over, schedule a new callback.
if(nextFlushedExpirationTime!==NoWork){scheduleCallbackWithExpirationTime(nextFlushedRoot,nextFlushedExpirationTime);}// Clean-up.
deadline=null;deadlineDidExpire=false;finishRendering();}function flushRoot(root,expirationTime){!!isRendering?invariant(false,'work.commit(): Cannot commit while already rendering. This likely means you attempted to commit from inside a lifecycle method.'):void 0;// Perform work on root as if the given expiration time is the current time.
// This has the effect of synchronously flushing all work up to and
// including the given time.
nextFlushedRoot=root;nextFlushedExpirationTime=expirationTime;performWorkOnRoot(root,expirationTime,true);// Flush any sync work that was scheduled by lifecycles
performSyncWork();}function finishRendering(){nestedUpdateCount=0;lastCommittedRootDuringThisBatch=null;if(completedBatches!==null){var batches=completedBatches;completedBatches=null;for(var i=0;i<batches.length;i++){var batch=batches[i];try{batch._onComplete();}catch(error){if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}}}if(hasUnhandledError){var error=unhandledError;unhandledError=null;hasUnhandledError=false;throw error;}}function performWorkOnRoot(root,expirationTime,isExpired){!!isRendering?invariant(false,'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isRendering=true;// Check if this is async work or sync/expired work.
if(deadline===null||isExpired){// Flush work without yielding.
// TODO: Non-yieldy work does not necessarily imply expired work. A renderer
// may want to perform some work without yielding, but also without
// requiring the root to complete (by triggering placeholders).
var finishedWork=root.finishedWork;if(finishedWork!==null){// This root is already complete. We can commit it.
completeRoot(root,finishedWork,expirationTime);}else{root.finishedWork=null;// If this root previously suspended, clear its existing timeout, since
// we're about to try rendering again.
var timeoutHandle=root.timeoutHandle;if(enableSuspense&&timeoutHandle!==noTimeout){root.timeoutHandle=noTimeout;// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
cancelTimeout(timeoutHandle);}var isYieldy=false;renderRoot(root,isYieldy,isExpired);finishedWork=root.finishedWork;if(finishedWork!==null){// We've completed the root. Commit it.
completeRoot(root,finishedWork,expirationTime);}}}else{// Flush async work.
var _finishedWork=root.finishedWork;if(_finishedWork!==null){// This root is already complete. We can commit it.
completeRoot(root,_finishedWork,expirationTime);}else{root.finishedWork=null;// If this root previously suspended, clear its existing timeout, since
// we're about to try rendering again.
var _timeoutHandle=root.timeoutHandle;if(enableSuspense&&_timeoutHandle!==noTimeout){root.timeoutHandle=noTimeout;// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
cancelTimeout(_timeoutHandle);}var _isYieldy=true;renderRoot(root,_isYieldy,isExpired);_finishedWork=root.finishedWork;if(_finishedWork!==null){// We've completed the root. Check the deadline one more time
// before committing.
if(!shouldYield()){// Still time left. Commit the root.
completeRoot(root,_finishedWork,expirationTime);}else{// There's no time left. Mark this root as complete. We'll come
// back and commit it later.
root.finishedWork=_finishedWork;}}}}isRendering=false;}function completeRoot(root,finishedWork,expirationTime){// Check if there's a batch that matches this expiration time.
var firstBatch=root.firstBatch;if(firstBatch!==null&&firstBatch._expirationTime<=expirationTime){if(completedBatches===null){completedBatches=[firstBatch];}else{completedBatches.push(firstBatch);}if(firstBatch._defer){// This root is blocked from committing by a batch. Unschedule it until
// we receive another update.
root.finishedWork=finishedWork;root.expirationTime=NoWork;return;}}// Commit the root.
root.finishedWork=null;// Check if this is a nested update (a sync update scheduled during the
// commit phase).
if(root===lastCommittedRootDuringThisBatch){// If the next root is the same as the previous root, this is a nested
// update. To prevent an infinite loop, increment the nested update count.
nestedUpdateCount++;}else{// Reset whenever we switch roots.
lastCommittedRootDuringThisBatch=root;nestedUpdateCount=0;}commitRoot(root,finishedWork);}// When working on async work, the reconciler asks the renderer if it should
// yield execution. For DOM, we implement this with requestIdleCallback.
function shouldYield(){if(deadlineDidExpire){return true;}if(deadline===null||deadline.timeRemaining()>timeHeuristicForUnitOfWork){// Disregard deadline.didTimeout. Only expired work should be flushed
// during a timeout. This path is only hit for non-expired work.
return false;}deadlineDidExpire=true;return true;}function onUncaughtError(error){!(nextFlushedRoot!==null)?invariant(false,'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.'):void 0;// Unschedule this root so we don't work on it again until there's
// another update.
nextFlushedRoot.expirationTime=NoWork;if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function batchedUpdates$1(fn,a){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return fn(a);}finally{isBatchingUpdates=previousIsBatchingUpdates;if(!isBatchingUpdates&&!isRendering){performSyncWork();}}}// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function unbatchedUpdates(fn,a){if(isBatchingUpdates&&!isUnbatchingUpdates){isUnbatchingUpdates=true;try{return fn(a);}finally{isUnbatchingUpdates=false;}}return fn(a);}// TODO: Batching should be implemented at the renderer level, not within
// the reconciler.
function flushSync(fn,a){!!isRendering?invariant(false,'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.'):void 0;var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return syncUpdates(fn,a);}finally{isBatchingUpdates=previousIsBatchingUpdates;performSyncWork();}}function interactiveUpdates$1(fn,a,b){if(isBatchingInteractiveUpdates){return fn(a,b);}// If there are any pending interactive updates, synchronously flush them.
// This needs to happen before we read any handlers, because the effect of
// the previous event may influence which handlers are called during
// this event.
if(!isBatchingUpdates&&!isRendering&&lowestPriorityPendingInteractiveExpirationTime!==NoWork){// Synchronously flush pending interactive updates.
performWork(lowestPriorityPendingInteractiveExpirationTime,null);lowestPriorityPendingInteractiveExpirationTime=NoWork;}var previousIsBatchingInteractiveUpdates=isBatchingInteractiveUpdates;var previousIsBatchingUpdates=isBatchingUpdates;isBatchingInteractiveUpdates=true;isBatchingUpdates=true;try{return fn(a,b);}finally{isBatchingInteractiveUpdates=previousIsBatchingInteractiveUpdates;isBatchingUpdates=previousIsBatchingUpdates;if(!isBatchingUpdates&&!isRendering){performSyncWork();}}}function flushInteractiveUpdates$1(){if(!isRendering&&lowestPriorityPendingInteractiveExpirationTime!==NoWork){// Synchronously flush pending interactive updates.
performWork(lowestPriorityPendingInteractiveExpirationTime,null);lowestPriorityPendingInteractiveExpirationTime=NoWork;}}function flushControlled(fn){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{syncUpdates(fn);}finally{isBatchingUpdates=previousIsBatchingUpdates;if(!isBatchingUpdates&&!isRendering){performSyncWork();}}}// 0 is PROD, 1 is DEV.
// Might add PROFILE later.
var didWarnAboutNestedUpdates=void 0;{didWarnAboutNestedUpdates=false;}function getContextForSubtree(parentComponent){if(!parentComponent){return emptyContextObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);if(fiber.tag===ClassComponent){var Component=fiber.type;if(isContextProvider(Component)){return processChildContext(fiber,Component,parentContext);}}else if(fiber.tag===ClassComponentLazy){var _Component=getResultFromResolvedThenable(fiber.type);if(isContextProvider(_Component)){return processChildContext(fiber,_Component,parentContext);}}return parentContext;}function scheduleRootUpdate(current$$1,element,expirationTime,callback){{if(phase==='render'&&current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;warningWithoutStack$1(false,'Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\n\n'+'Check the render method of %s.',getComponentName(current.type)||'Unknown');}}var update=createUpdate(expirationTime);// Caution: React DevTools currently depends on this property
// being called "element".
update.payload={element:element};callback=callback===undefined?null:callback;if(callback!==null){!(typeof callback==='function')?warningWithoutStack$1(false,'render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback):void 0;update.callback=callback;}enqueueUpdate(current$$1,update);scheduleWork(current$$1,expirationTime);return expirationTime;}function updateContainerAtExpirationTime(element,container,parentComponent,expirationTime,callback){// TODO: If this is a nested container, this won't be the root.
var current$$1=container.current;{if(ReactFiberInstrumentation_1.debugTool){if(current$$1.alternate===null){ReactFiberInstrumentation_1.debugTool.onMountContainer(container);}else if(element===null){ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);}else{ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);}}}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}return scheduleRootUpdate(current$$1,element,expirationTime,callback);}function findHostInstance(component){var fiber=get(component);if(fiber===undefined){if(typeof component.render==='function'){invariant(false,'Unable to find node on an unmounted component.');}else{invariant(false,'Argument appears to not be a ReactComponent. Keys: %s',Object.keys(component));}}var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}function createContainer(containerInfo,isAsync,hydrate){return createFiberRoot(containerInfo,isAsync,hydrate);}function updateContainer(element,container,parentComponent,callback){var current$$1=container.current;var currentTime=requestCurrentTime();var expirationTime=computeExpirationForFiber(currentTime,current$$1);return updateContainerAtExpirationTime(element,container,parentComponent,expirationTime,callback);}function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}}function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}function injectIntoDevTools(devToolsConfig){var _findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;return injectInternals(_assign({},devToolsConfig,{findHostInstanceByFiber:function findHostInstanceByFiber(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;},findFiberByHostInstance:function findFiberByHostInstance(instance){if(!_findFiberByHostInstance){// Might not be implemented by the renderer.
return null;}return _findFiberByHostInstance(instance);}}));}// This file intentionally does *not* have the Flow annotation.
// Don't add it. See `./inline-typed.js` for an explanation.
function createPortal$1(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.
implementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;return{// This tag allow us to uniquely identify this as a React Portal
$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}// TODO: this is special because it gets imported during build.
var ReactVersion='16.5.2';// TODO: This type is shared between the reconciler and ReactDOM, but will
// eventually be lifted out to the renderer.
var ReactCurrentOwner=ReactSharedInternals.ReactCurrentOwner;var topLevelUpdateWarnings=void 0;var warnOnInvalidCallback=void 0;var didWarnAboutUnstableCreatePortal=false;{if(typeof Map!=='function'||// $FlowIssue Flow incorrectly thinks Map has no prototype
Map.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||// $FlowIssue Flow incorrectly thinks Set has no prototype
Set.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){warningWithoutStack$1(false,'React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. https://fb.me/react-polyfills');}topLevelUpdateWarnings=function topLevelUpdateWarnings(container){if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);if(hostInstance){!(hostInstance.parentNode===container)?warningWithoutStack$1(false,'render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.'):void 0;}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode$1(rootEl));!(!hasNonRootReactChild||isRootRenderedBySomeReact)?warningWithoutStack$1(false,'render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.'):void 0;!(container.nodeType!==ELEMENT_NODE||!container.tagName||container.tagName.toUpperCase()!=='BODY')?warningWithoutStack$1(false,'render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.'):void 0;};warnOnInvalidCallback=function warnOnInvalidCallback(callback,callerName){!(callback===null||typeof callback==='function')?warningWithoutStack$1(false,'%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback):void 0;};}setRestoreImplementation(restoreControlledState$1);/* eslint-disable no-use-before-define *//* eslint-enable no-use-before-define */function ReactBatch(root){var expirationTime=computeUniqueAsyncExpiration();this._expirationTime=expirationTime;this._root=root;this._next=null;this._callbacks=null;this._didComplete=false;this._hasChildren=false;this._children=null;this._defer=true;}ReactBatch.prototype.render=function(children){!this._defer?invariant(false,'batch.render: Cannot render a batch that already committed.'):void 0;this._hasChildren=true;this._children=children;var internalRoot=this._root._internalRoot;var expirationTime=this._expirationTime;var work=new ReactWork();updateContainerAtExpirationTime(children,internalRoot,null,expirationTime,work._onCommit);return work;};ReactBatch.prototype.then=function(onComplete){if(this._didComplete){onComplete();return;}var callbacks=this._callbacks;if(callbacks===null){callbacks=this._callbacks=[];}callbacks.push(onComplete);};ReactBatch.prototype.commit=function(){var internalRoot=this._root._internalRoot;var firstBatch=internalRoot.firstBatch;!(this._defer&&firstBatch!==null)?invariant(false,'batch.commit: Cannot commit a batch multiple times.'):void 0;if(!this._hasChildren){// This batch is empty. Return.
this._next=null;this._defer=false;return;}var expirationTime=this._expirationTime;// Ensure this is the first batch in the list.
if(firstBatch!==this){// This batch is not the earliest batch. We need to move it to the front.
// Update its expiration time to be the expiration time of the earliest
// batch, so that we can flush it without flushing the other batches.
if(this._hasChildren){expirationTime=this._expirationTime=firstBatch._expirationTime;// Rendering this batch again ensures its children will be the final state
// when we flush (updates are processed in insertion order: last
// update wins).
// TODO: This forces a restart. Should we print a warning?
this.render(this._children);}// Remove the batch from the list.
var previous=null;var batch=firstBatch;while(batch!==this){previous=batch;batch=batch._next;}!(previous!==null)?invariant(false,'batch.commit: Cannot commit a batch multiple times.'):void 0;previous._next=batch._next;// Add it to the front.
this._next=firstBatch;firstBatch=internalRoot.firstBatch=this;}// Synchronously flush all the work up to this batch's expiration time.
this._defer=false;flushRoot(internalRoot,expirationTime);// Pop the batch from the list.
var next=this._next;this._next=null;firstBatch=internalRoot.firstBatch=next;// Append the next earliest batch's children to the update queue.
if(firstBatch!==null&&firstBatch._hasChildren){firstBatch.render(firstBatch._children);}};ReactBatch.prototype._onComplete=function(){if(this._didComplete){return;}this._didComplete=true;var callbacks=this._callbacks;if(callbacks===null){return;}// TODO: Error handling.
for(var i=0;i<callbacks.length;i++){var _callback=callbacks[i];_callback();}};function ReactWork(){this._callbacks=null;this._didCommit=false;// TODO: Avoid need to bind by replacing callbacks in the update queue with
// list of Work objects.
this._onCommit=this._onCommit.bind(this);}ReactWork.prototype.then=function(onCommit){if(this._didCommit){onCommit();return;}var callbacks=this._callbacks;if(callbacks===null){callbacks=this._callbacks=[];}callbacks.push(onCommit);};ReactWork.prototype._onCommit=function(){if(this._didCommit){return;}this._didCommit=true;var callbacks=this._callbacks;if(callbacks===null){return;}// TODO: Error handling.
for(var i=0;i<callbacks.length;i++){var _callback2=callbacks[i];!(typeof _callback2==='function')?invariant(false,'Invalid argument passed as callback. Expected a function. Instead received: %s',_callback2):void 0;_callback2();}};function ReactRoot(container,isAsync,hydrate){var root=createContainer(container,isAsync,hydrate);this._internalRoot=root;}ReactRoot.prototype.render=function(children,callback){var root=this._internalRoot;var work=new ReactWork();callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'render');}if(callback!==null){work.then(callback);}updateContainer(children,root,null,work._onCommit);return work;};ReactRoot.prototype.unmount=function(callback){var root=this._internalRoot;var work=new ReactWork();callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'render');}if(callback!==null){work.then(callback);}updateContainer(null,root,null,work._onCommit);return work;};ReactRoot.prototype.legacy_renderSubtreeIntoContainer=function(parentComponent,children,callback){var root=this._internalRoot;var work=new ReactWork();callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'render');}if(callback!==null){work.then(callback);}updateContainer(children,root,parentComponent,work._onCommit);return work;};ReactRoot.prototype.createBatch=function(){var batch=new ReactBatch(this);var expirationTime=batch._expirationTime;var internalRoot=this._internalRoot;var firstBatch=internalRoot.firstBatch;if(firstBatch===null){internalRoot.firstBatch=batch;batch._next=null;}else{// Insert sorted by expiration time then insertion order
var insertAfter=null;var insertBefore=firstBatch;while(insertBefore!==null&&insertBefore._expirationTime<=expirationTime){insertAfter=insertBefore;insertBefore=insertBefore._next;}batch._next=insertBefore;if(insertAfter!==null){insertAfter._next=batch;}}return batch;};/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function shouldHydrateDueToLegacyHeuristic(container){var rootElement=getReactRootElementInContainer(container);return!!(rootElement&&rootElement.nodeType===ELEMENT_NODE&&rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));}setBatchingImplementation(batchedUpdates$1,interactiveUpdates$1,flushInteractiveUpdates$1);var warnedAboutHydrateAPI=false;function legacyCreateRootFromDOMContainer(container,forceHydrate){var shouldHydrate=forceHydrate||shouldHydrateDueToLegacyHeuristic(container);// First clear any existing content.
if(!shouldHydrate){var warned=false;var rootSibling=void 0;while(rootSibling=container.lastChild){{if(!warned&&rootSibling.nodeType===ELEMENT_NODE&&rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)){warned=true;warningWithoutStack$1(false,'render(): Target node has markup rendered by React, but there '+'are unrelated nodes as well. This is most commonly caused by '+'white-space inserted around server-rendered markup.');}}container.removeChild(rootSibling);}}{if(shouldHydrate&&!forceHydrate&&!warnedAboutHydrateAPI){warnedAboutHydrateAPI=true;lowPriorityWarning$1(false,'render(): Calling ReactDOM.render() to hydrate server-rendered markup '+'will stop working in React v17. Replace the ReactDOM.render() call '+'with ReactDOM.hydrate() if you want React to attach to the server HTML.');}}// Legacy roots are not async by default.
var isAsync=false;return new ReactRoot(container,isAsync,shouldHydrate);}function legacyRenderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){// TODO: Ensure all entry points contain this check
!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;{topLevelUpdateWarnings(container);}// TODO: Without `any` type, Flow says "Property cannot be accessed on any
// member of intersection type." Whyyyyyy.
var root=container._reactRootContainer;if(!root){// Initial mount
root=container._reactRootContainer=legacyCreateRootFromDOMContainer(container,forceHydrate);if(typeof callback==='function'){var originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(root._internalRoot);originalCallback.call(instance);};}// Initial mount should not be batched.
unbatchedUpdates(function(){if(parentComponent!=null){root.legacy_renderSubtreeIntoContainer(parentComponent,children,callback);}else{root.render(children,callback);}});}else{if(typeof callback==='function'){var _originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(root._internalRoot);_originalCallback.call(instance);};}// Update
if(parentComponent!=null){root.legacy_renderSubtreeIntoContainer(parentComponent,children,callback);}else{root.render(children,callback);}}return getPublicRootInstance(root._internalRoot);}function createPortal(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;// TODO: pass ReactDOM portal implementation as third argument
return createPortal$1(children,container,null,key);}var ReactDOM={createPortal:createPortal,findDOMNode:function findDOMNode(componentOrElement){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.stateNode!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;!warnedAboutRefsInRender?warningWithoutStack$1(false,'%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(owner.type)||'A component'):void 0;owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}return findHostInstance(componentOrElement);},hydrate:function hydrate(element,container,callback){// TODO: throw or warn if we couldn't hydrate?
return legacyRenderSubtreeIntoContainer(null,element,container,true,callback);},render:function render(element,container,callback){return legacyRenderSubtreeIntoContainer(null,element,container,false,callback);},unstable_renderSubtreeIntoContainer:function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){!(parentComponent!=null&&has(parentComponent))?invariant(false,'parentComponent must be a valid React Component'):void 0;return legacyRenderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);},unmountComponentAtNode:function unmountComponentAtNode(container){!isValidContainer(container)?invariant(false,'unmountComponentAtNode(...): Target container is not a DOM element.'):void 0;if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode$1(rootEl);!!renderedByDifferentReact?warningWithoutStack$1(false,"unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by another copy of React.'):void 0;}// Unmount should not be batched.
unbatchedUpdates(function(){legacyRenderSubtreeIntoContainer(null,null,container,false,function(){container._reactRootContainer=null;});});// If you call unmountComponentAtNode twice in quick succession, you'll
// get `true` twice. That's probably fine?
return true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode$1(_rootEl));// Check if the container itself is a React root node.
var isContainerReactRoot=container.nodeType===ELEMENT_NODE&&isValidContainer(container.parentNode)&&!!container.parentNode._reactRootContainer;!!hasNonRootReactChild?warningWithoutStack$1(false,"unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.'):void 0;}return false;}},// Temporary alias since we already shipped React 16 RC with it.
// TODO: remove in React 17.
unstable_createPortal:function unstable_createPortal(){if(!didWarnAboutUnstableCreatePortal){didWarnAboutUnstableCreatePortal=true;lowPriorityWarning$1(false,'The ReactDOM.unstable_createPortal() alias has been deprecated, '+'and will be removed in React 17+. Update your code to use '+'ReactDOM.createPortal() instead. It has the exact same API, '+'but without the "unstable_" prefix.');}return createPortal.apply(undefined,arguments);},unstable_batchedUpdates:batchedUpdates$1,unstable_interactiveUpdates:interactiveUpdates$1,flushSync:flushSync,unstable_flushControlled:flushControlled,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{// Keep in sync with ReactDOMUnstableNativeDependencies.js
// and ReactTestUtils.js. This is an array for better minification.
Events:[getInstanceFromNode$1,getNodeFromInstance$1,getFiberCurrentPropsFromNode$1,injection.injectEventPluginsByName,eventNameDispatchConfigs,accumulateTwoPhaseDispatches,accumulateDirectDispatches,enqueueStateRestore,restoreStateIfNeeded,dispatchEvent,runEventsInBatch]}};ReactDOM.unstable_createRoot=function createRoot(container,options){!isValidContainer(container)?invariant(false,'unstable_createRoot(...): Target container is not a DOM element.'):void 0;var hydrate=options!=null&&options.hydrate===true;return new ReactRoot(container,true,hydrate);};var foundDevTools=injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.
if(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.
if(/^(https?|file):$/.test(protocol)){console.info('%cDownload the React DevTools '+'for a better development experience: '+'https://fb.me/react-devtools'+(protocol==='file:'?'\nYou might need to use a local HTTP server (instead of file://): '+'https://fb.me/react-devtools-faq':''),'font-weight:bold');}}}}var ReactDOM$2=Object.freeze({default:ReactDOM});var ReactDOM$3=ReactDOM$2&&ReactDOM||ReactDOM$2;// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactDom=ReactDOM$3.default||ReactDOM$3;module.exports=reactDom;})();}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__(40);
} else {
  module.exports = __webpack_require__(41);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.5.2
 * schedule-tracing.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


Object.defineProperty(exports, "__esModule", { value: !0 });var b = 0;exports.__interactionsRef = null;exports.__subscriberRef = null;exports.unstable_clear = function (a) {
  return a();
};exports.unstable_getCurrent = function () {
  return null;
};exports.unstable_getThreadID = function () {
  return ++b;
};exports.unstable_trace = function (a, d, c) {
  return c();
};exports.unstable_wrap = function (a) {
  return a;
};exports.unstable_subscribe = function () {};exports.unstable_unsubscribe = function () {};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.5.2
 * schedule-tracing.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (process.env.NODE_ENV !== "production") {
  (function () {
    'use strict';

    Object.defineProperty(exports, '__esModule', { value: true });

    // Exports ReactDOM.createRoot


    // Experimental error-boundary API that can recover from errors within a single
    // render phase

    // Suspense

    // Helps identify side effects in begin-phase lifecycle hooks and setState reducers:


    // In some cases, StrictMode should also double-render lifecycles.
    // This can be confusing for tests though,
    // And it can be bad for performance in production.
    // This feature flag can be used to control the behavior:


    // To preserve the "Pause on caught exceptions" behavior of the debugger, we
    // replay the begin phase of a failed component inside invokeGuardedCallback.


    // Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:


    // Warn about legacy context API


    // Gather advanced timing metrics for Profiler subtrees.


    // Trace which interactions trigger each commit.
    var enableSchedulerTracing = true;

    // Only used in www builds.


    // Only used in www builds.


    // React Fire: prevent the value and checked attributes from syncing
    // with their related DOM properties

    var DEFAULT_THREAD_ID = 0;

    // Counters used to generate unique IDs.
    var interactionIDCounter = 0;
    var threadIDCounter = 0;

    // Set of currently traced interactions.
    // Interactions "stack"–
    // Meaning that newly traced interactions are appended to the previously active set.
    // When an interaction goes out of scope, the previous set (if any) is restored.
    exports.__interactionsRef = null;

    // Listener(s) to notify when interactions begin and end.
    exports.__subscriberRef = null;

    if (enableSchedulerTracing) {
      exports.__interactionsRef = {
        current: new Set()
      };
      exports.__subscriberRef = {
        current: null
      };
    }

    function unstable_clear(callback) {
      if (!enableSchedulerTracing) {
        return callback();
      }

      var prevInteractions = exports.__interactionsRef.current;
      exports.__interactionsRef.current = new Set();

      try {
        return callback();
      } finally {
        exports.__interactionsRef.current = prevInteractions;
      }
    }

    function unstable_getCurrent() {
      if (!enableSchedulerTracing) {
        return null;
      } else {
        return exports.__interactionsRef.current;
      }
    }

    function unstable_getThreadID() {
      return ++threadIDCounter;
    }

    function unstable_trace(name, timestamp, callback) {
      var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;

      if (!enableSchedulerTracing) {
        return callback();
      }

      var interaction = {
        __count: 1,
        id: interactionIDCounter++,
        name: name,
        timestamp: timestamp
      };

      var prevInteractions = exports.__interactionsRef.current;

      // Traced interactions should stack/accumulate.
      // To do that, clone the current interactions.
      // The previous set will be restored upon completion.
      var interactions = new Set(prevInteractions);
      interactions.add(interaction);
      exports.__interactionsRef.current = interactions;

      var subscriber = exports.__subscriberRef.current;
      var returnValue = void 0;

      try {
        if (subscriber !== null) {
          subscriber.onInteractionTraced(interaction);
        }
      } finally {
        try {
          if (subscriber !== null) {
            subscriber.onWorkStarted(interactions, threadID);
          }
        } finally {
          try {
            returnValue = callback();
          } finally {
            exports.__interactionsRef.current = prevInteractions;

            try {
              if (subscriber !== null) {
                subscriber.onWorkStopped(interactions, threadID);
              }
            } finally {
              interaction.__count--;

              // If no async work was scheduled for this interaction,
              // Notify subscribers that it's completed.
              if (subscriber !== null && interaction.__count === 0) {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
              }
            }
          }
        }
      }

      return returnValue;
    }

    function unstable_wrap(callback) {
      var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;

      if (!enableSchedulerTracing) {
        return callback;
      }

      var wrappedInteractions = exports.__interactionsRef.current;

      var subscriber = exports.__subscriberRef.current;
      if (subscriber !== null) {
        subscriber.onWorkScheduled(wrappedInteractions, threadID);
      }

      // Update the pending async work count for the current interactions.
      // Update after calling subscribers in case of error.
      wrappedInteractions.forEach(function (interaction) {
        interaction.__count++;
      });

      var hasRun = false;

      function wrapped() {
        var prevInteractions = exports.__interactionsRef.current;
        exports.__interactionsRef.current = wrappedInteractions;

        subscriber = exports.__subscriberRef.current;

        try {
          var returnValue = void 0;

          try {
            if (subscriber !== null) {
              subscriber.onWorkStarted(wrappedInteractions, threadID);
            }
          } finally {
            try {
              returnValue = callback.apply(undefined, arguments);
            } finally {
              exports.__interactionsRef.current = prevInteractions;

              if (subscriber !== null) {
                subscriber.onWorkStopped(wrappedInteractions, threadID);
              }
            }
          }

          return returnValue;
        } finally {
          if (!hasRun) {
            // We only expect a wrapped function to be executed once,
            // But in the event that it's executed more than once–
            // Only decrement the outstanding interaction counts once.
            hasRun = true;

            // Update pending async counts for all wrapped interactions.
            // If this was the last scheduled async work for any of them,
            // Mark them as completed.
            wrappedInteractions.forEach(function (interaction) {
              interaction.__count--;

              if (subscriber !== null && interaction.__count === 0) {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
              }
            });
          }
        }
      }

      wrapped.cancel = function cancel() {
        subscriber = exports.__subscriberRef.current;

        try {
          if (subscriber !== null) {
            subscriber.onWorkCanceled(wrappedInteractions, threadID);
          }
        } finally {
          // Update pending async counts for all wrapped interactions.
          // If this was the last scheduled async work for any of them,
          // Mark them as completed.
          wrappedInteractions.forEach(function (interaction) {
            interaction.__count--;

            if (subscriber && interaction.__count === 0) {
              subscriber.onInteractionScheduledWorkCompleted(interaction);
            }
          });
        }
      };

      return wrapped;
    }

    var subscribers = null;
    if (enableSchedulerTracing) {
      subscribers = new Set();
    }

    function unstable_subscribe(subscriber) {
      if (enableSchedulerTracing) {
        subscribers.add(subscriber);

        if (subscribers.size === 1) {
          exports.__subscriberRef.current = {
            onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,
            onInteractionTraced: onInteractionTraced,
            onWorkCanceled: onWorkCanceled,
            onWorkScheduled: onWorkScheduled,
            onWorkStarted: onWorkStarted,
            onWorkStopped: onWorkStopped
          };
        }
      }
    }

    function unstable_unsubscribe(subscriber) {
      if (enableSchedulerTracing) {
        subscribers.delete(subscriber);

        if (subscribers.size === 0) {
          exports.__subscriberRef.current = null;
        }
      }
    }

    function onInteractionTraced(interaction) {
      var didCatchError = false;
      var caughtError = null;

      subscribers.forEach(function (subscriber) {
        try {
          subscriber.onInteractionTraced(interaction);
        } catch (error) {
          if (!didCatchError) {
            didCatchError = true;
            caughtError = error;
          }
        }
      });

      if (didCatchError) {
        throw caughtError;
      }
    }

    function onInteractionScheduledWorkCompleted(interaction) {
      var didCatchError = false;
      var caughtError = null;

      subscribers.forEach(function (subscriber) {
        try {
          subscriber.onInteractionScheduledWorkCompleted(interaction);
        } catch (error) {
          if (!didCatchError) {
            didCatchError = true;
            caughtError = error;
          }
        }
      });

      if (didCatchError) {
        throw caughtError;
      }
    }

    function onWorkScheduled(interactions, threadID) {
      var didCatchError = false;
      var caughtError = null;

      subscribers.forEach(function (subscriber) {
        try {
          subscriber.onWorkScheduled(interactions, threadID);
        } catch (error) {
          if (!didCatchError) {
            didCatchError = true;
            caughtError = error;
          }
        }
      });

      if (didCatchError) {
        throw caughtError;
      }
    }

    function onWorkStarted(interactions, threadID) {
      var didCatchError = false;
      var caughtError = null;

      subscribers.forEach(function (subscriber) {
        try {
          subscriber.onWorkStarted(interactions, threadID);
        } catch (error) {
          if (!didCatchError) {
            didCatchError = true;
            caughtError = error;
          }
        }
      });

      if (didCatchError) {
        throw caughtError;
      }
    }

    function onWorkStopped(interactions, threadID) {
      var didCatchError = false;
      var caughtError = null;

      subscribers.forEach(function (subscriber) {
        try {
          subscriber.onWorkStopped(interactions, threadID);
        } catch (error) {
          if (!didCatchError) {
            didCatchError = true;
            caughtError = error;
          }
        }
      });

      if (didCatchError) {
        throw caughtError;
      }
    }

    function onWorkCanceled(interactions, threadID) {
      var didCatchError = false;
      var caughtError = null;

      subscribers.forEach(function (subscriber) {
        try {
          subscriber.onWorkCanceled(interactions, threadID);
        } catch (error) {
          if (!didCatchError) {
            didCatchError = true;
            caughtError = error;
          }
        }
      });

      if (didCatchError) {
        throw caughtError;
      }
    }

    exports.unstable_clear = unstable_clear;
    exports.unstable_getCurrent = unstable_getCurrent;
    exports.unstable_getThreadID = unstable_getThreadID;
    exports.unstable_trace = unstable_trace;
    exports.unstable_wrap = unstable_wrap;
    exports.unstable_subscribe = unstable_subscribe;
    exports.unstable_unsubscribe = unstable_unsubscribe;
  })();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _routes = __webpack_require__(43);

var _routes2 = _interopRequireDefault(_routes);

var _reactRouterConfig = __webpack_require__(71);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App = function (_Component) {
    _inherits(App, _Component);

    function App() {
        _classCallCheck(this, App);

        return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));
    }

    _createClass(App, [{
        key: 'render',
        value: function render() {
            return _react2.default.createElement(
                'div',
                null,
                _react2.default.createElement(
                    'h1',
                    null,
                    'This is App root page.'
                ),
                _react2.default.createElement('hr', null),
                (0, _reactRouterConfig.renderRoutes)(_routes2.default)
            );
        }
    }]);

    return App;
}(_react.Component);

exports.default = App;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Home = __webpack_require__(44);

var _Home2 = _interopRequireDefault(_Home);

var _Languages = __webpack_require__(65);

var _Languages2 = _interopRequireDefault(_Languages);

var _Users = __webpack_require__(66);

var _Users2 = _interopRequireDefault(_Users);

var _repoGrid = __webpack_require__(67);

var _repoGrid2 = _interopRequireDefault(_repoGrid);

var _userGrid = __webpack_require__(70);

var _userGrid2 = _interopRequireDefault(_userGrid);

var _api = __webpack_require__(19);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var routes = [{
    path: '/',
    exact: true,
    component: _Home2.default
}, {
    path: '/languages',
    exact: true,
    component: _Languages2.default
}, {
    path: '/languages/:id',
    component: _repoGrid2.default,
    loadData: function loadData() {
        var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        return (0, _api.fetchPopularRepos)(path.split('/').pop());
    }
}, {
    path: '/users',
    exact: true,
    component: _Users2.default
}, {
    path: '/users/:id',
    component: _userGrid2.default,
    loadData: function loadData() {
        var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        return (0, _api.fetchUser)(path.split('/').pop());
    }
}];

exports.default = routes;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = Home;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Home() {
    return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(
            'h2',
            null,
            'This is Home page.'
        ),
        _react2.default.createElement(
            _reactRouterDom.NavLink,
            { activeStyle: { fontWeight: 'bold' }, to: '/languages' },
            'Languages'
        ),
        _react2.default.createElement('br', null),
        _react2.default.createElement(
            _reactRouterDom.NavLink,
            { activeStyle: { fontWeight: 'bold' }, to: '/users' },
            'Users'
        )
    );
}

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(4);

var _warning2 = _interopRequireDefault(_warning);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _history = __webpack_require__(5);

var _Router = __webpack_require__(16);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for a <Router> that uses HTML5 history.
 */

var BrowserRouter = function (_React$Component) {
  _inherits(BrowserRouter, _React$Component);

  function BrowserRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, BrowserRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = (0, _history.createBrowserHistory)(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  BrowserRouter.prototype.componentWillMount = function componentWillMount() {
    (0, _warning2.default)(!this.props.history, "<BrowserRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { BrowserRouter as Router }`.");
  };

  BrowserRouter.prototype.render = function render() {
    return _react2.default.createElement(_Router2.default, { history: this.history, children: this.props.children });
  };

  return BrowserRouter;
}(_react2.default.Component);

BrowserRouter.propTypes = {
  basename: _propTypes2.default.string,
  forceRefresh: _propTypes2.default.bool,
  getUserConfirmation: _propTypes2.default.func,
  keyLength: _propTypes2.default.number,
  children: _propTypes2.default.node
};

exports.default = BrowserRouter;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var assign = __webpack_require__(6);

var ReactPropTypesSecret = __webpack_require__(14);
var checkPropTypes = __webpack_require__(13);

var printWarning = function printWarning() {};

if (process.env.NODE_ENV !== 'production') {
  printWarning = function printWarning(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function (isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
          err.name = 'Invariant Violation';
          throw err;
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (!manualPropTypeCallCache[cacheKey] &&
          // Avoid spamming the console because they are often not actionable except for lib authors
          manualPropTypeWarningCount < 3) {
            printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(14);

function emptyFunction() {}

module.exports = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to) {
  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var toParts = to && to.split('/') || [];
  var fromParts = from && from.split('/') || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash = void 0;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) {
    fromParts.unshift('..');
  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

exports.default = resolvePathname;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

function valueEqual(a, b) {
  if (a === b) return true;

  if (a == null || b == null) return false;

  if (Array.isArray(a)) {
    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return valueEqual(item, b[index]);
    });
  }

  var aType = typeof a === 'undefined' ? 'undefined' : _typeof(a);
  var bType = typeof b === 'undefined' ? 'undefined' : _typeof(b);

  if (aType !== bType) return false;

  if (aType === 'object') {
    var aValue = a.valueOf();
    var bValue = b.valueOf();

    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);

    if (aKeys.length !== bKeys.length) return false;

    return aKeys.every(function (key) {
      return valueEqual(a[key], b[key]);
    });
  }

  return false;
}

exports.default = valueEqual;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(10);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(3);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(9);

var _PathUtils = __webpack_require__(7);

var _createTransitionManager = __webpack_require__(15);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__(21);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = (0, _DOMUtils.supportsHistory)();
  var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;

    var path = pathname + search + hash;

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + (0, _PathUtils.createPath)(location);
  };

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createBrowserHistory;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _warning = __webpack_require__(10);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(3);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(9);

var _PathUtils = __webpack_require__(7);

var _createTransitionManager = __webpack_require__(15);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__(21);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + (0, _PathUtils.stripLeadingSlash)(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: _PathUtils.stripLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  },
  slash: {
    encodePath: _PathUtils.addLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;

  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === (0, _PathUtils.createPath)(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [(0, _PathUtils.createPath)(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + (0, _PathUtils.createPath)(location));
  };

  var push = function push(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        (0, _warning2.default)(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf((0, _PathUtils.createPath)(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    (0, _warning2.default)(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createHashHistory;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(10);

var _warning2 = _interopRequireDefault(_warning);

var _PathUtils = __webpack_require__(7);

var _LocationUtils = __webpack_require__(9);

var _createTransitionManager = __webpack_require__(15);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? (0, _LocationUtils.createLocation)(entry, undefined, createKey()) : (0, _LocationUtils.createLocation)(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = _PathUtils.createPath;

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createMemoryHistory;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(4);

var _warning2 = _interopRequireDefault(_warning);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _history = __webpack_require__(5);

var _Router = __webpack_require__(16);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for a <Router> that uses window.location.hash.
 */

var HashRouter = function (_React$Component) {
  _inherits(HashRouter, _React$Component);

  function HashRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, HashRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = (0, _history.createHashHistory)(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  HashRouter.prototype.componentWillMount = function componentWillMount() {
    (0, _warning2.default)(!this.props.history, "<HashRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { HashRouter as Router }`.");
  };

  HashRouter.prototype.render = function render() {
    return _react2.default.createElement(_Router2.default, { history: this.history, children: this.props.children });
  };

  return HashRouter;
}(_react2.default.Component);

HashRouter.propTypes = {
  basename: _propTypes2.default.string,
  getUserConfirmation: _propTypes2.default.func,
  hashType: _propTypes2.default.oneOf(["hashbang", "noslash", "slash"]),
  children: _propTypes2.default.node
};

exports.default = HashRouter;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MemoryRouter = __webpack_require__(23);

var _MemoryRouter2 = _interopRequireDefault(_MemoryRouter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _MemoryRouter2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(2);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _Route = __webpack_require__(24);

var _Route2 = _interopRequireDefault(_Route);

var _Link = __webpack_require__(22);

var _Link2 = _interopRequireDefault(_Link);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

/**
 * A <Link> wrapper that knows if it's "active" or not.
 */
var NavLink = function NavLink(_ref) {
  var to = _ref.to,
      exact = _ref.exact,
      strict = _ref.strict,
      location = _ref.location,
      activeClassName = _ref.activeClassName,
      className = _ref.className,
      activeStyle = _ref.activeStyle,
      style = _ref.style,
      getIsActive = _ref.isActive,
      ariaCurrent = _ref["aria-current"],
      rest = _objectWithoutProperties(_ref, ["to", "exact", "strict", "location", "activeClassName", "className", "activeStyle", "style", "isActive", "aria-current"]);

  var path = (typeof to === "undefined" ? "undefined" : _typeof(to)) === "object" ? to.pathname : to;

  // Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202
  var escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");

  return _react2.default.createElement(_Route2.default, {
    path: escapedPath,
    exact: exact,
    strict: strict,
    location: location,
    children: function children(_ref2) {
      var location = _ref2.location,
          match = _ref2.match;

      var isActive = !!(getIsActive ? getIsActive(match, location) : match);

      return _react2.default.createElement(_Link2.default, _extends({
        to: to,
        className: isActive ? [className, activeClassName].filter(function (i) {
          return i;
        }).join(" ") : className,
        style: isActive ? _extends({}, style, activeStyle) : style,
        "aria-current": isActive && ariaCurrent || null
      }, rest));
    }
  });
};

NavLink.propTypes = {
  to: _Link2.default.propTypes.to,
  exact: _propTypes2.default.bool,
  strict: _propTypes2.default.bool,
  location: _propTypes2.default.object,
  activeClassName: _propTypes2.default.string,
  className: _propTypes2.default.string,
  activeStyle: _propTypes2.default.object,
  style: _propTypes2.default.object,
  isActive: _propTypes2.default.func,
  "aria-current": _propTypes2.default.oneOf(["page", "step", "location", "date", "time", "true"])
};

NavLink.defaultProps = {
  activeClassName: "active",
  "aria-current": "page"
};

exports.default = NavLink;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Prompt = __webpack_require__(26);

var _Prompt2 = _interopRequireDefault(_Prompt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Prompt2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Redirect = __webpack_require__(27);

var _Redirect2 = _interopRequireDefault(_Redirect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Redirect2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _StaticRouter = __webpack_require__(28);

var _StaticRouter2 = _interopRequireDefault(_StaticRouter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _StaticRouter2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Switch = __webpack_require__(29);

var _Switch2 = _interopRequireDefault(_Switch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Switch2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _generatePath = __webpack_require__(18);

var _generatePath2 = _interopRequireDefault(_generatePath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _generatePath2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _matchPath = __webpack_require__(12);

var _matchPath2 = _interopRequireDefault(_matchPath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _matchPath2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _withRouter = __webpack_require__(30);

var _withRouter2 = _interopRequireDefault(_withRouter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _withRouter2.default; // Written in this round about way for babel-transform-imports

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
        // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
}

module.exports = hoistNonReactStatics;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = Languages;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Languages() {
    var languages = [{
        name: 'All',
        param: 'all'
    }, {
        name: 'JavaScript',
        param: 'javascript'
    }, {
        name: 'Ruby',
        param: 'ruby'
    }, {
        name: 'Python',
        param: 'python'
    }, {
        name: 'Java',
        param: 'java'
    }];

    return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(
            'h2',
            null,
            'This is Languages page.'
        ),
        _react2.default.createElement(
            'ul',
            null,
            languages.map(function (_ref) {
                var name = _ref.name,
                    param = _ref.param;
                return _react2.default.createElement(
                    'li',
                    { key: param },
                    _react2.default.createElement(
                        _reactRouterDom.NavLink,
                        { activeStyle: { fontWeight: 'bold' }, to: '/languages/' + param },
                        name
                    )
                );
            })
        )
    );
}

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = Users;

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Users() {
    var users = [{
        name: 'Me',
        param: 'VladislavArkavenko'
    }, {
        name: 'Igor',
        param: 'polkpolio1'
    }, {
        name: 'Someone',
        param: 'someone'
    }];

    return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(
            'h2',
            null,
            'This is Users page.'
        ),
        _react2.default.createElement(
            'ul',
            null,
            users.map(function (_ref) {
                var name = _ref.name,
                    param = _ref.param;
                return _react2.default.createElement(
                    'li',
                    { key: param },
                    _react2.default.createElement(
                        _reactRouterDom.NavLink,
                        { activeStyle: { fontWeight: 'bold' }, to: '/users/' + param },
                        name
                    )
                );
            })
        )
    );
}

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _api = __webpack_require__(19);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RepoGrid = function (_Component) {
    _inherits(RepoGrid, _Component);

    function RepoGrid(props) {
        _classCallCheck(this, RepoGrid);

        var _this = _possibleConstructorReturn(this, (RepoGrid.__proto__ || Object.getPrototypeOf(RepoGrid)).call(this, props));

        var repos = void 0;

        if (true) {
            repos = window.__INITIAL_DATA__;
            delete window.__INITIAL_DATA__;
        } else {
            repos = props.staticContext.data;
        }

        _this.state = {
            repos: repos,
            loading: repos ? false : true
        };

        _this.fetchRepos = _this.fetchRepos.bind(_this);
        return _this;
    }

    _createClass(RepoGrid, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (!this.state.repos) {
                this.fetchRepos(this.props.match.params.id);
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps) {
            if (prevProps.match.params.id !== this.props.match.params.id) {
                this.fetchRepos(this.props.match.params.id);
            }
        }
    }, {
        key: 'fetchRepos',
        value: function fetchRepos(lang) {
            var _this2 = this;

            this.setState(function () {
                return {
                    loading: true
                };
            });

            (0, _api.fetchPopularRepos)(lang).then(function (repos) {
                return _this2.setState(function () {
                    return {
                        repos: repos,
                        loading: false
                    };
                });
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _state = this.state,
                repos = _state.repos,
                loading = _state.loading;


            if (loading) {
                return _react2.default.createElement(
                    'p',
                    null,
                    'Loading...'
                );
            }

            return _react2.default.createElement(
                'ul',
                { style: { display: 'flex', flexWrap: 'wrap' } },
                repos.map(function (_ref) {
                    var name = _ref.name,
                        owner = _ref.owner,
                        stargazers_count = _ref.stargazers_count,
                        html_url = _ref.html_url;
                    return _react2.default.createElement(
                        'li',
                        { key: name, style: { margin: 30 } },
                        _react2.default.createElement(
                            'ul',
                            null,
                            _react2.default.createElement(
                                'li',
                                null,
                                _react2.default.createElement(
                                    'a',
                                    { href: html_url },
                                    name
                                )
                            ),
                            _react2.default.createElement(
                                'li',
                                null,
                                '@',
                                owner.login
                            ),
                            _react2.default.createElement(
                                'li',
                                null,
                                stargazers_count,
                                ' stars'
                            )
                        )
                    );
                })
            );
        }
    }]);

    return RepoGrid;
}(_react.Component);

exports.default = RepoGrid;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// the whatwg-fetch polyfill installs the fetch() function
// on the global object (window or self)
//
// Return that as the export for use in Webpack, Browserify etc.
__webpack_require__(69);
module.exports = self.fetch.bind(self);

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Headers = Headers;
exports.Request = Request;
exports.Response = Response;
exports.fetch = fetch;
var support = {
  searchParams: 'URLSearchParams' in self,
  iterable: 'Symbol' in self && 'iterator' in Symbol,
  blob: 'FileReader' in self && 'Blob' in self && function () {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: 'FormData' in self,
  arrayBuffer: 'ArrayBuffer' in self
};

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}

if (support.arrayBuffer) {
  var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

  var isArrayBufferView = ArrayBuffer.isView || function (obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
    throw new TypeError('Invalid character in header field name');
  }
  return name.toLowerCase();
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }
  return value;
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function next() {
      var value = items.shift();
      return { done: value === undefined, value: value };
    }
  };

  if (support.iterable) {
    iterator[Symbol.iterator] = function () {
      return iterator;
    };
  }

  return iterator;
}

function Headers(headers) {
  this.map = {};

  if (headers instanceof Headers) {
    headers.forEach(function (value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function (header) {
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function (name) {
      this.append(name, headers[name]);
    }, this);
  }
}

Headers.prototype.append = function (name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};

Headers.prototype['delete'] = function (name) {
  delete this.map[normalizeName(name)];
};

Headers.prototype.get = function (name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};

Headers.prototype.has = function (name) {
  return this.map.hasOwnProperty(normalizeName(name));
};

Headers.prototype.set = function (name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};

Headers.prototype.forEach = function (callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};

Headers.prototype.keys = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};

Headers.prototype.values = function () {
  var items = [];
  this.forEach(function (value) {
    items.push(value);
  });
  return iteratorFor(items);
};

Headers.prototype.entries = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'));
  }
  body.bodyUsed = true;
}

function fileReaderReady(reader) {
  return new Promise(function (resolve, reject) {
    reader.onload = function () {
      resolve(reader.result);
    };
    reader.onerror = function () {
      reject(reader.error);
    };
  });
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}

function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsText(blob);
  return promise;
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join('');
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}

function Body() {
  this.bodyUsed = false;

  this._initBody = function (body) {
    this._bodyInit = body;
    if (!body) {
      this._bodyText = '';
    } else if (typeof body === 'string') {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8');
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
      }
    }
  };

  if (support.blob) {
    this.blob = function () {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob');
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };

    this.arrayBuffer = function () {
      if (this._bodyArrayBuffer) {
        return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
      } else {
        return this.blob().then(readBlobAsArrayBuffer);
      }
    };
  }

  this.text = function () {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text');
    } else {
      return Promise.resolve(this._bodyText);
    }
  };

  if (support.formData) {
    this.formData = function () {
      return this.text().then(decode);
    };
  }

  this.json = function () {
    return this.text().then(JSON.parse);
  };

  return this;
}

// HTTP methods whose capitalization should be normalized
var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}

function Request(input, options) {
  options = options || {};
  var body = options.body;

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read');
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }

  this.credentials = options.credentials || this.credentials || 'same-origin';
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || 'GET');
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal;
  this.referrer = null;

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests');
  }
  this._initBody(body);
}

Request.prototype.clone = function () {
  return new Request(this, { body: this._bodyInit });
};

function decode(body) {
  var form = new FormData();
  body.trim().split('&').forEach(function (bytes) {
    if (bytes) {
      var split = bytes.split('=');
      var name = split.shift().replace(/\+/g, ' ');
      var value = split.join('=').replace(/\+/g, ' ');
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}

function parseHeaders(rawHeaders) {
  var headers = new Headers();
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
  preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
    var parts = line.split(':');
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(':').trim();
      headers.append(key, value);
    }
  });
  return headers;
}

Body.call(Request.prototype);

function Response(bodyInit, options) {
  if (!options) {
    options = {};
  }

  this.type = 'default';
  this.status = options.status === undefined ? 200 : options.status;
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = 'statusText' in options ? options.statusText : 'OK';
  this.headers = new Headers(options.headers);
  this.url = options.url || '';
  this._initBody(bodyInit);
}

Body.call(Response.prototype);

Response.prototype.clone = function () {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  });
};

Response.error = function () {
  var response = new Response(null, { status: 0, statusText: '' });
  response.type = 'error';
  return response;
};

var redirectStatuses = [301, 302, 303, 307, 308];

Response.redirect = function (url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code');
  }

  return new Response(null, { status: status, headers: { location: url } });
};

var DOMException = exports.DOMException = self.DOMException;
try {
  new DOMException();
} catch (err) {
  exports.DOMException = DOMException = function DOMException(message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}

function fetch(input, init) {
  return new Promise(function (resolve, reject) {
    var request = new Request(input, init);

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'));
    }

    var xhr = new XMLHttpRequest();

    function abortXhr() {
      xhr.abort();
    }

    xhr.onload = function () {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      };
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
      var body = 'response' in xhr ? xhr.response : xhr.responseText;
      resolve(new Response(body, options));
    };

    xhr.onerror = function () {
      reject(new TypeError('Network request failed'));
    };

    xhr.ontimeout = function () {
      reject(new TypeError('Network request failed'));
    };

    xhr.onabort = function () {
      reject(new DOMException('Aborted', 'AbortError'));
    };

    xhr.open(request.method, request.url, true);

    if (request.credentials === 'include') {
      xhr.withCredentials = true;
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false;
    }

    if ('responseType' in xhr && support.blob) {
      xhr.responseType = 'blob';
    }

    request.headers.forEach(function (value, name) {
      xhr.setRequestHeader(name, value);
    });

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr);

      xhr.onreadystatechange = function () {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr);
        }
      };
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
  });
}

fetch.polyfill = true;

if (!self.fetch) {
  self.fetch = fetch;
  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;
}

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _api = __webpack_require__(19);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UserGrid = function (_Component) {
    _inherits(UserGrid, _Component);

    function UserGrid(props) {
        _classCallCheck(this, UserGrid);

        var _this = _possibleConstructorReturn(this, (UserGrid.__proto__ || Object.getPrototypeOf(UserGrid)).call(this, props));

        var user = void 0;

        if (true) {
            user = window.__INITIAL_DATA__;
            delete window.__INITIAL_DATA__;
        } else {
            user = props.staticContext.data;
        }

        _this.state = {
            user: user,
            loading: user ? false : true
        };

        _this.getUser = _this.getUser.bind(_this);
        return _this;
    }

    _createClass(UserGrid, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (!this.state.user) {
                this.getUser(this.props.match.params.id);
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps) {
            if (prevProps.match.params.id !== this.props.match.params.id) {
                this.getUser(this.props.match.params.id);
            }
        }
    }, {
        key: 'getUser',
        value: function getUser(name) {
            var _this2 = this;

            this.setState(function () {
                return {
                    loading: true
                };
            });

            (0, _api.fetchUser)(name).then(function (user) {
                return _this2.setState(function () {
                    return {
                        user: user,
                        loading: false
                    };
                });
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _state = this.state,
                user = _state.user,
                loading = _state.loading;


            if (loading) {
                return _react2.default.createElement(
                    'p',
                    null,
                    'Loading...'
                );
            }

            return _react2.default.createElement(
                'div',
                null,
                _react2.default.createElement('img', { src: user.avatar_url, alt: 'Avatar' }),
                _react2.default.createElement(
                    'a',
                    { href: user.url },
                    _react2.default.createElement(
                        'h5',
                        null,
                        user.login
                    )
                ),
                _react2.default.createElement(
                    'p',
                    null,
                    'Followers: ',
                    user.followers
                ),
                _react2.default.createElement(
                    'p',
                    null,
                    'Following: ',
                    user.following
                )
            );
        }
    }]);

    return UserGrid;
}(_react.Component);

exports.default = UserGrid;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderRoutes = exports.matchRoutes = undefined;

var _reactRouter = __webpack_require__(72);

var _extends2 = __webpack_require__(73);

var _extends3 = _interopRequireDefault(_extends2);

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function matchRoutes(routes, pathname,
/*not public API*/
branch) {
  if (branch === void 0) {
    branch = [];
  }

  routes.some(function (route) {
    var match = route.path ? (0, _reactRouter.matchPath)(pathname, route) : branch.length ? branch[branch.length - 1].match // use parent match
    : _reactRouter.Router.computeRootMatch(pathname); // use default "root" match

    if (match) {
      branch.push({
        route: route,
        match: match
      });

      if (route.routes) {
        matchRoutes(route.routes, pathname, branch);
      }
    }

    return match;
  });
  return branch;
}

function renderRoutes(routes, extraProps, switchProps) {
  if (extraProps === void 0) {
    extraProps = {};
  }

  if (switchProps === void 0) {
    switchProps = {};
  }

  return routes ? _react2.default.createElement(_reactRouter.Switch, switchProps, routes.map(function (route, i) {
    return _react2.default.createElement(_reactRouter.Route, {
      key: route.key || i,
      path: route.path,
      exact: route.exact,
      strict: route.strict,
      render: function render(props) {
        return route.render ? route.render((0, _extends3.default)({}, props, extraProps, {
          route: route
        })) : _react2.default.createElement(route.component, (0, _extends3.default)({}, props, extraProps, {
          route: route
        }));
      }
    });
  })) : null;
}

exports.matchRoutes = matchRoutes;
exports.renderRoutes = renderRoutes;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withRouter = exports.matchPath = exports.generatePath = exports.Switch = exports.StaticRouter = exports.Router = exports.Route = exports.Redirect = exports.Prompt = exports.MemoryRouter = undefined;

var _MemoryRouter2 = __webpack_require__(23);

var _MemoryRouter3 = _interopRequireDefault(_MemoryRouter2);

var _Prompt2 = __webpack_require__(26);

var _Prompt3 = _interopRequireDefault(_Prompt2);

var _Redirect2 = __webpack_require__(27);

var _Redirect3 = _interopRequireDefault(_Redirect2);

var _Route2 = __webpack_require__(17);

var _Route3 = _interopRequireDefault(_Route2);

var _Router2 = __webpack_require__(11);

var _Router3 = _interopRequireDefault(_Router2);

var _StaticRouter2 = __webpack_require__(28);

var _StaticRouter3 = _interopRequireDefault(_StaticRouter2);

var _Switch2 = __webpack_require__(29);

var _Switch3 = _interopRequireDefault(_Switch2);

var _generatePath2 = __webpack_require__(18);

var _generatePath3 = _interopRequireDefault(_generatePath2);

var _matchPath2 = __webpack_require__(12);

var _matchPath3 = _interopRequireDefault(_matchPath2);

var _withRouter2 = __webpack_require__(30);

var _withRouter3 = _interopRequireDefault(_withRouter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.MemoryRouter = _MemoryRouter3.default;
exports.Prompt = _Prompt3.default;
exports.Redirect = _Redirect3.default;
exports.Route = _Route3.default;
exports.Router = _Router3.default;
exports.StaticRouter = _StaticRouter3.default;
exports.Switch = _Switch3.default;
exports.generatePath = _generatePath3.default;
exports.matchPath = _matchPath3.default;
exports.withRouter = _withRouter3.default;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _extends;
function _extends() {
  exports.default = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNDg0ODE1YzBmNGY0Mzk3YTdjZTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ludmFyaWFudC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93YXJuaW5nL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvUGF0aFV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0xvY2F0aW9uVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3Rvcnkvbm9kZV9tb2R1bGVzL3dhcm5pbmcvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL21hdGNoUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUm91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUm91dGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9nZW5lcmF0ZVBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXJlZC9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0RPTVV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9NZW1vcnlSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUm91dGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Qcm9tcHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9SZWRpcmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1N0YXRpY1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1N3aXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL3dpdGhSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Jyb3dzZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zY2hlZHVsZS9janMvc2NoZWR1bGUucHJvZHVjdGlvbi5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlL2Nqcy9zY2hlZHVsZS5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlL3RyYWNpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlL2Nqcy9zY2hlZHVsZS10cmFjaW5nLnByb2R1Y3Rpb24ubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zY2hlZHVsZS9janMvc2NoZWR1bGUtdHJhY2luZy5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcmVkL0FwcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcmVkL3JvdXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2hhcmVkL0hvbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvQnJvd3NlclJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Jlc29sdmUtcGF0aG5hbWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ZhbHVlLWVxdWFsL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZUhhc2hIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvSGFzaFJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9NZW1vcnlSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTmF2TGluay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Qcm9tcHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvU3RhdGljUm91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N3aXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9nZW5lcmF0ZVBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvbWF0Y2hQYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL3dpdGhSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2Rpc3QvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MuY2pzLmpzIiwid2VicGFjazovLy8uL3NyYy9zaGFyZWQvTGFuZ3VhZ2VzLmpzIiwid2VicGFjazovLy8uL3NyYy9zaGFyZWQvVXNlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXJlZC9yZXBvR3JpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNvbW9ycGhpYy1mZXRjaC9mZXRjaC1ucG0tYnJvd3NlcmlmeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2hhdHdnLWZldGNoL2ZldGNoLmpzIiwid2VicGFjazovLy8uL3NyYy9zaGFyZWQvdXNlckdyaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1jb25maWcvZXNtL3JlYWN0LXJvdXRlci1jb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcy5qcyJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiRXJyb3IiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImUiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwiY2FsbCIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJsZW4iLCJydW4iLCJuZXh0VGljayIsImFyZ3MiLCJBcnJheSIsImFyZ3VtZW50cyIsImkiLCJwdXNoIiwiSXRlbSIsImFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsIm5hbWUiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlN5bWJvbCIsImZvciIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiJCR0eXBlb2YiLCJ0aHJvd09uRGlyZWN0QWNjZXNzIiwiaW52YXJpYW50IiwiY29uZGl0aW9uIiwiZm9ybWF0IiwiYSIsImIiLCJjIiwiZCIsImYiLCJ1bmRlZmluZWQiLCJlcnJvciIsImFyZ0luZGV4IiwicmVwbGFjZSIsImZyYW1lc1RvUG9wIiwiX19ERVZfXyIsIndhcm5pbmciLCJwcmludFdhcm5pbmciLCJrZXkiLCJtZXNzYWdlIiwiY29uc29sZSIsIngiLCJjcmVhdGVMb2NhdGlvbiIsImxvY2F0aW9uc0FyZUVxdWFsIiwicGFyc2VQYXRoIiwiY3JlYXRlUGF0aCIsImNyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiX2NyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiY3JlYXRlSGFzaEhpc3RvcnkiLCJfY3JlYXRlSGFzaEhpc3RvcnkiLCJjcmVhdGVNZW1vcnlIaXN0b3J5IiwiX2NyZWF0ZU1lbW9yeUhpc3RvcnkiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJPYmplY3QiLCJoYXNPd25Qcm9wZXJ0eSIsInByb3BJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInRvT2JqZWN0IiwidmFsIiwiVHlwZUVycm9yIiwic2hvdWxkVXNlTmF0aXZlIiwiYXNzaWduIiwidGVzdDEiLCJTdHJpbmciLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwidGVzdDIiLCJmcm9tQ2hhckNvZGUiLCJvcmRlcjIiLCJtYXAiLCJuIiwiam9pbiIsInRlc3QzIiwic3BsaXQiLCJmb3JFYWNoIiwibGV0dGVyIiwia2V5cyIsImVyciIsInRhcmdldCIsInNvdXJjZSIsImZyb20iLCJ0byIsInN5bWJvbHMiLCJzIiwiYWRkTGVhZGluZ1NsYXNoIiwicGF0aCIsImNoYXJBdCIsInN0cmlwTGVhZGluZ1NsYXNoIiwic3Vic3RyIiwiaGFzQmFzZW5hbWUiLCJwcmVmaXgiLCJSZWdFeHAiLCJ0ZXN0Iiwic3RyaXBCYXNlbmFtZSIsInN0cmlwVHJhaWxpbmdTbGFzaCIsInNsaWNlIiwicGF0aG5hbWUiLCJzZWFyY2giLCJoYXNoIiwiaGFzaEluZGV4IiwiaW5kZXhPZiIsInNlYXJjaEluZGV4IiwibG9jYXRpb24iLCJCcm93c2VyUm91dGVyIiwiX0Jyb3dzZXJSb3V0ZXIiLCJIYXNoUm91dGVyIiwiX0hhc2hSb3V0ZXIiLCJMaW5rIiwiX0xpbmsiLCJNZW1vcnlSb3V0ZXIiLCJfTWVtb3J5Um91dGVyIiwiTmF2TGluayIsIl9OYXZMaW5rIiwiUHJvbXB0IiwiX1Byb21wdCIsIlJlZGlyZWN0IiwiX1JlZGlyZWN0IiwiUm91dGUiLCJfUm91dGUiLCJSb3V0ZXIiLCJfUm91dGVyIiwiU3RhdGljUm91dGVyIiwiX1N0YXRpY1JvdXRlciIsIlN3aXRjaCIsIl9Td2l0Y2giLCJnZW5lcmF0ZVBhdGgiLCJfZ2VuZXJhdGVQYXRoIiwibWF0Y2hQYXRoIiwiX21hdGNoUGF0aCIsIndpdGhSb3V0ZXIiLCJfd2l0aFJvdXRlciIsIl9leHRlbmRzIiwic3RhdGUiLCJjdXJyZW50TG9jYXRpb24iLCJkZWNvZGVVUkkiLCJVUklFcnJvciIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIl9SZWFjdCRDb21wb25lbnQiLCJfdGVtcCIsIl90aGlzIiwiX3JldCIsIl9sZW4iLCJfa2V5IiwibWF0Y2giLCJjb21wdXRlTWF0Y2giLCJwcm9wcyIsImhpc3RvcnkiLCJnZXRDaGlsZENvbnRleHQiLCJyb3V0ZXIiLCJjb250ZXh0Iiwicm91dGUiLCJ1cmwiLCJwYXJhbXMiLCJpc0V4YWN0IiwiY29tcG9uZW50V2lsbE1vdW50IiwiX3RoaXMyIiwiX3Byb3BzIiwiY2hpbGRyZW4iLCJSZWFjdCIsIkNoaWxkcmVuIiwiY291bnQiLCJ1bmxpc3RlbiIsImxpc3RlbiIsInNldFN0YXRlIiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIm5leHRQcm9wcyIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVuZGVyIiwib25seSIsIkNvbXBvbmVudCIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsImlzUmVxdWlyZWQiLCJub2RlIiwiY29udGV4dFR5cGVzIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJwYXR0ZXJuQ2FjaGUiLCJjYWNoZUxpbWl0IiwiY2FjaGVDb3VudCIsImNvbXBpbGVQYXRoIiwicGF0dGVybiIsIm9wdGlvbnMiLCJjYWNoZUtleSIsImVuZCIsInN0cmljdCIsInNlbnNpdGl2ZSIsImNhY2hlIiwicmUiLCJjb21waWxlZFBhdHRlcm4iLCJwYXJlbnQiLCJfb3B0aW9ucyIsIl9vcHRpb25zJGV4YWN0IiwiZXhhY3QiLCJfb3B0aW9ucyRzdHJpY3QiLCJfb3B0aW9ucyRzZW5zaXRpdmUiLCJfY29tcGlsZVBhdGgiLCJleGVjIiwidmFsdWVzIiwicmVkdWNlIiwibWVtbyIsImluZGV4IiwiUmVhY3RQcm9wVHlwZXNTZWNyZXQiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJ0ZXh0IiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJjb21wb25lbnROYW1lIiwiZ2V0U3RhY2siLCJ0eXBlU3BlY05hbWUiLCJleCIsInN0YWNrIiwiY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIiLCJwcm9tcHQiLCJzZXRQcm9tcHQiLCJuZXh0UHJvbXB0IiwiY29uZmlybVRyYW5zaXRpb25UbyIsImFjdGlvbiIsImdldFVzZXJDb25maXJtYXRpb24iLCJjYWxsYmFjayIsInJlc3VsdCIsImFwcGVuZExpc3RlbmVyIiwiZm4iLCJpc0FjdGl2ZSIsImxpc3RlbmVyIiwiZmlsdGVyIiwiaXRlbSIsIm5vdGlmeUxpc3RlbmVycyIsImlzRW1wdHlDaGlsZHJlbiIsIl9yZWYiLCJjb21wdXRlZE1hdGNoIiwiY29tcG9uZW50IiwibmV4dENvbnRleHQiLCJfY29udGV4dCRyb3V0ZXIiLCJzdGF0aWNDb250ZXh0IiwiY3JlYXRlRWxlbWVudCIsInN0cmluZyIsImJvb2wiLCJmdW5jIiwib25lT2ZUeXBlIiwic2hhcGUiLCJjb21waWxlR2VuZXJhdG9yIiwiY29tcGlsZWRHZW5lcmF0b3IiLCJwYXRoVG9SZWdleHAiLCJjb21waWxlIiwiZ2VuZXJhdG9yIiwicHJldHR5IiwiZmV0Y2hQb3B1bGFyUmVwb3MiLCJmZXRjaFVzZXIiLCJsYW5ndWFnZSIsImVuY29kZWRVUkkiLCJlbmNvZGVVUkkiLCJ0aGVuIiwiZGF0YSIsImpzb24iLCJyZXBvcyIsIml0ZW1zIiwiY2F0Y2giLCJ3YXJuIiwidXNlciIsImNhblVzZURPTSIsIndpbmRvdyIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwiYXR0YWNoRXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGV0YWNoRXZlbnQiLCJnZXRDb25maXJtYXRpb24iLCJjb25maXJtIiwic3VwcG9ydHNIaXN0b3J5IiwidWEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlIiwic3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2giLCJpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwib2JqIiwiaXNNb2RpZmllZEV2ZW50IiwibWV0YUtleSIsImFsdEtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImhhbmRsZUNsaWNrIiwib25DbGljayIsImRlZmF1bHRQcmV2ZW50ZWQiLCJidXR0b24iLCJwcmV2ZW50RGVmYXVsdCIsIl90aGlzJHByb3BzIiwiaW5uZXJSZWYiLCJocmVmIiwiY3JlYXRlSHJlZiIsInJlZiIsImRlZmF1bHRQcm9wcyIsImluaXRpYWxFbnRyaWVzIiwiaW5pdGlhbEluZGV4IiwibnVtYmVyIiwia2V5TGVuZ3RoIiwiaXNhcnJheSIsInBhcnNlIiwidG9rZW5zVG9GdW5jdGlvbiIsInRva2Vuc1RvUmVnRXhwIiwiUEFUSF9SRUdFWFAiLCJzdHIiLCJ0b2tlbnMiLCJkZWZhdWx0RGVsaW1pdGVyIiwiZGVsaW1pdGVyIiwicmVzIiwibSIsImVzY2FwZWQiLCJvZmZzZXQiLCJuZXh0IiwiY2FwdHVyZSIsImdyb3VwIiwibW9kaWZpZXIiLCJhc3RlcmlzayIsInBhcnRpYWwiLCJyZXBlYXQiLCJvcHRpb25hbCIsImVzY2FwZUdyb3VwIiwiZXNjYXBlU3RyaW5nIiwiZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IiwiY2hhckNvZGVBdCIsInRvU3RyaW5nIiwidG9VcHBlckNhc2UiLCJlbmNvZGVBc3RlcmlzayIsIm1hdGNoZXMiLCJvcHRzIiwiZW5jb2RlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidG9rZW4iLCJzZWdtZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsImoiLCJhdHRhY2hLZXlzIiwiZmxhZ3MiLCJyZWdleHBUb1JlZ2V4cCIsImdyb3VwcyIsImFycmF5VG9SZWdleHAiLCJwYXJ0cyIsInJlZ2V4cCIsInN0cmluZ1RvUmVnZXhwIiwiZW5kc1dpdGhEZWxpbWl0ZXIiLCJlbmFibGUiLCJ1bmJsb2NrIiwiYmxvY2siLCJkaXNhYmxlIiwid2hlbiIsImlzU3RhdGljIiwicGVyZm9ybSIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwicHJldlRvIiwibmV4dFRvIiwiY29tcHV0ZVRvIiwiYWRkQmFzZW5hbWUiLCJiYXNlbmFtZSIsImJhc2UiLCJjcmVhdGVVUkwiLCJzdGF0aWNIYW5kbGVyIiwibWV0aG9kTmFtZSIsImhhbmRsZVB1c2giLCJoYW5kbGVSZXBsYWNlIiwiX3RoaXMkcHJvcHMyIiwiaGFuZGxlTGlzdGVuIiwiaGFuZGxlQmxvY2siLCJnbyIsImdvQmFjayIsImdvRm9yd2FyZCIsImNoaWxkIiwiZWxlbWVudCIsIl9lbGVtZW50JHByb3BzIiwicGF0aFByb3AiLCJjbG9uZUVsZW1lbnQiLCJDIiwid3JhcHBlZENvbXBvbmVudFJlZiIsInJlbWFpbmluZ1Byb3BzIiwicm91dGVDb21wb25lbnRQcm9wcyIsImRpc3BsYXlOYW1lIiwiV3JhcHBlZENvbXBvbmVudCIsIl9fSU5JVElBTF9EQVRBX18iLCJnZXRFbGVtZW50QnlJZCIsInAiLCJxIiwiciIsInQiLCJ1IiwidiIsInciLCJ5IiwieiIsIml0ZXJhdG9yIiwiQSIsImciLCJoIiwiayIsImwiLCJCIiwiaXNNb3VudGVkIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwiZW5xdWV1ZVJlcGxhY2VTdGF0ZSIsImVucXVldWVTZXRTdGF0ZSIsIkQiLCJFIiwicmVmcyIsInVwZGF0ZXIiLCJpc1JlYWN0Q29tcG9uZW50IiwiZm9yY2VVcGRhdGUiLCJGIiwiRyIsIkgiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsIkkiLCJjdXJyZW50IiwiY3VycmVudERpc3BhdGNoZXIiLCJKIiwiSyIsIl9fc2VsZiIsIl9fc291cmNlIiwiTCIsInR5cGUiLCJfb3duZXIiLCJNIiwiTiIsImVzY2FwZSIsIk8iLCJQIiwiUSIsInBvcCIsImtleVByZWZpeCIsIlIiLCJTIiwiVCIsImlzQXJyYXkiLCJkb25lIiwiVSIsIlYiLCJhYSIsIlciLCJiYSIsInJlYWRDb250ZXh0IiwiWCIsInRvQXJyYXkiLCJjcmVhdGVSZWYiLCJQdXJlQ29tcG9uZW50IiwiY3JlYXRlQ29udGV4dCIsIl9jYWxjdWxhdGVDaGFuZ2VkQml0cyIsIl9jdXJyZW50VmFsdWUiLCJfY3VycmVudFZhbHVlMiIsIlByb3ZpZGVyIiwiQ29uc3VtZXIiLCJ1bnN0YWJsZV9yZWFkIiwiX2NvbnRleHQiLCJiaW5kIiwiZm9yd2FyZFJlZiIsIkZyYWdtZW50IiwiU3RyaWN0TW9kZSIsInVuc3RhYmxlX0FzeW5jTW9kZSIsInVuc3RhYmxlX1Byb2ZpbGVyIiwiY3JlYXRlRmFjdG9yeSIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiUmVhY3RDdXJyZW50T3duZXIiLCJZIiwiZGVmYXVsdCIsIloiLCJfYXNzaWduIiwiUmVhY3RWZXJzaW9uIiwiaGFzU3ltYm9sIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfQVNZTkNfTU9ERV9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1BMQUNFSE9MREVSX1RZUEUiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwibWF5YmVJdGVyYXRvciIsImVuYWJsZVN1c3BlbnNlIiwidmFsaWRhdGVGb3JtYXQiLCJsb3dQcmlvcml0eVdhcm5pbmciLCJfbGVuMiIsIl9rZXkyIiwibG93UHJpb3JpdHlXYXJuaW5nJDEiLCJ3YXJuaW5nV2l0aG91dFN0YWNrIiwiX2FyZ3MkbWFwIiwiX21lc3NhZ2UiLCJ3YXJuaW5nV2l0aG91dFN0YWNrJDEiLCJkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQiLCJ3YXJuTm9vcCIsInB1YmxpY0luc3RhbmNlIiwiY2FsbGVyTmFtZSIsIl9jb25zdHJ1Y3RvciIsIndhcm5pbmdLZXkiLCJSZWFjdE5vb3BVcGRhdGVRdWV1ZSIsImNvbXBsZXRlU3RhdGUiLCJwYXJ0aWFsU3RhdGUiLCJlbXB0eU9iamVjdCIsImZyZWV6ZSIsImRlcHJlY2F0ZWRBUElzIiwicmVwbGFjZVN0YXRlIiwiZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nIiwiaW5mbyIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiZm5OYW1lIiwiQ29tcG9uZW50RHVtbXkiLCJwdXJlQ29tcG9uZW50UHJvdG90eXBlIiwicmVmT2JqZWN0Iiwic2VhbCIsIkJFRk9SRV9TTEFTSF9SRSIsImRlc2NyaWJlQ29tcG9uZW50RnJhbWUiLCJvd25lck5hbWUiLCJzb3VyY2VJbmZvIiwiZmlsZU5hbWUiLCJwYXRoQmVmb3JlU2xhc2giLCJmb2xkZXJOYW1lIiwibGluZU51bWJlciIsIlJlc29sdmVkIiwicmVmaW5lUmVzb2x2ZWRUaGVuYWJsZSIsInRoZW5hYmxlIiwiX3JlYWN0U3RhdHVzIiwiX3JlYWN0UmVzdWx0IiwiZ2V0Q29tcG9uZW50TmFtZSIsInRhZyIsInJlbmRlckZuIiwiZnVuY3Rpb25OYW1lIiwicmVzb2x2ZWRUaGVuYWJsZSIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50IiwiZ2V0Q3VycmVudFN0YWNrIiwiZ2V0U3RhY2tBZGRlbmR1bSIsIm93bmVyIiwiX3NvdXJjZSIsImltcGwiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIlJlYWN0Q29tcG9uZW50VHJlZUhvb2siLCJ3YXJuaW5nJDEiLCJSRVNFUlZFRF9QUk9QUyIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJoYXNWYWxpZFJlZiIsImNvbmZpZyIsImdldHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImlzUmVhY3RXYXJuaW5nIiwiaGFzVmFsaWRLZXkiLCJkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ0tleSIsImRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nUmVmIiwiUmVhY3RFbGVtZW50IiwiX3N0b3JlIiwicHJvcE5hbWUiLCJjaGlsZHJlbkxlbmd0aCIsImNoaWxkQXJyYXkiLCJjbG9uZUFuZFJlcGxhY2VLZXkiLCJvbGRFbGVtZW50IiwibmV3S2V5IiwibmV3RWxlbWVudCIsIl9zZWxmIiwiU0VQQVJBVE9SIiwiU1VCU0VQQVJBVE9SIiwiZXNjYXBlUmVnZXgiLCJlc2NhcGVyTG9va3VwIiwiZXNjYXBlZFN0cmluZyIsImRpZFdhcm5BYm91dE1hcHMiLCJ1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCIsImVzY2FwZVVzZXJQcm92aWRlZEtleSIsIlBPT0xfU0laRSIsInRyYXZlcnNlQ29udGV4dFBvb2wiLCJnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQiLCJtYXBSZXN1bHQiLCJtYXBGdW5jdGlvbiIsIm1hcENvbnRleHQiLCJ0cmF2ZXJzZUNvbnRleHQiLCJyZWxlYXNlVHJhdmVyc2VDb250ZXh0IiwidHJhdmVyc2VBbGxDaGlsZHJlbkltcGwiLCJuYW1lU29GYXIiLCJpbnZva2VDYWxsYmFjayIsImdldENvbXBvbmVudEtleSIsIm5leHROYW1lIiwic3VidHJlZUNvdW50IiwibmV4dE5hbWVQcmVmaXgiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJpaSIsImFkZGVuZHVtIiwiY2hpbGRyZW5TdHJpbmciLCJ0cmF2ZXJzZUFsbENoaWxkcmVuIiwiZm9yRWFjaFNpbmdsZUNoaWxkIiwiYm9va0tlZXBpbmciLCJmb3JFYWNoQ2hpbGRyZW4iLCJmb3JFYWNoRnVuYyIsImZvckVhY2hDb250ZXh0IiwibWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCIsImNoaWxkS2V5IiwibWFwcGVkQ2hpbGQiLCJtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsIiwiZXNjYXBlZFByZWZpeCIsIm1hcENoaWxkcmVuIiwiY291bnRDaGlsZHJlbiIsIm9ubHlDaGlsZCIsIm9ic2VydmVkQml0cyIsImRpc3BhdGNoZXIiLCJkZWZhdWx0VmFsdWUiLCJjYWxjdWxhdGVDaGFuZ2VkQml0cyIsIl9jdXJyZW50UmVuZGVyZXIiLCJfY3VycmVudFJlbmRlcmVyMiIsImxhenkiLCJjdG9yIiwicmVzb2x2ZSIsInJlamVjdCIsImlzVmFsaWRFbGVtZW50VHlwZSIsInByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duIiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJlbGVtZW50UHJvcHMiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsInZhbGlkYXRlUHJvcFR5cGVzIiwiZ2V0RGVmYXVsdFByb3BzIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJmcmFnbWVudCIsImNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiIsInZhbGlkVHlwZSIsInR5cGVTdHJpbmciLCJjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24iLCJ2YWxpZGF0ZWRGYWN0b3J5IiwiY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24iLCJQbGFjZWhvbGRlciIsIlJlYWN0JDIiLCJSZWFjdCQzIiwicmVhY3QiLCJjaGVja0RDRSIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImNhIiwiZGEiLCJvbkVycm9yIiwiZWEiLCJmYSIsImhhIiwiaWEiLCJqYSIsImthIiwibGEiLCJtYSIsIm5hIiwib2EiLCJwYSIsImV4dHJhY3RFdmVudHMiLCJldmVudFR5cGVzIiwicWEiLCJwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyIsInJhIiwicmVnaXN0cmF0aW9uTmFtZSIsInNhIiwidGEiLCJkZXBlbmRlbmNpZXMiLCJ2YSIsIndhIiwieGEiLCJjdXJyZW50VGFyZ2V0IiwieWEiLCJ6YSIsIkFhIiwiQmEiLCJfZGlzcGF0Y2hMaXN0ZW5lcnMiLCJfZGlzcGF0Y2hJbnN0YW5jZXMiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImlzUGVyc2lzdGVudCIsInJlbGVhc2UiLCJDYSIsIkRhIiwiRWEiLCJpbmplY3RFdmVudFBsdWdpbk9yZGVyIiwiaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lIiwiRmEiLCJzdGF0ZU5vZGUiLCJkaXNhYmxlZCIsIkdhIiwiSGEiLCJNYXRoIiwicmFuZG9tIiwiSWEiLCJKYSIsIkthIiwicGFyZW50Tm9kZSIsIkxhIiwiTWEiLCJOYSIsIk9hIiwicmV0dXJuIiwiUGEiLCJkaXNwYXRjaENvbmZpZyIsIlFhIiwiX3RhcmdldEluc3QiLCJSYSIsIlRhIiwiVWEiLCJWYSIsIldhIiwidG9Mb3dlckNhc2UiLCJZYSIsImFuaW1hdGlvbmVuZCIsImFuaW1hdGlvbml0ZXJhdGlvbiIsImFuaW1hdGlvbnN0YXJ0IiwidHJhbnNpdGlvbmVuZCIsIlphIiwiJGEiLCJzdHlsZSIsImFuaW1hdGlvbiIsInRyYW5zaXRpb24iLCJhYiIsImJiIiwiY2IiLCJkYiIsImViIiwiZmIiLCJnYiIsImhiIiwiaWIiLCJqYiIsInRleHRDb250ZW50Iiwia2IiLCJsYiIsIm5hdGl2ZUV2ZW50IiwiSW50ZXJmYWNlIiwiaXNEZWZhdWx0UHJldmVudGVkIiwicmV0dXJuVmFsdWUiLCJzdG9wUHJvcGFnYXRpb24iLCJjYW5jZWxCdWJibGUiLCJwZXJzaXN0IiwiZGVzdHJ1Y3RvciIsImV2ZW50UGhhc2UiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInRpbWVTdGFtcCIsIkRhdGUiLCJub3ciLCJpc1RydXN0ZWQiLCJleHRlbmQiLCJtYiIsIm5iIiwiZXZlbnRQb29sIiwib2IiLCJnZXRQb29sZWQiLCJwYiIsInFiIiwicmIiLCJzYiIsInRiIiwiZG9jdW1lbnRNb2RlIiwidWIiLCJ2YiIsIndiIiwieGIiLCJiZWZvcmVJbnB1dCIsImJ1YmJsZWQiLCJjYXB0dXJlZCIsImNvbXBvc2l0aW9uRW5kIiwiY29tcG9zaXRpb25TdGFydCIsImNvbXBvc2l0aW9uVXBkYXRlIiwieWIiLCJ6YiIsImtleUNvZGUiLCJBYiIsImRldGFpbCIsIkJiIiwiQ2IiLCJ3aGljaCIsIkRiIiwiY2hhciIsImxvY2FsZSIsIkViIiwiRmIiLCJHYiIsIkhiIiwiSWIiLCJKYiIsIktiIiwiTGIiLCJNYiIsIk5iIiwiT2IiLCJQYiIsIlFiIiwiY29sb3IiLCJkYXRlIiwiZGF0ZXRpbWUiLCJlbWFpbCIsIm1vbnRoIiwicGFzc3dvcmQiLCJyYW5nZSIsInRlbCIsInRpbWUiLCJ3ZWVrIiwiUmIiLCJub2RlTmFtZSIsIlNiIiwic3JjRWxlbWVudCIsImNvcnJlc3BvbmRpbmdVc2VFbGVtZW50Iiwibm9kZVR5cGUiLCJUYiIsInNldEF0dHJpYnV0ZSIsIlViIiwiVmIiLCJzZXQiLCJnZXRWYWx1ZSIsInNldFZhbHVlIiwic3RvcFRyYWNraW5nIiwiX3ZhbHVlVHJhY2tlciIsIldiIiwiWGIiLCJjaGVja2VkIiwiWWIiLCJaYiIsIiRiIiwiYWMiLCJiYyIsImNjIiwiZGMiLCJlYyIsImZjIiwiZ2MiLCJoYyIsImljIiwiamMiLCJrYyIsImxjIiwibWMiLCJfZGVidWdPd25lciIsIl9kZWJ1Z1NvdXJjZSIsIm5jIiwicGMiLCJxYyIsInJjIiwic2MiLCJ0YyIsImFjY2VwdHNCb29sZWFucyIsInVjIiwiaXNOYU4iLCJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlTmFtZXNwYWNlIiwibXVzdFVzZVByb3BlcnR5IiwicHJvcGVydHlOYW1lIiwidmMiLCJ3YyIsInRhYkluZGV4IiwieGMiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGVOUyIsInljIiwiemMiLCJkZWZhdWx0Q2hlY2tlZCIsIl93cmFwcGVyU3RhdGUiLCJpbml0aWFsQ2hlY2tlZCIsIkJjIiwiaW5pdGlhbFZhbHVlIiwiY29udHJvbGxlZCIsIkNjIiwiRGMiLCJFYyIsIkZjIiwib3duZXJEb2N1bWVudCIsImFjdGl2ZUVsZW1lbnQiLCJHYyIsImNoYW5nZSIsIkhjIiwiSWMiLCJKYyIsIktjIiwiTGMiLCJNYyIsIk5jIiwiT2MiLCJQYyIsIlFjIiwiUmMiLCJTYyIsIlRjIiwiVWMiLCJfaXNJbnB1dEV2ZW50U3VwcG9ydGVkIiwiVmMiLCJ2aWV3IiwiV2MiLCJBbHQiLCJDb250cm9sIiwiTWV0YSIsIlNoaWZ0IiwiWGMiLCJnZXRNb2RpZmllclN0YXRlIiwiWWMiLCJaYyIsIiRjIiwiYWQiLCJiZCIsImNkIiwic2NyZWVuWCIsInNjcmVlblkiLCJjbGllbnRYIiwiY2xpZW50WSIsInBhZ2VYIiwicGFnZVkiLCJidXR0b25zIiwicmVsYXRlZFRhcmdldCIsImZyb21FbGVtZW50IiwidG9FbGVtZW50IiwibW92ZW1lbnRYIiwibW92ZW1lbnRZIiwiZGQiLCJwb2ludGVySWQiLCJ3aWR0aCIsImhlaWdodCIsInByZXNzdXJlIiwidGFuZ2VudGlhbFByZXNzdXJlIiwidGlsdFgiLCJ0aWx0WSIsInR3aXN0IiwicG9pbnRlclR5cGUiLCJpc1ByaW1hcnkiLCJlZCIsIm1vdXNlRW50ZXIiLCJtb3VzZUxlYXZlIiwicG9pbnRlckVudGVyIiwicG9pbnRlckxlYXZlIiwiZmQiLCJkZWZhdWx0VmlldyIsInBhcmVudFdpbmRvdyIsImFsdGVybmF0ZSIsImdkIiwiaGQiLCJpZCIsImpkIiwiZWZmZWN0VGFnIiwia2QiLCJsZCIsInNpYmxpbmciLCJtZCIsIm5kIiwiYW5pbWF0aW9uTmFtZSIsImVsYXBzZWRUaW1lIiwicHNldWRvRWxlbWVudCIsIm9kIiwiY2xpcGJvYXJkRGF0YSIsInBkIiwicWQiLCJjaGFyQ29kZSIsInJkIiwiRXNjIiwiU3BhY2ViYXIiLCJMZWZ0IiwiVXAiLCJSaWdodCIsIkRvd24iLCJEZWwiLCJXaW4iLCJNZW51IiwiQXBwcyIsIlNjcm9sbCIsIk1velByaW50YWJsZUtleSIsInNkIiwidGQiLCJ1ZCIsImRhdGFUcmFuc2ZlciIsInZkIiwidG91Y2hlcyIsInRhcmdldFRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsIndkIiwieGQiLCJkZWx0YVgiLCJ3aGVlbERlbHRhWCIsImRlbHRhWSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YSIsImRlbHRhWiIsImRlbHRhTW9kZSIsInlkIiwiemQiLCJBZCIsIkJkIiwiaXNJbnRlcmFjdGl2ZSIsIkNkIiwiaXNJbnRlcmFjdGl2ZVRvcExldmVsRXZlbnRUeXBlIiwiRGQiLCJFZCIsIkZkIiwidGFyZ2V0SW5zdCIsImFuY2VzdG9ycyIsImNvbnRhaW5lckluZm8iLCJ0b3BMZXZlbFR5cGUiLCJHZCIsIkhkIiwiSWQiLCJKZCIsIktkIiwiTGQiLCJNZCIsIk5kIiwiT2QiLCJib2R5IiwiUWQiLCJmaXJzdENoaWxkIiwiUmQiLCJuZXh0U2libGluZyIsIlNkIiwiY29udGFpbnMiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsIlRkIiwiSFRNTElGcmFtZUVsZW1lbnQiLCJjb250ZW50RG9jdW1lbnQiLCJVZCIsImNvbnRlbnRFZGl0YWJsZSIsIlZkIiwiV2QiLCJzZWxlY3QiLCJYZCIsIllkIiwiWmQiLCIkZCIsImFlIiwic3RhcnQiLCJzZWxlY3Rpb25TdGFydCIsInNlbGVjdGlvbkVuZCIsImdldFNlbGVjdGlvbiIsImFuY2hvck5vZGUiLCJhbmNob3JPZmZzZXQiLCJmb2N1c05vZGUiLCJmb2N1c09mZnNldCIsImJlIiwib25TZWxlY3QiLCJTaW1wbGVFdmVudFBsdWdpbiIsIkVudGVyTGVhdmVFdmVudFBsdWdpbiIsIkNoYW5nZUV2ZW50UGx1Z2luIiwiU2VsZWN0RXZlbnRQbHVnaW4iLCJCZWZvcmVJbnB1dEV2ZW50UGx1Z2luIiwiY2UiLCJkZSIsImVlIiwic2VsZWN0ZWQiLCJkZWZhdWx0U2VsZWN0ZWQiLCJmZSIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiZ2UiLCJoZSIsImllIiwiamUiLCJodG1sIiwibWF0aG1sIiwic3ZnIiwia2UiLCJsZSIsIm1lIiwibmUiLCJNU0FwcCIsImV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uIiwibmFtZXNwYWNlVVJJIiwiaW5uZXJIVE1MIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsIm9lIiwibGFzdENoaWxkIiwibm9kZVZhbHVlIiwicGUiLCJhbmltYXRpb25JdGVyYXRpb25Db3VudCIsImJvcmRlckltYWdlT3V0c2V0IiwiYm9yZGVySW1hZ2VTbGljZSIsImJvcmRlckltYWdlV2lkdGgiLCJib3hGbGV4IiwiYm94RmxleEdyb3VwIiwiYm94T3JkaW5hbEdyb3VwIiwiY29sdW1uQ291bnQiLCJjb2x1bW5zIiwiZmxleCIsImZsZXhHcm93IiwiZmxleFBvc2l0aXZlIiwiZmxleFNocmluayIsImZsZXhOZWdhdGl2ZSIsImZsZXhPcmRlciIsImdyaWRBcmVhIiwiZ3JpZFJvdyIsImdyaWRSb3dFbmQiLCJncmlkUm93U3BhbiIsImdyaWRSb3dTdGFydCIsImdyaWRDb2x1bW4iLCJncmlkQ29sdW1uRW5kIiwiZ3JpZENvbHVtblNwYW4iLCJncmlkQ29sdW1uU3RhcnQiLCJmb250V2VpZ2h0IiwibGluZUNsYW1wIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsImZpbGxPcGFjaXR5IiwiZmxvb2RPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlTWl0ZXJsaW1pdCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsInFlIiwic3Vic3RyaW5nIiwidHJpbSIsInNldFByb3BlcnR5Iiwic2UiLCJtZW51aXRlbSIsImFyZWEiLCJiciIsImNvbCIsImVtYmVkIiwiaHIiLCJpbWciLCJpbnB1dCIsImtleWdlbiIsImxpbmsiLCJtZXRhIiwicGFyYW0iLCJ0cmFjayIsIndiciIsInRlIiwidWUiLCJpcyIsInZlIiwiYmx1ciIsImZvY3VzIiwid2UiLCJ4ZSIsInllIiwiemUiLCJhdXRvRm9jdXMiLCJBZSIsIl9faHRtbCIsIkJlIiwiQ2UiLCJTZXQiLCJEZSIsIkVlIiwiRmUiLCJHZSIsIkhlIiwiX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0IiwiSWUiLCJKZSIsIktlIiwiTGUiLCJNZSIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IiwiTmUiLCJPZSIsIlBlIiwiUWUiLCJSZSIsImlzRGlzYWJsZWQiLCJzdXBwb3J0c0ZpYmVyIiwiaW5qZWN0Iiwib25Db21taXRGaWJlclJvb3QiLCJvbkNvbW1pdEZpYmVyVW5tb3VudCIsIlNlIiwicGVuZGluZ1Byb3BzIiwiZmlyc3RDb250ZXh0RGVwZW5kZW5jeSIsIm1lbW9pemVkU3RhdGUiLCJ1cGRhdGVRdWV1ZSIsIm1lbW9pemVkUHJvcHMiLCJtb2RlIiwibGFzdEVmZmVjdCIsImZpcnN0RWZmZWN0IiwibmV4dEVmZmVjdCIsImNoaWxkRXhwaXJhdGlvblRpbWUiLCJleHBpcmF0aW9uVGltZSIsIlRlIiwiVWUiLCJWZSIsIldlIiwiWGUiLCJZZSIsInBlbmRpbmdDaGlsZHJlbiIsImltcGxlbWVudGF0aW9uIiwiWmUiLCJkaWRFcnJvciIsImVhcmxpZXN0UGVuZGluZ1RpbWUiLCJsYXRlc3RQZW5kaW5nVGltZSIsIiRlIiwiZWFybGllc3RTdXNwZW5kZWRUaW1lIiwibGF0ZXN0U3VzcGVuZGVkVGltZSIsImxhdGVzdFBpbmdlZFRpbWUiLCJuZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbiIsImFmIiwiYmYiLCJiYXNlU3RhdGUiLCJmaXJzdFVwZGF0ZSIsImxhc3RVcGRhdGUiLCJmaXJzdENhcHR1cmVkVXBkYXRlIiwibGFzdENhcHR1cmVkVXBkYXRlIiwiZmlyc3RDYXB0dXJlZEVmZmVjdCIsImxhc3RDYXB0dXJlZEVmZmVjdCIsImNmIiwiZGYiLCJwYXlsb2FkIiwiZWYiLCJmZiIsImdmIiwiaGYiLCJqZiIsImtmIiwibGYiLCJtZiIsIm5mIiwib2YiLCJwZiIsInFmIiwicmYiLCJzZiIsInRmIiwidWYiLCJ2ZiIsIndmIiwieGYiLCJ5ZiIsInpmIiwiQWYiLCJkb2N1bWVudEVsZW1lbnQiLCJ0YWdOYW1lIiwiQmYiLCJDZiIsIkRmIiwiRWYiLCJGZiIsIkpmIiwiX3JlYWN0SW50ZXJuYWxGaWJlciIsIkdmIiwiSGYiLCJJZiIsIktmIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiTGYiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIk1mIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IiwiTmYiLCJPZiIsIl9zdHJpbmdSZWYiLCJQZiIsIlFmIiwiTWFwIiwiZGVsZXRlIiwiUmYiLCJTZiIsIlRmIiwiVWYiLCJWZiIsIldmIiwiWGYiLCJZZiIsIlpmIiwiJGYiLCJhZyIsImJnIiwiY2ciLCJkZyIsImVnIiwiZmciLCJnZyIsImhnIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiaWciLCJqZyIsInBlbmRpbmdDb250ZXh0IiwibmciLCJvZyIsInBnIiwiaHlkcmF0ZSIsImhpZGRlbiIsInVuc3RhYmxlX29ic2VydmVkQml0cyIsInFnIiwicmciLCJzZyIsInRnIiwib25jbGljayIsInVnIiwidmciLCJ3ZyIsInhnIiwieWciLCJ6ZyIsIkFnIiwiaW5zZXJ0QmVmb3JlIiwiQmciLCJ3YXNNdWx0aXBsZSIsIm11bHRpcGxlIiwiQ2ciLCJEZyIsIkVnIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJGZyIsImFkZCIsImNvbXBvbmVudFN0YWNrIiwiR2ciLCJIZyIsIklnIiwiSmciLCJLZyIsIkxnIiwiTWciLCJOZyIsIk9nIiwiUGciLCJRZyIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZVRleHROb2RlIiwiUmciLCJTZyIsInBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZSIsIlRnIiwiaGFzIiwiZmluaXNoZWRXb3JrIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoIiwiVWciLCJWZyIsIm5leHRTY2hlZHVsZWRSb290IiwiV2ciLCJYZyIsIllnIiwiWmciLCJhaCIsIiRnIiwiYmgiLCJjaCIsImRoIiwiZWgiLCJmaCIsImdoIiwiaGgiLCJpaCIsImpoIiwidW5zdGFibGVfbm93Iiwia2giLCJsaCIsIm1oIiwibmgiLCJvaCIsInVuc3RhYmxlX2NhbmNlbFNjaGVkdWxlZFdvcmsiLCJ1bnN0YWJsZV9zY2hlZHVsZVdvcmsiLCJwaCIsInFoIiwiZGlkVGltZW91dCIsIl9vbkNvbXBsZXRlIiwicmgiLCJmaXJzdEJhdGNoIiwiX2V4cGlyYXRpb25UaW1lIiwiX2RlZmVyIiwicmFuZ2VDb3VudCIsIlhhIiwiZm9jdXNlZEVsZW0iLCJzZWxlY3Rpb25SYW5nZSIsInloIiwiX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUiLCJtaW4iLCJjcmVhdGVSYW5nZSIsInNldFN0YXJ0IiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJzZXRFbmQiLCJsZWZ0Iiwic2Nyb2xsTGVmdCIsInRvcCIsInNjcm9sbFRvcCIsIlNhIiwib2MiLCJJaCIsIkpoIiwia2ciLCJsZyIsIktoIiwiQWMiLCJtZyIsIlBkIiwiTGgiLCJ0aW1lUmVtYWluaW5nIiwic2giLCJ0aCIsInVoIiwidmgiLCJ3aCIsInhoIiwiemgiLCJBaCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JtIiwiQmgiLCJfcm9vdCIsIl9jYWxsYmFja3MiLCJfbmV4dCIsIl9oYXNDaGlsZHJlbiIsIl9kaWRDb21wbGV0ZSIsIl9jaGlsZHJlbiIsIl9pbnRlcm5hbFJvb3QiLCJDaCIsIl9vbkNvbW1pdCIsImNvbW1pdCIsIl9kaWRDb21taXQiLCJEaCIsInRpbWVvdXRIYW5kbGUiLCJ1bm1vdW50IiwibGVnYWN5X3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwiY3JlYXRlQmF0Y2giLCJFaCIsIkZoIiwiaGFzQXR0cmlidXRlIiwiR2giLCJfcmVhY3RSb290Q29udGFpbmVyIiwiSGgiLCJNaCIsImNyZWF0ZVBvcnRhbCIsImZpbmRET01Ob2RlIiwidW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwidW5zdGFibGVfY3JlYXRlUG9ydGFsIiwidW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJ1bnN0YWJsZV9pbnRlcmFjdGl2ZVVwZGF0ZXMiLCJmbHVzaFN5bmMiLCJ1bnN0YWJsZV9mbHVzaENvbnRyb2xsZWQiLCJFdmVudHMiLCJ1bnN0YWJsZV9jcmVhdGVSb290IiwiZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJmaW5kSG9zdEluc3RhbmNlQnlGaWJlciIsImJ1bmRsZVR5cGUiLCJyZW5kZXJlclBhY2thZ2VOYW1lIiwiTmgiLCJPaCIsInBlcmZvcm1hbmNlIiwidGltZXNPdXRBdCIsInByZXZpb3VzIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJfc2NoZWRNb2NrIiwicG9zdE1lc3NhZ2UiLCJERUZFUlJFRF9USU1FT1VUIiwiZmlyc3RDYWxsYmFja05vZGUiLCJpc1BlcmZvcm1pbmdXb3JrIiwiaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQiLCJoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdyIsInJlbWFpbmluZyIsImdldEZyYW1lRGVhZGxpbmUiLCJkZWFkbGluZU9iamVjdCIsImVuc3VyZUhvc3RDYWxsYmFja0lzU2NoZWR1bGVkIiwiY2FuY2VsQ2FsbGJhY2siLCJyZXF1ZXN0Q2FsbGJhY2siLCJmbHVzaFdvcmsiLCJmbHVzaEZpcnN0Q2FsbGJhY2siLCJmbHVzaGVkTm9kZSIsImN1cnJlbnRUaW1lIiwibmV3Tm9kZSIsImNhbGxiYWNrTm9kZSIsImxvY2FsRGF0ZSIsImxvY2FsU2V0VGltZW91dCIsImxvY2FsQ2xlYXJUaW1lb3V0IiwibG9jYWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJsb2NhbENhbmNlbEFuaW1hdGlvbkZyYW1lIiwiQU5JTUFUSU9OX0ZSQU1FX1RJTUVPVVQiLCJyQUZJRCIsInJBRlRpbWVvdXRJRCIsInJlcXVlc3RBbmltYXRpb25GcmFtZVdpdGhUaW1lb3V0IiwidGltZXN0YW1wIiwiUGVyZm9ybWFuY2UiLCJ0aW1lb3V0SUQiLCJhYnNvbHV0ZVRpbWVvdXQiLCJzY2hlZHVsZWRDYWxsYmFjayIsImlzSWRsZVNjaGVkdWxlZCIsInRpbWVvdXRUaW1lIiwiaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCIsImlzUGVyZm9ybWluZ0lkbGVXb3JrIiwiZnJhbWVEZWFkbGluZSIsInByZXZpb3VzRnJhbWVUaW1lIiwiYWN0aXZlRnJhbWVUaW1lIiwibWVzc2FnZUtleSIsImlkbGVUaWNrIiwiYW5pbWF0aW9uVGljayIsInJhZlRpbWUiLCJuZXh0RnJhbWVUaW1lIiwic2NoZWR1bGUiLCJ0cmFjaW5nIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCIsImZ1bmNBcmdzIiwiZGlzcGF0Y2hFdmVudCIsImNyZWF0ZUV2ZW50IiwiZmFrZU5vZGUiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYiLCJldnQiLCJ3aW5kb3dFdmVudCIsImNhbGxDYWxsYmFjayIsImV2dFR5cGUiLCJkaWRTZXRFcnJvciIsImlzQ3Jvc3NPcmlnaW5FcnJvciIsImhhbmRsZVdpbmRvd0Vycm9yIiwiY29sbm8iLCJsaW5lbm8iLCJfc3VwcHJlc3NMb2dnaW5nIiwiaW5uZXIiLCJpbml0RXZlbnQiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEiLCJoYXNFcnJvciIsImNhdWdodEVycm9yIiwiaGFzUmV0aHJvd0Vycm9yIiwicmV0aHJvd0Vycm9yIiwicmVwb3J0ZXIiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2siLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IiLCJjbGVhckNhdWdodEVycm9yIiwicmV0aHJvd0NhdWdodEVycm9yIiwiaGFzQ2F1Z2h0RXJyb3IiLCJldmVudFBsdWdpbk9yZGVyIiwibmFtZXNUb1BsdWdpbnMiLCJyZWNvbXB1dGVQbHVnaW5PcmRlcmluZyIsInBsdWdpbk5hbWUiLCJwbHVnaW5Nb2R1bGUiLCJwbHVnaW5JbmRleCIsInBsdWdpbnMiLCJwdWJsaXNoZWRFdmVudHMiLCJldmVudE5hbWUiLCJwdWJsaXNoRXZlbnRGb3JQbHVnaW4iLCJldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MiLCJwaGFzZU5hbWUiLCJwaGFzZWRSZWdpc3RyYXRpb25OYW1lIiwicHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUiLCJyZWdpc3RyYXRpb25OYW1lTW9kdWxlcyIsInJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMiLCJsb3dlckNhc2VkTmFtZSIsInBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMiLCJvbmRibGNsaWNrIiwiaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyIiwiaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyIsImlzT3JkZXJpbmdEaXJ0eSIsImdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUiLCJnZXRJbnN0YW5jZUZyb21Ob2RlIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZSIsInNldENvbXBvbmVudFRyZWUiLCJnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlSW1wbCIsImdldEluc3RhbmNlRnJvbU5vZGVJbXBsIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZUltcGwiLCJ2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyIsImRpc3BhdGNoTGlzdGVuZXJzIiwiZGlzcGF0Y2hJbnN0YW5jZXMiLCJsaXN0ZW5lcnNJc0FyciIsImxpc3RlbmVyc0xlbiIsImluc3RhbmNlc0lzQXJyIiwiaW5zdGFuY2VzTGVuIiwiZXhlY3V0ZURpc3BhdGNoIiwic2ltdWxhdGVkIiwiaW5zdCIsImV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlciIsImFjY3VtdWxhdGVJbnRvIiwiZm9yRWFjaEFjY3VtdWxhdGVkIiwiYXJyIiwic2NvcGUiLCJldmVudFF1ZXVlIiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlIiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkIiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwiLCJzaG91bGRQcmV2ZW50TW91c2VFdmVudCIsImluamVjdGlvbiIsImdldExpc3RlbmVyIiwibmF0aXZlRXZlbnRUYXJnZXQiLCJldmVudHMiLCJwb3NzaWJsZVBsdWdpbiIsImV4dHJhY3RlZEV2ZW50cyIsInJ1bkV2ZW50c0luQmF0Y2giLCJwcm9jZXNzaW5nRXZlbnRRdWV1ZSIsInJ1bkV4dHJhY3RlZEV2ZW50c0luQmF0Y2giLCJGdW5jdGlvbmFsQ29tcG9uZW50IiwiRnVuY3Rpb25hbENvbXBvbmVudExhenkiLCJDbGFzc0NvbXBvbmVudCIsIkNsYXNzQ29tcG9uZW50TGF6eSIsIkluZGV0ZXJtaW5hdGVDb21wb25lbnQiLCJIb3N0Um9vdCIsIkhvc3RQb3J0YWwiLCJIb3N0Q29tcG9uZW50IiwiSG9zdFRleHQiLCJNb2RlIiwiQ29udGV4dENvbnN1bWVyIiwiQ29udGV4dFByb3ZpZGVyIiwiRm9yd2FyZFJlZiIsIkZvcndhcmRSZWZMYXp5IiwiUHJvZmlsZXIiLCJQbGFjZWhvbGRlckNvbXBvbmVudCIsInJhbmRvbUtleSIsImludGVybmFsSW5zdGFuY2VLZXkiLCJpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXkiLCJwcmVjYWNoZUZpYmVyTm9kZSIsImhvc3RJbnN0IiwiZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUiLCJnZXRJbnN0YW5jZUZyb21Ob2RlJDEiLCJnZXROb2RlRnJvbUluc3RhbmNlJDEiLCJnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEiLCJ1cGRhdGVGaWJlclByb3BzIiwiZ2V0UGFyZW50IiwiZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IiLCJpbnN0QSIsImluc3RCIiwiZGVwdGhBIiwidGVtcEEiLCJkZXB0aEIiLCJ0ZW1wQiIsImRlcHRoIiwidHJhdmVyc2VUd29QaGFzZSIsImFyZyIsInRyYXZlcnNlRW50ZXJMZWF2ZSIsImFyZ0Zyb20iLCJhcmdUbyIsImNvbW1vbiIsInBhdGhGcm9tIiwicGF0aFRvIiwiX2FsdGVybmF0ZSIsIl9pIiwibGlzdGVuZXJBdFBoYXNlIiwicHJvcGFnYXRpb25QaGFzZSIsImFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMiLCJwaGFzZSIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUiLCJhY2N1bXVsYXRlRGlzcGF0Y2hlcyIsImlnbm9yZWREaXJlY3Rpb24iLCJhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMiLCJhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMiLCJsZWF2ZSIsImVudGVyIiwiYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMiLCJ1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUiLCJ1bnNhZmVDYXN0RE9NVG9wTGV2ZWxUeXBlVG9TdHJpbmciLCJtYWtlUHJlZml4TWFwIiwic3R5bGVQcm9wIiwicHJlZml4ZXMiLCJ2ZW5kb3JQcmVmaXhlcyIsInByZWZpeGVkRXZlbnROYW1lcyIsImdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lIiwicHJlZml4TWFwIiwiVE9QX0FCT1JUIiwiVE9QX0FOSU1BVElPTl9FTkQiLCJUT1BfQU5JTUFUSU9OX0lURVJBVElPTiIsIlRPUF9BTklNQVRJT05fU1RBUlQiLCJUT1BfQkxVUiIsIlRPUF9DQU5fUExBWSIsIlRPUF9DQU5fUExBWV9USFJPVUdIIiwiVE9QX0NBTkNFTCIsIlRPUF9DSEFOR0UiLCJUT1BfQ0xJQ0siLCJUT1BfQ0xPU0UiLCJUT1BfQ09NUE9TSVRJT05fRU5EIiwiVE9QX0NPTVBPU0lUSU9OX1NUQVJUIiwiVE9QX0NPTVBPU0lUSU9OX1VQREFURSIsIlRPUF9DT05URVhUX01FTlUiLCJUT1BfQ09QWSIsIlRPUF9DVVQiLCJUT1BfRE9VQkxFX0NMSUNLIiwiVE9QX0FVWF9DTElDSyIsIlRPUF9EUkFHIiwiVE9QX0RSQUdfRU5EIiwiVE9QX0RSQUdfRU5URVIiLCJUT1BfRFJBR19FWElUIiwiVE9QX0RSQUdfTEVBVkUiLCJUT1BfRFJBR19PVkVSIiwiVE9QX0RSQUdfU1RBUlQiLCJUT1BfRFJPUCIsIlRPUF9EVVJBVElPTl9DSEFOR0UiLCJUT1BfRU1QVElFRCIsIlRPUF9FTkNSWVBURUQiLCJUT1BfRU5ERUQiLCJUT1BfRVJST1IiLCJUT1BfRk9DVVMiLCJUT1BfR09UX1BPSU5URVJfQ0FQVFVSRSIsIlRPUF9JTlBVVCIsIlRPUF9JTlZBTElEIiwiVE9QX0tFWV9ET1dOIiwiVE9QX0tFWV9QUkVTUyIsIlRPUF9LRVlfVVAiLCJUT1BfTE9BRCIsIlRPUF9MT0FEX1NUQVJUIiwiVE9QX0xPQURFRF9EQVRBIiwiVE9QX0xPQURFRF9NRVRBREFUQSIsIlRPUF9MT1NUX1BPSU5URVJfQ0FQVFVSRSIsIlRPUF9NT1VTRV9ET1dOIiwiVE9QX01PVVNFX01PVkUiLCJUT1BfTU9VU0VfT1VUIiwiVE9QX01PVVNFX09WRVIiLCJUT1BfTU9VU0VfVVAiLCJUT1BfUEFTVEUiLCJUT1BfUEFVU0UiLCJUT1BfUExBWSIsIlRPUF9QTEFZSU5HIiwiVE9QX1BPSU5URVJfQ0FOQ0VMIiwiVE9QX1BPSU5URVJfRE9XTiIsIlRPUF9QT0lOVEVSX01PVkUiLCJUT1BfUE9JTlRFUl9PVVQiLCJUT1BfUE9JTlRFUl9PVkVSIiwiVE9QX1BPSU5URVJfVVAiLCJUT1BfUFJPR1JFU1MiLCJUT1BfUkFURV9DSEFOR0UiLCJUT1BfUkVTRVQiLCJUT1BfU0NST0xMIiwiVE9QX1NFRUtFRCIsIlRPUF9TRUVLSU5HIiwiVE9QX1NFTEVDVElPTl9DSEFOR0UiLCJUT1BfU1RBTExFRCIsIlRPUF9TVUJNSVQiLCJUT1BfU1VTUEVORCIsIlRPUF9URVhUX0lOUFVUIiwiVE9QX1RJTUVfVVBEQVRFIiwiVE9QX1RPR0dMRSIsIlRPUF9UT1VDSF9DQU5DRUwiLCJUT1BfVE9VQ0hfRU5EIiwiVE9QX1RPVUNIX01PVkUiLCJUT1BfVE9VQ0hfU1RBUlQiLCJUT1BfVFJBTlNJVElPTl9FTkQiLCJUT1BfVk9MVU1FX0NIQU5HRSIsIlRPUF9XQUlUSU5HIiwiVE9QX1dIRUVMIiwibWVkaWFFdmVudFR5cGVzIiwiZ2V0UmF3RXZlbnROYW1lIiwicm9vdCIsInN0YXJ0VGV4dCIsImZhbGxiYWNrVGV4dCIsImluaXRpYWxpemUiLCJnZXRUZXh0IiwicmVzZXQiLCJnZXREYXRhIiwic3RhcnRWYWx1ZSIsInN0YXJ0TGVuZ3RoIiwiZW5kVmFsdWUiLCJlbmRMZW5ndGgiLCJtaW5FbmQiLCJzbGljZVRhaWwiLCJFVkVOVF9QT09MX1NJWkUiLCJFdmVudEludGVyZmFjZSIsImZ1bmN0aW9uVGhhdFJldHVybnNUcnVlIiwiZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlIiwiU3ludGhldGljRXZlbnQiLCJub3JtYWxpemUiLCJnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uIiwiU3VwZXIiLCJDbGFzcyIsImFkZEV2ZW50UG9vbGluZ1RvIiwiZ2V0VmFsIiwiaXNGdW5jdGlvbiIsIndhcm5pbmdDb25kaXRpb24iLCJnZXRQb29sZWRFdmVudCIsIm5hdGl2ZUluc3QiLCJFdmVudENvbnN0cnVjdG9yIiwicmVsZWFzZVBvb2xlZEV2ZW50IiwiU3ludGhldGljQ29tcG9zaXRpb25FdmVudCIsIlN5bnRoZXRpY0lucHV0RXZlbnQiLCJFTkRfS0VZQ09ERVMiLCJTVEFSVF9LRVlDT0RFIiwiY2FuVXNlQ29tcG9zaXRpb25FdmVudCIsImNhblVzZVRleHRJbnB1dEV2ZW50IiwidXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEiLCJTUEFDRUJBUl9DT0RFIiwiU1BBQ0VCQVJfQ0hBUiIsImhhc1NwYWNlS2V5cHJlc3MiLCJpc0tleXByZXNzQ29tbWFuZCIsImdldENvbXBvc2l0aW9uRXZlbnRUeXBlIiwiaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQiLCJpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQiLCJnZXREYXRhRnJvbUN1c3RvbUV2ZW50IiwiaXNVc2luZ0tvcmVhbklNRSIsImlzQ29tcG9zaW5nIiwiZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQiLCJldmVudFR5cGUiLCJmYWxsYmFja0RhdGEiLCJjdXN0b21EYXRhIiwiZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyIsImNoYXJzIiwiZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzIiwiZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQiLCJjb21wb3NpdGlvbiIsInJlc3RvcmVJbXBsIiwicmVzdG9yZVRhcmdldCIsInJlc3RvcmVRdWV1ZSIsInJlc3RvcmVTdGF0ZU9mVGFyZ2V0IiwiaW50ZXJuYWxJbnN0YW5jZSIsInNldFJlc3RvcmVJbXBsZW1lbnRhdGlvbiIsImVucXVldWVTdGF0ZVJlc3RvcmUiLCJuZWVkc1N0YXRlUmVzdG9yZSIsInJlc3RvcmVTdGF0ZUlmTmVlZGVkIiwicXVldWVkVGFyZ2V0cyIsIl9iYXRjaGVkVXBkYXRlc0ltcGwiLCJib29ra2VlcGluZyIsIl9pbnRlcmFjdGl2ZVVwZGF0ZXNJbXBsIiwiX2ZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzSW1wbCIsImlzQmF0Y2hpbmciLCJiYXRjaGVkVXBkYXRlcyIsImNvbnRyb2xsZWRDb21wb25lbnRzSGF2ZVBlbmRpbmdVcGRhdGVzIiwiaW50ZXJhY3RpdmVVcGRhdGVzIiwic2V0QmF0Y2hpbmdJbXBsZW1lbnRhdGlvbiIsImJhdGNoZWRVcGRhdGVzSW1wbCIsImludGVyYWN0aXZlVXBkYXRlc0ltcGwiLCJmbHVzaEludGVyYWN0aXZlVXBkYXRlc0ltcGwiLCJzdXBwb3J0ZWRJbnB1dFR5cGVzIiwiaXNUZXh0SW5wdXRFbGVtZW50IiwiZWxlbSIsIkVMRU1FTlRfTk9ERSIsIlRFWFRfTk9ERSIsIkNPTU1FTlRfTk9ERSIsIkRPQ1VNRU5UX05PREUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwiZ2V0RXZlbnRUYXJnZXQiLCJpc0V2ZW50U3VwcG9ydGVkIiwiZXZlbnROYW1lU3VmZml4IiwiaXNTdXBwb3J0ZWQiLCJpc0NoZWNrYWJsZSIsImdldFRyYWNrZXIiLCJkZXRhY2hUcmFja2VyIiwiZ2V0VmFsdWVGcm9tTm9kZSIsInRyYWNrVmFsdWVPbk5vZGUiLCJ2YWx1ZUZpZWxkIiwiZGVzY3JpcHRvciIsImN1cnJlbnRWYWx1ZSIsInRyYWNrZXIiLCJ1cGRhdGVWYWx1ZUlmQ2hhbmdlZCIsImxhc3RWYWx1ZSIsIm5leHRWYWx1ZSIsIlBlbmRpbmciLCJSZWplY3RlZCIsImdldFJlc3VsdEZyb21SZXNvbHZlZFRoZW5hYmxlIiwiZGVzY3JpYmVGaWJlciIsImZpYmVyIiwiZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kIiwid29ya0luUHJvZ3Jlc3MiLCJnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCIsImdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYiLCJyZXNldEN1cnJlbnRGaWJlciIsInNldEN1cnJlbnRGaWJlciIsInNldEN1cnJlbnRQaGFzZSIsImxpZmVDeWNsZVBoYXNlIiwiUkVTRVJWRUQiLCJTVFJJTkciLCJCT09MRUFOSVNIX1NUUklORyIsIkJPT0xFQU4iLCJPVkVSTE9BREVEX0JPT0xFQU4iLCJOVU1FUklDIiwiUE9TSVRJVkVfTlVNRVJJQyIsIkFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIiLCJBVFRSSUJVVEVfTkFNRV9DSEFSIiwiUk9PVF9BVFRSSUJVVEVfTkFNRSIsIlZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYIiwiaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSIsInZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSIsImlzQXR0cmlidXRlTmFtZVNhZmUiLCJzaG91bGRJZ25vcmVBdHRyaWJ1dGUiLCJwcm9wZXJ0eUluZm8iLCJpc0N1c3RvbUNvbXBvbmVudFRhZyIsInNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nIiwic2hvdWxkUmVtb3ZlQXR0cmlidXRlIiwiZ2V0UHJvcGVydHlJbmZvIiwicHJvcGVydGllcyIsIlByb3BlcnR5SW5mb1JlY29yZCIsIkNBTUVMSVpFIiwiY2FwaXRhbGl6ZSIsImdldFZhbHVlRm9yUHJvcGVydHkiLCJleHBlY3RlZCIsInN0cmluZ1ZhbHVlIiwiZ2V0QXR0cmlidXRlIiwiZ2V0VmFsdWVGb3JBdHRyaWJ1dGUiLCJzZXRWYWx1ZUZvclByb3BlcnR5IiwiX2F0dHJpYnV0ZU5hbWUiLCJfdHlwZSIsImF0dHJpYnV0ZVZhbHVlIiwiZ2V0VG9TdHJpbmdWYWx1ZSIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSIsIlJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzIiwiaGFzUmVhZE9ubHlWYWx1ZSIsImNoZWNrYm94IiwiaW1hZ2UiLCJyYWRpbyIsInN1Ym1pdCIsIm9uQ2hhbmdlIiwicmVhZE9ubHkiLCJlbmFibGVVc2VyVGltaW5nQVBJIiwiZW5hYmxlR2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoIiwiZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIiwiZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzRm9yU3RyaWN0TW9kZSIsInJlcGxheUZhaWxlZFVuaXRPZldvcmtXaXRoSW52b2tlR3VhcmRlZENhbGxiYWNrIiwid2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMiLCJ3YXJuQWJvdXRMZWdhY3lDb250ZXh0QVBJIiwiZW5hYmxlUHJvZmlsZXJUaW1lciIsImVuYWJsZVNjaGVkdWxlclRyYWNpbmciLCJkaXNhYmxlSW5wdXRBdHRyaWJ1dGVTeW5jaW5nIiwiZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlIiwiZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCIsImRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQiLCJkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkIiwiaXNDb250cm9sbGVkIiwidXNlc0NoZWNrZWQiLCJnZXRIb3N0UHJvcHMiLCJob3N0UHJvcHMiLCJpbml0V3JhcHBlclN0YXRlIiwidXBkYXRlQ2hlY2tlZCIsInVwZGF0ZVdyYXBwZXIiLCJfY29udHJvbGxlZCIsInNldERlZmF1bHRWYWx1ZSIsInBvc3RNb3VudFdyYXBwZXIiLCJpc0h5ZHJhdGluZyIsImlzQnV0dG9uIiwiX2luaXRpYWxWYWx1ZSIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUiLCJ1cGRhdGVOYW1lZENvdXNpbnMiLCJyb290Tm9kZSIsInF1ZXJ5Um9vdCIsIm90aGVyTm9kZSIsIm90aGVyUHJvcHMiLCJldmVudFR5cGVzJDEiLCJjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQiLCJhY3RpdmVFbGVtZW50SW5zdCIsInNob3VsZFVzZUNoYW5nZUV2ZW50IiwibWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCIsInJ1bkV2ZW50SW5CYXRjaCIsImdldEluc3RJZlZhbHVlQ2hhbmdlZCIsInRhcmdldE5vZGUiLCJnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQiLCJpc0lucHV0RXZlbnRTdXBwb3J0ZWQiLCJzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UiLCJoYW5kbGVQcm9wZXJ0eUNoYW5nZSIsInN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwiaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsIiwiZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbCIsInNob3VsZFVzZUNsaWNrRXZlbnQiLCJnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCIsImdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQiLCJoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyIiwiZ2V0VGFyZ2V0SW5zdEZ1bmMiLCJoYW5kbGVFdmVudEZ1bmMiLCJET01FdmVudFBsdWdpbk9yZGVyIiwiU3ludGhldGljVUlFdmVudCIsIm1vZGlmaWVyS2V5VG9Qcm9wIiwibW9kaWZpZXJTdGF0ZUdldHRlciIsImtleUFyZyIsInN5bnRoZXRpY0V2ZW50Iiwia2V5UHJvcCIsImdldEV2ZW50TW9kaWZpZXJTdGF0ZSIsInByZXZpb3VzU2NyZWVuWCIsInByZXZpb3VzU2NyZWVuWSIsImlzTW92ZW1lbnRYU2V0IiwiaXNNb3ZlbWVudFlTZXQiLCJTeW50aGV0aWNNb3VzZUV2ZW50IiwiU3ludGhldGljUG9pbnRlckV2ZW50IiwiZXZlbnRUeXBlcyQyIiwiaXNPdmVyRXZlbnQiLCJpc091dEV2ZW50Iiwid2luIiwiZG9jIiwicmVsYXRlZCIsImV2ZW50SW50ZXJmYWNlIiwibGVhdmVFdmVudFR5cGUiLCJlbnRlckV2ZW50VHlwZSIsImV2ZW50VHlwZVByZWZpeCIsImZyb21Ob2RlIiwidG9Ob2RlIiwiaGFzT3duUHJvcGVydHkkMSIsInNoYWxsb3dFcXVhbCIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzQiIsIk5vRWZmZWN0IiwiUGVyZm9ybWVkV29yayIsIlBsYWNlbWVudCIsIlVwZGF0ZSIsIlBsYWNlbWVudEFuZFVwZGF0ZSIsIkRlbGV0aW9uIiwiQ29udGVudFJlc2V0IiwiQ2FsbGJhY2siLCJEaWRDYXB0dXJlIiwiUmVmIiwiU25hcHNob3QiLCJMaWZlY3ljbGVFZmZlY3RNYXNrIiwiSG9zdEVmZmVjdE1hc2siLCJJbmNvbXBsZXRlIiwiU2hvdWxkQ2FwdHVyZSIsIlJlYWN0Q3VycmVudE93bmVyJDEiLCJNT1VOVElORyIsIk1PVU5URUQiLCJVTk1PVU5URUQiLCJpc0ZpYmVyTW91bnRlZEltcGwiLCJpc0ZpYmVyTW91bnRlZCIsIm93bmVyRmliZXIiLCJfd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIiLCJhc3NlcnRJc01vdW50ZWQiLCJmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aCIsInBhcmVudEEiLCJwYXJlbnRCIiwiZGlkRmluZENoaWxkIiwiX2NoaWxkIiwiZmluZEN1cnJlbnRIb3N0RmliZXIiLCJjdXJyZW50UGFyZW50IiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzIiwiYWRkRXZlbnRCdWJibGVMaXN0ZW5lciIsImFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyIiwiU3ludGhldGljQW5pbWF0aW9uRXZlbnQiLCJTeW50aGV0aWNDbGlwYm9hcmRFdmVudCIsIlN5bnRoZXRpY0ZvY3VzRXZlbnQiLCJnZXRFdmVudENoYXJDb2RlIiwibm9ybWFsaXplS2V5IiwidHJhbnNsYXRlVG9LZXkiLCJnZXRFdmVudEtleSIsIlN5bnRoZXRpY0tleWJvYXJkRXZlbnQiLCJTeW50aGV0aWNEcmFnRXZlbnQiLCJTeW50aGV0aWNUb3VjaEV2ZW50IiwiU3ludGhldGljVHJhbnNpdGlvbkV2ZW50IiwiU3ludGhldGljV2hlZWxFdmVudCIsImludGVyYWN0aXZlRXZlbnRUeXBlTmFtZXMiLCJub25JbnRlcmFjdGl2ZUV2ZW50VHlwZU5hbWVzIiwiZXZlbnRUeXBlcyQ0IiwidG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnIiwiYWRkRXZlbnRUeXBlTmFtZVRvQ29uZmlnIiwidG9wRXZlbnQiLCJjYXBpdGFsaXplZEV2ZW50Iiwib25FdmVudCIsImV2ZW50VHVwbGUiLCJrbm93bkhUTUxUb3BMZXZlbFR5cGVzIiwiQ0FMTEJBQ0tfQk9PS0tFRVBJTkdfUE9PTF9TSVpFIiwiY2FsbGJhY2tCb29ra2VlcGluZ1Bvb2wiLCJmaW5kUm9vdENvbnRhaW5lck5vZGUiLCJnZXRUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmciLCJyZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nIiwiaGFuZGxlVG9wTGV2ZWwiLCJhbmNlc3RvciIsIl9lbmFibGVkIiwic2V0RW5hYmxlZCIsImVuYWJsZWQiLCJpc0VuYWJsZWQiLCJ0cmFwQnViYmxlZEV2ZW50IiwiZGlzcGF0Y2giLCJkaXNwYXRjaEludGVyYWN0aXZlRXZlbnQiLCJ0cmFwQ2FwdHVyZWRFdmVudCIsImFscmVhZHlMaXN0ZW5pbmdUbyIsInJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciIsInRvcExpc3RlbmVyc0lES2V5IiwiZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQiLCJtb3VudEF0IiwibGlzdGVuVG8iLCJpc0xpc3RlbmluZyIsImRlcGVuZGVuY3kiLCJpc01lZGlhRXZlbnQiLCJpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzIiwiZ2V0QWN0aXZlRWxlbWVudCIsImdldExlYWZOb2RlIiwiZ2V0U2libGluZ05vZGUiLCJnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0Iiwibm9kZVN0YXJ0Iiwibm9kZUVuZCIsImdldE9mZnNldHMiLCJvdXRlck5vZGUiLCJzZWxlY3Rpb24iLCJnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyIsImluZGV4V2l0aGluQW5jaG9yIiwiaW5kZXhXaXRoaW5Gb2N1cyIsIm91dGVyIiwic2V0T2Zmc2V0cyIsIm9mZnNldHMiLCJ0ZW1wIiwic3RhcnRNYXJrZXIiLCJlbmRNYXJrZXIiLCJpc1RleHROb2RlIiwiY29udGFpbnNOb2RlIiwiaW5uZXJOb2RlIiwiaXNJbkRvY3VtZW50IiwiZ2V0QWN0aXZlRWxlbWVudERlZXAiLCJoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMiLCJnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbiIsImdldFNlbGVjdGlvbiQxIiwicmVzdG9yZVNlbGVjdGlvbiIsInByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24iLCJjdXJGb2N1c2VkRWxlbSIsInByaW9yRm9jdXNlZEVsZW0iLCJwcmlvclNlbGVjdGlvblJhbmdlIiwic2V0U2VsZWN0aW9uIiwic2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50IiwiZXZlbnRUeXBlcyQzIiwiYWN0aXZlRWxlbWVudCQxIiwiYWN0aXZlRWxlbWVudEluc3QkMSIsImxhc3RTZWxlY3Rpb24iLCJtb3VzZURvd24iLCJnZXRFdmVudFRhcmdldERvY3VtZW50IiwiZXZlbnRUYXJnZXQiLCJjb25zdHJ1Y3RTZWxlY3RFdmVudCIsImN1cnJlbnRTZWxlY3Rpb24iLCJkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiIsImRpZFdhcm5JbnZhbGlkQ2hpbGQiLCJmbGF0dGVuQ2hpbGRyZW4iLCJjb250ZW50IiwidmFsaWRhdGVQcm9wcyIsInBvc3RNb3VudFdyYXBwZXIkMSIsImdldEhvc3RQcm9wcyQxIiwiZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEiLCJ2YWx1ZVByb3BOYW1lcyIsImNoZWNrU2VsZWN0UHJvcFR5cGVzIiwidXBkYXRlT3B0aW9ucyIsInByb3BWYWx1ZSIsInNldERlZmF1bHRTZWxlY3RlZCIsInNlbGVjdGVkVmFsdWVzIiwic2VsZWN0ZWRWYWx1ZSIsIl9zZWxlY3RlZFZhbHVlIiwiX2kyIiwiZ2V0SG9zdFByb3BzJDIiLCJpbml0V3JhcHBlclN0YXRlJDEiLCJwb3N0TW91bnRXcmFwcGVyJDIiLCJwb3N0VXBkYXRlV3JhcHBlciIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUkMiIsImRpZFdhcm5WYWxEZWZhdWx0VmFsIiwiZ2V0SG9zdFByb3BzJDMiLCJpbml0V3JhcHBlclN0YXRlJDIiLCJ1cGRhdGVXcmFwcGVyJDEiLCJuZXdWYWx1ZSIsInBvc3RNb3VudFdyYXBwZXIkMyIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyIsIkhUTUxfTkFNRVNQQUNFJDEiLCJNQVRIX05BTUVTUEFDRSIsIlNWR19OQU1FU1BBQ0UiLCJOYW1lc3BhY2VzIiwiZ2V0SW50cmluc2ljTmFtZXNwYWNlIiwiZ2V0Q2hpbGROYW1lc3BhY2UiLCJwYXJlbnROYW1lc3BhY2UiLCJjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uIiwiYXJnMCIsImFyZzEiLCJhcmcyIiwiYXJnMyIsInJldXNhYmxlU1ZHQ29udGFpbmVyIiwic2V0SW5uZXJIVE1MIiwic3ZnTm9kZSIsInNldFRleHRDb250ZW50IiwiaXNVbml0bGVzc051bWJlciIsInByZWZpeEtleSIsInByb3AiLCJkYW5nZXJvdXNTdHlsZVZhbHVlIiwiaXNDdXN0b21Qcm9wZXJ0eSIsImlzRW1wdHkiLCJ1cHBlcmNhc2VQYXR0ZXJuIiwibXNQYXR0ZXJuIiwiaHlwaGVuYXRlU3R5bGVOYW1lIiwid2FyblZhbGlkU3R5bGUiLCJiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4iLCJtc1BhdHRlcm4kMSIsImh5cGhlblBhdHRlcm4iLCJiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4iLCJ3YXJuZWRTdHlsZU5hbWVzIiwid2FybmVkU3R5bGVWYWx1ZXMiLCJ3YXJuZWRGb3JOYU5WYWx1ZSIsIndhcm5lZEZvckluZmluaXR5VmFsdWUiLCJjYW1lbGl6ZSIsIl8iLCJjaGFyYWN0ZXIiLCJ3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSIsIndhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSIsIndhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiIsIndhcm5TdHlsZVZhbHVlSXNOYU4iLCJ3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkiLCJpc0Zpbml0ZSIsIndhcm5WYWxpZFN0eWxlJDEiLCJjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMiLCJzdHlsZXMiLCJzZXJpYWxpemVkIiwic3R5bGVOYW1lIiwic3R5bGVWYWx1ZSIsInNldFZhbHVlRm9yU3R5bGVzIiwib21pdHRlZENsb3NlVGFncyIsInZvaWRFbGVtZW50VGFncyIsIkhUTUwkMSIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUkMiIsImFzc2VydFZhbGlkUHJvcHMiLCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmciLCJpc0N1c3RvbUNvbXBvbmVudCIsInBvc3NpYmxlU3RhbmRhcmROYW1lcyIsImFjY2VwdCIsImFjY2VwdGNoYXJzZXQiLCJhY2Nlc3NrZXkiLCJhbGxvd2Z1bGxzY3JlZW4iLCJhbHQiLCJhcyIsImFzeW5jIiwiYXV0b2NhcGl0YWxpemUiLCJhdXRvY29tcGxldGUiLCJhdXRvY29ycmVjdCIsImF1dG9mb2N1cyIsImF1dG9wbGF5IiwiYXV0b3NhdmUiLCJjZWxscGFkZGluZyIsImNlbGxzcGFjaW5nIiwiY2hhbGxlbmdlIiwiY2hhcnNldCIsImNpdGUiLCJjbGFzcyIsImNsYXNzaWQiLCJjbGFzc25hbWUiLCJjb2xzIiwiY29sc3BhbiIsImNvbnRlbnRlZGl0YWJsZSIsImNvbnRleHRtZW51IiwiY29udHJvbHMiLCJjb250cm9sc2xpc3QiLCJjb29yZHMiLCJjcm9zc29yaWdpbiIsImRhbmdlcm91c2x5c2V0aW5uZXJodG1sIiwiZGVmYXVsdGNoZWNrZWQiLCJkZWZhdWx0dmFsdWUiLCJkZWZlciIsImRvd25sb2FkIiwiZHJhZ2dhYmxlIiwiZW5jdHlwZSIsImZvcm1tZXRob2QiLCJmb3JtYWN0aW9uIiwiZm9ybWVuY3R5cGUiLCJmb3Jtbm92YWxpZGF0ZSIsImZvcm10YXJnZXQiLCJmcmFtZWJvcmRlciIsImhlYWRlcnMiLCJoaWdoIiwiaHJlZmxhbmciLCJodG1sZm9yIiwiaHR0cGVxdWl2IiwiaWNvbiIsImlubmVyaHRtbCIsImlucHV0bW9kZSIsImludGVncml0eSIsIml0ZW1pZCIsIml0ZW1wcm9wIiwiaXRlbXJlZiIsIml0ZW1zY29wZSIsIml0ZW10eXBlIiwia2V5cGFyYW1zIiwia2V5dHlwZSIsImtpbmQiLCJsYWJlbCIsImxhbmciLCJsaXN0IiwibG9vcCIsImxvdyIsIm1hbmlmZXN0IiwibWFyZ2lud2lkdGgiLCJtYXJnaW5oZWlnaHQiLCJtYXgiLCJtYXhsZW5ndGgiLCJtZWRpYSIsIm1lZGlhZ3JvdXAiLCJtZXRob2QiLCJtaW5sZW5ndGgiLCJtdXRlZCIsIm5vbW9kdWxlIiwibm9uY2UiLCJub3ZhbGlkYXRlIiwib3BlbiIsIm9wdGltdW0iLCJwbGFjZWhvbGRlciIsInBsYXlzaW5saW5lIiwicG9zdGVyIiwicHJlbG9hZCIsInByb2ZpbGUiLCJyYWRpb2dyb3VwIiwicmVhZG9ubHkiLCJyZWZlcnJlcnBvbGljeSIsInJlbCIsInJlcXVpcmVkIiwicmV2ZXJzZWQiLCJyb2xlIiwicm93cyIsInJvd3NwYW4iLCJzYW5kYm94Iiwic2NvcGVkIiwic2Nyb2xsaW5nIiwic2VhbWxlc3MiLCJzaXplIiwic2l6ZXMiLCJzcGFuIiwic3BlbGxjaGVjayIsInNyYyIsInNyY2RvYyIsInNyY2xhbmciLCJzcmNzZXQiLCJzdW1tYXJ5IiwidGFiaW5kZXgiLCJ1c2VtYXAiLCJ3bW9kZSIsIndyYXAiLCJhYm91dCIsImFjY2VudGhlaWdodCIsImFjY3VtdWxhdGUiLCJhZGRpdGl2ZSIsImFsaWdubWVudGJhc2VsaW5lIiwiYWxsb3dyZW9yZGVyIiwiYWxwaGFiZXRpYyIsImFtcGxpdHVkZSIsImFyYWJpY2Zvcm0iLCJhc2NlbnQiLCJhdHRyaWJ1dGVuYW1lIiwiYXR0cmlidXRldHlwZSIsImF1dG9yZXZlcnNlIiwiYXppbXV0aCIsImJhc2VmcmVxdWVuY3kiLCJiYXNlbGluZXNoaWZ0IiwiYmFzZXByb2ZpbGUiLCJiYm94IiwiYmVnaW4iLCJiaWFzIiwiYnkiLCJjYWxjbW9kZSIsImNhcGhlaWdodCIsImNsaXAiLCJjbGlwcGF0aCIsImNsaXBwYXRodW5pdHMiLCJjbGlwcnVsZSIsImNvbG9yaW50ZXJwb2xhdGlvbiIsImNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnMiLCJjb2xvcnByb2ZpbGUiLCJjb2xvcnJlbmRlcmluZyIsImNvbnRlbnRzY3JpcHR0eXBlIiwiY29udGVudHN0eWxldHlwZSIsImN1cnNvciIsImN4IiwiY3kiLCJkYXRhdHlwZSIsImRlY2VsZXJhdGUiLCJkZXNjZW50IiwiZGlmZnVzZWNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGlzcGxheSIsImRpdmlzb3IiLCJkb21pbmFudGJhc2VsaW5lIiwiZHVyIiwiZHgiLCJkeSIsImVkZ2Vtb2RlIiwiZWxldmF0aW9uIiwiZW5hYmxlYmFja2dyb3VuZCIsImV4cG9uZW50IiwiZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZCIsImZpbGwiLCJmaWxsb3BhY2l0eSIsImZpbGxydWxlIiwiZmlsdGVycmVzIiwiZmlsdGVydW5pdHMiLCJmbG9vZG9wYWNpdHkiLCJmbG9vZGNvbG9yIiwiZm9jdXNhYmxlIiwiZm9udGZhbWlseSIsImZvbnRzaXplIiwiZm9udHNpemVhZGp1c3QiLCJmb250c3RyZXRjaCIsImZvbnRzdHlsZSIsImZvbnR2YXJpYW50IiwiZm9udHdlaWdodCIsImZ4IiwiZnkiLCJnMSIsImcyIiwiZ2x5cGhuYW1lIiwiZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWwiLCJnbHlwaG9yaWVudGF0aW9udmVydGljYWwiLCJnbHlwaHJlZiIsImdyYWRpZW50dHJhbnNmb3JtIiwiZ3JhZGllbnR1bml0cyIsImhhbmdpbmciLCJob3JpemFkdngiLCJob3Jpem9yaWdpbngiLCJpZGVvZ3JhcGhpYyIsImltYWdlcmVuZGVyaW5nIiwiaW4yIiwiaW4iLCJpbmxpc3QiLCJpbnRlcmNlcHQiLCJrMSIsImsyIiwiazMiLCJrNCIsImtlcm5lbG1hdHJpeCIsImtlcm5lbHVuaXRsZW5ndGgiLCJrZXJuaW5nIiwia2V5cG9pbnRzIiwia2V5c3BsaW5lcyIsImtleXRpbWVzIiwibGVuZ3RoYWRqdXN0IiwibGV0dGVyc3BhY2luZyIsImxpZ2h0aW5nY29sb3IiLCJsaW1pdGluZ2NvbmVhbmdsZSIsImxvY2FsIiwibWFya2VyZW5kIiwibWFya2VyaGVpZ2h0IiwibWFya2VybWlkIiwibWFya2Vyc3RhcnQiLCJtYXJrZXJ1bml0cyIsIm1hcmtlcndpZHRoIiwibWFzayIsIm1hc2tjb250ZW50dW5pdHMiLCJtYXNrdW5pdHMiLCJtYXRoZW1hdGljYWwiLCJudW1vY3RhdmVzIiwib3BlcmF0b3IiLCJvcmllbnQiLCJvcmllbnRhdGlvbiIsIm9yaWdpbiIsIm92ZXJmbG93Iiwib3ZlcmxpbmVwb3NpdGlvbiIsIm92ZXJsaW5ldGhpY2tuZXNzIiwicGFpbnRvcmRlciIsInBhbm9zZTEiLCJwYXRobGVuZ3RoIiwicGF0dGVybmNvbnRlbnR1bml0cyIsInBhdHRlcm50cmFuc2Zvcm0iLCJwYXR0ZXJudW5pdHMiLCJwb2ludGVyZXZlbnRzIiwicG9pbnRzIiwicG9pbnRzYXR4IiwicG9pbnRzYXR5IiwicG9pbnRzYXR6IiwicHJlc2VydmVhbHBoYSIsInByZXNlcnZlYXNwZWN0cmF0aW8iLCJwcmltaXRpdmV1bml0cyIsInByb3BlcnR5IiwicmFkaXVzIiwicmVmeCIsInJlZnkiLCJyZW5kZXJpbmdpbnRlbnQiLCJyZXBlYXRjb3VudCIsInJlcGVhdGR1ciIsInJlcXVpcmVkZXh0ZW5zaW9ucyIsInJlcXVpcmVkZmVhdHVyZXMiLCJyZXNvdXJjZSIsInJlc3RhcnQiLCJyZXN1bHRzIiwicm90YXRlIiwicngiLCJyeSIsInNjYWxlIiwic2VjdXJpdHkiLCJzZWVkIiwic2hhcGVyZW5kZXJpbmciLCJzbG9wZSIsInNwYWNpbmciLCJzcGVjdWxhcmNvbnN0YW50Iiwic3BlY3VsYXJleHBvbmVudCIsInNwZWVkIiwic3ByZWFkbWV0aG9kIiwic3RhcnRvZmZzZXQiLCJzdGRkZXZpYXRpb24iLCJzdGVtaCIsInN0ZW12Iiwic3RpdGNodGlsZXMiLCJzdG9wY29sb3IiLCJzdG9wb3BhY2l0eSIsInN0cmlrZXRocm91Z2hwb3NpdGlvbiIsInN0cmlrZXRocm91Z2h0aGlja25lc3MiLCJzdHJva2UiLCJzdHJva2VkYXNoYXJyYXkiLCJzdHJva2VkYXNob2Zmc2V0Iiwic3Ryb2tlbGluZWNhcCIsInN0cm9rZWxpbmVqb2luIiwic3Ryb2tlbWl0ZXJsaW1pdCIsInN0cm9rZXdpZHRoIiwic3Ryb2tlb3BhY2l0eSIsInN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZyIsInN1cHByZXNzaHlkcmF0aW9ud2FybmluZyIsInN1cmZhY2VzY2FsZSIsInN5c3RlbWxhbmd1YWdlIiwidGFibGV2YWx1ZXMiLCJ0YXJnZXR4IiwidGFyZ2V0eSIsInRleHRhbmNob3IiLCJ0ZXh0ZGVjb3JhdGlvbiIsInRleHRsZW5ndGgiLCJ0ZXh0cmVuZGVyaW5nIiwidHJhbnNmb3JtIiwidHlwZW9mIiwidTEiLCJ1MiIsInVuZGVybGluZXBvc2l0aW9uIiwidW5kZXJsaW5ldGhpY2tuZXNzIiwidW5pY29kZSIsInVuaWNvZGViaWRpIiwidW5pY29kZXJhbmdlIiwidW5pdHNwZXJlbSIsInVuc2VsZWN0YWJsZSIsInZhbHBoYWJldGljIiwidmVjdG9yZWZmZWN0IiwidmVydGFkdnkiLCJ2ZXJ0b3JpZ2lueCIsInZlcnRvcmlnaW55IiwidmhhbmdpbmciLCJ2aWRlb2dyYXBoaWMiLCJ2aWV3Ym94Iiwidmlld3RhcmdldCIsInZpc2liaWxpdHkiLCJ2bWF0aGVtYXRpY2FsIiwidm9jYWIiLCJ3aWR0aHMiLCJ3b3Jkc3BhY2luZyIsIndyaXRpbmdtb2RlIiwieDEiLCJ4MiIsInhjaGFubmVsc2VsZWN0b3IiLCJ4aGVpZ2h0IiwieGxpbmthY3R1YXRlIiwieGxpbmthcmNyb2xlIiwieGxpbmtocmVmIiwieGxpbmtyb2xlIiwieGxpbmtzaG93IiwieGxpbmt0aXRsZSIsInhsaW5rdHlwZSIsInhtbGJhc2UiLCJ4bWxsYW5nIiwieG1sbnMiLCJ4bWxuc3hsaW5rIiwieG1sc3BhY2UiLCJ5MSIsInkyIiwieWNoYW5uZWxzZWxlY3RvciIsInpvb21hbmRwYW4iLCJhcmlhUHJvcGVydGllcyIsIndhcm5lZFByb3BlcnRpZXMiLCJyQVJJQSIsInJBUklBQ2FtZWwiLCJoYXNPd25Qcm9wZXJ0eSQyIiwidmFsaWRhdGVQcm9wZXJ0eSIsImFyaWFOYW1lIiwiY29ycmVjdE5hbWUiLCJzdGFuZGFyZE5hbWUiLCJ3YXJuSW52YWxpZEFSSUFQcm9wcyIsImludmFsaWRQcm9wcyIsImlzVmFsaWQiLCJ1bmtub3duUHJvcFN0cmluZyIsInZhbGlkYXRlUHJvcGVydGllcyIsImRpZFdhcm5WYWx1ZU51bGwiLCJ2YWxpZGF0ZVByb3BlcnRpZXMkMSIsInZhbGlkYXRlUHJvcGVydHkkMSIsIndhcm5lZFByb3BlcnRpZXMkMSIsIl9oYXNPd25Qcm9wZXJ0eSIsIkVWRU5UX05BTUVfUkVHRVgiLCJJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgiLCJyQVJJQSQxIiwickFSSUFDYW1lbCQxIiwiY2FuVXNlRXZlbnRTeXN0ZW0iLCJpc1Jlc2VydmVkIiwid2FyblVua25vd25Qcm9wZXJ0aWVzIiwidW5rbm93blByb3BzIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDIiLCJkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiIsImRpZFdhcm5TaGFkeURPTSIsIkRBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIiwiU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIiwiU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSIsIkFVVE9GT0NVUyIsIkNISUxEUkVOIiwiU1RZTEUiLCJIVE1MIiwiSFRNTF9OQU1FU1BBQ0UiLCJ3YXJuZWRVbmtub3duVGFncyIsInN1cHByZXNzSHlkcmF0aW9uV2FybmluZyIsInZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQiLCJ3YXJuRm9yVGV4dERpZmZlcmVuY2UiLCJ3YXJuRm9yUHJvcERpZmZlcmVuY2UiLCJ3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzIiwid2FybkZvckludmFsaWRFdmVudExpc3RlbmVyIiwiY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZyIsIm5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZSIsIm5vcm1hbGl6ZUhUTUwiLCJkaWFsb2ciLCJ3ZWJ2aWV3IiwiTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYIiwiTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYIiwibWFya3VwIiwibWFya3VwU3RyaW5nIiwic2VydmVyVGV4dCIsImNsaWVudFRleHQiLCJub3JtYWxpemVkQ2xpZW50VGV4dCIsIm5vcm1hbGl6ZWRTZXJ2ZXJUZXh0Iiwic2VydmVyVmFsdWUiLCJjbGllbnRWYWx1ZSIsIm5vcm1hbGl6ZWRDbGllbnRWYWx1ZSIsIm5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSIsImF0dHJpYnV0ZU5hbWVzIiwibmFtZXMiLCJ0ZXN0RWxlbWVudCIsImVuc3VyZUxpc3RlbmluZ1RvIiwicm9vdENvbnRhaW5lckVsZW1lbnQiLCJpc0RvY3VtZW50T3JGcmFnbWVudCIsImdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lciIsInRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50Iiwic2V0SW5pdGlhbERPTVByb3BlcnRpZXMiLCJkb21FbGVtZW50IiwicHJvcEtleSIsIm5leHRQcm9wIiwibmV4dEh0bWwiLCJjYW5TZXRUZXh0Q29udGVudCIsInVwZGF0ZURPTVByb3BlcnRpZXMiLCJ1cGRhdGVQYXlsb2FkIiwid2FzQ3VzdG9tQ29tcG9uZW50VGFnIiwiZGl2Iiwic2V0SW5pdGlhbFByb3BlcnRpZXMiLCJyYXdQcm9wcyIsInNoYWR5Um9vdCIsImRpZmZQcm9wZXJ0aWVzIiwibGFzdFJhd1Byb3BzIiwibmV4dFJhd1Byb3BzIiwibGFzdFByb3BzIiwic3R5bGVVcGRhdGVzIiwibGFzdFN0eWxlIiwibGFzdFByb3AiLCJsYXN0SHRtbCIsInVwZGF0ZVByb3BlcnRpZXMiLCJnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZSIsImRpZmZIeWRyYXRlZFByb3BlcnRpZXMiLCJleHRyYUF0dHJpYnV0ZU5hbWVzIiwiYXR0cmlidXRlcyIsInNlcnZlckhUTUwiLCJleHBlY3RlZEhUTUwiLCJleHBlY3RlZFN0eWxlIiwiaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nIiwib3duTmFtZXNwYWNlIiwiZGlmZkh5ZHJhdGVkVGV4dCIsInRleHROb2RlIiwiaXNEaWZmZXJlbnQiLCJ3YXJuRm9yVW5tYXRjaGVkVGV4dCIsIndhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQiLCJ3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0Iiwid2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50Iiwid2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0IiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxIiwidmFsaWRhdGVET01OZXN0aW5nIiwidXBkYXRlZEFuY2VzdG9ySW5mbyIsInNwZWNpYWxUYWdzIiwiaW5TY29wZVRhZ3MiLCJidXR0b25TY29wZVRhZ3MiLCJpbXBsaWVkRW5kVGFncyIsImVtcHR5QW5jZXN0b3JJbmZvIiwiZm9ybVRhZyIsImFUYWdJblNjb3BlIiwiYnV0dG9uVGFnSW5TY29wZSIsIm5vYnJUYWdJblNjb3BlIiwicFRhZ0luQnV0dG9uU2NvcGUiLCJsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nIiwiZGxJdGVtVGFnQXV0b2Nsb3NpbmciLCJvbGRJbmZvIiwiYW5jZXN0b3JJbmZvIiwiaXNUYWdWYWxpZFdpdGhQYXJlbnQiLCJwYXJlbnRUYWciLCJmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnIiwiZGlkV2FybiIsImNoaWxkVGFnIiwiY2hpbGRUZXh0IiwicGFyZW50SW5mbyIsImludmFsaWRQYXJlbnQiLCJpbnZhbGlkQW5jZXN0b3IiLCJpbnZhbGlkUGFyZW50T3JBbmNlc3RvciIsImFuY2VzdG9yVGFnIiwid2FybktleSIsInRhZ0Rpc3BsYXlOYW1lIiwid2hpdGVzcGFjZUluZm8iLCJzaGltIiwic3VwcG9ydHNQZXJzaXN0ZW5jZSIsImNsb25lSW5zdGFuY2UiLCJjcmVhdGVDb250YWluZXJDaGlsZFNldCIsImFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCIsImZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4iLCJyZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4iLCJTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyIsImV2ZW50c0VuYWJsZWQiLCJzZWxlY3Rpb25JbmZvcm1hdGlvbiIsInNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQiLCJnZXRSb290SG9zdENvbnRleHQiLCJyb290Q29udGFpbmVySW5zdGFuY2UiLCJuYW1lc3BhY2UiLCJjb250YWluZXIiLCJ2YWxpZGF0ZWRUYWciLCJfYW5jZXN0b3JJbmZvIiwiZ2V0Q2hpbGRIb3N0Q29udGV4dCIsInBhcmVudEhvc3RDb250ZXh0IiwicGFyZW50SG9zdENvbnRleHREZXYiLCJfbmFtZXNwYWNlIiwiX2FuY2VzdG9ySW5mbzIiLCJnZXRQdWJsaWNJbnN0YW5jZSIsInByZXBhcmVGb3JDb21taXQiLCJyZXNldEFmdGVyQ29tbWl0IiwiY3JlYXRlSW5zdGFuY2UiLCJob3N0Q29udGV4dCIsImludGVybmFsSW5zdGFuY2VIYW5kbGUiLCJob3N0Q29udGV4dERldiIsIm93bkFuY2VzdG9ySW5mbyIsImFwcGVuZEluaXRpYWxDaGlsZCIsInBhcmVudEluc3RhbmNlIiwiZmluYWxpemVJbml0aWFsQ2hpbGRyZW4iLCJwcmVwYXJlVXBkYXRlIiwib2xkUHJvcHMiLCJuZXdQcm9wcyIsInNob3VsZFNldFRleHRDb250ZW50Iiwic2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSIsImNyZWF0ZVRleHRJbnN0YW5jZSIsImlzUHJpbWFyeVJlbmRlcmVyIiwic2NoZWR1bGVUaW1lb3V0IiwiY2FuY2VsVGltZW91dCIsIm5vVGltZW91dCIsInN1cHBvcnRzTXV0YXRpb24iLCJjb21taXRNb3VudCIsImNvbW1pdFVwZGF0ZSIsInJlc2V0VGV4dENvbnRlbnQiLCJjb21taXRUZXh0VXBkYXRlIiwidGV4dEluc3RhbmNlIiwib2xkVGV4dCIsIm5ld1RleHQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyIiwiYmVmb3JlQ2hpbGQiLCJpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsInN1cHBvcnRzSHlkcmF0aW9uIiwiY2FuSHlkcmF0ZUluc3RhbmNlIiwiY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSIsImdldE5leHRIeWRyYXRhYmxlU2libGluZyIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkIiwiaHlkcmF0ZUluc3RhbmNlIiwiaHlkcmF0ZVRleHRJbnN0YW5jZSIsImRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UiLCJwYXJlbnRDb250YWluZXIiLCJkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlIiwicGFyZW50UHJvcHMiLCJkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UiLCJkaWROb3RIeWRyYXRlSW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UiLCJyZWFjdEVtb2ppIiwid2FybmluZ0Vtb2ppIiwic3VwcG9ydHNVc2VyVGltaW5nIiwibWFyayIsImNsZWFyTWFya3MiLCJtZWFzdXJlIiwiY2xlYXJNZWFzdXJlcyIsImN1cnJlbnRGaWJlciIsImN1cnJlbnRQaGFzZSIsImN1cnJlbnRQaGFzZUZpYmVyIiwiaXNDb21taXR0aW5nIiwiaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0IiwiaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UiLCJjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wIiwiZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQiLCJpc1dhaXRpbmdGb3JDYWxsYmFjayIsImxhYmVsc0luQ3VycmVudENvbW1pdCIsImZvcm1hdE1hcmtOYW1lIiwibWFya05hbWUiLCJmb3JtYXRMYWJlbCIsInN1ZmZpeCIsImJlZ2luTWFyayIsImNsZWFyTWFyayIsImVuZE1hcmsiLCJmb3JtYXR0ZWRNYXJrTmFtZSIsImZvcm1hdHRlZExhYmVsIiwiZ2V0RmliZXJNYXJrTmFtZSIsImRlYnVnSUQiLCJnZXRGaWJlckxhYmVsIiwiYmVnaW5GaWJlck1hcmsiLCJfZGVidWdJRCIsImNsZWFyRmliZXJNYXJrIiwiZW5kRmliZXJNYXJrIiwic2hvdWxkSWdub3JlRmliZXIiLCJjbGVhclBlbmRpbmdQaGFzZU1lYXN1cmVtZW50IiwicGF1c2VUaW1lcnMiLCJfZGVidWdJc0N1cnJlbnRseVRpbWluZyIsInJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5IiwicmVzdW1lVGltZXJzIiwicmVjb3JkRWZmZWN0IiwicmVjb3JkU2NoZWR1bGVVcGRhdGUiLCJzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyIiwic3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyIiwiZGlkRXhwaXJlIiwic3RhcnRXb3JrVGltZXIiLCJjYW5jZWxXb3JrVGltZXIiLCJzdG9wV29ya1RpbWVyIiwic3RvcEZhaWxlZFdvcmtUaW1lciIsInN0YXJ0UGhhc2VUaW1lciIsInN0b3BQaGFzZVRpbWVyIiwic3RhcnRXb3JrTG9vcFRpbWVyIiwibmV4dFVuaXRPZldvcmsiLCJzdG9wV29ya0xvb3BUaW1lciIsImludGVycnVwdGVkQnkiLCJkaWRDb21wbGV0ZVJvb3QiLCJzdGFydENvbW1pdFRpbWVyIiwiY2xlYXIiLCJzdG9wQ29tbWl0VGltZXIiLCJzdGFydENvbW1pdFNuYXBzaG90RWZmZWN0c1RpbWVyIiwic3RvcENvbW1pdFNuYXBzaG90RWZmZWN0c1RpbWVyIiwic3RhcnRDb21taXRIb3N0RWZmZWN0c1RpbWVyIiwic3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIiLCJzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lciIsInN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIiLCJ2YWx1ZVN0YWNrIiwiZmliZXJTdGFjayIsImNyZWF0ZUN1cnNvciIsImNoZWNrVGhhdFN0YWNrSXNFbXB0eSIsInJlc2V0U3RhY2tBZnRlckZhdGFsRXJyb3JJbkRldiIsIndhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCIsImVtcHR5Q29udGV4dE9iamVjdCIsImNvbnRleHRTdGFja0N1cnNvciIsImRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IiLCJwcmV2aW91c0NvbnRleHQiLCJnZXRVbm1hc2tlZENvbnRleHQiLCJkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIiLCJpc0NvbnRleHRQcm92aWRlciIsImNhY2hlQ29udGV4dCIsInVubWFza2VkQ29udGV4dCIsIm1hc2tlZENvbnRleHQiLCJnZXRNYXNrZWRDb250ZXh0IiwiaGFzQ29udGV4dENoYW5nZWQiLCJwb3BDb250ZXh0IiwicG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0IiwicHVzaFRvcExldmVsQ29udGV4dE9iamVjdCIsImRpZENoYW5nZSIsInByb2Nlc3NDaGlsZENvbnRleHQiLCJwYXJlbnRDb250ZXh0IiwiY2hpbGRDb250ZXh0IiwiY29udGV4dEtleSIsInB1c2hDb250ZXh0UHJvdmlkZXIiLCJtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCIsImludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIiLCJtZXJnZWRDb250ZXh0IiwiZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQiLCJfQ29tcG9uZW50IiwiaGFzTG9nZ2VkRXJyb3IiLCJjYXRjaEVycm9ycyIsImlzRGV2VG9vbHNQcmVzZW50IiwiaW5qZWN0SW50ZXJuYWxzIiwiaW50ZXJuYWxzIiwiaG9vayIsInJlbmRlcmVySUQiLCJvbkNvbW1pdFJvb3QiLCJvbkNvbW1pdFVubW91bnQiLCJtYXhTaWduZWQzMUJpdEludCIsIk5vV29yayIsIlN5bmMiLCJOZXZlciIsIlVOSVRfU0laRSIsIk1BR0lDX05VTUJFUl9PRkZTRVQiLCJtc1RvRXhwaXJhdGlvblRpbWUiLCJtcyIsImV4cGlyYXRpb25UaW1lVG9NcyIsImNlaWxpbmciLCJudW0iLCJwcmVjaXNpb24iLCJjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldCIsImV4cGlyYXRpb25Jbk1zIiwiYnVja2V0U2l6ZU1zIiwiTE9XX1BSSU9SSVRZX0VYUElSQVRJT04iLCJMT1dfUFJJT1JJVFlfQkFUQ0hfU0laRSIsImNvbXB1dGVBc3luY0V4cGlyYXRpb24iLCJISUdIX1BSSU9SSVRZX0VYUElSQVRJT04iLCJISUdIX1BSSU9SSVRZX0JBVENIX1NJWkUiLCJjb21wdXRlSW50ZXJhY3RpdmVFeHBpcmF0aW9uIiwiTm9Db250ZXh0IiwiQXN5bmNNb2RlIiwiUHJvZmlsZU1vZGUiLCJoYXNCYWRNYXBQb2x5ZmlsbCIsIm5vbkV4dGVuc2libGVPYmplY3QiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsInRlc3RNYXAiLCJ0ZXN0U2V0IiwiZGVidWdDb3VudGVyIiwiRmliZXJOb2RlIiwiYWN0dWFsRHVyYXRpb24iLCJhY3R1YWxTdGFydFRpbWUiLCJzZWxmQmFzZUR1cmF0aW9uIiwidHJlZUJhc2VEdXJhdGlvbiIsImNyZWF0ZUZpYmVyIiwic2hvdWxkQ29uc3RydWN0IiwicmVzb2x2ZUxhenlDb21wb25lbnRUYWciLCJjcmVhdGVXb3JrSW5Qcm9ncmVzcyIsImNyZWF0ZUhvc3RSb290RmliZXIiLCJpc0FzeW5jIiwiY3JlYXRlRmliZXJGcm9tRWxlbWVudCIsImZpYmVyVGFnIiwiZ2V0VGFnIiwiY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQiLCJjcmVhdGVGaWJlckZyb21Qcm9maWxlciIsImVsZW1lbnRzIiwib25SZW5kZXIiLCJjcmVhdGVGaWJlckZyb21UZXh0IiwiY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24iLCJjcmVhdGVGaWJlckZyb21Qb3J0YWwiLCJwb3J0YWwiLCJhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFViIsImNyZWF0ZUZpYmVyUm9vdCIsInVuaW5pdGlhbGl6ZWRGaWJlciIsImludGVyYWN0aW9uVGhyZWFkSUQiLCJ1bnN0YWJsZV9nZXRUaHJlYWRJRCIsIm1lbW9pemVkSW50ZXJhY3Rpb25zIiwicGVuZGluZ0ludGVyYWN0aW9uTWFwIiwiUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MiLCJkaXNjYXJkUGVuZGluZ1dhcm5pbmdzIiwiZmx1c2hQZW5kaW5nRGVwcmVjYXRpb25XYXJuaW5ncyIsImZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzIiwicmVjb3JkRGVwcmVjYXRpb25XYXJuaW5ncyIsInJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzIiwicmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmciLCJmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nIiwiTElGRUNZQ0xFX1NVR0dFU1RJT05TIiwicGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyIsInBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MiLCJwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MiLCJwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmciLCJkaWRXYXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcyIsImRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMiLCJkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0Iiwic2V0VG9Tb3J0ZWRTdHJpbmciLCJzb3J0IiwibGlmZWN5Y2xlV2FybmluZ3NNYXAiLCJzdHJpY3RSb290IiwibGlmZWN5Y2xlc1dhcm5pbmdNZXNhZ2VzIiwibGlmZWN5Y2xlIiwibGlmZWN5Y2xlV2FybmluZ3MiLCJjb21wb25lbnROYW1lcyIsImZvcm1hdHRlZCIsInN1Z2dlc3Rpb24iLCJzb3J0ZWRDb21wb25lbnROYW1lcyIsInN0cmljdFJvb3RDb21wb25lbnRTdGFjayIsImZpbmRTdHJpY3RSb290IiwibWF5YmVTdHJpY3RSb290IiwidW5pcXVlTmFtZXMiLCJzb3J0ZWROYW1lcyIsIl91bmlxdWVOYW1lcyIsIl9zb3J0ZWROYW1lcyIsIl91bmlxdWVOYW1lczIiLCJfc29ydGVkTmFtZXMyIiwiX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyIsIndhcm5pbmdzRm9yUm9vdCIsInVuc2FmZUxpZmVjeWNsZXMiLCJmaWJlckFycmF5IiwiUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiIsImRlYnVnVG9vbCIsIlJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSIsIm1hcmtQZW5kaW5nUHJpb3JpdHlMZXZlbCIsImZpbmROZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbiIsIm1hcmtDb21taXR0ZWRQcmlvcml0eUxldmVscyIsImVhcmxpZXN0UmVtYWluaW5nVGltZSIsImhhc0xvd2VyUHJpb3JpdHlXb3JrIiwiZXJyb3JlZEV4cGlyYXRpb25UaW1lIiwiaXNQcmlvcml0eUxldmVsU3VzcGVuZGVkIiwibWFya1N1c3BlbmRlZFByaW9yaXR5TGV2ZWwiLCJzdXNwZW5kZWRUaW1lIiwiY2xlYXJQaW5nIiwibWFya1BpbmdlZFByaW9yaXR5TGV2ZWwiLCJwaW5nZWRUaW1lIiwiY29tcGxldGVkVGltZSIsImZpbmRFYXJsaWVzdE91dHN0YW5kaW5nUHJpb3JpdHlMZXZlbCIsInJlbmRlckV4cGlyYXRpb25UaW1lIiwiZWFybGllc3RFeHBpcmF0aW9uVGltZSIsImRpZEV4cGlyZUF0RXhwaXJhdGlvblRpbWUiLCJjb21wbGV0ZWRFeHBpcmF0aW9uVGltZSIsIlVwZGF0ZVN0YXRlIiwiUmVwbGFjZVN0YXRlIiwiRm9yY2VVcGRhdGUiLCJDYXB0dXJlVXBkYXRlIiwiaGFzRm9yY2VVcGRhdGUiLCJkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlIiwiY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlIiwicmVzZXRDdXJyZW50bHlQcm9jZXNzaW5nUXVldWUiLCJjcmVhdGVVcGRhdGVRdWV1ZSIsImNsb25lVXBkYXRlUXVldWUiLCJjcmVhdGVVcGRhdGUiLCJhcHBlbmRVcGRhdGVUb1F1ZXVlIiwidXBkYXRlIiwiZW5xdWV1ZVVwZGF0ZSIsInF1ZXVlMSIsInF1ZXVlMiIsImVucXVldWVDYXB0dXJlZFVwZGF0ZSIsIndvcmtJblByb2dyZXNzUXVldWUiLCJlbnN1cmVXb3JrSW5Qcm9ncmVzc1F1ZXVlSXNBQ2xvbmUiLCJnZXRTdGF0ZUZyb21VcGRhdGUiLCJwcmV2U3RhdGUiLCJfcGF5bG9hZCIsIl9wYXlsb2FkMiIsInByb2Nlc3NVcGRhdGVRdWV1ZSIsIm5ld0Jhc2VTdGF0ZSIsIm5ld0ZpcnN0VXBkYXRlIiwibmV3RXhwaXJhdGlvblRpbWUiLCJyZXN1bHRTdGF0ZSIsInVwZGF0ZUV4cGlyYXRpb25UaW1lIiwiX2NhbGxiYWNrIiwibmV3Rmlyc3RDYXB0dXJlZFVwZGF0ZSIsIl91cGRhdGVFeHBpcmF0aW9uVGltZSIsIl9jYWxsYmFjazIiLCJyZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZyIsImNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmciLCJjb21taXRVcGRhdGVRdWV1ZSIsImZpbmlzaGVkUXVldWUiLCJjb21taXRVcGRhdGVFZmZlY3RzIiwiZWZmZWN0IiwiX2NhbGxiYWNrMyIsImNyZWF0ZUNhcHR1cmVkVmFsdWUiLCJ2YWx1ZUN1cnNvciIsInJlbmRlcmVyU2lnaWwiLCJjdXJyZW50bHlSZW5kZXJpbmdGaWJlciIsImxhc3RDb250ZXh0RGVwZW5kZW5jeSIsImxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCIsInJlc2V0Q29udGV4dERlcGVuZGVuY2VzIiwicHVzaFByb3ZpZGVyIiwicHJvdmlkZXJGaWJlciIsInBvcFByb3ZpZGVyIiwib2xkVmFsdWUiLCJjaGFuZ2VkQml0cyIsInByb3BhZ2F0ZUNvbnRleHRDaGFuZ2UiLCJuZXh0RmliZXIiLCJwcmVwYXJlVG9SZWFkQ29udGV4dCIsInJlc29sdmVkT2JzZXJ2ZWRCaXRzIiwiY29udGV4dEl0ZW0iLCJOT19DT05URVhUIiwiY29udGV4dFN0YWNrQ3Vyc29yJDEiLCJjb250ZXh0RmliZXJTdGFja0N1cnNvciIsInJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yIiwicmVxdWlyZWRDb250ZXh0IiwiZ2V0Um9vdEhvc3RDb250YWluZXIiLCJyb290SW5zdGFuY2UiLCJwdXNoSG9zdENvbnRhaW5lciIsIm5leHRSb290SW5zdGFuY2UiLCJuZXh0Um9vdENvbnRleHQiLCJwb3BIb3N0Q29udGFpbmVyIiwiZ2V0SG9zdENvbnRleHQiLCJwdXNoSG9zdENvbnRleHQiLCJwb3BIb3N0Q29udGV4dCIsImNvbW1pdFRpbWUiLCJwcm9maWxlclN0YXJ0VGltZSIsImdldENvbW1pdFRpbWUiLCJyZWNvcmRDb21taXRUaW1lIiwic3RhcnRQcm9maWxlclRpbWVyIiwic3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmciLCJzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhIiwib3ZlcnJpZGVCYXNlVGltZSIsImZha2VJbnRlcm5hbEluc3RhbmNlIiwiZW1wdHlSZWZzT2JqZWN0IiwiZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50IiwiZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlIiwiZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlIiwiZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSIsImRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSIsIndhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZSIsIndhcm5PbkludmFsaWRDYWxsYmFjayQxIiwiZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUiLCJkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2siLCJhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImNsYXNzQ29tcG9uZW50VXBkYXRlciIsInJlcXVlc3RDdXJyZW50VGltZSIsImNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIiLCJzY2hlZHVsZVdvcmsiLCJjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSIsIm9sZFN0YXRlIiwibmV3U3RhdGUiLCJuZXh0TGVnYWN5Q29udGV4dCIsInNob3VsZFVwZGF0ZSIsImNoZWNrQ2xhc3NJbnN0YW5jZSIsInJlbmRlclByZXNlbnQiLCJub0dldEluaXRpYWxTdGF0ZU9uRVM2IiwiZ2V0SW5pdGlhbFN0YXRlIiwibm9HZXREZWZhdWx0UHJvcHNPbkVTNiIsIm5vSW5zdGFuY2VQcm9wVHlwZXMiLCJub0luc3RhbmNlQ29udGV4dFR5cGVzIiwibm9Db21wb25lbnRTaG91bGRVcGRhdGUiLCJjb21wb25lbnRTaG91bGRVcGRhdGUiLCJub0NvbXBvbmVudERpZFVubW91bnQiLCJjb21wb25lbnREaWRVbm1vdW50Iiwibm9Db21wb25lbnREaWRSZWNlaXZlUHJvcHMiLCJjb21wb25lbnREaWRSZWNlaXZlUHJvcHMiLCJub0NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwibm9VbnNhZmVDb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJoYXNNdXRhdGVkUHJvcHMiLCJub0luc3RhbmNlRGVmYXVsdFByb3BzIiwibm9JbnN0YW5jZUdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIm5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2giLCJub1N0YXRpY0dldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiX3N0YXRlIiwiYWRvcHRDbGFzc0luc3RhbmNlIiwiX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSIsImNvbnN0cnVjdENsYXNzSW5zdGFuY2UiLCJpc0NvbnRleHRDb25zdW1lciIsImZvdW5kV2lsbE1vdW50TmFtZSIsImZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUiLCJmb3VuZFdpbGxVcGRhdGVOYW1lIiwiX2NvbXBvbmVudE5hbWUiLCJuZXdBcGlOYW1lIiwiY2FsbENvbXBvbmVudFdpbGxNb3VudCIsImNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwibW91bnRDbGFzc0luc3RhbmNlIiwicmVzdW1lTW91bnRDbGFzc0luc3RhbmNlIiwib2xkQ29udGV4dCIsIm5leHRMZWdhY3lVbm1hc2tlZENvbnRleHQiLCJoYXNOZXdMaWZlY3ljbGVzIiwidXBkYXRlQ2xhc3NJbnN0YW5jZSIsImRpZFdhcm5BYm91dEdlbmVyYXRvcnMiLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZJblN0cmljdE1vZGUiLCJvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmciLCJ3YXJuRm9yTWlzc2luZ0tleSIsImlzQXJyYXkkMSIsImNvZXJjZVJlZiIsInJldHVybkZpYmVyIiwiY3VycmVudCQkMSIsIm1peGVkUmVmIiwic3RyaW5nUmVmIiwidGhyb3dPbkludmFsaWRPYmplY3RUeXBlIiwibmV3Q2hpbGQiLCJ3YXJuT25GdW5jdGlvblR5cGUiLCJDaGlsZFJlY29uY2lsZXIiLCJzaG91bGRUcmFja1NpZGVFZmZlY3RzIiwiZGVsZXRlQ2hpbGQiLCJjaGlsZFRvRGVsZXRlIiwibGFzdCIsImRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuIiwiY3VycmVudEZpcnN0Q2hpbGQiLCJtYXBSZW1haW5pbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGRyZW4iLCJleGlzdGluZ0NoaWxkIiwidXNlRmliZXIiLCJjbG9uZSIsInBsYWNlQ2hpbGQiLCJuZXdGaWJlciIsImxhc3RQbGFjZWRJbmRleCIsIm5ld0luZGV4Iiwib2xkSW5kZXgiLCJwbGFjZVNpbmdsZUNoaWxkIiwidXBkYXRlVGV4dE5vZGUiLCJjcmVhdGVkIiwiZXhpc3RpbmciLCJ1cGRhdGVFbGVtZW50IiwidXBkYXRlUG9ydGFsIiwidXBkYXRlRnJhZ21lbnQiLCJjcmVhdGVDaGlsZCIsIl9jcmVhdGVkIiwiX2NyZWF0ZWQyIiwiX2NyZWF0ZWQzIiwidXBkYXRlU2xvdCIsIm9sZEZpYmVyIiwidXBkYXRlRnJvbU1hcCIsIm5ld0lkeCIsIm1hdGNoZWRGaWJlciIsIl9tYXRjaGVkRmliZXIiLCJfbWF0Y2hlZEZpYmVyMiIsIl9tYXRjaGVkRmliZXIzIiwid2Fybk9uSW52YWxpZEtleSIsImtub3duS2V5cyIsInJlY29uY2lsZUNoaWxkcmVuQXJyYXkiLCJuZXdDaGlsZHJlbiIsInJlc3VsdGluZ0ZpcnN0Q2hpbGQiLCJwcmV2aW91c05ld0ZpYmVyIiwibmV4dE9sZEZpYmVyIiwiX25ld0ZpYmVyIiwiX25ld0ZpYmVyMiIsInJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IiLCJuZXdDaGlsZHJlbkl0ZXJhYmxlIiwidG9TdHJpbmdUYWciLCJfbmV3Q2hpbGRyZW4iLCJfc3RlcCIsIl9uZXdGaWJlcjMiLCJfbmV3RmliZXI0IiwicmVjb25jaWxlU2luZ2xlVGV4dE5vZGUiLCJyZWNvbmNpbGVTaW5nbGVFbGVtZW50IiwiX2NyZWF0ZWQ0IiwicmVjb25jaWxlU2luZ2xlUG9ydGFsIiwicmVjb25jaWxlQ2hpbGRGaWJlcnMiLCJpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50IiwiaXNPYmplY3QiLCJfaXNNb2NrRnVuY3Rpb24iLCJtb3VudENoaWxkRmliZXJzIiwiY2xvbmVDaGlsZEZpYmVycyIsImN1cnJlbnRDaGlsZCIsImh5ZHJhdGlvblBhcmVudEZpYmVyIiwibmV4dEh5ZHJhdGFibGVJbnN0YW5jZSIsImVudGVySHlkcmF0aW9uU3RhdGUiLCJkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UiLCJpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlIiwiX3RleHQiLCJ0cnlIeWRyYXRlIiwibmV4dEluc3RhbmNlIiwidHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UiLCJmaXJzdEF0dGVtcHRlZEluc3RhbmNlIiwicHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSIsInByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIiwicG9wVG9OZXh0SG9zdFBhcmVudCIsInBvcEh5ZHJhdGlvblN0YXRlIiwicmVzZXRIeWRyYXRpb25TdGF0ZSIsInJlYWRMYXp5Q29tcG9uZW50VHlwZSIsInN0YXR1cyIsInJlc29sdmVkVmFsdWUiLCJkZWZhdWx0RXhwb3J0IiwiUmVhY3RDdXJyZW50T3duZXIkMyIsImRpZFdhcm5BYm91dEJhZENsYXNzIiwiZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbmFsQ29tcG9uZW50IiwiZGlkV2FybkFib3V0U3RhdGVsZXNzUmVmcyIsInJlY29uY2lsZUNoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwidXBkYXRlRm9yd2FyZFJlZiIsImN1cnJlbnRSZWYiLCJiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrIiwibWVtb2l6ZVByb3BzIiwidXBkYXRlTW9kZSIsInVwZGF0ZVByb2ZpbGVyIiwibWFya1JlZiIsInVwZGF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJ1cGRhdGVDbGFzc0NvbXBvbmVudCIsImhhc0NvbnRleHQiLCJmaW5pc2hDbGFzc0NvbXBvbmVudCIsImRpZENhcHR1cmVFcnJvciIsIm1lbW9pemVTdGF0ZSIsInB1c2hIb3N0Um9vdENvbnRleHQiLCJ1cGRhdGVIb3N0Um9vdCIsInByZXZDaGlsZHJlbiIsIm5leHRTdGF0ZSIsInVwZGF0ZUhvc3RDb21wb25lbnQiLCJpc0RpcmVjdFRleHRDaGlsZCIsInVwZGF0ZUhvc3RUZXh0IiwicmVzb2x2ZURlZmF1bHRQcm9wcyIsImJhc2VQcm9wcyIsIm1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsInJlc29sdmVkVGFnIiwicmVzb2x2ZWRQcm9wcyIsImRlYnVnU291cmNlIiwidXBkYXRlUGxhY2Vob2xkZXJDb21wb25lbnQiLCJhbHJlYWR5Q2FwdHVyZWQiLCJuZXh0RGlkVGltZW91dCIsImZhbGxiYWNrIiwidXBkYXRlUG9ydGFsQ29tcG9uZW50IiwidXBkYXRlQ29udGV4dFByb3ZpZGVyIiwicHJvdmlkZXJUeXBlIiwicHJvdmlkZXJQcm9wVHlwZXMiLCJ1cGRhdGVDb250ZXh0Q29uc3VtZXIiLCJiZWdpbldvcmsiLCJfQ29tcG9uZW50MyIsIl9Db21wb25lbnQ0IiwiX3VucmVzb2x2ZWRQcm9wcyIsIl90aGVuYWJsZTIiLCJfQ29tcG9uZW50NSIsIl91bnJlc29sdmVkUHJvcHMyIiwiX0NvbXBvbmVudDYiLCJfdW5yZXNvbHZlZFByb3BzMyIsIl90aGVuYWJsZTMiLCJfQ29tcG9uZW50NyIsIl91bnJlc29sdmVkUHJvcHM0IiwiX2NoaWxkMiIsIl90aGVuYWJsZSIsIl9Db21wb25lbnQyIiwidW5yZXNvbHZlZFByb3BzIiwibWFya1VwZGF0ZSIsIm1hcmtSZWYkMSIsImFwcGVuZEFsbENoaWxkcmVuIiwidXBkYXRlSG9zdENvbnRhaW5lciIsInVwZGF0ZUhvc3RDb21wb25lbnQkMSIsInVwZGF0ZUhvc3RUZXh0JDEiLCJjdXJyZW50SG9zdENvbnRleHQiLCJhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyIiwiY29udGFpbmVyQ2hpbGRTZXQiLCJwb3J0YWxPclJvb3QiLCJjaGlsZHJlblVuY2hhbmdlZCIsIm5ld0NoaWxkU2V0IiwiY3VycmVudEluc3RhbmNlIiwicmVjeWNsYWJsZUluc3RhbmNlIiwibmV3SW5zdGFuY2UiLCJjb21wbGV0ZVdvcmsiLCJmaWJlclJvb3QiLCJ3YXNIeWRyYXRlZCIsIl9yb290Q29udGFpbmVySW5zdGFuY2UiLCJfY3VycmVudEhvc3RDb250ZXh0IiwiX3dhc0h5ZHJhdGVkIiwic2hvd0Vycm9yRGlhbG9nIiwiY2FwdHVyZWRFcnJvciIsImxvZ0NhcHR1cmVkRXJyb3IiLCJsb2dFcnJvciIsImVycm9yQm91bmRhcnlOYW1lIiwiZXJyb3JCb3VuZGFyeUZvdW5kIiwid2lsbFJldHJ5IiwiY29tcG9uZW50TmFtZU1lc3NhZ2UiLCJlcnJvckJvdW5kYXJ5TWVzc2FnZSIsImNvbWJpbmVkTWVzc2FnZSIsImRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiYm91bmRhcnkiLCJlcnJvckluZm8iLCJlcnJvckJvdW5kYXJ5IiwiY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyIiwic2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50IiwidW5tb3VudEVycm9yIiwiY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IiLCJzYWZlbHlEZXRhY2hSZWYiLCJyZWZFcnJvciIsImNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyIsInNuYXBzaG90IiwiZGlkV2FyblNldCIsImNvbW1pdExpZmVDeWNsZXMiLCJmaW5pc2hlZFJvb3QiLCJjb21taXR0ZWRFeHBpcmF0aW9uVGltZSIsIl91cGRhdGVRdWV1ZSIsIl9pbnN0YW5jZSIsIl9pbnN0YW5jZTIiLCJ0aW1lZE91dEF0IiwiY29tbWl0QXR0YWNoUmVmIiwiaW5zdGFuY2VUb1VzZSIsImNvbW1pdERldGFjaFJlZiIsImNvbW1pdFVubW91bnQiLCJ1bm1vdW50SG9zdENvbXBvbmVudHMiLCJlbXB0eVBvcnRhbENvbnRhaW5lciIsImNvbW1pdE5lc3RlZFVubW91bnRzIiwiZGV0YWNoRmliZXIiLCJlbXB0eUNoaWxkU2V0IiwiY29tbWl0Q29udGFpbmVyIiwiX3BlbmRpbmdDaGlsZHJlbiIsImdldEhvc3RQYXJlbnRGaWJlciIsImlzSG9zdFBhcmVudCIsImdldEhvc3RTaWJsaW5nIiwic2libGluZ3MiLCJjb21taXRQbGFjZW1lbnQiLCJwYXJlbnRGaWJlciIsImlzQ29udGFpbmVyIiwiYmVmb3JlIiwiY3VycmVudFBhcmVudElzVmFsaWQiLCJjdXJyZW50UGFyZW50SXNDb250YWluZXIiLCJmaW5kUGFyZW50IiwiY29tbWl0RGVsZXRpb24iLCJjb21taXRXb3JrIiwiY29tbWl0UmVzZXRUZXh0Q29udGVudCIsIk5vb3BDb21wb25lbnQiLCJjcmVhdGVSb290RXJyb3JVcGRhdGUiLCJvblVuY2F1Z2h0RXJyb3IiLCJjcmVhdGVDbGFzc0Vycm9yVXBkYXRlIiwibWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZCIsInRocm93RXhjZXB0aW9uIiwic291cmNlRmliZXIiLCJfd29ya0luUHJvZ3Jlc3MiLCJlYXJsaWVzdFRpbWVvdXRNcyIsInN0YXJ0VGltZU1zIiwidGltZW91dFByb3BNcyIsImRlbGF5TXMiLCJwaW5nVGltZSIsIm9uUmVzb2x2ZU9yUmVqZWN0IiwicmV0cnlTdXNwZW5kZWRSb290IiwiYWJzb2x1dGVUaW1lb3V0TXMiLCJlYXJsaWVzdEV4cGlyYXRpb25UaW1lTXMiLCJyZW5kZXJEaWRTdXNwZW5kIiwicmVuZGVyRGlkRXJyb3IiLCJfZXJyb3JJbmZvIiwiaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeSIsIl91cGRhdGUiLCJ1bndpbmRXb3JrIiwiX2VmZmVjdFRhZyIsIl9lZmZlY3RUYWcyIiwiX2VmZmVjdFRhZzMiLCJ1bndpbmRJbnRlcnJ1cHRlZFdvcmsiLCJpbnRlcnJ1cHRlZFdvcmsiLCJfY2hpbGRDb250ZXh0VHlwZXMiLCJEaXNwYXRjaGVyIiwiUmVhY3RDdXJyZW50T3duZXIkMiIsImRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiIsImRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCIsIndhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkIiwid2FybkFib3V0SW52YWxpZFVwZGF0ZXMiLCJfX2ludGVyYWN0aW9uc1JlZiIsImxhc3RVbmlxdWVBc3luY0V4cGlyYXRpb24iLCJleHBpcmF0aW9uQ29udGV4dCIsImlzV29ya2luZyIsIm5leHRSb290IiwibmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIiwibmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zIiwibmV4dFJlbmRlckRpZEVycm9yIiwiaXNDb21taXR0aW5nJDEiLCJsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCIsInN1c3BlbnNlRGlkVGltZW91dCIsInN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMiLCJyZXBsYXlVbml0T2ZXb3JrIiwiaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrIiwib3JpZ2luYWxSZXBsYXlFcnJvciIsInJldGhyb3dPcmlnaW5hbEVycm9yIiwiZmFpbGVkVW5pdE9mV29yayIsInRocm93blZhbHVlIiwiaXNZaWVsZHkiLCJ3b3JrTG9vcCIsInJlcGxheUVycm9yIiwicmVzZXRTdGFjayIsImNvbW1pdEFsbEhvc3RFZmZlY3RzIiwicHJpbWFyeUVmZmVjdFRhZyIsIl9jdXJyZW50IiwiX2N1cnJlbnQyIiwiY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlY3ljbGVzIiwiY29tbWl0QWxsTGlmZUN5Y2xlcyIsImNvbW1pdFJvb3QiLCJ1cGRhdGVFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdCIsImNoaWxkRXhwaXJhdGlvblRpbWVCZWZvcmVDb21taXQiLCJlYXJsaWVzdFJlbWFpbmluZ1RpbWVCZWZvcmVDb21taXQiLCJwcmV2SW50ZXJhY3Rpb25zIiwiY29tbWl0dGVkSW50ZXJhY3Rpb25zIiwic2NoZWR1bGVkSW50ZXJhY3Rpb25zIiwic2NoZWR1bGVkRXhwaXJhdGlvblRpbWUiLCJfZGlkRXJyb3IiLCJfZXJyb3IiLCJfZGlkRXJyb3IyIiwiX2Vycm9yMiIsIm9uQ29tbWl0V29yayIsInVwZGF0ZUV4cGlyYXRpb25UaW1lQWZ0ZXJDb21taXQiLCJjaGlsZEV4cGlyYXRpb25UaW1lQWZ0ZXJDb21taXQiLCJlYXJsaWVzdFJlbWFpbmluZ1RpbWVBZnRlckNvbW1pdCIsIm9uQ29tbWl0Iiwic3Vic2NyaWJlciIsIl9fc3Vic2NyaWJlclJlZiIsInRocmVhZElEIiwiY29tcHV0ZVRocmVhZElEIiwib25Xb3JrU3RvcHBlZCIsImhhc1VuaGFuZGxlZEVycm9yIiwidW5oYW5kbGVkRXJyb3IiLCJpbnRlcmFjdGlvbiIsIl9fY291bnQiLCJvbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZCIsInJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSIsInJlbmRlclRpbWUiLCJuZXdDaGlsZEV4cGlyYXRpb25UaW1lIiwic2hvdWxkQnViYmxlQWN0dWFsRHVyYXRpb25zIiwiY2hpbGRVcGRhdGVFeHBpcmF0aW9uVGltZSIsImNoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZSIsIl9jaGlsZFVwZGF0ZUV4cGlyYXRpb25UaW1lIiwiX2NoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZSIsImNvbXBsZXRlVW5pdE9mV29yayIsInNpYmxpbmdGaWJlciIsIm9uQ29tcGxldGVXb3JrIiwicGVyZm9ybVVuaXRPZldvcmsiLCJvbkJlZ2luV29yayIsInNob3VsZFlpZWxkIiwicmVuZGVyUm9vdCIsImlzRXhwaXJlZCIsImludGVyYWN0aW9ucyIsIm9uV29ya1N0YXJ0ZWQiLCJkaWRGYXRhbCIsIl9kaWRDb21wbGV0ZVJvb3QiLCJvbkZhdGFsIiwiX2RpZENvbXBsZXRlUm9vdDIiLCJvbllpZWxkIiwicm9vdFdvcmtJblByb2dyZXNzIiwic3VzcGVuZGVkRXhwaXJhdGlvblRpbWUiLCJyb290RXhwaXJhdGlvblRpbWUiLCJvblN1c3BlbmQiLCJfc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUiLCJfcm9vdEV4cGlyYXRpb25UaW1lIiwiX3N1c3BlbmRlZEV4cGlyYXRpb25UaW1lMiIsImN1cnJlbnRUaW1lTXMiLCJtc1VudGlsVGltZW91dCIsIl9yb290RXhwaXJhdGlvblRpbWUyIiwib25Db21wbGV0ZSIsInJvb3RGaWJlciIsIl9lcnJvckluZm8yIiwiX3VwZGF0ZTIiLCJjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uIiwiaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcyIsImxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUiLCJyZXRyeVRpbWUiLCJzY2hlZHVsZVdvcmtUb1Jvb3QiLCJzdG9yZUludGVyYWN0aW9uc0ZvckV4cGlyYXRpb25UaW1lIiwicmVxdWVzdFdvcmsiLCJ1cGRhdGVJbnRlcmFjdGlvbkNvdW50cyIsInBlbmRpbmdJbnRlcmFjdGlvbnMiLCJvbldvcmtTY2hlZHVsZWQiLCJuZXN0ZWRVcGRhdGVDb3VudCIsIk5FU1RFRF9VUERBVEVfTElNSVQiLCJzeW5jVXBkYXRlcyIsInByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQiLCJmaXJzdFNjaGVkdWxlZFJvb3QiLCJsYXN0U2NoZWR1bGVkUm9vdCIsImNhbGxiYWNrRXhwaXJhdGlvblRpbWUiLCJjYWxsYmFja0lEIiwiaXNSZW5kZXJpbmciLCJuZXh0Rmx1c2hlZFJvb3QiLCJuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lIiwiZGVhZGxpbmVEaWRFeHBpcmUiLCJkZWFkbGluZSIsImlzQmF0Y2hpbmdVcGRhdGVzIiwiaXNVbmJhdGNoaW5nVXBkYXRlcyIsImNvbXBsZXRlZEJhdGNoZXMiLCJvcmlnaW5hbFN0YXJ0VGltZU1zIiwiY3VycmVudFJlbmRlcmVyVGltZSIsImN1cnJlbnRTY2hlZHVsZXJUaW1lIiwibGFzdENvbW1pdHRlZFJvb3REdXJpbmdUaGlzQmF0Y2giLCJ0aW1lSGV1cmlzdGljRm9yVW5pdE9mV29yayIsInJlY29tcHV0ZUN1cnJlbnRSZW5kZXJlclRpbWUiLCJzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb25UaW1lIiwiY3VycmVudE1zIiwiZXhwaXJhdGlvblRpbWVNcyIsInBlcmZvcm1Bc3luY1dvcmsiLCJvblRpbWVvdXQiLCJmbHVzaFJvb3QiLCJmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCIsImFkZFJvb3RUb1NjaGVkdWxlIiwicGVyZm9ybVdvcmtPblJvb3QiLCJwZXJmb3JtU3luY1dvcmsiLCJyZW1haW5pbmdFeHBpcmF0aW9uVGltZSIsImhpZ2hlc3RQcmlvcml0eVdvcmsiLCJoaWdoZXN0UHJpb3JpdHlSb290IiwicHJldmlvdXNTY2hlZHVsZWRSb290IiwiZGwiLCJwZXJmb3JtV29yayIsIm1pbkV4cGlyYXRpb25UaW1lIiwiZmluaXNoUmVuZGVyaW5nIiwiYmF0Y2hlcyIsImJhdGNoIiwiY29tcGxldGVSb290IiwiX2ZpbmlzaGVkV29yayIsIl90aW1lb3V0SGFuZGxlIiwiX2lzWWllbGR5IiwiYmF0Y2hlZFVwZGF0ZXMkMSIsInByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMiLCJ1bmJhdGNoZWRVcGRhdGVzIiwiaW50ZXJhY3RpdmVVcGRhdGVzJDEiLCJwcmV2aW91c0lzQmF0Y2hpbmdJbnRlcmFjdGl2ZVVwZGF0ZXMiLCJmbHVzaEludGVyYWN0aXZlVXBkYXRlcyQxIiwiZmx1c2hDb250cm9sbGVkIiwiZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyIsImdldENvbnRleHRGb3JTdWJ0cmVlIiwicGFyZW50Q29tcG9uZW50Iiwic2NoZWR1bGVSb290VXBkYXRlIiwidXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZSIsIm9uTW91bnRDb250YWluZXIiLCJvblVubW91bnRDb250YWluZXIiLCJvblVwZGF0ZUNvbnRhaW5lciIsImZpbmRIb3N0SW5zdGFuY2UiLCJob3N0RmliZXIiLCJjcmVhdGVDb250YWluZXIiLCJ1cGRhdGVDb250YWluZXIiLCJnZXRQdWJsaWNSb290SW5zdGFuY2UiLCJjb250YWluZXJGaWJlciIsImZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzIiwiaW5qZWN0SW50b0RldlRvb2xzIiwiZGV2VG9vbHNDb25maWciLCJjcmVhdGVQb3J0YWwkMSIsInRvcExldmVsVXBkYXRlV2FybmluZ3MiLCJ3YXJuT25JbnZhbGlkQ2FsbGJhY2siLCJkaWRXYXJuQWJvdXRVbnN0YWJsZUNyZWF0ZVBvcnRhbCIsImhvc3RJbnN0YW5jZSIsImlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QiLCJyb290RWwiLCJnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIiLCJoYXNOb25Sb290UmVhY3RDaGlsZCIsIlJlYWN0QmF0Y2giLCJpbnRlcm5hbFJvb3QiLCJ3b3JrIiwiUmVhY3RXb3JrIiwiY2FsbGJhY2tzIiwiUmVhY3RSb290IiwiaW5zZXJ0QWZ0ZXIiLCJpc1ZhbGlkQ29udGFpbmVyIiwic2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljIiwicm9vdEVsZW1lbnQiLCJ3YXJuZWRBYm91dEh5ZHJhdGVBUEkiLCJsZWdhY3lDcmVhdGVSb290RnJvbURPTUNvbnRhaW5lciIsImZvcmNlSHlkcmF0ZSIsInNob3VsZEh5ZHJhdGUiLCJ3YXJuZWQiLCJyb290U2libGluZyIsImxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwib3JpZ2luYWxDYWxsYmFjayIsIl9vcmlnaW5hbENhbGxiYWNrIiwiUmVhY3RET00iLCJjb21wb25lbnRPckVsZW1lbnQiLCJ3YXJuZWRBYm91dFJlZnNJblJlbmRlciIsImNvbnRhaW5lck5vZGUiLCJyZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QiLCJfcm9vdEVsIiwiaXNDb250YWluZXJSZWFjdFJvb3QiLCJjcmVhdGVSb290IiwiZm91bmREZXZUb29scyIsInByb3RvY29sIiwiUmVhY3RET00kMiIsIlJlYWN0RE9NJDMiLCJyZWFjdERvbSIsInVuc3RhYmxlX2NsZWFyIiwidW5zdGFibGVfZ2V0Q3VycmVudCIsInVuc3RhYmxlX3RyYWNlIiwidW5zdGFibGVfd3JhcCIsInVuc3RhYmxlX3N1YnNjcmliZSIsInVuc3RhYmxlX3Vuc3Vic2NyaWJlIiwiREVGQVVMVF9USFJFQURfSUQiLCJpbnRlcmFjdGlvbklEQ291bnRlciIsInRocmVhZElEQ291bnRlciIsIm9uSW50ZXJhY3Rpb25UcmFjZWQiLCJ3cmFwcGVkSW50ZXJhY3Rpb25zIiwiaGFzUnVuIiwid3JhcHBlZCIsImNhbmNlbCIsIm9uV29ya0NhbmNlbGVkIiwic3Vic2NyaWJlcnMiLCJkaWRDYXRjaEVycm9yIiwiQXBwIiwicm91dGVzIiwiSG9tZSIsIkxhbmd1YWdlcyIsIlJlcG9HcmlkIiwibG9hZERhdGEiLCJVc2VycyIsIlVzZXJHcmlkIiwiZm9yY2VSZWZyZXNoIiwiZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCIsIklURVJBVE9SX1NZTUJPTCIsIkFOT05ZTU9VUyIsIlJlYWN0UHJvcFR5cGVzIiwiY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIiLCJzeW1ib2wiLCJhbnkiLCJjcmVhdGVBbnlUeXBlQ2hlY2tlciIsImFycmF5T2YiLCJjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIiLCJjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIiLCJpbnN0YW5jZU9mIiwiY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlciIsImNyZWF0ZU5vZGVDaGVja2VyIiwib2JqZWN0T2YiLCJjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyIiwib25lT2YiLCJjcmVhdGVFbnVtVHlwZUNoZWNrZXIiLCJjcmVhdGVVbmlvblR5cGVDaGVja2VyIiwiY3JlYXRlU2hhcGVUeXBlQ2hlY2tlciIsImNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIiLCJQcm9wVHlwZUVycm9yIiwiY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIiLCJ2YWxpZGF0ZSIsIm1hbnVhbFByb3BUeXBlQ2FsbENhY2hlIiwibWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQiLCJjaGVja1R5cGUiLCJwcm9wRnVsbE5hbWUiLCJzZWNyZXQiLCJjaGFpbmVkQ2hlY2tUeXBlIiwiZXhwZWN0ZWRUeXBlIiwicHJvcFR5cGUiLCJnZXRQcm9wVHlwZSIsInByZWNpc2VUeXBlIiwiZ2V0UHJlY2lzZVR5cGUiLCJ0eXBlQ2hlY2tlciIsImV4cGVjdGVkQ2xhc3MiLCJleHBlY3RlZENsYXNzTmFtZSIsImFjdHVhbENsYXNzTmFtZSIsImdldENsYXNzTmFtZSIsImV4cGVjdGVkVmFsdWVzIiwidmFsdWVzU3RyaW5nIiwiYXJyYXlPZlR5cGVDaGVja2VycyIsImNoZWNrZXIiLCJnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmciLCJpc05vZGUiLCJzaGFwZVR5cGVzIiwiYWxsS2V5cyIsImV2ZXJ5IiwiZW50cnkiLCJpc1N5bWJvbCIsImVtcHR5RnVuY3Rpb24iLCJnZXRTaGltIiwiaXNBYnNvbHV0ZSIsInNwbGljZU9uZSIsInJlc29sdmVQYXRobmFtZSIsInRvUGFydHMiLCJmcm9tUGFydHMiLCJpc1RvQWJzIiwiaXNGcm9tQWJzIiwibXVzdEVuZEFicyIsImhhc1RyYWlsaW5nU2xhc2giLCJ1cCIsInBhcnQiLCJ1bnNoaWZ0IiwiX3R5cGVvZiIsInZhbHVlRXF1YWwiLCJhVHlwZSIsImJUeXBlIiwiYVZhbHVlIiwidmFsdWVPZiIsImJWYWx1ZSIsImFLZXlzIiwiYktleXMiLCJQb3BTdGF0ZUV2ZW50IiwiSGFzaENoYW5nZUV2ZW50IiwiZ2V0SGlzdG9yeVN0YXRlIiwiZ2xvYmFsSGlzdG9yeSIsImNhblVzZUhpc3RvcnkiLCJuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lciIsIl9wcm9wcyRmb3JjZVJlZnJlc2giLCJfcHJvcHMkZ2V0VXNlckNvbmZpcm0iLCJfcHJvcHMka2V5TGVuZ3RoIiwiZ2V0RE9NTG9jYXRpb24iLCJoaXN0b3J5U3RhdGUiLCJfd2luZG93JGxvY2F0aW9uIiwiY3JlYXRlS2V5IiwidHJhbnNpdGlvbk1hbmFnZXIiLCJoYW5kbGVQb3BTdGF0ZSIsImhhbmRsZVBvcCIsImhhbmRsZUhhc2hDaGFuZ2UiLCJmb3JjZU5leHRQb3AiLCJvayIsInJldmVydFBvcCIsImZyb21Mb2NhdGlvbiIsInRvTG9jYXRpb24iLCJ0b0luZGV4IiwiZnJvbUluZGV4IiwiZGVsdGEiLCJpbml0aWFsTG9jYXRpb24iLCJwdXNoU3RhdGUiLCJwcmV2SW5kZXgiLCJuZXh0S2V5cyIsImxpc3RlbmVyQ291bnQiLCJjaGVja0RPTUxpc3RlbmVycyIsImlzQmxvY2tlZCIsIkhhc2hQYXRoQ29kZXJzIiwiaGFzaGJhbmciLCJlbmNvZGVQYXRoIiwiZGVjb2RlUGF0aCIsIm5vc2xhc2giLCJzbGFzaCIsImdldEhhc2hQYXRoIiwicHVzaEhhc2hQYXRoIiwicmVwbGFjZUhhc2hQYXRoIiwiY2FuR29XaXRob3V0UmVsb2FkIiwiX3Byb3BzJGhhc2hUeXBlIiwiaGFzaFR5cGUiLCJfSGFzaFBhdGhDb2RlcnMkaGFzaFQiLCJpZ25vcmVQYXRoIiwiZW5jb2RlZFBhdGgiLCJwcmV2TG9jYXRpb24iLCJhbGxQYXRocyIsImxhc3RJbmRleE9mIiwiaGFzaENoYW5nZWQiLCJuZXh0UGF0aHMiLCJjbGFtcCIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwiX3Byb3BzJGluaXRpYWxFbnRyaWVzIiwiX3Byb3BzJGluaXRpYWxJbmRleCIsIm5leHRJbmRleCIsIm5leHRFbnRyaWVzIiwic3BsaWNlIiwiY2FuR28iLCJhY3RpdmVDbGFzc05hbWUiLCJjbGFzc05hbWUiLCJhY3RpdmVTdHlsZSIsImdldElzQWN0aXZlIiwiYXJpYUN1cnJlbnQiLCJyZXN0IiwiZXNjYXBlZFBhdGgiLCJfcmVmMiIsIlJFQUNUX1NUQVRJQ1MiLCJtaXhpbnMiLCJLTk9XTl9TVEFUSUNTIiwiY2FsbGVyIiwiY2FsbGVlIiwiYXJpdHkiLCJnZXRQcm90b3R5cGVPZiIsIm9iamVjdFByb3RvdHlwZSIsImhvaXN0Tm9uUmVhY3RTdGF0aWNzIiwidGFyZ2V0Q29tcG9uZW50Iiwic291cmNlQ29tcG9uZW50IiwiYmxhY2tsaXN0IiwiaW5oZXJpdGVkQ29tcG9uZW50IiwibGFuZ3VhZ2VzIiwidXNlcnMiLCJfX2lzQnJvd3Nlcl9fIiwibG9hZGluZyIsImZldGNoUmVwb3MiLCJmbGV4V3JhcCIsInN0YXJnYXplcnNfY291bnQiLCJodG1sX3VybCIsIm1hcmdpbiIsImxvZ2luIiwiZmV0Y2giLCJIZWFkZXJzIiwiUmVxdWVzdCIsIlJlc3BvbnNlIiwic3VwcG9ydCIsInNlYXJjaFBhcmFtcyIsIml0ZXJhYmxlIiwiYmxvYiIsIkJsb2IiLCJmb3JtRGF0YSIsImFycmF5QnVmZmVyIiwiaXNEYXRhVmlldyIsIkRhdGFWaWV3IiwiaXNQcm90b3R5cGVPZiIsInZpZXdDbGFzc2VzIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsIm5vcm1hbGl6ZU5hbWUiLCJub3JtYWxpemVWYWx1ZSIsIml0ZXJhdG9yRm9yIiwic2hpZnQiLCJhcHBlbmQiLCJoZWFkZXIiLCJ0aGlzQXJnIiwiY29uc3VtZWQiLCJib2R5VXNlZCIsIlByb21pc2UiLCJmaWxlUmVhZGVyUmVhZHkiLCJyZWFkZXIiLCJvbmxvYWQiLCJvbmVycm9yIiwicmVhZEJsb2JBc0FycmF5QnVmZmVyIiwiRmlsZVJlYWRlciIsInByb21pc2UiLCJyZWFkQXNBcnJheUJ1ZmZlciIsInJlYWRCbG9iQXNUZXh0IiwicmVhZEFzVGV4dCIsInJlYWRBcnJheUJ1ZmZlckFzVGV4dCIsImJ1ZiIsIlVpbnQ4QXJyYXkiLCJidWZmZXJDbG9uZSIsImJ5dGVMZW5ndGgiLCJidWZmZXIiLCJCb2R5IiwiX2luaXRCb2R5IiwiX2JvZHlJbml0IiwiX2JvZHlUZXh0IiwiX2JvZHlCbG9iIiwiRm9ybURhdGEiLCJfYm9keUZvcm1EYXRhIiwiVVJMU2VhcmNoUGFyYW1zIiwiX2JvZHlBcnJheUJ1ZmZlciIsInJlamVjdGVkIiwiZGVjb2RlIiwibWV0aG9kcyIsIm5vcm1hbGl6ZU1ldGhvZCIsInVwY2FzZWQiLCJjcmVkZW50aWFscyIsInNpZ25hbCIsInJlZmVycmVyIiwiYnl0ZXMiLCJkZWNvZGVVUklDb21wb25lbnQiLCJwYXJzZUhlYWRlcnMiLCJyYXdIZWFkZXJzIiwicHJlUHJvY2Vzc2VkSGVhZGVycyIsImxpbmUiLCJib2R5SW5pdCIsInN0YXR1c1RleHQiLCJyZXNwb25zZSIsInJlZGlyZWN0U3RhdHVzZXMiLCJyZWRpcmVjdCIsIlJhbmdlRXJyb3IiLCJET01FeGNlcHRpb24iLCJpbml0IiwicmVxdWVzdCIsImFib3J0ZWQiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsImFib3J0WGhyIiwiYWJvcnQiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJyZXNwb25zZVVSTCIsInJlc3BvbnNlVGV4dCIsIm9udGltZW91dCIsIm9uYWJvcnQiLCJ3aXRoQ3JlZGVudGlhbHMiLCJyZXNwb25zZVR5cGUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsInNlbmQiLCJwb2x5ZmlsbCIsImdldFVzZXIiLCJhdmF0YXJfdXJsIiwiZm9sbG93ZXJzIiwiZm9sbG93aW5nIiwibWF0Y2hSb3V0ZXMiLCJicmFuY2giLCJzb21lIiwiY29tcHV0ZVJvb3RNYXRjaCIsInJlbmRlclJvdXRlcyIsImV4dHJhUHJvcHMiLCJzd2l0Y2hQcm9wcyJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQzdEQSwrQ0FBYTs7QUFFYixJQUFJQSxRQUFRQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNDLFNBQU9DLE9BQVAsR0FBaUJDLG1CQUFPQSxDQUFDLEVBQVIsQ0FBakI7QUFDRCxDQUZELE1BRU87QUFDTEYsU0FBT0MsT0FBUCxHQUFpQkMsbUJBQU9BLENBQUMsRUFBUixDQUFqQjtBQUNELEM7Ozs7Ozs7Ozs7QUNORDtBQUNBLElBQUlMLFVBQVVH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UUFFZUMsVSxHQUFmQyxvQjs7Ozs7Ozs7Ozs7O2tCQ25CZUMsUTtBQUFULFNBQVNBLFFBQVQsR0FBb0I7QUFDakMsK0JBQVc3RSxPQUFPUSxNQUFQLElBQWlCLFVBQVVnQixNQUFWLEVBQWtCO0FBQzVDLFNBQUssSUFBSTFGLElBQUksQ0FBYixFQUFnQkEsSUFBSUQsVUFBVVQsTUFBOUIsRUFBc0NVLEdBQXRDLEVBQTJDO0FBQ3pDLFVBQUkyRixTQUFTNUYsVUFBVUMsQ0FBVixDQUFiOztBQUVBLFdBQUssSUFBSW1ELEdBQVQsSUFBZ0J3QyxNQUFoQixFQUF3QjtBQUN0QixZQUFJekIsT0FBTzlELFNBQVAsQ0FBaUIrRCxjQUFqQixDQUFnQ3JGLElBQWhDLENBQXFDNkcsTUFBckMsRUFBNkN4QyxHQUE3QyxDQUFKLEVBQXVEO0FBQ3JEdUMsaUJBQU92QyxHQUFQLElBQWN3QyxPQUFPeEMsR0FBUCxDQUFkO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFdBQU91QyxNQUFQO0FBQ0QsR0FaRDs7QUFjQSxTQUFPcUQsU0FBUzFJLEtBQVQsQ0FBZSxJQUFmLEVBQXFCTixTQUFyQixDQUFQO0FBQ0QsQyIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMzEpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDQ4NDgxNWMwZjRmNDM5N2E3Y2UwIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgU3ltYm9sLmZvciAmJlxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAweGVhYzc7XG5cbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9O1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107IH0pXG4gICAgICApO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ludmFyaWFudC9icm93c2VyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBfX0RFVl9fID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJztcblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAoX19ERVZfXykge1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfVxuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkobnVsbCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy93YXJuaW5nL3dhcm5pbmcuanMiLCJpbXBvcnQgX2NyZWF0ZUJyb3dzZXJIaXN0b3J5IGZyb20gJy4vY3JlYXRlQnJvd3Nlckhpc3RvcnknO1xuZXhwb3J0IHsgX2NyZWF0ZUJyb3dzZXJIaXN0b3J5IGFzIGNyZWF0ZUJyb3dzZXJIaXN0b3J5IH07XG5pbXBvcnQgX2NyZWF0ZUhhc2hIaXN0b3J5IGZyb20gJy4vY3JlYXRlSGFzaEhpc3RvcnknO1xuZXhwb3J0IHsgX2NyZWF0ZUhhc2hIaXN0b3J5IGFzIGNyZWF0ZUhhc2hIaXN0b3J5IH07XG5pbXBvcnQgX2NyZWF0ZU1lbW9yeUhpc3RvcnkgZnJvbSAnLi9jcmVhdGVNZW1vcnlIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVNZW1vcnlIaXN0b3J5IGFzIGNyZWF0ZU1lbW9yeUhpc3RvcnkgfTtcblxuZXhwb3J0IHsgY3JlYXRlTG9jYXRpb24sIGxvY2F0aW9uc0FyZUVxdWFsIH0gZnJvbSAnLi9Mb2NhdGlvblV0aWxzJztcbmV4cG9ydCB7IHBhcnNlUGF0aCwgY3JlYXRlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9pbmRleC5qcyIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsImV4cG9ydCB2YXIgYWRkTGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gYWRkTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoIDogJy8nICsgcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgc3RyaXBMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiBzdHJpcExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xufTtcblxuZXhwb3J0IHZhciBoYXNCYXNlbmFtZSA9IGZ1bmN0aW9uIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gbmV3IFJlZ0V4cCgnXicgKyBwcmVmaXggKyAnKFxcXFwvfFxcXFw/fCN8JCknLCAnaScpLnRlc3QocGF0aCk7XG59O1xuXG5leHBvcnQgdmFyIHN0cmlwQmFzZW5hbWUgPSBmdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSA/IHBhdGguc3Vic3RyKHByZWZpeC5sZW5ndGgpIDogcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgc3RyaXBUcmFpbGluZ1NsYXNoID0gZnVuY3Rpb24gc3RyaXBUcmFpbGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KHBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJyA/IHBhdGguc2xpY2UoMCwgLTEpIDogcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgcGFyc2VQYXRoID0gZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHBhdGhuYW1lID0gcGF0aCB8fCAnLyc7XG4gIHZhciBzZWFyY2ggPSAnJztcbiAgdmFyIGhhc2ggPSAnJztcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xuICAgIGhhc2ggPSBwYXRobmFtZS5zdWJzdHIoaGFzaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignPycpO1xuICBpZiAoc2VhcmNoSW5kZXggIT09IC0xKSB7XG4gICAgc2VhcmNoID0gcGF0aG5hbWUuc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCA9PT0gJz8nID8gJycgOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCA9PT0gJyMnID8gJycgOiBoYXNoXG4gIH07XG59O1xuXG5leHBvcnQgdmFyIGNyZWF0ZVBhdGggPSBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoLFxuICAgICAgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG5cblxuICB2YXIgcGF0aCA9IHBhdGhuYW1lIHx8ICcvJztcblxuICBpZiAoc2VhcmNoICYmIHNlYXJjaCAhPT0gJz8nKSBwYXRoICs9IHNlYXJjaC5jaGFyQXQoMCkgPT09ICc/JyA/IHNlYXJjaCA6ICc/JyArIHNlYXJjaDtcblxuICBpZiAoaGFzaCAmJiBoYXNoICE9PSAnIycpIHBhdGggKz0gaGFzaC5jaGFyQXQoMCkgPT09ICcjJyA/IGhhc2ggOiAnIycgKyBoYXNoO1xuXG4gIHJldHVybiBwYXRoO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9QYXRoVXRpbHMuanMiLCJpbXBvcnQgX0Jyb3dzZXJSb3V0ZXIgZnJvbSBcIi4vQnJvd3NlclJvdXRlclwiO1xuZXhwb3J0IHsgX0Jyb3dzZXJSb3V0ZXIgYXMgQnJvd3NlclJvdXRlciB9O1xuaW1wb3J0IF9IYXNoUm91dGVyIGZyb20gXCIuL0hhc2hSb3V0ZXJcIjtcbmV4cG9ydCB7IF9IYXNoUm91dGVyIGFzIEhhc2hSb3V0ZXIgfTtcbmltcG9ydCBfTGluayBmcm9tIFwiLi9MaW5rXCI7XG5leHBvcnQgeyBfTGluayBhcyBMaW5rIH07XG5pbXBvcnQgX01lbW9yeVJvdXRlciBmcm9tIFwiLi9NZW1vcnlSb3V0ZXJcIjtcbmV4cG9ydCB7IF9NZW1vcnlSb3V0ZXIgYXMgTWVtb3J5Um91dGVyIH07XG5pbXBvcnQgX05hdkxpbmsgZnJvbSBcIi4vTmF2TGlua1wiO1xuZXhwb3J0IHsgX05hdkxpbmsgYXMgTmF2TGluayB9O1xuaW1wb3J0IF9Qcm9tcHQgZnJvbSBcIi4vUHJvbXB0XCI7XG5leHBvcnQgeyBfUHJvbXB0IGFzIFByb21wdCB9O1xuaW1wb3J0IF9SZWRpcmVjdCBmcm9tIFwiLi9SZWRpcmVjdFwiO1xuZXhwb3J0IHsgX1JlZGlyZWN0IGFzIFJlZGlyZWN0IH07XG5pbXBvcnQgX1JvdXRlIGZyb20gXCIuL1JvdXRlXCI7XG5leHBvcnQgeyBfUm91dGUgYXMgUm91dGUgfTtcbmltcG9ydCBfUm91dGVyIGZyb20gXCIuL1JvdXRlclwiO1xuZXhwb3J0IHsgX1JvdXRlciBhcyBSb3V0ZXIgfTtcbmltcG9ydCBfU3RhdGljUm91dGVyIGZyb20gXCIuL1N0YXRpY1JvdXRlclwiO1xuZXhwb3J0IHsgX1N0YXRpY1JvdXRlciBhcyBTdGF0aWNSb3V0ZXIgfTtcbmltcG9ydCBfU3dpdGNoIGZyb20gXCIuL1N3aXRjaFwiO1xuZXhwb3J0IHsgX1N3aXRjaCBhcyBTd2l0Y2ggfTtcbmltcG9ydCBfZ2VuZXJhdGVQYXRoIGZyb20gXCIuL2dlbmVyYXRlUGF0aFwiO1xuZXhwb3J0IHsgX2dlbmVyYXRlUGF0aCBhcyBnZW5lcmF0ZVBhdGggfTtcbmltcG9ydCBfbWF0Y2hQYXRoIGZyb20gXCIuL21hdGNoUGF0aFwiO1xuZXhwb3J0IHsgX21hdGNoUGF0aCBhcyBtYXRjaFBhdGggfTtcbmltcG9ydCBfd2l0aFJvdXRlciBmcm9tIFwiLi93aXRoUm91dGVyXCI7XG5leHBvcnQgeyBfd2l0aFJvdXRlciBhcyB3aXRoUm91dGVyIH07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvaW5kZXguanMiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgcmVzb2x2ZVBhdGhuYW1lIGZyb20gJ3Jlc29sdmUtcGF0aG5hbWUnO1xuaW1wb3J0IHZhbHVlRXF1YWwgZnJvbSAndmFsdWUtZXF1YWwnO1xuaW1wb3J0IHsgcGFyc2VQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuXG5leHBvcnQgdmFyIGNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGtleSwgY3VycmVudExvY2F0aW9uKSB7XG4gIHZhciBsb2NhdGlvbiA9IHZvaWQgMDtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIC8vIFR3by1hcmcgZm9ybTogcHVzaChwYXRoLCBzdGF0ZSlcbiAgICBsb2NhdGlvbiA9IHBhcnNlUGF0aChwYXRoKTtcbiAgICBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9IGVsc2Uge1xuICAgIC8vIE9uZS1hcmcgZm9ybTogcHVzaChsb2NhdGlvbilcbiAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBwYXRoKTtcblxuICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5wYXRobmFtZSA9ICcnO1xuXG4gICAgaWYgKGxvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLnNlYXJjaC5jaGFyQXQoMCkgIT09ICc/JykgbG9jYXRpb24uc2VhcmNoID0gJz8nICsgbG9jYXRpb24uc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5zZWFyY2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLmhhc2guY2hhckF0KDApICE9PSAnIycpIGxvY2F0aW9uLmhhc2ggPSAnIycgKyBsb2NhdGlvbi5oYXNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQgJiYgbG9jYXRpb24uc3RhdGUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbG9jYXRpb24ucGF0aG5hbWUgPSBkZWNvZGVVUkkobG9jYXRpb24ucGF0aG5hbWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBVUklFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFVSSUVycm9yKCdQYXRobmFtZSBcIicgKyBsb2NhdGlvbi5wYXRobmFtZSArICdcIiBjb3VsZCBub3QgYmUgZGVjb2RlZC4gJyArICdUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgYW4gaW52YWxpZCBwZXJjZW50LWVuY29kaW5nLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChrZXkpIGxvY2F0aW9uLmtleSA9IGtleTtcblxuICBpZiAoY3VycmVudExvY2F0aW9uKSB7XG4gICAgLy8gUmVzb2x2ZSBpbmNvbXBsZXRlL3JlbGF0aXZlIHBhdGhuYW1lIHJlbGF0aXZlIHRvIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWU7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSByZXNvbHZlUGF0aG5hbWUobG9jYXRpb24ucGF0aG5hbWUsIGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gcHJpb3IgbG9jYXRpb24gYW5kIHBhdGhuYW1lIGlzIGVtcHR5LCBzZXQgaXQgdG8gL1xuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gJy8nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2NhdGlvbjtcbn07XG5cbmV4cG9ydCB2YXIgbG9jYXRpb25zQXJlRXF1YWwgPSBmdW5jdGlvbiBsb2NhdGlvbnNBcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmIGEuc2VhcmNoID09PSBiLnNlYXJjaCAmJiBhLmhhc2ggPT09IGIuaGFzaCAmJiBhLmtleSA9PT0gYi5rZXkgJiYgdmFsdWVFcXVhbChhLnN0YXRlLCBiLnN0YXRlKTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvTG9jYXRpb25VdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiA+IDIgPyBsZW4gLSAyIDogMCk7XG4gICAgZm9yICh2YXIga2V5ID0gMjsga2V5IDwgbGVuOyBrZXkrKykge1xuICAgICAgYXJnc1trZXkgLSAyXSA9IGFyZ3VtZW50c1trZXldO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5sZW5ndGggPCAxMCB8fCAoL15bc1xcV10qJC8pLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHdhcm5pbmcgZm9ybWF0IHNob3VsZCBiZSBhYmxlIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgJyArXG4gICAgICAgICd3YXJuaW5nLiBQbGVhc2UsIHVzZSBhIG1vcmUgZGVzY3JpcHRpdmUgZm9ybWF0IHRoYW46ICcgKyBmb3JtYXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3Rvcnkvbm9kZV9tb2R1bGVzL3dhcm5pbmcvYnJvd3Nlci5qcyIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSBcIndhcm5pbmdcIjtcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSBcImludmFyaWFudFwiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBwdXR0aW5nIGhpc3Rvcnkgb24gY29udGV4dC5cbiAqL1xuXG52YXIgUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUm91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG1hdGNoOiBfdGhpcy5jb21wdXRlTWF0Y2goX3RoaXMucHJvcHMuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZSlcbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIFJvdXRlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZXI6IF9leHRlbmRzKHt9LCB0aGlzLmNvbnRleHQucm91dGVyLCB7XG4gICAgICAgIGhpc3Rvcnk6IHRoaXMucHJvcHMuaGlzdG9yeSxcbiAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICBsb2NhdGlvbjogdGhpcy5wcm9wcy5oaXN0b3J5LmxvY2F0aW9uLFxuICAgICAgICAgIG1hdGNoOiB0aGlzLnN0YXRlLm1hdGNoXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXB1dGVNYXRjaCA9IGZ1bmN0aW9uIGNvbXB1dGVNYXRjaChwYXRobmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBcIi9cIixcbiAgICAgIHVybDogXCIvXCIsXG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgaXNFeGFjdDogcGF0aG5hbWUgPT09IFwiL1wiXG4gICAgfTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF9wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgaGlzdG9yeSA9IF9wcm9wcy5oaXN0b3J5O1xuXG5cbiAgICBpbnZhcmlhbnQoY2hpbGRyZW4gPT0gbnVsbCB8fCBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPT09IDEsIFwiQSA8Um91dGVyPiBtYXkgaGF2ZSBvbmx5IG9uZSBjaGlsZCBlbGVtZW50XCIpO1xuXG4gICAgLy8gRG8gdGhpcyBoZXJlIHNvIHdlIGNhbiBzZXRTdGF0ZSB3aGVuIGEgPFJlZGlyZWN0PiBjaGFuZ2VzIHRoZVxuICAgIC8vIGxvY2F0aW9uIGluIGNvbXBvbmVudFdpbGxNb3VudC4gVGhpcyBoYXBwZW5zIGUuZy4gd2hlbiBkb2luZ1xuICAgIC8vIHNlcnZlciByZW5kZXJpbmcgdXNpbmcgYSA8U3RhdGljUm91dGVyPi5cbiAgICB0aGlzLnVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMyLnNldFN0YXRlKHtcbiAgICAgICAgbWF0Y2g6IF90aGlzMi5jb21wdXRlTWF0Y2goaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgd2FybmluZyh0aGlzLnByb3BzLmhpc3RvcnkgPT09IG5leHRQcm9wcy5oaXN0b3J5LCBcIllvdSBjYW5ub3QgY2hhbmdlIDxSb3V0ZXIgaGlzdG9yeT5cIik7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMudW5saXN0ZW4oKTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuXG4gICAgcmV0dXJuIGNoaWxkcmVuID8gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbikgOiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGhpc3Rvcnk6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuUm91dGVyLmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuUm91dGVyLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBSb3V0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZXIuanMiLCJpbXBvcnQgcGF0aFRvUmVnZXhwIGZyb20gXCJwYXRoLXRvLXJlZ2V4cFwiO1xuXG52YXIgcGF0dGVybkNhY2hlID0ge307XG52YXIgY2FjaGVMaW1pdCA9IDEwMDAwO1xudmFyIGNhY2hlQ291bnQgPSAwO1xuXG52YXIgY29tcGlsZVBhdGggPSBmdW5jdGlvbiBjb21waWxlUGF0aChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHZhciBjYWNoZUtleSA9IFwiXCIgKyBvcHRpb25zLmVuZCArIG9wdGlvbnMuc3RyaWN0ICsgb3B0aW9ucy5zZW5zaXRpdmU7XG4gIHZhciBjYWNoZSA9IHBhdHRlcm5DYWNoZVtjYWNoZUtleV0gfHwgKHBhdHRlcm5DYWNoZVtjYWNoZUtleV0gPSB7fSk7XG5cbiAgaWYgKGNhY2hlW3BhdHRlcm5dKSByZXR1cm4gY2FjaGVbcGF0dGVybl07XG5cbiAgdmFyIGtleXMgPSBbXTtcbiAgdmFyIHJlID0gcGF0aFRvUmVnZXhwKHBhdHRlcm4sIGtleXMsIG9wdGlvbnMpO1xuICB2YXIgY29tcGlsZWRQYXR0ZXJuID0geyByZTogcmUsIGtleXM6IGtleXMgfTtcblxuICBpZiAoY2FjaGVDb3VudCA8IGNhY2hlTGltaXQpIHtcbiAgICBjYWNoZVtwYXR0ZXJuXSA9IGNvbXBpbGVkUGF0dGVybjtcbiAgICBjYWNoZUNvdW50Kys7XG4gIH1cblxuICByZXR1cm4gY29tcGlsZWRQYXR0ZXJuO1xufTtcblxuLyoqXG4gKiBQdWJsaWMgQVBJIGZvciBtYXRjaGluZyBhIFVSTCBwYXRobmFtZSB0byBhIHBhdGggcGF0dGVybi5cbiAqL1xudmFyIG1hdGNoUGF0aCA9IGZ1bmN0aW9uIG1hdGNoUGF0aChwYXRobmFtZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBwYXJlbnQgPSBhcmd1bWVudHNbMl07XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSBvcHRpb25zID0geyBwYXRoOiBvcHRpb25zIH07XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIHBhdGggPSBfb3B0aW9ucy5wYXRoLFxuICAgICAgX29wdGlvbnMkZXhhY3QgPSBfb3B0aW9ucy5leGFjdCxcbiAgICAgIGV4YWN0ID0gX29wdGlvbnMkZXhhY3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkZXhhY3QsXG4gICAgICBfb3B0aW9ucyRzdHJpY3QgPSBfb3B0aW9ucy5zdHJpY3QsXG4gICAgICBzdHJpY3QgPSBfb3B0aW9ucyRzdHJpY3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkc3RyaWN0LFxuICAgICAgX29wdGlvbnMkc2Vuc2l0aXZlID0gX29wdGlvbnMuc2Vuc2l0aXZlLFxuICAgICAgc2Vuc2l0aXZlID0gX29wdGlvbnMkc2Vuc2l0aXZlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJHNlbnNpdGl2ZTtcblxuXG4gIGlmIChwYXRoID09IG51bGwpIHJldHVybiBwYXJlbnQ7XG5cbiAgdmFyIF9jb21waWxlUGF0aCA9IGNvbXBpbGVQYXRoKHBhdGgsIHsgZW5kOiBleGFjdCwgc3RyaWN0OiBzdHJpY3QsIHNlbnNpdGl2ZTogc2Vuc2l0aXZlIH0pLFxuICAgICAgcmUgPSBfY29tcGlsZVBhdGgucmUsXG4gICAgICBrZXlzID0gX2NvbXBpbGVQYXRoLmtleXM7XG5cbiAgdmFyIG1hdGNoID0gcmUuZXhlYyhwYXRobmFtZSk7XG5cbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHVybCA9IG1hdGNoWzBdLFxuICAgICAgdmFsdWVzID0gbWF0Y2guc2xpY2UoMSk7XG5cbiAgdmFyIGlzRXhhY3QgPSBwYXRobmFtZSA9PT0gdXJsO1xuXG4gIGlmIChleGFjdCAmJiAhaXNFeGFjdCkgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBwYXRoLCAvLyB0aGUgcGF0aCBwYXR0ZXJuIHVzZWQgdG8gbWF0Y2hcbiAgICB1cmw6IHBhdGggPT09IFwiL1wiICYmIHVybCA9PT0gXCJcIiA/IFwiL1wiIDogdXJsLCAvLyB0aGUgbWF0Y2hlZCBwb3J0aW9uIG9mIHRoZSBVUkxcbiAgICBpc0V4YWN0OiBpc0V4YWN0LCAvLyB3aGV0aGVyIG9yIG5vdCB3ZSBtYXRjaGVkIGV4YWN0bHlcbiAgICBwYXJhbXM6IGtleXMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBrZXksIGluZGV4KSB7XG4gICAgICBtZW1vW2tleS5uYW1lXSA9IHZhbHVlc1tpbmRleF07XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LCB7fSlcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1hdGNoUGF0aDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL21hdGNoUGF0aC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKVxuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwiaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5cbnZhciBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IGZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCkge1xuICB2YXIgcHJvbXB0ID0gbnVsbDtcblxuICB2YXIgc2V0UHJvbXB0ID0gZnVuY3Rpb24gc2V0UHJvbXB0KG5leHRQcm9tcHQpIHtcbiAgICB3YXJuaW5nKHByb21wdCA9PSBudWxsLCAnQSBoaXN0b3J5IHN1cHBvcnRzIG9ubHkgb25lIHByb21wdCBhdCBhIHRpbWUnKTtcblxuICAgIHByb21wdCA9IG5leHRQcm9tcHQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByb21wdCA9PT0gbmV4dFByb21wdCkgcHJvbXB0ID0gbnVsbDtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjb25maXJtVHJhbnNpdGlvblRvID0gZnVuY3Rpb24gY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IElmIGFub3RoZXIgdHJhbnNpdGlvbiBzdGFydHMgd2hpbGUgd2UncmUgc3RpbGwgY29uZmlybWluZ1xuICAgIC8vIHRoZSBwcmV2aW91cyBvbmUsIHdlIG1heSBlbmQgdXAgaW4gYSB3ZWlyZCBzdGF0ZS4gRmlndXJlIG91dCB0aGVcbiAgICAvLyBiZXN0IHdheSB0byBoYW5kbGUgdGhpcy5cbiAgICBpZiAocHJvbXB0ICE9IG51bGwpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0eXBlb2YgcHJvbXB0ID09PSAnZnVuY3Rpb24nID8gcHJvbXB0KGxvY2F0aW9uLCBhY3Rpb24pIDogcHJvbXB0O1xuXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXRVc2VyQ29uZmlybWF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbihyZXN1bHQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnQSBoaXN0b3J5IG5lZWRzIGEgZ2V0VXNlckNvbmZpcm1hdGlvbiBmdW5jdGlvbiBpbiBvcmRlciB0byB1c2UgYSBwcm9tcHQgbWVzc2FnZScpO1xuXG4gICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldHVybiBmYWxzZSBmcm9tIGEgdHJhbnNpdGlvbiBob29rIHRvIGNhbmNlbCB0aGUgdHJhbnNpdGlvbi5cbiAgICAgICAgY2FsbGJhY2socmVzdWx0ICE9PSBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbGlzdGVuZXJzID0gW107XG5cbiAgdmFyIGFwcGVuZExpc3RlbmVyID0gZnVuY3Rpb24gYXBwZW5kTGlzdGVuZXIoZm4pIHtcbiAgICB2YXIgaXNBY3RpdmUgPSB0cnVlO1xuXG4gICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgICBpZiAoaXNBY3RpdmUpIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzQWN0aXZlID0gZmFsc2U7XG4gICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBsaXN0ZW5lcjtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIG5vdGlmeUxpc3RlbmVycyA9IGZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVycygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgc2V0UHJvbXB0OiBzZXRQcm9tcHQsXG4gICAgY29uZmlybVRyYW5zaXRpb25UbzogY29uZmlybVRyYW5zaXRpb25UbyxcbiAgICBhcHBlbmRMaXN0ZW5lcjogYXBwZW5kTGlzdGVuZXIsXG4gICAgbm90aWZ5TGlzdGVuZXJzOiBub3RpZnlMaXN0ZW5lcnNcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzIiwiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBSb3V0ZXIgZnJvbSBcInJlYWN0LXJvdXRlci9lcy9Sb3V0ZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgUm91dGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JvdXRlci5qcyIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSBcIndhcm5pbmdcIjtcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSBcImludmFyaWFudFwiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IG1hdGNoUGF0aCBmcm9tIFwiLi9tYXRjaFBhdGhcIjtcblxudmFyIGlzRW1wdHlDaGlsZHJlbiA9IGZ1bmN0aW9uIGlzRW1wdHlDaGlsZHJlbihjaGlsZHJlbikge1xuICByZXR1cm4gUmVhY3QuQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pID09PSAwO1xufTtcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgbWF0Y2hpbmcgYSBzaW5nbGUgcGF0aCBhbmQgcmVuZGVyaW5nLlxuICovXG5cbnZhciBSb3V0ZSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhSb3V0ZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUm91dGUoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSb3V0ZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBtYXRjaDogX3RoaXMuY29tcHV0ZU1hdGNoKF90aGlzLnByb3BzLCBfdGhpcy5jb250ZXh0LnJvdXRlcilcbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIFJvdXRlLnByb3RvdHlwZS5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdXRlcjogX2V4dGVuZHMoe30sIHRoaXMuY29udGV4dC5yb3V0ZXIsIHtcbiAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICBsb2NhdGlvbjogdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCB0aGlzLmNvbnRleHQucm91dGVyLnJvdXRlLmxvY2F0aW9uLFxuICAgICAgICAgIG1hdGNoOiB0aGlzLnN0YXRlLm1hdGNoXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgfTtcblxuICBSb3V0ZS5wcm90b3R5cGUuY29tcHV0ZU1hdGNoID0gZnVuY3Rpb24gY29tcHV0ZU1hdGNoKF9yZWYsIHJvdXRlcikge1xuICAgIHZhciBjb21wdXRlZE1hdGNoID0gX3JlZi5jb21wdXRlZE1hdGNoLFxuICAgICAgICBsb2NhdGlvbiA9IF9yZWYubG9jYXRpb24sXG4gICAgICAgIHBhdGggPSBfcmVmLnBhdGgsXG4gICAgICAgIHN0cmljdCA9IF9yZWYuc3RyaWN0LFxuICAgICAgICBleGFjdCA9IF9yZWYuZXhhY3QsXG4gICAgICAgIHNlbnNpdGl2ZSA9IF9yZWYuc2Vuc2l0aXZlO1xuXG4gICAgaWYgKGNvbXB1dGVkTWF0Y2gpIHJldHVybiBjb21wdXRlZE1hdGNoOyAvLyA8U3dpdGNoPiBhbHJlYWR5IGNvbXB1dGVkIHRoZSBtYXRjaCBmb3IgdXNcblxuICAgIGludmFyaWFudChyb3V0ZXIsIFwiWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZT4gb3Igd2l0aFJvdXRlcigpIG91dHNpZGUgYSA8Um91dGVyPlwiKTtcblxuICAgIHZhciByb3V0ZSA9IHJvdXRlci5yb3V0ZTtcblxuICAgIHZhciBwYXRobmFtZSA9IChsb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbikucGF0aG5hbWU7XG5cbiAgICByZXR1cm4gbWF0Y2hQYXRoKHBhdGhuYW1lLCB7IHBhdGg6IHBhdGgsIHN0cmljdDogc3RyaWN0LCBleGFjdDogZXhhY3QsIHNlbnNpdGl2ZTogc2Vuc2l0aXZlIH0sIHJvdXRlLm1hdGNoKTtcbiAgfTtcblxuICBSb3V0ZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHdhcm5pbmcoISh0aGlzLnByb3BzLmNvbXBvbmVudCAmJiB0aGlzLnByb3BzLnJlbmRlciksIFwiWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZSBjb21wb25lbnQ+IGFuZCA8Um91dGUgcmVuZGVyPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIHJlbmRlcj4gd2lsbCBiZSBpZ25vcmVkXCIpO1xuXG4gICAgd2FybmluZyghKHRoaXMucHJvcHMuY29tcG9uZW50ICYmIHRoaXMucHJvcHMuY2hpbGRyZW4gJiYgIWlzRW1wdHlDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuKSksIFwiWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZSBjb21wb25lbnQ+IGFuZCA8Um91dGUgY2hpbGRyZW4+IGluIHRoZSBzYW1lIHJvdXRlOyA8Um91dGUgY2hpbGRyZW4+IHdpbGwgYmUgaWdub3JlZFwiKTtcblxuICAgIHdhcm5pbmcoISh0aGlzLnByb3BzLnJlbmRlciAmJiB0aGlzLnByb3BzLmNoaWxkcmVuICYmICFpc0VtcHR5Q2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbikpLCBcIllvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgcmVuZGVyPiBhbmQgPFJvdXRlIGNoaWxkcmVuPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIGNoaWxkcmVuPiB3aWxsIGJlIGlnbm9yZWRcIik7XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICB3YXJuaW5nKCEobmV4dFByb3BzLmxvY2F0aW9uICYmICF0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxSb3V0ZT4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBpbml0aWFsbHkgdXNlZCBubyBcImxvY2F0aW9uXCIgcHJvcCBhbmQgdGhlbiBwcm92aWRlZCBvbmUgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKTtcblxuICAgIHdhcm5pbmcoISghbmV4dFByb3BzLmxvY2F0aW9uICYmIHRoaXMucHJvcHMubG9jYXRpb24pLCAnPFJvdXRlPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IHByb3ZpZGVkIGEgXCJsb2NhdGlvblwiIHByb3AgaW5pdGlhbGx5IGJ1dCBvbWl0dGVkIGl0IG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG1hdGNoOiB0aGlzLmNvbXB1dGVNYXRjaChuZXh0UHJvcHMsIG5leHRDb250ZXh0LnJvdXRlcilcbiAgICB9KTtcbiAgfTtcblxuICBSb3V0ZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBtYXRjaCA9IHRoaXMuc3RhdGUubWF0Y2g7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3Byb3BzLmNoaWxkcmVuLFxuICAgICAgICBjb21wb25lbnQgPSBfcHJvcHMuY29tcG9uZW50LFxuICAgICAgICByZW5kZXIgPSBfcHJvcHMucmVuZGVyO1xuICAgIHZhciBfY29udGV4dCRyb3V0ZXIgPSB0aGlzLmNvbnRleHQucm91dGVyLFxuICAgICAgICBoaXN0b3J5ID0gX2NvbnRleHQkcm91dGVyLmhpc3RvcnksXG4gICAgICAgIHJvdXRlID0gX2NvbnRleHQkcm91dGVyLnJvdXRlLFxuICAgICAgICBzdGF0aWNDb250ZXh0ID0gX2NvbnRleHQkcm91dGVyLnN0YXRpY0NvbnRleHQ7XG5cbiAgICB2YXIgbG9jYXRpb24gPSB0aGlzLnByb3BzLmxvY2F0aW9uIHx8IHJvdXRlLmxvY2F0aW9uO1xuICAgIHZhciBwcm9wcyA9IHsgbWF0Y2g6IG1hdGNoLCBsb2NhdGlvbjogbG9jYXRpb24sIGhpc3Rvcnk6IGhpc3RvcnksIHN0YXRpY0NvbnRleHQ6IHN0YXRpY0NvbnRleHQgfTtcblxuICAgIGlmIChjb21wb25lbnQpIHJldHVybiBtYXRjaCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcykgOiBudWxsO1xuXG4gICAgaWYgKHJlbmRlcikgcmV0dXJuIG1hdGNoID8gcmVuZGVyKHByb3BzKSA6IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBjaGlsZHJlbihwcm9wcyk7XG5cbiAgICBpZiAoY2hpbGRyZW4gJiYgIWlzRW1wdHlDaGlsZHJlbihjaGlsZHJlbikpIHJldHVybiBSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBSb3V0ZTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUm91dGUucHJvcFR5cGVzID0ge1xuICBjb21wdXRlZE1hdGNoOiBQcm9wVHlwZXMub2JqZWN0LCAvLyBwcml2YXRlLCBmcm9tIDxTd2l0Y2g+XG4gIHBhdGg6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGV4YWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgc3RyaWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgc2Vuc2l0aXZlOiBQcm9wVHlwZXMuYm9vbCxcbiAgY29tcG9uZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgcmVuZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubm9kZV0pLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9iamVjdFxufTtcblJvdXRlLmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGhpc3Rvcnk6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICByb3V0ZTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHN0YXRpY0NvbnRleHQ6IFByb3BUeXBlcy5vYmplY3RcbiAgfSlcbn07XG5Sb3V0ZS5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgUm91dGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZS5qcyIsImltcG9ydCBwYXRoVG9SZWdleHAgZnJvbSBcInBhdGgtdG8tcmVnZXhwXCI7XG5cbnZhciBwYXR0ZXJuQ2FjaGUgPSB7fTtcbnZhciBjYWNoZUxpbWl0ID0gMTAwMDA7XG52YXIgY2FjaGVDb3VudCA9IDA7XG5cbnZhciBjb21waWxlR2VuZXJhdG9yID0gZnVuY3Rpb24gY29tcGlsZUdlbmVyYXRvcihwYXR0ZXJuKSB7XG4gIHZhciBjYWNoZUtleSA9IHBhdHRlcm47XG4gIHZhciBjYWNoZSA9IHBhdHRlcm5DYWNoZVtjYWNoZUtleV0gfHwgKHBhdHRlcm5DYWNoZVtjYWNoZUtleV0gPSB7fSk7XG5cbiAgaWYgKGNhY2hlW3BhdHRlcm5dKSByZXR1cm4gY2FjaGVbcGF0dGVybl07XG5cbiAgdmFyIGNvbXBpbGVkR2VuZXJhdG9yID0gcGF0aFRvUmVnZXhwLmNvbXBpbGUocGF0dGVybik7XG5cbiAgaWYgKGNhY2hlQ291bnQgPCBjYWNoZUxpbWl0KSB7XG4gICAgY2FjaGVbcGF0dGVybl0gPSBjb21waWxlZEdlbmVyYXRvcjtcbiAgICBjYWNoZUNvdW50Kys7XG4gIH1cblxuICByZXR1cm4gY29tcGlsZWRHZW5lcmF0b3I7XG59O1xuXG4vKipcbiAqIFB1YmxpYyBBUEkgZm9yIGdlbmVyYXRpbmcgYSBVUkwgcGF0aG5hbWUgZnJvbSBhIHBhdHRlcm4gYW5kIHBhcmFtZXRlcnMuXG4gKi9cbnZhciBnZW5lcmF0ZVBhdGggPSBmdW5jdGlvbiBnZW5lcmF0ZVBhdGgoKSB7XG4gIHZhciBwYXR0ZXJuID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBcIi9cIjtcbiAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgaWYgKHBhdHRlcm4gPT09IFwiL1wiKSB7XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbiAgdmFyIGdlbmVyYXRvciA9IGNvbXBpbGVHZW5lcmF0b3IocGF0dGVybik7XG4gIHJldHVybiBnZW5lcmF0b3IocGFyYW1zLCB7IHByZXR0eTogdHJ1ZSB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdlbmVyYXRlUGF0aDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL2dlbmVyYXRlUGF0aC5qcyIsImltcG9ydCBmZXRjaCBmcm9tICdpc29tb3JwaGljLWZldGNoJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoUG9wdWxhclJlcG9zIChsYW5ndWFnZSA9ICdhbGwnKSB7XHJcbiAgICBjb25zdCBlbmNvZGVkVVJJID0gZW5jb2RlVVJJKGBodHRwczovL2FwaS5naXRodWIuY29tL3NlYXJjaC9yZXBvc2l0b3JpZXM/cT1zdGFyczo+MStsYW5ndWFnZToke2xhbmd1YWdlfSZzb3J0PXN0YXJzJm9yZGVyPWRlc2MmdHlwZT1SZXBvc2l0b3JpZXNgKVxyXG5cclxuICAgIHJldHVybiBmZXRjaChlbmNvZGVkVVJJKVxyXG4gICAgICAgIC50aGVuKGRhdGEgPT4gZGF0YS5qc29uKCkgKVxyXG4gICAgICAgIC50aGVuKHJlcG9zID0+IHJlcG9zLml0ZW1zKVxyXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hVc2VyKHVzZXIgPSAnc29tZW9uZScpIHtcclxuICAgIGNvbnN0IGVuY29kZWRVUkkgPSBlbmNvZGVVUkkoYGh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vdXNlcnMvJHt1c2VyfWApXHJcblxyXG4gICAgcmV0dXJuIGZldGNoKGVuY29kZWRVUkkpXHJcbiAgICAgICAgLnRoZW4oZGF0YSA9PiBkYXRhLmpzb24oKSApXHJcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnIpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgICAgfSk7XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2hhcmVkL2FwaS5qcyIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZS5kZXZlbG9wbWVudC5qcycpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlL2luZGV4LmpzIiwiZXhwb3J0IHZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5leHBvcnQgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5hZGRFdmVudExpc3RlbmVyID8gbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbmV4cG9ydCB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPyBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxuZXhwb3J0IHZhciBnZXRDb25maXJtYXRpb24gPSBmdW5jdGlvbiBnZXRDb25maXJtYXRpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTtcbn07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3Qtcm91dGVyL2lzc3Vlcy81ODZcbiAqL1xuZXhwb3J0IHZhciBzdXBwb3J0c0hpc3RvcnkgPSBmdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmICgodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiYgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiYgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJyb3dzZXIgZmlyZXMgcG9wc3RhdGUgb24gaGFzaCBjaGFuZ2UuXG4gKiBJRTEwIGFuZCBJRTExIGRvIG5vdC5cbiAqL1xuZXhwb3J0IHZhciBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlID0gZnVuY3Rpb24gc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSA9PT0gLTE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cbiAqL1xuZXhwb3J0IHZhciBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IGZ1bmN0aW9uIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgZ2l2ZW4gcG9wc3RhdGUgZXZlbnQgaXMgYW4gZXh0cmFuZW91cyBXZWJLaXQgZXZlbnQuXG4gKiBBY2NvdW50cyBmb3IgdGhlIGZhY3QgdGhhdCBDaHJvbWUgb24gaU9TIGZpcmVzIHJlYWwgcG9wc3RhdGUgZXZlbnRzXG4gKiBjb250YWluaW5nIHVuZGVmaW5lZCBzdGF0ZSB3aGVuIHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5cbiAqL1xuZXhwb3J0IHZhciBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50ID0gZnVuY3Rpb24gaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQuc3RhdGUgPT09IHVuZGVmaW5lZCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0NyaU9TJykgPT09IC0xO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9ET01VdGlscy5qcyIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gXCJwcm9wLXR5cGVzXCI7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gXCJpbnZhcmlhbnRcIjtcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uIH0gZnJvbSBcImhpc3RvcnlcIjtcblxudmFyIGlzTW9kaWZpZWRFdmVudCA9IGZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59O1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgYSBoaXN0b3J5LWF3YXJlIDxhPi5cbiAqL1xuXG52YXIgTGluayA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhMaW5rLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBMaW5rKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGluayk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkNsaWNrKSBfdGhpcy5wcm9wcy5vbkNsaWNrKGV2ZW50KTtcblxuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkICYmIC8vIG9uQ2xpY2sgcHJldmVudGVkIGRlZmF1bHRcbiAgICAgIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiAvLyBpZ25vcmUgZXZlcnl0aGluZyBidXQgbGVmdCBjbGlja3NcbiAgICAgICFfdGhpcy5wcm9wcy50YXJnZXQgJiYgLy8gbGV0IGJyb3dzZXIgaGFuZGxlIFwidGFyZ2V0PV9ibGFua1wiIGV0Yy5cbiAgICAgICFpc01vZGlmaWVkRXZlbnQoZXZlbnQpIC8vIGlnbm9yZSBjbGlja3Mgd2l0aCBtb2RpZmllciBrZXlzXG4gICAgICApIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgdmFyIGhpc3RvcnkgPSBfdGhpcy5jb250ZXh0LnJvdXRlci5oaXN0b3J5O1xuICAgICAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgICAgICByZXBsYWNlID0gX3RoaXMkcHJvcHMucmVwbGFjZSxcbiAgICAgICAgICAgICAgdG8gPSBfdGhpcyRwcm9wcy50bztcblxuXG4gICAgICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgICAgIGhpc3RvcnkucmVwbGFjZSh0byk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpc3RvcnkucHVzaCh0byk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBMaW5rLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIHJlcGxhY2UgPSBfcHJvcHMucmVwbGFjZSxcbiAgICAgICAgdG8gPSBfcHJvcHMudG8sXG4gICAgICAgIGlubmVyUmVmID0gX3Byb3BzLmlubmVyUmVmLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFtcInJlcGxhY2VcIiwgXCJ0b1wiLCBcImlubmVyUmVmXCJdKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgaW52YXJpYW50KHRoaXMuY29udGV4dC5yb3V0ZXIsIFwiWW91IHNob3VsZCBub3QgdXNlIDxMaW5rPiBvdXRzaWRlIGEgPFJvdXRlcj5cIik7XG5cbiAgICBpbnZhcmlhbnQodG8gIT09IHVuZGVmaW5lZCwgJ1lvdSBtdXN0IHNwZWNpZnkgdGhlIFwidG9cIiBwcm9wZXJ0eScpO1xuXG4gICAgdmFyIGhpc3RvcnkgPSB0aGlzLmNvbnRleHQucm91dGVyLmhpc3Rvcnk7XG5cbiAgICB2YXIgbG9jYXRpb24gPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBjcmVhdGVMb2NhdGlvbih0bywgbnVsbCwgbnVsbCwgaGlzdG9yeS5sb2NhdGlvbikgOiB0bztcblxuICAgIHZhciBocmVmID0gaGlzdG9yeS5jcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7IG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xpY2ssIGhyZWY6IGhyZWYsIHJlZjogaW5uZXJSZWYgfSkpO1xuICB9O1xuXG4gIHJldHVybiBMaW5rO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5MaW5rLnByb3BUeXBlcyA9IHtcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLnN0cmluZyxcbiAgcmVwbGFjZTogUHJvcFR5cGVzLmJvb2wsXG4gIHRvOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSkuaXNSZXF1aXJlZCxcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSlcbn07XG5MaW5rLmRlZmF1bHRQcm9wcyA9IHtcbiAgcmVwbGFjZTogZmFsc2Vcbn07XG5MaW5rLmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGhpc3Rvcnk6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBwdXNoOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgcmVwbGFjZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICAgIGNyZWF0ZUhyZWY6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgICB9KS5pc1JlcXVpcmVkXG4gIH0pLmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgTGluaztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9MaW5rLmpzIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tIFwid2FybmluZ1wiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IHsgY3JlYXRlTWVtb3J5SGlzdG9yeSBhcyBjcmVhdGVIaXN0b3J5IH0gZnJvbSBcImhpc3RvcnlcIjtcbmltcG9ydCBSb3V0ZXIgZnJvbSBcIi4vUm91dGVyXCI7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIGEgPFJvdXRlcj4gdGhhdCBzdG9yZXMgbG9jYXRpb24gaW4gbWVtb3J5LlxuICovXG5cbnZhciBNZW1vcnlSb3V0ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTWVtb3J5Um91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNZW1vcnlSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZW1vcnlSb3V0ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KF90aGlzLnByb3BzKSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBNZW1vcnlSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksIFwiPE1lbW9yeVJvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgXCIgKyBcInVzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IE1lbW9yeVJvdXRlciBhcyBSb3V0ZXIgfWAuXCIpO1xuICB9O1xuXG4gIE1lbW9yeVJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnksIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pO1xuICB9O1xuXG4gIHJldHVybiBNZW1vcnlSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbk1lbW9yeVJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGluaXRpYWxFbnRyaWVzOiBQcm9wVHlwZXMuYXJyYXksXG4gIGluaXRpYWxJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gIGtleUxlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IE1lbW9yeVJvdXRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL01lbW9yeVJvdXRlci5qcyIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgUm91dGUgZnJvbSBcInJlYWN0LXJvdXRlci9lcy9Sb3V0ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBSb3V0ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Sb3V0ZS5qcyIsInZhciBpc2FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbi8qKlxuICogRXhwb3NlIGBwYXRoVG9SZWdleHBgLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGhUb1JlZ2V4cFxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBwYXJzZVxubW9kdWxlLmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGVcbm1vZHVsZS5leHBvcnRzLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb1JlZ0V4cCA9IHRva2Vuc1RvUmVnRXhwXG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIiwgdW5kZWZpbmVkXVxuICAvLyBcIi9yb3V0ZShcXFxcZCspXCIgID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gIC8vIFwiLypcIiAgICAgICAgICAgID0+IFtcIi9cIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIipcIl1cbiAgJyhbXFxcXC8uXSk/KD86KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKShbKyo/XSk/fChcXFxcKikpJ1xuXS5qb2luKCd8JyksICdnJylcblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBmb3IgdGhlIHJhdyB0b2tlbnMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshQXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIHRva2VucyA9IFtdXG4gIHZhciBrZXkgPSAwXG4gIHZhciBpbmRleCA9IDBcbiAgdmFyIHBhdGggPSAnJ1xuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nXG4gIHZhciByZXNcblxuICB3aGlsZSAoKHJlcyA9IFBBVEhfUkVHRVhQLmV4ZWMoc3RyKSkgIT0gbnVsbCkge1xuICAgIHZhciBtID0gcmVzWzBdXG4gICAgdmFyIGVzY2FwZWQgPSByZXNbMV1cbiAgICB2YXIgb2Zmc2V0ID0gcmVzLmluZGV4XG4gICAgcGF0aCArPSBzdHIuc2xpY2UoaW5kZXgsIG9mZnNldClcbiAgICBpbmRleCA9IG9mZnNldCArIG0ubGVuZ3RoXG5cbiAgICAvLyBJZ25vcmUgYWxyZWFkeSBlc2NhcGVkIHNlcXVlbmNlcy5cbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcGF0aCArPSBlc2NhcGVkWzFdXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHZhciBuZXh0ID0gc3RyW2luZGV4XVxuICAgIHZhciBwcmVmaXggPSByZXNbMl1cbiAgICB2YXIgbmFtZSA9IHJlc1szXVxuICAgIHZhciBjYXB0dXJlID0gcmVzWzRdXG4gICAgdmFyIGdyb3VwID0gcmVzWzVdXG4gICAgdmFyIG1vZGlmaWVyID0gcmVzWzZdXG4gICAgdmFyIGFzdGVyaXNrID0gcmVzWzddXG5cbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgdG9rZW5zLlxuICAgIGlmIChwYXRoKSB7XG4gICAgICB0b2tlbnMucHVzaChwYXRoKVxuICAgICAgcGF0aCA9ICcnXG4gICAgfVxuXG4gICAgdmFyIHBhcnRpYWwgPSBwcmVmaXggIT0gbnVsbCAmJiBuZXh0ICE9IG51bGwgJiYgbmV4dCAhPT0gcHJlZml4XG4gICAgdmFyIHJlcGVhdCA9IG1vZGlmaWVyID09PSAnKycgfHwgbW9kaWZpZXIgPT09ICcqJ1xuICAgIHZhciBvcHRpb25hbCA9IG1vZGlmaWVyID09PSAnPycgfHwgbW9kaWZpZXIgPT09ICcqJ1xuICAgIHZhciBkZWxpbWl0ZXIgPSByZXNbMl0gfHwgZGVmYXVsdERlbGltaXRlclxuICAgIHZhciBwYXR0ZXJuID0gY2FwdHVyZSB8fCBncm91cFxuXG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgIHByZWZpeDogcHJlZml4IHx8ICcnLFxuICAgICAgZGVsaW1pdGVyOiBkZWxpbWl0ZXIsXG4gICAgICBvcHRpb25hbDogb3B0aW9uYWwsXG4gICAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICAgIHBhcnRpYWw6IHBhcnRpYWwsXG4gICAgICBhc3RlcmlzazogISFhc3RlcmlzayxcbiAgICAgIHBhdHRlcm46IHBhdHRlcm4gPyBlc2NhcGVHcm91cChwYXR0ZXJuKSA6IChhc3RlcmlzayA/ICcuKicgOiAnW14nICsgZXNjYXBlU3RyaW5nKGRlbGltaXRlcikgKyAnXSs/JylcbiAgICB9KVxuICB9XG5cbiAgLy8gTWF0Y2ggYW55IGNoYXJhY3RlcnMgc3RpbGwgcmVtYWluaW5nLlxuICBpZiAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgcGF0aCArPSBzdHIuc3Vic3RyKGluZGV4KVxuICB9XG5cbiAgLy8gSWYgdGhlIHBhdGggZXhpc3RzLCBwdXNoIGl0IG9udG8gdGhlIGVuZC5cbiAgaWYgKHBhdGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXRoKVxuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBzdHJpbmcgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IWZ1bmN0aW9uKE9iamVjdD0sIE9iamVjdD0pfVxuICovXG5mdW5jdGlvbiBjb21waWxlIChzdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSlcbn1cblxuLyoqXG4gKiBQcmV0dGllciBlbmNvZGluZyBvZiBVUkkgcGF0aCBzZWdtZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bXFwvPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEVuY29kZSB0aGUgYXN0ZXJpc2sgcGFyYW1ldGVyLiBTaW1pbGFyIHRvIGBwcmV0dHlgLCBidXQgYWxsb3dzIHNsYXNoZXMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVBc3RlcmlzayAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb0Z1bmN0aW9uICh0b2tlbnMpIHtcbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gIHZhciBtYXRjaGVzID0gbmV3IEFycmF5KHRva2Vucy5sZW5ndGgpXG5cbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHBhdHRlcm5zIGJlZm9yZSBjb21waWxhdGlvbi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIHRva2Vuc1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1hdGNoZXNbaV0gPSBuZXcgUmVnRXhwKCdeKD86JyArIHRva2Vuc1tpXS5wYXR0ZXJuICsgJykkJylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIHZhciBwYXRoID0gJydcbiAgICB2YXIgZGF0YSA9IG9iaiB8fCB7fVxuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fVxuICAgIHZhciBlbmNvZGUgPSBvcHRpb25zLnByZXR0eSA/IGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSA6IGVuY29kZVVSSUNvbXBvbmVudFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoICs9IHRva2VuXG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gZGF0YVt0b2tlbi5uYW1lXVxuICAgICAgdmFyIHNlZ21lbnRcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgLy8gUHJlcGVuZCBwYXJ0aWFsIHNlZ21lbnQgcHJlZml4ZXMuXG4gICAgICAgICAgaWYgKHRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIGJlIGRlZmluZWQnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc2FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAoIXRva2VuLnJlcGVhdCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IHJlcGVhdCwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ2AnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgYmUgZW1wdHknKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdKVxuXG4gICAgICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFsbCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHNlZ21lbnQpICsgJ2AnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGggKz0gKGogPT09IDAgPyB0b2tlbi5wcmVmaXggOiB0b2tlbi5kZWxpbWl0ZXIpICsgc2VnbWVudFxuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgc2VnbWVudCA9IHRva2VuLmFzdGVyaXNrID8gZW5jb2RlQXN0ZXJpc2sodmFsdWUpIDogZW5jb2RlKHZhbHVlKVxuXG4gICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBcIicgKyBzZWdtZW50ICsgJ1wiJylcbiAgICAgIH1cblxuICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhcbiAgfVxufVxuXG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfFxcL1xcXFxdKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBFc2NhcGUgdGhlIGNhcHR1cmluZyBncm91cCBieSBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBncm91cFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcbiAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoLyhbPSE6JFxcLygpXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogQXR0YWNoIHRoZSBrZXlzIGFzIGEgcHJvcGVydHkgb2YgdGhlIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSByZVxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXR0YWNoS2V5cyAocmUsIGtleXMpIHtcbiAgcmUua2V5cyA9IGtleXNcbiAgcmV0dXJuIHJlXG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSdcbn1cblxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAgKHBhdGgsIGtleXMpIHtcbiAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpXG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBpLFxuICAgICAgICBwcmVmaXg6IG51bGwsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBwYXJ0aWFsOiBmYWxzZSxcbiAgICAgICAgYXN0ZXJpc2s6IGZhbHNlLFxuICAgICAgICBwYXR0ZXJuOiBudWxsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHBhdGgsIGtleXMpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgcGFydHMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSlcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSlcblxuICByZXR1cm4gYXR0YWNoS2V5cyhyZWdleHAsIGtleXMpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvUmVnRXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgICAgICAgICB0b2tlbnNcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0ga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ0V4cCAodG9rZW5zLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpXG4gICAga2V5cyA9IFtdXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdFxuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQgIT09IGZhbHNlXG4gIHZhciByb3V0ZSA9ICcnXG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcodG9rZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcodG9rZW4ucHJlZml4KVxuICAgICAgdmFyIGNhcHR1cmUgPSAnKD86JyArIHRva2VuLnBhdHRlcm4gKyAnKSdcblxuICAgICAga2V5cy5wdXNoKHRva2VuKVxuXG4gICAgICBpZiAodG9rZW4ucmVwZWF0KSB7XG4gICAgICAgIGNhcHR1cmUgKz0gJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJ1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgY2FwdHVyZSA9ICcoPzonICsgcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpKT8nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKT8nXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknXG4gICAgICB9XG5cbiAgICAgIHJvdXRlICs9IGNhcHR1cmVcbiAgICB9XG4gIH1cblxuICB2YXIgZGVsaW1pdGVyID0gZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJylcbiAgdmFyIGVuZHNXaXRoRGVsaW1pdGVyID0gcm91dGUuc2xpY2UoLWRlbGltaXRlci5sZW5ndGgpID09PSBkZWxpbWl0ZXJcblxuICAvLyBJbiBub24tc3RyaWN0IG1vZGUgd2UgYWxsb3cgYSBzbGFzaCBhdCB0aGUgZW5kIG9mIG1hdGNoLiBJZiB0aGUgcGF0aCB0b1xuICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcbiAgLy8gaXMgdmFsaWQgYXQgdGhlIGVuZCBvZiBhIHBhdGggbWF0Y2gsIG5vdCBpbiB0aGUgbWlkZGxlLiBUaGlzIGlzIGltcG9ydGFudFxuICAvLyBpbiBub24tZW5kaW5nIG1vZGUsIHdoZXJlIFwiL3Rlc3QvXCIgc2hvdWxkbid0IG1hdGNoIFwiL3Rlc3QvL3JvdXRlXCIuXG4gIGlmICghc3RyaWN0KSB7XG4gICAgcm91dGUgPSAoZW5kc1dpdGhEZWxpbWl0ZXIgPyByb3V0ZS5zbGljZSgwLCAtZGVsaW1pdGVyLmxlbmd0aCkgOiByb3V0ZSkgKyAnKD86JyArIGRlbGltaXRlciArICcoPz0kKSk/J1xuICB9XG5cbiAgaWYgKGVuZCkge1xuICAgIHJvdXRlICs9ICckJ1xuICB9IGVsc2Uge1xuICAgIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoIGFzXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgICByb3V0ZSArPSBzdHJpY3QgJiYgZW5kc1dpdGhEZWxpbWl0ZXIgPyAnJyA6ICcoPz0nICsgZGVsaW1pdGVyICsgJ3wkKSdcbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJ14nICsgcm91dGUsIGZsYWdzKG9wdGlvbnMpKSwga2V5cylcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICpcbiAqIEBwYXJhbSAgeyhzdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSAgICAgICBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKVxuICAgIGtleXMgPSBbXVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpKVxuICB9XG5cbiAgaWYgKGlzYXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cCgvKiogQHR5cGUgeyFBcnJheX0gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qcyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IGludmFyaWFudCBmcm9tIFwiaW52YXJpYW50XCI7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHByb21wdGluZyB0aGUgdXNlciBiZWZvcmUgbmF2aWdhdGluZyBhd2F5XG4gKiBmcm9tIGEgc2NyZWVuIHdpdGggYSBjb21wb25lbnQuXG4gKi9cblxudmFyIFByb21wdCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhQcm9tcHQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFByb21wdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvbXB0KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLnVuYmxvY2spIHRoaXMudW5ibG9jaygpO1xuXG4gICAgdGhpcy51bmJsb2NrID0gdGhpcy5jb250ZXh0LnJvdXRlci5oaXN0b3J5LmJsb2NrKG1lc3NhZ2UpO1xuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgaWYgKHRoaXMudW5ibG9jaykge1xuICAgICAgdGhpcy51bmJsb2NrKCk7XG4gICAgICB0aGlzLnVuYmxvY2sgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBpbnZhcmlhbnQodGhpcy5jb250ZXh0LnJvdXRlciwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFByb21wdD4gb3V0c2lkZSBhIDxSb3V0ZXI+XCIpO1xuXG4gICAgaWYgKHRoaXMucHJvcHMud2hlbikgdGhpcy5lbmFibGUodGhpcy5wcm9wcy5tZXNzYWdlKTtcbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMud2hlbikge1xuICAgICAgaWYgKCF0aGlzLnByb3BzLndoZW4gfHwgdGhpcy5wcm9wcy5tZXNzYWdlICE9PSBuZXh0UHJvcHMubWVzc2FnZSkgdGhpcy5lbmFibGUobmV4dFByb3BzLm1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB9XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBQcm9tcHQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblByb21wdC5wcm9wVHlwZXMgPSB7XG4gIHdoZW46IFByb3BUeXBlcy5ib29sLFxuICBtZXNzYWdlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLnN0cmluZ10pLmlzUmVxdWlyZWRcbn07XG5Qcm9tcHQuZGVmYXVsdFByb3BzID0ge1xuICB3aGVuOiB0cnVlXG59O1xuUHJvbXB0LmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGhpc3Rvcnk6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBibG9jazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0pLmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBQcm9tcHQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Qcm9tcHQuanMiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCB3YXJuaW5nIGZyb20gXCJ3YXJuaW5nXCI7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gXCJpbnZhcmlhbnRcIjtcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQgZ2VuZXJhdGVQYXRoIGZyb20gXCIuL2dlbmVyYXRlUGF0aFwiO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciB1cGRhdGluZyB0aGUgbG9jYXRpb24gcHJvZ3JhbW1hdGljYWxseVxuICogd2l0aCBhIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgUmVkaXJlY3QgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUmVkaXJlY3QsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJlZGlyZWN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWRpcmVjdCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5pc1N0YXRpYyA9IGZ1bmN0aW9uIGlzU3RhdGljKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQucm91dGVyICYmIHRoaXMuY29udGV4dC5yb3V0ZXIuc3RhdGljQ29udGV4dDtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGludmFyaWFudCh0aGlzLmNvbnRleHQucm91dGVyLCBcIllvdSBzaG91bGQgbm90IHVzZSA8UmVkaXJlY3Q+IG91dHNpZGUgYSA8Um91dGVyPlwiKTtcblxuICAgIGlmICh0aGlzLmlzU3RhdGljKCkpIHRoaXMucGVyZm9ybSgpO1xuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICghdGhpcy5pc1N0YXRpYygpKSB0aGlzLnBlcmZvcm0oKTtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIHZhciBwcmV2VG8gPSBjcmVhdGVMb2NhdGlvbihwcmV2UHJvcHMudG8pO1xuICAgIHZhciBuZXh0VG8gPSBjcmVhdGVMb2NhdGlvbih0aGlzLnByb3BzLnRvKTtcblxuICAgIGlmIChsb2NhdGlvbnNBcmVFcXVhbChwcmV2VG8sIG5leHRUbykpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiWW91IHRyaWVkIHRvIHJlZGlyZWN0IHRvIHRoZSBzYW1lIHJvdXRlIHlvdSdyZSBjdXJyZW50bHkgb246IFwiICsgKFwiXFxcIlwiICsgbmV4dFRvLnBhdGhuYW1lICsgbmV4dFRvLnNlYXJjaCArIFwiXFxcIlwiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wZXJmb3JtKCk7XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLmNvbXB1dGVUbyA9IGZ1bmN0aW9uIGNvbXB1dGVUbyhfcmVmKSB7XG4gICAgdmFyIGNvbXB1dGVkTWF0Y2ggPSBfcmVmLmNvbXB1dGVkTWF0Y2gsXG4gICAgICAgIHRvID0gX3JlZi50bztcblxuICAgIGlmIChjb21wdXRlZE1hdGNoKSB7XG4gICAgICBpZiAodHlwZW9mIHRvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVBhdGgodG8sIGNvbXB1dGVkTWF0Y2gucGFyYW1zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgdG8sIHtcbiAgICAgICAgICBwYXRobmFtZTogZ2VuZXJhdGVQYXRoKHRvLnBhdGhuYW1lLCBjb21wdXRlZE1hdGNoLnBhcmFtcylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvO1xuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gcGVyZm9ybSgpIHtcbiAgICB2YXIgaGlzdG9yeSA9IHRoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeTtcbiAgICB2YXIgcHVzaCA9IHRoaXMucHJvcHMucHVzaDtcblxuICAgIHZhciB0byA9IHRoaXMuY29tcHV0ZVRvKHRoaXMucHJvcHMpO1xuXG4gICAgaWYgKHB1c2gpIHtcbiAgICAgIGhpc3RvcnkucHVzaCh0byk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZSh0byk7XG4gICAgfVxuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFJlZGlyZWN0O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5SZWRpcmVjdC5wcm9wVHlwZXMgPSB7XG4gIGNvbXB1dGVkTWF0Y2g6IFByb3BUeXBlcy5vYmplY3QsIC8vIHByaXZhdGUsIGZyb20gPFN3aXRjaD5cbiAgcHVzaDogUHJvcFR5cGVzLmJvb2wsXG4gIGZyb206IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSkuaXNSZXF1aXJlZFxufTtcblJlZGlyZWN0LmRlZmF1bHRQcm9wcyA9IHtcbiAgcHVzaDogZmFsc2Vcbn07XG5SZWRpcmVjdC5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgcHVzaDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICAgIHJlcGxhY2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgICB9KS5pc1JlcXVpcmVkLFxuICAgIHN0YXRpY0NvbnRleHQ6IFByb3BUeXBlcy5vYmplY3RcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBSZWRpcmVjdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JlZGlyZWN0LmpzIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gXCJ3YXJuaW5nXCI7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gXCJpbnZhcmlhbnRcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBjcmVhdGVQYXRoIH0gZnJvbSBcImhpc3RvcnlcIjtcbmltcG9ydCBSb3V0ZXIgZnJvbSBcIi4vUm91dGVyXCI7XG5cbnZhciBhZGRMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiBhZGRMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09IFwiL1wiID8gcGF0aCA6IFwiL1wiICsgcGF0aDtcbn07XG5cbnZhciBhZGRCYXNlbmFtZSA9IGZ1bmN0aW9uIGFkZEJhc2VuYW1lKGJhc2VuYW1lLCBsb2NhdGlvbikge1xuICBpZiAoIWJhc2VuYW1lKSByZXR1cm4gbG9jYXRpb247XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgIHBhdGhuYW1lOiBhZGRMZWFkaW5nU2xhc2goYmFzZW5hbWUpICsgbG9jYXRpb24ucGF0aG5hbWVcbiAgfSk7XG59O1xuXG52YXIgc3RyaXBCYXNlbmFtZSA9IGZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUoYmFzZW5hbWUsIGxvY2F0aW9uKSB7XG4gIGlmICghYmFzZW5hbWUpIHJldHVybiBsb2NhdGlvbjtcblxuICB2YXIgYmFzZSA9IGFkZExlYWRpbmdTbGFzaChiYXNlbmFtZSk7XG5cbiAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmluZGV4T2YoYmFzZSkgIT09IDApIHJldHVybiBsb2NhdGlvbjtcblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLnN1YnN0cihiYXNlLmxlbmd0aClcbiAgfSk7XG59O1xuXG52YXIgY3JlYXRlVVJMID0gZnVuY3Rpb24gY3JlYXRlVVJMKGxvY2F0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgbG9jYXRpb24gPT09IFwic3RyaW5nXCIgPyBsb2NhdGlvbiA6IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xufTtcblxudmFyIHN0YXRpY0hhbmRsZXIgPSBmdW5jdGlvbiBzdGF0aWNIYW5kbGVyKG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IGNhbm5vdCAlcyB3aXRoIDxTdGF0aWNSb3V0ZXI+XCIsIG1ldGhvZE5hbWUpO1xuICB9O1xufTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbi8qKlxuICogVGhlIHB1YmxpYyB0b3AtbGV2ZWwgQVBJIGZvciBhIFwic3RhdGljXCIgPFJvdXRlcj4sIHNvLWNhbGxlZCBiZWNhdXNlIGl0XG4gKiBjYW4ndCBhY3R1YWxseSBjaGFuZ2UgdGhlIGN1cnJlbnQgbG9jYXRpb24uIEluc3RlYWQsIGl0IGp1c3QgcmVjb3Jkc1xuICogbG9jYXRpb24gY2hhbmdlcyBpbiBhIGNvbnRleHQgb2JqZWN0LiBVc2VmdWwgbWFpbmx5IGluIHRlc3RpbmcgYW5kXG4gKiBzZXJ2ZXItcmVuZGVyaW5nIHNjZW5hcmlvcy5cbiAqL1xuXG52YXIgU3RhdGljUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFN0YXRpY1JvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3RhdGljUm91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RhdGljUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5jcmVhdGVIcmVmID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHJldHVybiBhZGRMZWFkaW5nU2xhc2goX3RoaXMucHJvcHMuYmFzZW5hbWUgKyBjcmVhdGVVUkwocGF0aCkpO1xuICAgIH0sIF90aGlzLmhhbmRsZVB1c2ggPSBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGJhc2VuYW1lID0gX3RoaXMkcHJvcHMuYmFzZW5hbWUsXG4gICAgICAgICAgY29udGV4dCA9IF90aGlzJHByb3BzLmNvbnRleHQ7XG5cbiAgICAgIGNvbnRleHQuYWN0aW9uID0gXCJQVVNIXCI7XG4gICAgICBjb250ZXh0LmxvY2F0aW9uID0gYWRkQmFzZW5hbWUoYmFzZW5hbWUsIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSk7XG4gICAgICBjb250ZXh0LnVybCA9IGNyZWF0ZVVSTChjb250ZXh0LmxvY2F0aW9uKTtcbiAgICB9LCBfdGhpcy5oYW5kbGVSZXBsYWNlID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgYmFzZW5hbWUgPSBfdGhpcyRwcm9wczIuYmFzZW5hbWUsXG4gICAgICAgICAgY29udGV4dCA9IF90aGlzJHByb3BzMi5jb250ZXh0O1xuXG4gICAgICBjb250ZXh0LmFjdGlvbiA9IFwiUkVQTEFDRVwiO1xuICAgICAgY29udGV4dC5sb2NhdGlvbiA9IGFkZEJhc2VuYW1lKGJhc2VuYW1lLCBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpO1xuICAgICAgY29udGV4dC51cmwgPSBjcmVhdGVVUkwoY29udGV4dC5sb2NhdGlvbik7XG4gICAgfSwgX3RoaXMuaGFuZGxlTGlzdGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfSwgX3RoaXMuaGFuZGxlQmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIFN0YXRpY1JvdXRlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZXI6IHtcbiAgICAgICAgc3RhdGljQ29udGV4dDogdGhpcy5wcm9wcy5jb250ZXh0XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBTdGF0aWNSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksIFwiPFN0YXRpY1JvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgXCIgKyBcInVzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IFN0YXRpY1JvdXRlciBhcyBSb3V0ZXIgfWAuXCIpO1xuICB9O1xuXG4gIFN0YXRpY1JvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBiYXNlbmFtZSA9IF9wcm9wcy5iYXNlbmFtZSxcbiAgICAgICAgY29udGV4dCA9IF9wcm9wcy5jb250ZXh0LFxuICAgICAgICBsb2NhdGlvbiA9IF9wcm9wcy5sb2NhdGlvbixcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbXCJiYXNlbmFtZVwiLCBcImNvbnRleHRcIiwgXCJsb2NhdGlvblwiXSk7XG5cbiAgICB2YXIgaGlzdG9yeSA9IHtcbiAgICAgIGNyZWF0ZUhyZWY6IHRoaXMuY3JlYXRlSHJlZixcbiAgICAgIGFjdGlvbjogXCJQT1BcIixcbiAgICAgIGxvY2F0aW9uOiBzdHJpcEJhc2VuYW1lKGJhc2VuYW1lLCBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpLFxuICAgICAgcHVzaDogdGhpcy5oYW5kbGVQdXNoLFxuICAgICAgcmVwbGFjZTogdGhpcy5oYW5kbGVSZXBsYWNlLFxuICAgICAgZ286IHN0YXRpY0hhbmRsZXIoXCJnb1wiKSxcbiAgICAgIGdvQmFjazogc3RhdGljSGFuZGxlcihcImdvQmFja1wiKSxcbiAgICAgIGdvRm9yd2FyZDogc3RhdGljSGFuZGxlcihcImdvRm9yd2FyZFwiKSxcbiAgICAgIGxpc3RlbjogdGhpcy5oYW5kbGVMaXN0ZW4sXG4gICAgICBibG9jazogdGhpcy5oYW5kbGVCbG9ja1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIF9leHRlbmRzKHt9LCBwcm9wcywgeyBoaXN0b3J5OiBoaXN0b3J5IH0pKTtcbiAgfTtcblxuICByZXR1cm4gU3RhdGljUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5TdGF0aWNSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgY29udGV4dDogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pXG59O1xuU3RhdGljUm91dGVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgYmFzZW5hbWU6IFwiXCIsXG4gIGxvY2F0aW9uOiBcIi9cIlxufTtcblN0YXRpY1JvdXRlci5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgU3RhdGljUm91dGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3RhdGljUm91dGVyLmpzIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gXCJwcm9wLXR5cGVzXCI7XG5pbXBvcnQgd2FybmluZyBmcm9tIFwid2FybmluZ1wiO1xuaW1wb3J0IGludmFyaWFudCBmcm9tIFwiaW52YXJpYW50XCI7XG5pbXBvcnQgbWF0Y2hQYXRoIGZyb20gXCIuL21hdGNoUGF0aFwiO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgdGhlIGZpcnN0IDxSb3V0ZT4gdGhhdCBtYXRjaGVzLlxuICovXG5cbnZhciBTd2l0Y2ggPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU3dpdGNoLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTd2l0Y2goKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN3aXRjaCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFN3aXRjaC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGludmFyaWFudCh0aGlzLmNvbnRleHQucm91dGVyLCBcIllvdSBzaG91bGQgbm90IHVzZSA8U3dpdGNoPiBvdXRzaWRlIGEgPFJvdXRlcj5cIik7XG4gIH07XG5cbiAgU3dpdGNoLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB3YXJuaW5nKCEobmV4dFByb3BzLmxvY2F0aW9uICYmICF0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxTd2l0Y2g+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgaW5pdGlhbGx5IHVzZWQgbm8gXCJsb2NhdGlvblwiIHByb3AgYW5kIHRoZW4gcHJvdmlkZWQgb25lIG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG5cbiAgICB3YXJuaW5nKCEoIW5leHRQcm9wcy5sb2NhdGlvbiAmJiB0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxTd2l0Y2g+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgcHJvdmlkZWQgYSBcImxvY2F0aW9uXCIgcHJvcCBpbml0aWFsbHkgYnV0IG9taXR0ZWQgaXQgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKTtcbiAgfTtcblxuICBTd2l0Y2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcm91dGUgPSB0aGlzLmNvbnRleHQucm91dGVyLnJvdXRlO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG5cbiAgICB2YXIgbG9jYXRpb24gPSB0aGlzLnByb3BzLmxvY2F0aW9uIHx8IHJvdXRlLmxvY2F0aW9uO1xuXG4gICAgdmFyIG1hdGNoID0gdm9pZCAwLFxuICAgICAgICBjaGlsZCA9IHZvaWQgMDtcbiAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgaWYgKG1hdGNoID09IG51bGwgJiYgUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgdmFyIF9lbGVtZW50JHByb3BzID0gZWxlbWVudC5wcm9wcyxcbiAgICAgICAgICAgIHBhdGhQcm9wID0gX2VsZW1lbnQkcHJvcHMucGF0aCxcbiAgICAgICAgICAgIGV4YWN0ID0gX2VsZW1lbnQkcHJvcHMuZXhhY3QsXG4gICAgICAgICAgICBzdHJpY3QgPSBfZWxlbWVudCRwcm9wcy5zdHJpY3QsXG4gICAgICAgICAgICBzZW5zaXRpdmUgPSBfZWxlbWVudCRwcm9wcy5zZW5zaXRpdmUsXG4gICAgICAgICAgICBmcm9tID0gX2VsZW1lbnQkcHJvcHMuZnJvbTtcblxuICAgICAgICB2YXIgcGF0aCA9IHBhdGhQcm9wIHx8IGZyb207XG5cbiAgICAgICAgY2hpbGQgPSBlbGVtZW50O1xuICAgICAgICBtYXRjaCA9IG1hdGNoUGF0aChsb2NhdGlvbi5wYXRobmFtZSwgeyBwYXRoOiBwYXRoLCBleGFjdDogZXhhY3QsIHN0cmljdDogc3RyaWN0LCBzZW5zaXRpdmU6IHNlbnNpdGl2ZSB9LCByb3V0ZS5tYXRjaCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWF0Y2ggPyBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHsgbG9jYXRpb246IGxvY2F0aW9uLCBjb21wdXRlZE1hdGNoOiBtYXRjaCB9KSA6IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFN3aXRjaDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuU3dpdGNoLmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHJvdXRlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZFxufTtcblN3aXRjaC5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3Rcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgU3dpdGNoO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3dpdGNoLmpzIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gXCJwcm9wLXR5cGVzXCI7XG5pbXBvcnQgaG9pc3RTdGF0aWNzIGZyb20gXCJob2lzdC1ub24tcmVhY3Qtc3RhdGljc1wiO1xuaW1wb3J0IFJvdXRlIGZyb20gXCIuL1JvdXRlXCI7XG5cbi8qKlxuICogQSBwdWJsaWMgaGlnaGVyLW9yZGVyIGNvbXBvbmVudCB0byBhY2Nlc3MgdGhlIGltcGVyYXRpdmUgQVBJXG4gKi9cbnZhciB3aXRoUm91dGVyID0gZnVuY3Rpb24gd2l0aFJvdXRlcihDb21wb25lbnQpIHtcbiAgdmFyIEMgPSBmdW5jdGlvbiBDKHByb3BzKSB7XG4gICAgdmFyIHdyYXBwZWRDb21wb25lbnRSZWYgPSBwcm9wcy53cmFwcGVkQ29tcG9uZW50UmVmLFxuICAgICAgICByZW1haW5pbmdQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wid3JhcHBlZENvbXBvbmVudFJlZlwiXSk7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZSwge1xuICAgICAgY2hpbGRyZW46IGZ1bmN0aW9uIGNoaWxkcmVuKHJvdXRlQ29tcG9uZW50UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7fSwgcmVtYWluaW5nUHJvcHMsIHJvdXRlQ29tcG9uZW50UHJvcHMsIHtcbiAgICAgICAgICByZWY6IHdyYXBwZWRDb21wb25lbnRSZWZcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIEMuZGlzcGxheU5hbWUgPSBcIndpdGhSb3V0ZXIoXCIgKyAoQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lKSArIFwiKVwiO1xuICBDLldyYXBwZWRDb21wb25lbnQgPSBDb21wb25lbnQ7XG4gIEMucHJvcFR5cGVzID0ge1xuICAgIHdyYXBwZWRDb21wb25lbnRSZWY6IFByb3BUeXBlcy5mdW5jXG4gIH07XG5cbiAgcmV0dXJuIGhvaXN0U3RhdGljcyhDLCBDb21wb25lbnQpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgd2l0aFJvdXRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL3dpdGhSb3V0ZXIuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXHJcbmltcG9ydCB7IGh5ZHJhdGUgfSBmcm9tICdyZWFjdC1kb20nXHJcbmltcG9ydCBBcHAgZnJvbSAnLi4vc2hhcmVkL0FwcCdcclxuaW1wb3J0IHsgQnJvd3NlclJvdXRlciB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nXHJcblxyXG5oeWRyYXRlKFxyXG4gICAgPEJyb3dzZXJSb3V0ZXI+XHJcbiAgICAgICAgPEFwcCBkYXRhPXsgd2luZG93Ll9fSU5JVElBTF9EQVRBX18gfSAvPlxyXG4gICAgPC9Ccm93c2VyUm91dGVyPixcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcHAnKVxyXG4pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9icm93c2VyL2luZGV4LmpzIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi41LjJcbiAqIHJlYWN0LnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO3ZhciBtPXJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpLG49XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvcixwPW4/U3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIik6NjAxMDMscT1uP1N5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIik6NjAxMDYscj1uP1N5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKTo2MDEwNyx0PW4/U3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpOjYwMTA4LHU9bj9TeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIik6NjAxMTQsdj1uP1N5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKTo2MDEwOSx3PW4/U3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIik6NjAxMTAseD1uP1N5bWJvbC5mb3IoXCJyZWFjdC5hc3luY19tb2RlXCIpOjYwMTExLHk9bj9TeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIik6NjAxMTI7biYmU3ltYm9sLmZvcihcInJlYWN0LnBsYWNlaG9sZGVyXCIpO1xudmFyIHo9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yO2Z1bmN0aW9uIEEoYSxiLGQsYyxlLGcsaCxmKXtpZighYSl7YT12b2lkIDA7aWYodm9pZCAwPT09YilhPUVycm9yKFwiTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy5cIik7ZWxzZXt2YXIgaz1bZCxjLGUsZyxoLGZdLGw9MDthPUVycm9yKGIucmVwbGFjZSgvJXMvZyxmdW5jdGlvbigpe3JldHVybiBrW2wrK119KSk7YS5uYW1lPVwiSW52YXJpYW50IFZpb2xhdGlvblwifWEuZnJhbWVzVG9Qb3A9MTt0aHJvdyBhO319XG5mdW5jdGlvbiBCKGEpe2Zvcih2YXIgYj1hcmd1bWVudHMubGVuZ3RoLTEsZD1cImh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PVwiK2EsYz0wO2M8YjtjKyspZCs9XCImYXJnc1tdPVwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbYysxXSk7QSghMSxcIk1pbmlmaWVkIFJlYWN0IGVycm9yICNcIithK1wiOyB2aXNpdCAlcyBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuIFwiLGQpfXZhciBDPXtpc01vdW50ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oKXt9fSxEPXt9O1xuZnVuY3Rpb24gRShhLGIsZCl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1EO3RoaXMudXBkYXRlcj1kfHxDfUUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9e307RS5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24oYSxiKXtcIm9iamVjdFwiIT09dHlwZW9mIGEmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiZudWxsIT1hP0IoXCI4NVwiKTp2b2lkIDA7dGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLGEsYixcInNldFN0YXRlXCIpfTtFLnByb3RvdHlwZS5mb3JjZVVwZGF0ZT1mdW5jdGlvbihhKXt0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsYSxcImZvcmNlVXBkYXRlXCIpfTtmdW5jdGlvbiBGKCl7fUYucHJvdG90eXBlPUUucHJvdG90eXBlO2Z1bmN0aW9uIEcoYSxiLGQpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9RDt0aGlzLnVwZGF0ZXI9ZHx8Q312YXIgSD1HLnByb3RvdHlwZT1uZXcgRjtcbkguY29uc3RydWN0b3I9RzttKEgsRS5wcm90b3R5cGUpO0guaXNQdXJlUmVhY3RDb21wb25lbnQ9ITA7dmFyIEk9e2N1cnJlbnQ6bnVsbCxjdXJyZW50RGlzcGF0Y2hlcjpudWxsfSxKPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksSz17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuZnVuY3Rpb24gTChhLGIsZCl7dmFyIGM9dm9pZCAwLGU9e30sZz1udWxsLGg9bnVsbDtpZihudWxsIT1iKWZvcihjIGluIHZvaWQgMCE9PWIucmVmJiYoaD1iLnJlZiksdm9pZCAwIT09Yi5rZXkmJihnPVwiXCIrYi5rZXkpLGIpSi5jYWxsKGIsYykmJiFLLmhhc093blByb3BlcnR5KGMpJiYoZVtjXT1iW2NdKTt2YXIgZj1hcmd1bWVudHMubGVuZ3RoLTI7aWYoMT09PWYpZS5jaGlsZHJlbj1kO2Vsc2UgaWYoMTxmKXtmb3IodmFyIGs9QXJyYXkoZiksbD0wO2w8ZjtsKyspa1tsXT1hcmd1bWVudHNbbCsyXTtlLmNoaWxkcmVuPWt9aWYoYSYmYS5kZWZhdWx0UHJvcHMpZm9yKGMgaW4gZj1hLmRlZmF1bHRQcm9wcyxmKXZvaWQgMD09PWVbY10mJihlW2NdPWZbY10pO3JldHVybnskJHR5cGVvZjpwLHR5cGU6YSxrZXk6ZyxyZWY6aCxwcm9wczplLF9vd25lcjpJLmN1cnJlbnR9fVxuZnVuY3Rpb24gTShhLGIpe3JldHVybnskJHR5cGVvZjpwLHR5cGU6YS50eXBlLGtleTpiLHJlZjphLnJlZixwcm9wczphLnByb3BzLF9vd25lcjphLl9vd25lcn19ZnVuY3Rpb24gTihhKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09cH1mdW5jdGlvbiBlc2NhcGUoYSl7dmFyIGI9e1wiPVwiOlwiPTBcIixcIjpcIjpcIj0yXCJ9O3JldHVyblwiJFwiKyhcIlwiK2EpLnJlcGxhY2UoL1s9Ol0vZyxmdW5jdGlvbihhKXtyZXR1cm4gYlthXX0pfXZhciBPPS9cXC8rL2csUD1bXTtmdW5jdGlvbiBRKGEsYixkLGMpe2lmKFAubGVuZ3RoKXt2YXIgZT1QLnBvcCgpO2UucmVzdWx0PWE7ZS5rZXlQcmVmaXg9YjtlLmZ1bmM9ZDtlLmNvbnRleHQ9YztlLmNvdW50PTA7cmV0dXJuIGV9cmV0dXJue3Jlc3VsdDphLGtleVByZWZpeDpiLGZ1bmM6ZCxjb250ZXh0OmMsY291bnQ6MH19XG5mdW5jdGlvbiBSKGEpe2EucmVzdWx0PW51bGw7YS5rZXlQcmVmaXg9bnVsbDthLmZ1bmM9bnVsbDthLmNvbnRleHQ9bnVsbDthLmNvdW50PTA7MTA+UC5sZW5ndGgmJlAucHVzaChhKX1cbmZ1bmN0aW9uIFMoYSxiLGQsYyl7dmFyIGU9dHlwZW9mIGE7aWYoXCJ1bmRlZmluZWRcIj09PWV8fFwiYm9vbGVhblwiPT09ZSlhPW51bGw7dmFyIGc9ITE7aWYobnVsbD09PWEpZz0hMDtlbHNlIHN3aXRjaChlKXtjYXNlIFwic3RyaW5nXCI6Y2FzZSBcIm51bWJlclwiOmc9ITA7YnJlYWs7Y2FzZSBcIm9iamVjdFwiOnN3aXRjaChhLiQkdHlwZW9mKXtjYXNlIHA6Y2FzZSBxOmc9ITB9fWlmKGcpcmV0dXJuIGQoYyxhLFwiXCI9PT1iP1wiLlwiK1QoYSwwKTpiKSwxO2c9MDtiPVwiXCI9PT1iP1wiLlwiOmIrXCI6XCI7aWYoQXJyYXkuaXNBcnJheShhKSlmb3IodmFyIGg9MDtoPGEubGVuZ3RoO2grKyl7ZT1hW2hdO3ZhciBmPWIrVChlLGgpO2crPVMoZSxmLGQsYyl9ZWxzZSBpZihudWxsPT09YXx8XCJvYmplY3RcIiE9PXR5cGVvZiBhP2Y9bnVsbDooZj16JiZhW3pdfHxhW1wiQEBpdGVyYXRvclwiXSxmPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBmP2Y6bnVsbCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGYpZm9yKGE9Zi5jYWxsKGEpLGg9XG4wOyEoZT1hLm5leHQoKSkuZG9uZTspZT1lLnZhbHVlLGY9YitUKGUsaCsrKSxnKz1TKGUsZixkLGMpO2Vsc2VcIm9iamVjdFwiPT09ZSYmKGQ9XCJcIithLEIoXCIzMVwiLFwiW29iamVjdCBPYmplY3RdXCI9PT1kP1wib2JqZWN0IHdpdGgga2V5cyB7XCIrT2JqZWN0LmtleXMoYSkuam9pbihcIiwgXCIpK1wifVwiOmQsXCJcIikpO3JldHVybiBnfWZ1bmN0aW9uIFUoYSxiLGQpe3JldHVybiBudWxsPT1hPzA6UyhhLFwiXCIsYixkKX1mdW5jdGlvbiBUKGEsYil7cmV0dXJuXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmbnVsbCE9YS5rZXk/ZXNjYXBlKGEua2V5KTpiLnRvU3RyaW5nKDM2KX1mdW5jdGlvbiBWKGEsYil7YS5mdW5jLmNhbGwoYS5jb250ZXh0LGIsYS5jb3VudCsrKX1cbmZ1bmN0aW9uIGFhKGEsYixkKXt2YXIgYz1hLnJlc3VsdCxlPWEua2V5UHJlZml4O2E9YS5mdW5jLmNhbGwoYS5jb250ZXh0LGIsYS5jb3VudCsrKTtBcnJheS5pc0FycmF5KGEpP1coYSxjLGQsZnVuY3Rpb24oYSl7cmV0dXJuIGF9KTpudWxsIT1hJiYoTihhKSYmKGE9TShhLGUrKCFhLmtleXx8YiYmYi5rZXk9PT1hLmtleT9cIlwiOihcIlwiK2Eua2V5KS5yZXBsYWNlKE8sXCIkJi9cIikrXCIvXCIpK2QpKSxjLnB1c2goYSkpfWZ1bmN0aW9uIFcoYSxiLGQsYyxlKXt2YXIgZz1cIlwiO251bGwhPWQmJihnPShcIlwiK2QpLnJlcGxhY2UoTyxcIiQmL1wiKStcIi9cIik7Yj1RKGIsZyxjLGUpO1UoYSxhYSxiKTtSKGIpfWZ1bmN0aW9uIGJhKGEsYil7dmFyIGQ9SS5jdXJyZW50RGlzcGF0Y2hlcjtudWxsPT09ZD9CKFwiMjc3XCIpOnZvaWQgMDtyZXR1cm4gZC5yZWFkQ29udGV4dChhLGIpfVxudmFyIFg9e0NoaWxkcmVuOnttYXA6ZnVuY3Rpb24oYSxiLGQpe2lmKG51bGw9PWEpcmV0dXJuIGE7dmFyIGM9W107VyhhLGMsbnVsbCxiLGQpO3JldHVybiBjfSxmb3JFYWNoOmZ1bmN0aW9uKGEsYixkKXtpZihudWxsPT1hKXJldHVybiBhO2I9UShudWxsLG51bGwsYixkKTtVKGEsVixiKTtSKGIpfSxjb3VudDpmdW5jdGlvbihhKXtyZXR1cm4gVShhLGZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LG51bGwpfSx0b0FycmF5OmZ1bmN0aW9uKGEpe3ZhciBiPVtdO1coYSxiLG51bGwsZnVuY3Rpb24oYSl7cmV0dXJuIGF9KTtyZXR1cm4gYn0sb25seTpmdW5jdGlvbihhKXtOKGEpP3ZvaWQgMDpCKFwiMTQzXCIpO3JldHVybiBhfX0sY3JlYXRlUmVmOmZ1bmN0aW9uKCl7cmV0dXJue2N1cnJlbnQ6bnVsbH19LENvbXBvbmVudDpFLFB1cmVDb21wb25lbnQ6RyxjcmVhdGVDb250ZXh0OmZ1bmN0aW9uKGEsYil7dm9pZCAwPT09YiYmKGI9bnVsbCk7YT17JCR0eXBlb2Y6dyxfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6Yixcbl9jdXJyZW50VmFsdWU6YSxfY3VycmVudFZhbHVlMjphLFByb3ZpZGVyOm51bGwsQ29uc3VtZXI6bnVsbCx1bnN0YWJsZV9yZWFkOm51bGx9O2EuUHJvdmlkZXI9eyQkdHlwZW9mOnYsX2NvbnRleHQ6YX07YS5Db25zdW1lcj1hO2EudW5zdGFibGVfcmVhZD1iYS5iaW5kKG51bGwsYSk7cmV0dXJuIGF9LGZvcndhcmRSZWY6ZnVuY3Rpb24oYSl7cmV0dXJueyQkdHlwZW9mOnkscmVuZGVyOmF9fSxGcmFnbWVudDpyLFN0cmljdE1vZGU6dCx1bnN0YWJsZV9Bc3luY01vZGU6eCx1bnN0YWJsZV9Qcm9maWxlcjp1LGNyZWF0ZUVsZW1lbnQ6TCxjbG9uZUVsZW1lbnQ6ZnVuY3Rpb24oYSxiLGQpe251bGw9PT1hfHx2b2lkIDA9PT1hP0IoXCIyNjdcIixhKTp2b2lkIDA7dmFyIGM9dm9pZCAwLGU9bSh7fSxhLnByb3BzKSxnPWEua2V5LGg9YS5yZWYsZj1hLl9vd25lcjtpZihudWxsIT1iKXt2b2lkIDAhPT1iLnJlZiYmKGg9Yi5yZWYsZj1JLmN1cnJlbnQpO3ZvaWQgMCE9PWIua2V5JiYoZz1cIlwiK2Iua2V5KTtcbnZhciBrPXZvaWQgMDthLnR5cGUmJmEudHlwZS5kZWZhdWx0UHJvcHMmJihrPWEudHlwZS5kZWZhdWx0UHJvcHMpO2ZvcihjIGluIGIpSi5jYWxsKGIsYykmJiFLLmhhc093blByb3BlcnR5KGMpJiYoZVtjXT12b2lkIDA9PT1iW2NdJiZ2b2lkIDAhPT1rP2tbY106YltjXSl9Yz1hcmd1bWVudHMubGVuZ3RoLTI7aWYoMT09PWMpZS5jaGlsZHJlbj1kO2Vsc2UgaWYoMTxjKXtrPUFycmF5KGMpO2Zvcih2YXIgbD0wO2w8YztsKyspa1tsXT1hcmd1bWVudHNbbCsyXTtlLmNoaWxkcmVuPWt9cmV0dXJueyQkdHlwZW9mOnAsdHlwZTphLnR5cGUsa2V5OmcscmVmOmgscHJvcHM6ZSxfb3duZXI6Zn19LGNyZWF0ZUZhY3Rvcnk6ZnVuY3Rpb24oYSl7dmFyIGI9TC5iaW5kKG51bGwsYSk7Yi50eXBlPWE7cmV0dXJuIGJ9LGlzVmFsaWRFbGVtZW50Ok4sdmVyc2lvbjpcIjE2LjUuMlwiLF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOntSZWFjdEN1cnJlbnRPd25lcjpJLFxuYXNzaWduOm19fSxZPXtkZWZhdWx0Olh9LFo9WSYmWHx8WTttb2R1bGUuZXhwb3J0cz1aLmRlZmF1bHR8fFo7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi41LjJcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcycpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNi41LjInO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTtcbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfUExBQ0VIT0xERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBsYWNlaG9sZGVyJykgOiAweGVhZDE7XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEV4cG9ydHMgUmVhY3RET00uY3JlYXRlUm9vdFxuXG5cbi8vIEV4cGVyaW1lbnRhbCBlcnJvci1ib3VuZGFyeSBBUEkgdGhhdCBjYW4gcmVjb3ZlciBmcm9tIGVycm9ycyB3aXRoaW4gYSBzaW5nbGVcbi8vIHJlbmRlciBwaGFzZVxuXG4vLyBTdXNwZW5zZVxudmFyIGVuYWJsZVN1c3BlbnNlID0gZmFsc2U7XG4vLyBIZWxwcyBpZGVudGlmeSBzaWRlIGVmZmVjdHMgaW4gYmVnaW4tcGhhc2UgbGlmZWN5Y2xlIGhvb2tzIGFuZCBzZXRTdGF0ZSByZWR1Y2VyczpcblxuXG4vLyBJbiBzb21lIGNhc2VzLCBTdHJpY3RNb2RlIHNob3VsZCBhbHNvIGRvdWJsZS1yZW5kZXIgbGlmZWN5Y2xlcy5cbi8vIFRoaXMgY2FuIGJlIGNvbmZ1c2luZyBmb3IgdGVzdHMgdGhvdWdoLFxuLy8gQW5kIGl0IGNhbiBiZSBiYWQgZm9yIHBlcmZvcm1hbmNlIGluIHByb2R1Y3Rpb24uXG4vLyBUaGlzIGZlYXR1cmUgZmxhZyBjYW4gYmUgdXNlZCB0byBjb250cm9sIHRoZSBiZWhhdmlvcjpcblxuXG4vLyBUbyBwcmVzZXJ2ZSB0aGUgXCJQYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9uc1wiIGJlaGF2aW9yIG9mIHRoZSBkZWJ1Z2dlciwgd2Vcbi8vIHJlcGxheSB0aGUgYmVnaW4gcGhhc2Ugb2YgYSBmYWlsZWQgY29tcG9uZW50IGluc2lkZSBpbnZva2VHdWFyZGVkQ2FsbGJhY2suXG5cblxuLy8gV2FybiBhYm91dCBkZXByZWNhdGVkLCBhc3luYy11bnNhZmUgbGlmZWN5Y2xlczsgcmVsYXRlcyB0byBSRkMgIzY6XG5cblxuLy8gV2FybiBhYm91dCBsZWdhY3kgY29udGV4dCBBUElcblxuXG4vLyBHYXRoZXIgYWR2YW5jZWQgdGltaW5nIG1ldHJpY3MgZm9yIFByb2ZpbGVyIHN1YnRyZWVzLlxuXG5cbi8vIFRyYWNlIHdoaWNoIGludGVyYWN0aW9ucyB0cmlnZ2VyIGVhY2ggY29tbWl0LlxuXG5cbi8vIE9ubHkgdXNlZCBpbiB3d3cgYnVpbGRzLlxuXG5cbi8vIE9ubHkgdXNlZCBpbiB3d3cgYnVpbGRzLlxuXG5cbi8vIFJlYWN0IEZpcmU6IHByZXZlbnQgdGhlIHZhbHVlIGFuZCBjaGVja2VkIGF0dHJpYnV0ZXMgZnJvbSBzeW5jaW5nXG4vLyB3aXRoIHRoZWlyIHJlbGF0ZWQgRE9NIHByb3BlcnRpZXNcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvciA9IHZvaWQgMDtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLy8gUmVseWluZyBvbiB0aGUgYGludmFyaWFudCgpYCBpbXBsZW1lbnRhdGlvbiBsZXRzIHVzXG4vLyBwcmVzZXJ2ZSB0aGUgZm9ybWF0IGFuZCBwYXJhbXMgaW4gdGhlIHd3dyBidWlsZHMuXG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYGxvd1ByaW9yaXR5V2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmdXaXRob3V0U3RhY2sgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB3YXJuaW5nV2l0aG91dFN0YWNrID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmdXaXRob3V0U3RhY2soY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA+IDgpIHtcbiAgICAgIC8vIENoZWNrIGJlZm9yZSB0aGUgY29uZGl0aW9uIHRvIGNhdGNoIHZpb2xhdGlvbnMgZWFybHkuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dhcm5pbmdXaXRob3V0U3RhY2soKSBjdXJyZW50bHkgc3VwcG9ydHMgYXQgbW9zdCA4IGFyZ3VtZW50cy4nKTtcbiAgICB9XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgX2FyZ3MkbWFwID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICAgIH0pLFxuICAgICAgICAgIGEgPSBfYXJncyRtYXBbMF0sXG4gICAgICAgICAgYiA9IF9hcmdzJG1hcFsxXSxcbiAgICAgICAgICBjID0gX2FyZ3MkbWFwWzJdLFxuICAgICAgICAgIGQgPSBfYXJncyRtYXBbM10sXG4gICAgICAgICAgZSA9IF9hcmdzJG1hcFs0XSxcbiAgICAgICAgICBmID0gX2FyZ3MkbWFwWzVdLFxuICAgICAgICAgIGcgPSBfYXJncyRtYXBbNl0sXG4gICAgICAgICAgaCA9IF9hcmdzJG1hcFs3XTtcblxuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdDtcblxuICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGJlY2F1c2UgaXQgYnJlYWtzIElFOTpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCBhLCBiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSwgYSwgYiwgYyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGEsIGIsIGMsIGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCBhLCBiLCBjLCBkLCBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSwgYSwgYiwgYywgZCwgZSwgZik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGEsIGIsIGMsIGQsIGUsIGYsIGcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCBhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dhcm5pbmdXaXRob3V0U3RhY2soKSBjdXJyZW50bHkgc3VwcG9ydHMgYXQgbW9zdCA4IGFyZ3VtZW50cy4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIF9tZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKF9tZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG52YXIgd2FybmluZ1dpdGhvdXRTdGFjayQxID0gd2FybmluZ1dpdGhvdXRTdGFjaztcblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIChfY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgX2NvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyAnLicgKyBjYWxsZXJOYW1lO1xuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCBcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFwiICsgJ1RoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uICcgKyAnSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgICcgKyAnY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xue1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpIDogdm9pZCAwO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgY29tcG9uZW50IHdpdGggZGVmYXVsdCBzaGFsbG93IGVxdWFsaXR5IGNoZWNrIGZvciBzQ1UuXG4gKi9cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbnZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKHB1cmVDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbi8vIGFuIGltbXV0YWJsZSBvYmplY3Qgd2l0aCBhIHNpbmdsZSBtdXRhYmxlIHZhbHVlXG5mdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG4gIHZhciByZWZPYmplY3QgPSB7XG4gICAgY3VycmVudDogbnVsbFxuICB9O1xuICB7XG4gICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVmT2JqZWN0O1xufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGwsXG4gIGN1cnJlbnREaXNwYXRjaGVyOiBudWxsXG59O1xuXG52YXIgQkVGT1JFX1NMQVNIX1JFID0gL14oLiopW1xcXFxcXC9dLztcblxudmFyIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUgPSBmdW5jdGlvbiAobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgdmFyIHNvdXJjZUluZm8gPSAnJztcbiAgaWYgKHNvdXJjZSkge1xuICAgIHZhciBwYXRoID0gc291cmNlLmZpbGVOYW1lO1xuICAgIHZhciBmaWxlTmFtZSA9IHBhdGgucmVwbGFjZShCRUZPUkVfU0xBU0hfUkUsICcnKTtcbiAgICB7XG4gICAgICAvLyBJbiBERVYsIGluY2x1ZGUgY29kZSBmb3IgYSBjb21tb24gc3BlY2lhbCBjYXNlOlxuICAgICAgLy8gcHJlZmVyIFwiZm9sZGVyL2luZGV4LmpzXCIgaW5zdGVhZCBvZiBqdXN0IFwiaW5kZXguanNcIi5cbiAgICAgIGlmICgvXmluZGV4XFwuLy50ZXN0KGZpbGVOYW1lKSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBwYXRoLm1hdGNoKEJFRk9SRV9TTEFTSF9SRSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHZhciBwYXRoQmVmb3JlU2xhc2ggPSBtYXRjaFsxXTtcbiAgICAgICAgICBpZiAocGF0aEJlZm9yZVNsYXNoKSB7XG4gICAgICAgICAgICB2YXIgZm9sZGVyTmFtZSA9IHBhdGhCZWZvcmVTbGFzaC5yZXBsYWNlKEJFRk9SRV9TTEFTSF9SRSwgJycpO1xuICAgICAgICAgICAgZmlsZU5hbWUgPSBmb2xkZXJOYW1lICsgJy8nICsgZmlsZU5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZUluZm8gPSAnIChhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJztcbiAgfSBlbHNlIGlmIChvd25lck5hbWUpIHtcbiAgICBzb3VyY2VJbmZvID0gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknO1xuICB9XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgc291cmNlSW5mbztcbn07XG5cbnZhciBSZXNvbHZlZCA9IDE7XG5cblxuXG5cbmZ1bmN0aW9uIHJlZmluZVJlc29sdmVkVGhlbmFibGUodGhlbmFibGUpIHtcbiAgcmV0dXJuIHRoZW5hYmxlLl9yZWFjdFN0YXR1cyA9PT0gUmVzb2x2ZWQgPyB0aGVuYWJsZS5fcmVhY3RSZXN1bHQgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdBc3luY01vZGUnO1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcbiAgICBjYXNlIFJFQUNUX1BMQUNFSE9MREVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1BsYWNlaG9sZGVyJztcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgcmV0dXJuICdDb250ZXh0LkNvbnN1bWVyJztcbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgcmV0dXJuICdDb250ZXh0LlByb3ZpZGVyJztcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgdmFyIHJlbmRlckZuID0gdHlwZS5yZW5kZXI7XG4gICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSByZW5kZXJGbi5kaXNwbGF5TmFtZSB8fCByZW5kZXJGbi5uYW1lIHx8ICcnO1xuICAgICAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/ICdGb3J3YXJkUmVmKCcgKyBmdW5jdGlvbk5hbWUgKyAnKScgOiAnRm9yd2FyZFJlZicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHR5cGUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRoZW5hYmxlID0gdHlwZTtcbiAgICAgIHZhciByZXNvbHZlZFRoZW5hYmxlID0gcmVmaW5lUmVzb2x2ZWRUaGVuYWJsZSh0aGVuYWJsZSk7XG4gICAgICBpZiAocmVzb2x2ZWRUaGVuYWJsZSkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShyZXNvbHZlZFRoZW5hYmxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG5cbnZhciBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZWxlbWVudDtcbiAgfVxufVxuXG57XG4gIC8vIFN0YWNrIGltcGxlbWVudGF0aW9uIGluamVjdGVkIGJ5IHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnO1xuXG4gICAgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuICAgIGlmIChjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50LnR5cGUpO1xuICAgICAgdmFyIG93bmVyID0gY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX293bmVyO1xuICAgICAgc3RhY2sgKz0gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fc291cmNlLCBvd25lciAmJiBnZXRDb21wb25lbnROYW1lKG93bmVyLnR5cGUpKTtcbiAgICB9XG5cbiAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgaW5qZWN0ZWQgcmVuZGVyZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuICAgIGlmIChpbXBsKSB7XG4gICAgICBzdGFjayArPSBpbXBsKCkgfHwgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgLy8gVXNlZCBieSByZW5kZXJlcnMgdG8gYXZvaWQgYnVuZGxpbmcgb2JqZWN0LWFzc2lnbiB0d2ljZSBpbiBVTUQgYnVuZGxlczpcbiAgYXNzaWduOiBfYXNzaWduXG59O1xuXG57XG4gIF9hc3NpZ24oUmVhY3RTaGFyZWRJbnRlcm5hbHMsIHtcbiAgICAvLyBUaGVzZSBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHByb2R1Y3Rpb24uXG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTogUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSxcbiAgICAvLyBTaGltIGZvciBSZWFjdCBET00gMTYuMC4wIHdoaWNoIHN0aWxsIGRlc3RydWN0dXJlZCAoYnV0IG5vdCB1c2VkKSB0aGlzLlxuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBSZWFjdCAxNy4wLlxuICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s6IHt9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IHdhcm5pbmdXaXRob3V0U3RhY2skMTtcblxue1xuICB3YXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3dhcm5pbmctYW5kLWludmFyaWFudC1hcmdzXG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMS5hcHBseSh1bmRlZmluZWQsIFtmYWxzZSwgZm9ybWF0ICsgJyVzJ10uY29uY2F0KGFyZ3MsIFtzdGFja10pKTtcbiAgfTtcbn1cblxudmFyIHdhcm5pbmckMSA9IHdhcm5pbmc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG5cbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHZvaWQgMDtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHZvaWQgMDtcblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTtcbiAgICAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7XG4gICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZSA9IHZvaWQgMDtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIFJlYWN0RWxlbWVudHMgb2YgYSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVmYWN0b3J5XG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG5cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICAhIShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCAlcy4nLCBlbGVtZW50KSA6IHZvaWQgMDtcblxuICB2YXIgcHJvcE5hbWUgPSB2b2lkIDA7XG5cbiAgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB2b2lkIDA7XG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSAoJycgKyBrZXkpLnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG5cbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuXG52YXIgUE9PTF9TSVpFID0gMTA7XG52YXIgdHJhdmVyc2VDb250ZXh0UG9vbCA9IFtdO1xuZnVuY3Rpb24gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gdHJhdmVyc2VDb250ZXh0UG9vbC5wb3AoKTtcbiAgICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbWFwUmVzdWx0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gICAgdHJhdmVyc2VDb250ZXh0LmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY29udGV4dCA9IG1hcENvbnRleHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcbiAgICByZXR1cm4gdHJhdmVyc2VDb250ZXh0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IG1hcFJlc3VsdCxcbiAgICAgIGtleVByZWZpeDoga2V5UHJlZml4LFxuICAgICAgZnVuYzogbWFwRnVuY3Rpb24sXG4gICAgICBjb250ZXh0OiBtYXBDb250ZXh0LFxuICAgICAgY291bnQ6IDBcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KSB7XG4gIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmZ1bmMgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY29udGV4dCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCA8IFBPT0xfU0laRSkge1xuICAgIHRyYXZlcnNlQ29udGV4dFBvb2wucHVzaCh0cmF2ZXJzZUNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQgPSB2b2lkIDA7XG4gIHZhciBuZXh0TmFtZSA9IHZvaWQgMDtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgICFkaWRXYXJuQWJvdXRNYXBzID8gd2FybmluZyQxKGZhbHNlLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXAgPSB2b2lkIDA7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQgIT09IG51bGwgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChudWxsLCBudWxsLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50RGlzcGF0Y2hlcjtcbiAgIShkaXNwYXRjaGVyICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0NvbnRleHQudW5zdGFibGVfcmVhZCgpOiBDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLCBlLmcuIGluc2lkZSB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuJykgOiB2b2lkIDA7XG4gIHJldHVybiBkaXNwYXRjaGVyLnJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykge1xuICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICAhKGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSBudWxsIHx8IHR5cGVvZiBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gJ2Z1bmN0aW9uJykgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdjcmVhdGVDb250ZXh0OiBFeHBlY3RlZCB0aGUgb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNhbGN1bGF0ZUNoYW5nZWRCaXRzLFxuICAgIC8vIEFzIGEgd29ya2Fyb3VuZCB0byBzdXBwb3J0IG11bHRpcGxlIGNvbmN1cnJlbnQgcmVuZGVyZXJzLCB3ZSBjYXRlZ29yaXplXG4gICAgLy8gc29tZSByZW5kZXJlcnMgYXMgcHJpbWFyeSBhbmQgb3RoZXJzIGFzIHNlY29uZGFyeS4gV2Ugb25seSBleHBlY3RcbiAgICAvLyB0aGVyZSB0byBiZSB0d28gY29uY3VycmVudCByZW5kZXJlcnMgYXQgbW9zdDogUmVhY3QgTmF0aXZlIChwcmltYXJ5KSBhbmRcbiAgICAvLyBGYWJyaWMgKHNlY29uZGFyeSk7IFJlYWN0IERPTSAocHJpbWFyeSkgYW5kIFJlYWN0IEFSVCAoc2Vjb25kYXJ5KS5cbiAgICAvLyBTZWNvbmRhcnkgcmVuZGVyZXJzIHN0b3JlIHRoZWlyIGNvbnRleHQgdmFsdWVzIG9uIHNlcGFyYXRlIGZpZWxkcy5cbiAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbCxcbiAgICB1bnN0YWJsZV9yZWFkOiBudWxsXG4gIH07XG5cbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dFxuICB9O1xuICBjb250ZXh0LkNvbnN1bWVyID0gY29udGV4dDtcbiAgY29udGV4dC51bnN0YWJsZV9yZWFkID0gcmVhZENvbnRleHQuYmluZChudWxsLCBjb250ZXh0KTtcblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBsYXp5KGN0b3IpIHtcbiAgdmFyIHRoZW5hYmxlID0gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAodGhlbmFibGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gTGF6aWx5IGNyZWF0ZSB0aGVuYWJsZSBieSB3cmFwcGluZyBpbiBhbiBleHRyYSB0aGVuYWJsZS5cbiAgICAgICAgdGhlbmFibGUgPSBjdG9yKCk7XG4gICAgICAgIGN0b3IgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoZW5hYmxlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9LFxuXG4gICAgLy8gUmVhY3QgdXNlcyB0aGVzZSBmaWVsZHMgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAgICBfcmVhY3RTdGF0dXM6IC0xLFxuICAgIF9yZWFjdFJlc3VsdDogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICB7XG4gICAgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHdhcyBnaXZlbiAlcy4nLCByZW5kZXIgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcmVuZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgIShcbiAgICAgIC8vIERvIG5vdCB3YXJuIGZvciAwIGFyZ3VtZW50cyBiZWNhdXNlIGl0IGNvdWxkIGJlIGR1ZSB0byB1c2FnZSBvZiB0aGUgJ2FyZ3VtZW50cycgb2JqZWN0XG4gICAgICByZW5kZXIubGVuZ3RoID09PSAwIHx8IHJlbmRlci5sZW5ndGggPT09IDIpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGFjY2VwdCBleGFjdGx5IHR3byBwYXJhbWV0ZXJzOiBwcm9wcyBhbmQgcmVmLiAlcycsIHJlbmRlci5sZW5ndGggPT09IDEgPyAnRGlkIHlvdSBmb3JnZXQgdG8gdXNlIHRoZSByZWYgcGFyYW1ldGVyPycgOiAnQW55IGFkZGl0aW9uYWwgcGFyYW1ldGVyIHdpbGwgYmUgdW5kZWZpbmVkLicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIGlmIChyZW5kZXIgIT0gbnVsbCkge1xuICAgICAgIShyZW5kZXIuZGVmYXVsdFByb3BzID09IG51bGwgJiYgcmVuZGVyLnByb3BUeXBlcyA9PSBudWxsKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBwcm9wVHlwZXMgb3IgZGVmYXVsdFByb3BzLiAnICsgJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/JykgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8XG4gIC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QTEFDRUhPTERFUl9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlb2YgdHlwZS50aGVuID09PSAnZnVuY3Rpb24nIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpO1xufVxuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudFByb3BzLl9fc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudFByb3BzLl9fc291cmNlO1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSAnXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lci50eXBlKSArICcuJztcbiAgfVxuXG4gIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuICB7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcbiAgfVxuICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcCA9IHZvaWQgMDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIG5hbWUgPSB2b2lkIDAsXG4gICAgICBwcm9wVHlwZXMgPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIENsYXNzIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgbmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpIHtcbiAgICAvLyBGb3J3YXJkUmVmXG4gICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHR5cGUucmVuZGVyLmRpc3BsYXlOYW1lIHx8IHR5cGUucmVuZGVyLm5hbWUgfHwgJyc7XG4gICAgbmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyAnRm9yd2FyZFJlZignICsgZnVuY3Rpb25OYW1lICsgJyknIDogJ0ZvcndhcmRSZWYnKTtcbiAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb3BUeXBlcykge1xuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0pO1xuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIG5hbWUgfHwgJ1Vua25vd24nKTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuICB9XG5cbiAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTtcblxuICAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShwcm9wcyk7XG4gICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZVN0cmluZyA9IHZvaWQgMDtcbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgdHlwZVN0cmluZyA9ICc8JyArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArICcgLz4nO1xuICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgfVxuXG4gICAgd2FybmluZyQxKGZhbHNlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgaWYgKHZhbGlkVHlwZSkge1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIC8vIExlZ2FjeSBob29rOiByZW1vdmUgaXRcbiAge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgbmV3RWxlbWVudCA9IGNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbnZhciBSZWFjdCA9IHtcbiAgQ2hpbGRyZW46IHtcbiAgICBtYXA6IG1hcENoaWxkcmVuLFxuICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgICB0b0FycmF5OiB0b0FycmF5LFxuICAgIG9ubHk6IG9ubHlDaGlsZFxuICB9LFxuXG4gIGNyZWF0ZVJlZjogY3JlYXRlUmVmLFxuICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUHVyZUNvbXBvbmVudCxcblxuICBjcmVhdGVDb250ZXh0OiBjcmVhdGVDb250ZXh0LFxuICBmb3J3YXJkUmVmOiBmb3J3YXJkUmVmLFxuXG4gIEZyYWdtZW50OiBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuICBTdHJpY3RNb2RlOiBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFLFxuICB1bnN0YWJsZV9Bc3luY01vZGU6IFJFQUNUX0FTWU5DX01PREVfVFlQRSxcbiAgdW5zdGFibGVfUHJvZmlsZXI6IFJFQUNUX1BST0ZJTEVSX1RZUEUsXG5cbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLFxuICBjbG9uZUVsZW1lbnQ6IGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uLFxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24sXG4gIGlzVmFsaWRFbGVtZW50OiBpc1ZhbGlkRWxlbWVudCxcblxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6IFJlYWN0U2hhcmVkSW50ZXJuYWxzXG59O1xuXG5pZiAoZW5hYmxlU3VzcGVuc2UpIHtcbiAgUmVhY3QuUGxhY2Vob2xkZXIgPSBSRUFDVF9QTEFDRUhPTERFUl9UWVBFO1xuICBSZWFjdC5sYXp5ID0gbGF6eTtcbn1cblxuXG5cbnZhciBSZWFjdCQyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmF1bHQ6IFJlYWN0XG59KTtcblxudmFyIFJlYWN0JDMgPSAoIFJlYWN0JDIgJiYgUmVhY3QgKSB8fCBSZWFjdCQyO1xuXG4vLyBUT0RPOiBkZWNpZGUgb24gdGhlIHRvcC1sZXZlbCBleHBvcnQgZm9ybS5cbi8vIFRoaXMgaXMgaGFja3kgYnV0IG1ha2VzIGl0IHdvcmsgd2l0aCBib3RoIFJvbGx1cCBhbmQgSmVzdC5cbnZhciByZWFjdCA9IFJlYWN0JDMuZGVmYXVsdCB8fCBSZWFjdCQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0O1xuICB9KSgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2hlY2tEQ0UoKSB7XG4gIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgaWYgKFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGlzIGJyYW5jaCBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWRcbiAgICAvLyBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGNvbmRpdGlvbiBpcyB0cnVlIG9ubHkgaW4gZGV2ZWxvcG1lbnQuXG4gICAgLy8gVGhlcmVmb3JlIGlmIHRoZSBicmFuY2ggaXMgc3RpbGwgaGVyZSwgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdhc24ndFxuICAgIC8vIHByb3Blcmx5IGFwcGxpZWQuXG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBtZXNzYWdlLiBSZWFjdCBEZXZUb29scyByZWxpZXMgb24gaXQuIEFsc28gbWFrZSBzdXJlXG4gICAgLy8gdGhpcyBtZXNzYWdlIGRvZXNuJ3Qgb2NjdXIgZWxzZXdoZXJlIGluIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgY2F1c2VcbiAgICAvLyBhIGZhbHNlIHBvc2l0aXZlLlxuICAgIHRocm93IG5ldyBFcnJvcignXl9eJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY29kZSBhYm92ZSBoYXMgYmVlbiBkZWFkIGNvZGUgZWxpbWluYXRlZCAoRENFJ2QpLlxuICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRShjaGVja0RDRSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIERldlRvb2xzIHNob3VsZG4ndCBjcmFzaCBSZWFjdCwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gV2Ugc2hvdWxkIHN0aWxsIHJlcG9ydCBpbiBjYXNlIHdlIGJyZWFrIHRoaXMgY29kZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gRENFIGNoZWNrIHNob3VsZCBoYXBwZW4gYmVmb3JlIFJlYWN0RE9NIGJ1bmRsZSBleGVjdXRlcyBzbyB0aGF0XG4gIC8vIERldlRvb2xzIGNhbiByZXBvcnQgYmFkIG1pbmlmaWNhdGlvbiBkdXJpbmcgaW5qZWN0aW9uLlxuICBjaGVja0RDRSgpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjUuMlxuICogcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLypcbiBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiovXG4ndXNlIHN0cmljdCc7dmFyIGFhPXJlcXVpcmUoXCJyZWFjdFwiKSxuPXJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpLGJhPXJlcXVpcmUoXCJzY2hlZHVsZVwiKTtmdW5jdGlvbiBjYShhLGIsYyxkLGUsZixnLGgpe2lmKCFhKXthPXZvaWQgMDtpZih2b2lkIDA9PT1iKWE9RXJyb3IoXCJNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwiKTtlbHNle3ZhciBrPVtjLGQsZSxmLGcsaF0sbD0wO2E9RXJyb3IoYi5yZXBsYWNlKC8lcy9nLGZ1bmN0aW9uKCl7cmV0dXJuIGtbbCsrXX0pKTthLm5hbWU9XCJJbnZhcmlhbnQgVmlvbGF0aW9uXCJ9YS5mcmFtZXNUb1BvcD0xO3Rocm93IGE7fX1cbmZ1bmN0aW9uIHQoYSl7Zm9yKHZhciBiPWFyZ3VtZW50cy5sZW5ndGgtMSxjPVwiaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnQ9XCIrYSxkPTA7ZDxiO2QrKyljKz1cIiZhcmdzW109XCIrZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tkKzFdKTtjYSghMSxcIk1pbmlmaWVkIFJlYWN0IGVycm9yICNcIithK1wiOyB2aXNpdCAlcyBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuIFwiLGMpfWFhP3ZvaWQgMDp0KFwiMjI3XCIpO2Z1bmN0aW9uIGRhKGEsYixjLGQsZSxmLGcsaCxrKXt2YXIgbD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMyk7dHJ5e2IuYXBwbHkoYyxsKX1jYXRjaChtKXt0aGlzLm9uRXJyb3IobSl9fVxudmFyIGVhPSExLGZhPW51bGwsaGE9ITEsaWE9bnVsbCxqYT17b25FcnJvcjpmdW5jdGlvbihhKXtlYT0hMDtmYT1hfX07ZnVuY3Rpb24ga2EoYSxiLGMsZCxlLGYsZyxoLGspe2VhPSExO2ZhPW51bGw7ZGEuYXBwbHkoamEsYXJndW1lbnRzKX1mdW5jdGlvbiBsYShhLGIsYyxkLGUsZixnLGgsayl7a2EuYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKGVhKXtpZihlYSl7dmFyIGw9ZmE7ZWE9ITE7ZmE9bnVsbH1lbHNlIHQoXCIxOThcIiksbD12b2lkIDA7aGF8fChoYT0hMCxpYT1sKX19dmFyIG1hPW51bGwsbmE9e307XG5mdW5jdGlvbiBvYSgpe2lmKG1hKWZvcih2YXIgYSBpbiBuYSl7dmFyIGI9bmFbYV0sYz1tYS5pbmRleE9mKGEpOy0xPGM/dm9pZCAwOnQoXCI5NlwiLGEpO2lmKCFwYVtjXSl7Yi5leHRyYWN0RXZlbnRzP3ZvaWQgMDp0KFwiOTdcIixhKTtwYVtjXT1iO2M9Yi5ldmVudFR5cGVzO2Zvcih2YXIgZCBpbiBjKXt2YXIgZT12b2lkIDA7dmFyIGY9Y1tkXSxnPWIsaD1kO3FhLmhhc093blByb3BlcnR5KGgpP3QoXCI5OVwiLGgpOnZvaWQgMDtxYVtoXT1mO3ZhciBrPWYucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7aWYoayl7Zm9yKGUgaW4gaylrLmhhc093blByb3BlcnR5KGUpJiZyYShrW2VdLGcsaCk7ZT0hMH1lbHNlIGYucmVnaXN0cmF0aW9uTmFtZT8ocmEoZi5yZWdpc3RyYXRpb25OYW1lLGcsaCksZT0hMCk6ZT0hMTtlP3ZvaWQgMDp0KFwiOThcIixkLGEpfX19fVxuZnVuY3Rpb24gcmEoYSxiLGMpe3NhW2FdP3QoXCIxMDBcIixhKTp2b2lkIDA7c2FbYV09Yjt0YVthXT1iLmV2ZW50VHlwZXNbY10uZGVwZW5kZW5jaWVzfXZhciBwYT1bXSxxYT17fSxzYT17fSx0YT17fSx1YT1udWxsLHZhPW51bGwsd2E9bnVsbDtmdW5jdGlvbiB4YShhLGIsYyxkKXtiPWEudHlwZXx8XCJ1bmtub3duLWV2ZW50XCI7YS5jdXJyZW50VGFyZ2V0PXdhKGQpO2xhKGIsYyx2b2lkIDAsYSk7YS5jdXJyZW50VGFyZ2V0PW51bGx9ZnVuY3Rpb24geWEoYSxiKXtudWxsPT1iP3QoXCIzMFwiKTp2b2lkIDA7aWYobnVsbD09YSlyZXR1cm4gYjtpZihBcnJheS5pc0FycmF5KGEpKXtpZihBcnJheS5pc0FycmF5KGIpKXJldHVybiBhLnB1c2guYXBwbHkoYSxiKSxhO2EucHVzaChiKTtyZXR1cm4gYX1yZXR1cm4gQXJyYXkuaXNBcnJheShiKT9bYV0uY29uY2F0KGIpOlthLGJdfVxuZnVuY3Rpb24gemEoYSxiLGMpe0FycmF5LmlzQXJyYXkoYSk/YS5mb3JFYWNoKGIsYyk6YSYmYi5jYWxsKGMsYSl9dmFyIEFhPW51bGw7ZnVuY3Rpb24gQmEoYSxiKXtpZihhKXt2YXIgYz1hLl9kaXNwYXRjaExpc3RlbmVycyxkPWEuX2Rpc3BhdGNoSW5zdGFuY2VzO2lmKEFycmF5LmlzQXJyYXkoYykpZm9yKHZhciBlPTA7ZTxjLmxlbmd0aCYmIWEuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtlKyspeGEoYSxiLGNbZV0sZFtlXSk7ZWxzZSBjJiZ4YShhLGIsYyxkKTthLl9kaXNwYXRjaExpc3RlbmVycz1udWxsO2EuX2Rpc3BhdGNoSW5zdGFuY2VzPW51bGw7YS5pc1BlcnNpc3RlbnQoKXx8YS5jb25zdHJ1Y3Rvci5yZWxlYXNlKGEpfX1mdW5jdGlvbiBDYShhKXtyZXR1cm4gQmEoYSwhMCl9ZnVuY3Rpb24gRGEoYSl7cmV0dXJuIEJhKGEsITEpfVxudmFyIEVhPXtpbmplY3RFdmVudFBsdWdpbk9yZGVyOmZ1bmN0aW9uKGEpe21hP3QoXCIxMDFcIik6dm9pZCAwO21hPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEpO29hKCl9LGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTpmdW5jdGlvbihhKXt2YXIgYj0hMSxjO2ZvcihjIGluIGEpaWYoYS5oYXNPd25Qcm9wZXJ0eShjKSl7dmFyIGQ9YVtjXTtuYS5oYXNPd25Qcm9wZXJ0eShjKSYmbmFbY109PT1kfHwobmFbY10/dChcIjEwMlwiLGMpOnZvaWQgMCxuYVtjXT1kLGI9ITApfWImJm9hKCl9fTtcbmZ1bmN0aW9uIEZhKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7aWYoIWMpcmV0dXJuIG51bGw7dmFyIGQ9dWEoYyk7aWYoIWQpcmV0dXJuIG51bGw7Yz1kW2JdO2E6c3dpdGNoKGIpe2Nhc2UgXCJvbkNsaWNrXCI6Y2FzZSBcIm9uQ2xpY2tDYXB0dXJlXCI6Y2FzZSBcIm9uRG91YmxlQ2xpY2tcIjpjYXNlIFwib25Eb3VibGVDbGlja0NhcHR1cmVcIjpjYXNlIFwib25Nb3VzZURvd25cIjpjYXNlIFwib25Nb3VzZURvd25DYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlVXBcIjpjYXNlIFwib25Nb3VzZVVwQ2FwdHVyZVwiOihkPSFkLmRpc2FibGVkKXx8KGE9YS50eXBlLGQ9IShcImJ1dHRvblwiPT09YXx8XCJpbnB1dFwiPT09YXx8XCJzZWxlY3RcIj09PWF8fFwidGV4dGFyZWFcIj09PWEpKTthPSFkO2JyZWFrIGE7ZGVmYXVsdDphPSExfWlmKGEpcmV0dXJuIG51bGw7YyYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGM/dChcIjIzMVwiLGIsdHlwZW9mIGMpOnZvaWQgMDtcbnJldHVybiBjfWZ1bmN0aW9uIEdhKGEsYil7bnVsbCE9PWEmJihBYT15YShBYSxhKSk7YT1BYTtBYT1udWxsO2lmKGEmJihiP3phKGEsQ2EpOnphKGEsRGEpLEFhP3QoXCI5NVwiKTp2b2lkIDAsaGEpKXRocm93IGI9aWEsaGE9ITEsaWE9bnVsbCxiO312YXIgSGE9TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksSWE9XCJfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSRcIitIYSxKYT1cIl9fcmVhY3RFdmVudEhhbmRsZXJzJFwiK0hhO2Z1bmN0aW9uIEthKGEpe2lmKGFbSWFdKXJldHVybiBhW0lhXTtmb3IoOyFhW0lhXTspaWYoYS5wYXJlbnROb2RlKWE9YS5wYXJlbnROb2RlO2Vsc2UgcmV0dXJuIG51bGw7YT1hW0lhXTtyZXR1cm4gNz09PWEudGFnfHw4PT09YS50YWc/YTpudWxsfWZ1bmN0aW9uIExhKGEpe2E9YVtJYV07cmV0dXJuIWF8fDchPT1hLnRhZyYmOCE9PWEudGFnP251bGw6YX1cbmZ1bmN0aW9uIE1hKGEpe2lmKDc9PT1hLnRhZ3x8OD09PWEudGFnKXJldHVybiBhLnN0YXRlTm9kZTt0KFwiMzNcIil9ZnVuY3Rpb24gTmEoYSl7cmV0dXJuIGFbSmFdfHxudWxsfWZ1bmN0aW9uIE9hKGEpe2RvIGE9YS5yZXR1cm47d2hpbGUoYSYmNyE9PWEudGFnKTtyZXR1cm4gYT9hOm51bGx9ZnVuY3Rpb24gUGEoYSxiLGMpe2lmKGI9RmEoYSxjLmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW2JdKSljLl9kaXNwYXRjaExpc3RlbmVycz15YShjLl9kaXNwYXRjaExpc3RlbmVycyxiKSxjLl9kaXNwYXRjaEluc3RhbmNlcz15YShjLl9kaXNwYXRjaEluc3RhbmNlcyxhKX1cbmZ1bmN0aW9uIFFhKGEpe2lmKGEmJmEuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpe2Zvcih2YXIgYj1hLl90YXJnZXRJbnN0LGM9W107YjspYy5wdXNoKGIpLGI9T2EoYik7Zm9yKGI9Yy5sZW5ndGg7MDxiLS07KVBhKGNbYl0sXCJjYXB0dXJlZFwiLGEpO2ZvcihiPTA7YjxjLmxlbmd0aDtiKyspUGEoY1tiXSxcImJ1YmJsZWRcIixhKX19ZnVuY3Rpb24gUmEoYSxiLGMpe2EmJmMmJmMuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSYmKGI9RmEoYSxjLmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpKSYmKGMuX2Rpc3BhdGNoTGlzdGVuZXJzPXlhKGMuX2Rpc3BhdGNoTGlzdGVuZXJzLGIpLGMuX2Rpc3BhdGNoSW5zdGFuY2VzPXlhKGMuX2Rpc3BhdGNoSW5zdGFuY2VzLGEpKX1mdW5jdGlvbiBUYShhKXthJiZhLmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUmJlJhKGEuX3RhcmdldEluc3QsbnVsbCxhKX1cbmZ1bmN0aW9uIFVhKGEpe3phKGEsUWEpfXZhciBWYT0hKFwidW5kZWZpbmVkXCI9PT10eXBlb2Ygd2luZG93fHwhd2luZG93LmRvY3VtZW50fHwhd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO2Z1bmN0aW9uIFdhKGEsYil7dmFyIGM9e307Y1thLnRvTG93ZXJDYXNlKCldPWIudG9Mb3dlckNhc2UoKTtjW1wiV2Via2l0XCIrYV09XCJ3ZWJraXRcIitiO2NbXCJNb3pcIithXT1cIm1velwiK2I7cmV0dXJuIGN9dmFyIFlhPXthbmltYXRpb25lbmQ6V2EoXCJBbmltYXRpb25cIixcIkFuaW1hdGlvbkVuZFwiKSxhbmltYXRpb25pdGVyYXRpb246V2EoXCJBbmltYXRpb25cIixcIkFuaW1hdGlvbkl0ZXJhdGlvblwiKSxhbmltYXRpb25zdGFydDpXYShcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uU3RhcnRcIiksdHJhbnNpdGlvbmVuZDpXYShcIlRyYW5zaXRpb25cIixcIlRyYW5zaXRpb25FbmRcIil9LFphPXt9LCRhPXt9O1xuVmEmJigkYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlLFwiQW5pbWF0aW9uRXZlbnRcImluIHdpbmRvd3x8KGRlbGV0ZSBZYS5hbmltYXRpb25lbmQuYW5pbWF0aW9uLGRlbGV0ZSBZYS5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uLGRlbGV0ZSBZYS5hbmltYXRpb25zdGFydC5hbmltYXRpb24pLFwiVHJhbnNpdGlvbkV2ZW50XCJpbiB3aW5kb3d8fGRlbGV0ZSBZYS50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb24pO2Z1bmN0aW9uIGFiKGEpe2lmKFphW2FdKXJldHVybiBaYVthXTtpZighWWFbYV0pcmV0dXJuIGE7dmFyIGI9WWFbYV0sYztmb3IoYyBpbiBiKWlmKGIuaGFzT3duUHJvcGVydHkoYykmJmMgaW4gJGEpcmV0dXJuIFphW2FdPWJbY107cmV0dXJuIGF9XG52YXIgYmI9YWIoXCJhbmltYXRpb25lbmRcIiksY2I9YWIoXCJhbmltYXRpb25pdGVyYXRpb25cIiksZGI9YWIoXCJhbmltYXRpb25zdGFydFwiKSxlYj1hYihcInRyYW5zaXRpb25lbmRcIiksZmI9XCJhYm9ydCBjYW5wbGF5IGNhbnBsYXl0aHJvdWdoIGR1cmF0aW9uY2hhbmdlIGVtcHRpZWQgZW5jcnlwdGVkIGVuZGVkIGVycm9yIGxvYWRlZGRhdGEgbG9hZGVkbWV0YWRhdGEgbG9hZHN0YXJ0IHBhdXNlIHBsYXkgcGxheWluZyBwcm9ncmVzcyByYXRlY2hhbmdlIHNlZWtlZCBzZWVraW5nIHN0YWxsZWQgc3VzcGVuZCB0aW1ldXBkYXRlIHZvbHVtZWNoYW5nZSB3YWl0aW5nXCIuc3BsaXQoXCIgXCIpLGdiPW51bGwsaGI9bnVsbCxpYj1udWxsO1xuZnVuY3Rpb24gamIoKXtpZihpYilyZXR1cm4gaWI7dmFyIGEsYj1oYixjPWIubGVuZ3RoLGQsZT1cInZhbHVlXCJpbiBnYj9nYi52YWx1ZTpnYi50ZXh0Q29udGVudCxmPWUubGVuZ3RoO2ZvcihhPTA7YTxjJiZiW2FdPT09ZVthXTthKyspO3ZhciBnPWMtYTtmb3IoZD0xO2Q8PWcmJmJbYy1kXT09PWVbZi1kXTtkKyspO3JldHVybiBpYj1lLnNsaWNlKGEsMTxkPzEtZDp2b2lkIDApfWZ1bmN0aW9uIGtiKCl7cmV0dXJuITB9ZnVuY3Rpb24gbGIoKXtyZXR1cm4hMX1cbmZ1bmN0aW9uIHooYSxiLGMsZCl7dGhpcy5kaXNwYXRjaENvbmZpZz1hO3RoaXMuX3RhcmdldEluc3Q9Yjt0aGlzLm5hdGl2ZUV2ZW50PWM7YT10aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtmb3IodmFyIGUgaW4gYSlhLmhhc093blByb3BlcnR5KGUpJiYoKGI9YVtlXSk/dGhpc1tlXT1iKGMpOlwidGFyZ2V0XCI9PT1lP3RoaXMudGFyZ2V0PWQ6dGhpc1tlXT1jW2VdKTt0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD0obnVsbCE9Yy5kZWZhdWx0UHJldmVudGVkP2MuZGVmYXVsdFByZXZlbnRlZDohMT09PWMucmV0dXJuVmFsdWUpP2tiOmxiO3RoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9bGI7cmV0dXJuIHRoaXN9XG5uKHoucHJvdG90eXBlLHtwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe3RoaXMuZGVmYXVsdFByZXZlbnRlZD0hMDt2YXIgYT10aGlzLm5hdGl2ZUV2ZW50O2EmJihhLnByZXZlbnREZWZhdWx0P2EucHJldmVudERlZmF1bHQoKTpcInVua25vd25cIiE9PXR5cGVvZiBhLnJldHVyblZhbHVlJiYoYS5yZXR1cm5WYWx1ZT0hMSksdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9a2IpfSxzdG9wUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm5hdGl2ZUV2ZW50O2EmJihhLnN0b3BQcm9wYWdhdGlvbj9hLnN0b3BQcm9wYWdhdGlvbigpOlwidW5rbm93blwiIT09dHlwZW9mIGEuY2FuY2VsQnViYmxlJiYoYS5jYW5jZWxCdWJibGU9ITApLHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9a2IpfSxwZXJzaXN0OmZ1bmN0aW9uKCl7dGhpcy5pc1BlcnNpc3RlbnQ9a2J9LGlzUGVyc2lzdGVudDpsYixkZXN0cnVjdG9yOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2UsXG5iO2ZvcihiIGluIGEpdGhpc1tiXT1udWxsO3RoaXMubmF0aXZlRXZlbnQ9dGhpcy5fdGFyZ2V0SW5zdD10aGlzLmRpc3BhdGNoQ29uZmlnPW51bGw7dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD10aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1sYjt0aGlzLl9kaXNwYXRjaEluc3RhbmNlcz10aGlzLl9kaXNwYXRjaExpc3RlbmVycz1udWxsfX0pO3ouSW50ZXJmYWNlPXt0eXBlOm51bGwsdGFyZ2V0Om51bGwsY3VycmVudFRhcmdldDpmdW5jdGlvbigpe3JldHVybiBudWxsfSxldmVudFBoYXNlOm51bGwsYnViYmxlczpudWxsLGNhbmNlbGFibGU6bnVsbCx0aW1lU3RhbXA6ZnVuY3Rpb24oYSl7cmV0dXJuIGEudGltZVN0YW1wfHxEYXRlLm5vdygpfSxkZWZhdWx0UHJldmVudGVkOm51bGwsaXNUcnVzdGVkOm51bGx9O1xuei5leHRlbmQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYigpe31mdW5jdGlvbiBjKCl7cmV0dXJuIGQuYXBwbHkodGhpcyxhcmd1bWVudHMpfXZhciBkPXRoaXM7Yi5wcm90b3R5cGU9ZC5wcm90b3R5cGU7dmFyIGU9bmV3IGI7bihlLGMucHJvdG90eXBlKTtjLnByb3RvdHlwZT1lO2MucHJvdG90eXBlLmNvbnN0cnVjdG9yPWM7Yy5JbnRlcmZhY2U9bih7fSxkLkludGVyZmFjZSxhKTtjLmV4dGVuZD1kLmV4dGVuZDttYihjKTtyZXR1cm4gY307bWIoeik7ZnVuY3Rpb24gbmIoYSxiLGMsZCl7aWYodGhpcy5ldmVudFBvb2wubGVuZ3RoKXt2YXIgZT10aGlzLmV2ZW50UG9vbC5wb3AoKTt0aGlzLmNhbGwoZSxhLGIsYyxkKTtyZXR1cm4gZX1yZXR1cm4gbmV3IHRoaXMoYSxiLGMsZCl9ZnVuY3Rpb24gb2IoYSl7YSBpbnN0YW5jZW9mIHRoaXM/dm9pZCAwOnQoXCIyNzlcIik7YS5kZXN0cnVjdG9yKCk7MTA+dGhpcy5ldmVudFBvb2wubGVuZ3RoJiZ0aGlzLmV2ZW50UG9vbC5wdXNoKGEpfVxuZnVuY3Rpb24gbWIoYSl7YS5ldmVudFBvb2w9W107YS5nZXRQb29sZWQ9bmI7YS5yZWxlYXNlPW9ifXZhciBwYj16LmV4dGVuZCh7ZGF0YTpudWxsfSkscWI9ei5leHRlbmQoe2RhdGE6bnVsbH0pLHJiPVs5LDEzLDI3LDMyXSxzYj1WYSYmXCJDb21wb3NpdGlvbkV2ZW50XCJpbiB3aW5kb3csdGI9bnVsbDtWYSYmXCJkb2N1bWVudE1vZGVcImluIGRvY3VtZW50JiYodGI9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTtcbnZhciB1Yj1WYSYmXCJUZXh0RXZlbnRcImluIHdpbmRvdyYmIXRiLHZiPVZhJiYoIXNifHx0YiYmODx0YiYmMTE+PXRiKSx3Yj1TdHJpbmcuZnJvbUNoYXJDb2RlKDMyKSx4Yj17YmVmb3JlSW5wdXQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25CZWZvcmVJbnB1dFwiLGNhcHR1cmVkOlwib25CZWZvcmVJbnB1dENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOltcImNvbXBvc2l0aW9uZW5kXCIsXCJrZXlwcmVzc1wiLFwidGV4dElucHV0XCIsXCJwYXN0ZVwiXX0sY29tcG9zaXRpb25FbmQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25Db21wb3NpdGlvbkVuZFwiLGNhcHR1cmVkOlwib25Db21wb3NpdGlvbkVuZENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwiYmx1ciBjb21wb3NpdGlvbmVuZCBrZXlkb3duIGtleXByZXNzIGtleXVwIG1vdXNlZG93blwiLnNwbGl0KFwiIFwiKX0sY29tcG9zaXRpb25TdGFydDp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNvbXBvc2l0aW9uU3RhcnRcIixcbmNhcHR1cmVkOlwib25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJibHVyIGNvbXBvc2l0aW9uc3RhcnQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIil9LGNvbXBvc2l0aW9uVXBkYXRlOntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ29tcG9zaXRpb25VcGRhdGVcIixjYXB0dXJlZDpcIm9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcImJsdXIgY29tcG9zaXRpb251cGRhdGUga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBtb3VzZWRvd25cIi5zcGxpdChcIiBcIil9fSx5Yj0hMTtcbmZ1bmN0aW9uIHpiKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJrZXl1cFwiOnJldHVybi0xIT09cmIuaW5kZXhPZihiLmtleUNvZGUpO2Nhc2UgXCJrZXlkb3duXCI6cmV0dXJuIDIyOSE9PWIua2V5Q29kZTtjYXNlIFwia2V5cHJlc3NcIjpjYXNlIFwibW91c2Vkb3duXCI6Y2FzZSBcImJsdXJcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBBYihhKXthPWEuZGV0YWlsO3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmXCJkYXRhXCJpbiBhP2EuZGF0YTpudWxsfXZhciBCYj0hMTtmdW5jdGlvbiBDYihhLGIpe3N3aXRjaChhKXtjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpyZXR1cm4gQWIoYik7Y2FzZSBcImtleXByZXNzXCI6aWYoMzIhPT1iLndoaWNoKXJldHVybiBudWxsO3liPSEwO3JldHVybiB3YjtjYXNlIFwidGV4dElucHV0XCI6cmV0dXJuIGE9Yi5kYXRhLGE9PT13YiYmeWI/bnVsbDphO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxuZnVuY3Rpb24gRGIoYSxiKXtpZihCYilyZXR1cm5cImNvbXBvc2l0aW9uZW5kXCI9PT1hfHwhc2ImJnpiKGEsYik/KGE9amIoKSxpYj1oYj1nYj1udWxsLEJiPSExLGEpOm51bGw7c3dpdGNoKGEpe2Nhc2UgXCJwYXN0ZVwiOnJldHVybiBudWxsO2Nhc2UgXCJrZXlwcmVzc1wiOmlmKCEoYi5jdHJsS2V5fHxiLmFsdEtleXx8Yi5tZXRhS2V5KXx8Yi5jdHJsS2V5JiZiLmFsdEtleSl7aWYoYi5jaGFyJiYxPGIuY2hhci5sZW5ndGgpcmV0dXJuIGIuY2hhcjtpZihiLndoaWNoKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGIud2hpY2gpfXJldHVybiBudWxsO2Nhc2UgXCJjb21wb3NpdGlvbmVuZFwiOnJldHVybiB2YiYmXCJrb1wiIT09Yi5sb2NhbGU/bnVsbDpiLmRhdGE7ZGVmYXVsdDpyZXR1cm4gbnVsbH19XG52YXIgRWI9e2V2ZW50VHlwZXM6eGIsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT12b2lkIDA7dmFyIGY9dm9pZCAwO2lmKHNiKWI6e3N3aXRjaChhKXtjYXNlIFwiY29tcG9zaXRpb25zdGFydFwiOmU9eGIuY29tcG9zaXRpb25TdGFydDticmVhayBiO2Nhc2UgXCJjb21wb3NpdGlvbmVuZFwiOmU9eGIuY29tcG9zaXRpb25FbmQ7YnJlYWsgYjtjYXNlIFwiY29tcG9zaXRpb251cGRhdGVcIjplPXhiLmNvbXBvc2l0aW9uVXBkYXRlO2JyZWFrIGJ9ZT12b2lkIDB9ZWxzZSBCYj96YihhLGMpJiYoZT14Yi5jb21wb3NpdGlvbkVuZCk6XCJrZXlkb3duXCI9PT1hJiYyMjk9PT1jLmtleUNvZGUmJihlPXhiLmNvbXBvc2l0aW9uU3RhcnQpO2U/KHZiJiZcImtvXCIhPT1jLmxvY2FsZSYmKEJifHxlIT09eGIuY29tcG9zaXRpb25TdGFydD9lPT09eGIuY29tcG9zaXRpb25FbmQmJkJiJiYoZj1qYigpKTooZ2I9ZCxoYj1cInZhbHVlXCJpbiBnYj9nYi52YWx1ZTpnYi50ZXh0Q29udGVudCxCYj1cbiEwKSksZT1wYi5nZXRQb29sZWQoZSxiLGMsZCksZj9lLmRhdGE9ZjooZj1BYihjKSxudWxsIT09ZiYmKGUuZGF0YT1mKSksVWEoZSksZj1lKTpmPW51bGw7KGE9dWI/Q2IoYSxjKTpEYihhLGMpKT8oYj1xYi5nZXRQb29sZWQoeGIuYmVmb3JlSW5wdXQsYixjLGQpLGIuZGF0YT1hLFVhKGIpKTpiPW51bGw7cmV0dXJuIG51bGw9PT1mP2I6bnVsbD09PWI/ZjpbZixiXX19LEZiPW51bGwsR2I9bnVsbCxIYj1udWxsO2Z1bmN0aW9uIEliKGEpe2lmKGE9dmEoYSkpe1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBGYj90KFwiMjgwXCIpOnZvaWQgMDt2YXIgYj11YShhLnN0YXRlTm9kZSk7RmIoYS5zdGF0ZU5vZGUsYS50eXBlLGIpfX1mdW5jdGlvbiBKYihhKXtHYj9IYj9IYi5wdXNoKGEpOkhiPVthXTpHYj1hfWZ1bmN0aW9uIEtiKCl7aWYoR2Ipe3ZhciBhPUdiLGI9SGI7SGI9R2I9bnVsbDtJYihhKTtpZihiKWZvcihhPTA7YTxiLmxlbmd0aDthKyspSWIoYlthXSl9fVxuZnVuY3Rpb24gTGIoYSxiKXtyZXR1cm4gYShiKX1mdW5jdGlvbiBNYihhLGIsYyl7cmV0dXJuIGEoYixjKX1mdW5jdGlvbiBOYigpe312YXIgT2I9ITE7ZnVuY3Rpb24gUGIoYSxiKXtpZihPYilyZXR1cm4gYShiKTtPYj0hMDt0cnl7cmV0dXJuIExiKGEsYil9ZmluYWxseXtpZihPYj0hMSxudWxsIT09R2J8fG51bGwhPT1IYilOYigpLEtiKCl9fXZhciBRYj17Y29sb3I6ITAsZGF0ZTohMCxkYXRldGltZTohMCxcImRhdGV0aW1lLWxvY2FsXCI6ITAsZW1haWw6ITAsbW9udGg6ITAsbnVtYmVyOiEwLHBhc3N3b3JkOiEwLHJhbmdlOiEwLHNlYXJjaDohMCx0ZWw6ITAsdGV4dDohMCx0aW1lOiEwLHVybDohMCx3ZWVrOiEwfTtmdW5jdGlvbiBSYihhKXt2YXIgYj1hJiZhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09Yj8hIVFiW2EudHlwZV06XCJ0ZXh0YXJlYVwiPT09Yj8hMDohMX1cbmZ1bmN0aW9uIFNiKGEpe2E9YS50YXJnZXR8fGEuc3JjRWxlbWVudHx8d2luZG93O2EuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQmJihhPWEuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpO3JldHVybiAzPT09YS5ub2RlVHlwZT9hLnBhcmVudE5vZGU6YX1mdW5jdGlvbiBUYihhKXtpZighVmEpcmV0dXJuITE7YT1cIm9uXCIrYTt2YXIgYj1hIGluIGRvY3VtZW50O2J8fChiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksYi5zZXRBdHRyaWJ1dGUoYSxcInJldHVybjtcIiksYj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgYlthXSk7cmV0dXJuIGJ9ZnVuY3Rpb24gVWIoYSl7dmFyIGI9YS50eXBlO3JldHVybihhPWEubm9kZU5hbWUpJiZcImlucHV0XCI9PT1hLnRvTG93ZXJDYXNlKCkmJihcImNoZWNrYm94XCI9PT1ifHxcInJhZGlvXCI9PT1iKX1cbmZ1bmN0aW9uIFZiKGEpe3ZhciBiPVViKGEpP1wiY2hlY2tlZFwiOlwidmFsdWVcIixjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsYiksZD1cIlwiK2FbYl07aWYoIWEuaGFzT3duUHJvcGVydHkoYikmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgYyYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGMuZ2V0JiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5zZXQpe3ZhciBlPWMuZ2V0LGY9Yy5zZXQ7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsYix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlLmNhbGwodGhpcyl9LHNldDpmdW5jdGlvbihhKXtkPVwiXCIrYTtmLmNhbGwodGhpcyxhKX19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxiLHtlbnVtZXJhYmxlOmMuZW51bWVyYWJsZX0pO3JldHVybntnZXRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiBkfSxzZXRWYWx1ZTpmdW5jdGlvbihhKXtkPVwiXCIrYX0sc3RvcFRyYWNraW5nOmZ1bmN0aW9uKCl7YS5fdmFsdWVUcmFja2VyPVxubnVsbDtkZWxldGUgYVtiXX19fX1mdW5jdGlvbiBXYihhKXthLl92YWx1ZVRyYWNrZXJ8fChhLl92YWx1ZVRyYWNrZXI9VmIoYSkpfWZ1bmN0aW9uIFhiKGEpe2lmKCFhKXJldHVybiExO3ZhciBiPWEuX3ZhbHVlVHJhY2tlcjtpZighYilyZXR1cm4hMDt2YXIgYz1iLmdldFZhbHVlKCk7dmFyIGQ9XCJcIjthJiYoZD1VYihhKT9hLmNoZWNrZWQ/XCJ0cnVlXCI6XCJmYWxzZVwiOmEudmFsdWUpO2E9ZDtyZXR1cm4gYSE9PWM/KGIuc2V0VmFsdWUoYSksITApOiExfVxudmFyIFliPWFhLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELFpiPS9eKC4qKVtcXFxcXFwvXS8sQz1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yLCRiPUM/U3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIik6NjAxMDMsYWM9Qz9TeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpOjYwMTA2LGJjPUM/U3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpOjYwMTA3LGNjPUM/U3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpOjYwMTA4LGRjPUM/U3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpOjYwMTE0LGVjPUM/U3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpOjYwMTA5LGZjPUM/U3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIik6NjAxMTAsZ2M9Qz9TeW1ib2wuZm9yKFwicmVhY3QuYXN5bmNfbW9kZVwiKTo2MDExMSxoYz1DP1N5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTo2MDExMixpYz1DP1N5bWJvbC5mb3IoXCJyZWFjdC5wbGFjZWhvbGRlclwiKTpcbjYwMTEzLGpjPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcjtmdW5jdGlvbiBrYyhhKXtpZihudWxsPT09YXx8XCJvYmplY3RcIiE9PXR5cGVvZiBhKXJldHVybiBudWxsO2E9amMmJmFbamNdfHxhW1wiQEBpdGVyYXRvclwiXTtyZXR1cm5cImZ1bmN0aW9uXCI9PT10eXBlb2YgYT9hOm51bGx9XG5mdW5jdGlvbiBsYyhhKXtpZihudWxsPT1hKXJldHVybiBudWxsO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhKXJldHVybiBhLmRpc3BsYXlOYW1lfHxhLm5hbWV8fG51bGw7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhKXJldHVybiBhO3N3aXRjaChhKXtjYXNlIGdjOnJldHVyblwiQXN5bmNNb2RlXCI7Y2FzZSBiYzpyZXR1cm5cIkZyYWdtZW50XCI7Y2FzZSBhYzpyZXR1cm5cIlBvcnRhbFwiO2Nhc2UgZGM6cmV0dXJuXCJQcm9maWxlclwiO2Nhc2UgY2M6cmV0dXJuXCJTdHJpY3RNb2RlXCI7Y2FzZSBpYzpyZXR1cm5cIlBsYWNlaG9sZGVyXCJ9aWYoXCJvYmplY3RcIj09PXR5cGVvZiBhKXtzd2l0Y2goYS4kJHR5cGVvZil7Y2FzZSBmYzpyZXR1cm5cIkNvbnRleHQuQ29uc3VtZXJcIjtjYXNlIGVjOnJldHVyblwiQ29udGV4dC5Qcm92aWRlclwiO2Nhc2UgaGM6dmFyIGI9YS5yZW5kZXI7Yj1iLmRpc3BsYXlOYW1lfHxiLm5hbWV8fFwiXCI7cmV0dXJuIGEuZGlzcGxheU5hbWV8fChcIlwiIT09Yj9cIkZvcndhcmRSZWYoXCIrYitcIilcIjpcblwiRm9yd2FyZFJlZlwiKX1pZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYS50aGVuJiYoYT0xPT09YS5fcmVhY3RTdGF0dXM/YS5fcmVhY3RSZXN1bHQ6bnVsbCkpcmV0dXJuIGxjKGEpfXJldHVybiBudWxsfWZ1bmN0aW9uIG1jKGEpe3ZhciBiPVwiXCI7ZG97YTpzd2l0Y2goYS50YWcpe2Nhc2UgNDpjYXNlIDA6Y2FzZSAxOmNhc2UgMjpjYXNlIDM6Y2FzZSA3OmNhc2UgMTA6dmFyIGM9YS5fZGVidWdPd25lcixkPWEuX2RlYnVnU291cmNlLGU9bGMoYS50eXBlKTt2YXIgZj1udWxsO2MmJihmPWxjKGMudHlwZSkpO2M9ZTtlPVwiXCI7ZD9lPVwiIChhdCBcIitkLmZpbGVOYW1lLnJlcGxhY2UoWmIsXCJcIikrXCI6XCIrZC5saW5lTnVtYmVyK1wiKVwiOmYmJihlPVwiIChjcmVhdGVkIGJ5IFwiK2YrXCIpXCIpO2Y9XCJcXG4gICAgaW4gXCIrKGN8fFwiVW5rbm93blwiKStlO2JyZWFrIGE7ZGVmYXVsdDpmPVwiXCJ9Yis9ZjthPWEucmV0dXJufXdoaWxlKGEpO3JldHVybiBifVxudmFyIG5jPS9eWzpBLVpfYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXVs6QS1aX2EtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcLS4wLTlcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwXSokLyxwYz1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LHFjPXt9LHJjPXt9O1xuZnVuY3Rpb24gc2MoYSl7aWYocGMuY2FsbChyYyxhKSlyZXR1cm4hMDtpZihwYy5jYWxsKHFjLGEpKXJldHVybiExO2lmKG5jLnRlc3QoYSkpcmV0dXJuIHJjW2FdPSEwO3FjW2FdPSEwO3JldHVybiExfWZ1bmN0aW9uIHRjKGEsYixjLGQpe2lmKG51bGwhPT1jJiYwPT09Yy50eXBlKXJldHVybiExO3N3aXRjaCh0eXBlb2YgYil7Y2FzZSBcImZ1bmN0aW9uXCI6Y2FzZSBcInN5bWJvbFwiOnJldHVybiEwO2Nhc2UgXCJib29sZWFuXCI6aWYoZClyZXR1cm4hMTtpZihudWxsIT09YylyZXR1cm4hYy5hY2NlcHRzQm9vbGVhbnM7YT1hLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCw1KTtyZXR1cm5cImRhdGEtXCIhPT1hJiZcImFyaWEtXCIhPT1hO2RlZmF1bHQ6cmV0dXJuITF9fVxuZnVuY3Rpb24gdWMoYSxiLGMsZCl7aWYobnVsbD09PWJ8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgYnx8dGMoYSxiLGMsZCkpcmV0dXJuITA7aWYoZClyZXR1cm4hMTtpZihudWxsIT09Yylzd2l0Y2goYy50eXBlKXtjYXNlIDM6cmV0dXJuIWI7Y2FzZSA0OnJldHVybiExPT09YjtjYXNlIDU6cmV0dXJuIGlzTmFOKGIpO2Nhc2UgNjpyZXR1cm4gaXNOYU4oYil8fDE+Yn1yZXR1cm4hMX1mdW5jdGlvbiBEKGEsYixjLGQsZSl7dGhpcy5hY2NlcHRzQm9vbGVhbnM9Mj09PWJ8fDM9PT1ifHw0PT09Yjt0aGlzLmF0dHJpYnV0ZU5hbWU9ZDt0aGlzLmF0dHJpYnV0ZU5hbWVzcGFjZT1lO3RoaXMubXVzdFVzZVByb3BlcnR5PWM7dGhpcy5wcm9wZXJ0eU5hbWU9YTt0aGlzLnR5cGU9Yn12YXIgRT17fTtcblwiY2hpbGRyZW4gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgZGVmYXVsdFZhbHVlIGRlZmF1bHRDaGVja2VkIGlubmVySFRNTCBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nIHN0eWxlXCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7RVthXT1uZXcgRChhLDAsITEsYSxudWxsKX0pO1tbXCJhY2NlcHRDaGFyc2V0XCIsXCJhY2NlcHQtY2hhcnNldFwiXSxbXCJjbGFzc05hbWVcIixcImNsYXNzXCJdLFtcImh0bWxGb3JcIixcImZvclwiXSxbXCJodHRwRXF1aXZcIixcImh0dHAtZXF1aXZcIl1dLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YVswXTtFW2JdPW5ldyBEKGIsMSwhMSxhWzFdLG51bGwpfSk7W1wiY29udGVudEVkaXRhYmxlXCIsXCJkcmFnZ2FibGVcIixcInNwZWxsQ2hlY2tcIixcInZhbHVlXCJdLmZvckVhY2goZnVuY3Rpb24oYSl7RVthXT1uZXcgRChhLDIsITEsYS50b0xvd2VyQ2FzZSgpLG51bGwpfSk7XG5bXCJhdXRvUmV2ZXJzZVwiLFwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiLFwiZm9jdXNhYmxlXCIsXCJwcmVzZXJ2ZUFscGhhXCJdLmZvckVhY2goZnVuY3Rpb24oYSl7RVthXT1uZXcgRChhLDIsITEsYSxudWxsKX0pO1wiYWxsb3dGdWxsU2NyZWVuIGFzeW5jIGF1dG9Gb2N1cyBhdXRvUGxheSBjb250cm9scyBkZWZhdWx0IGRlZmVyIGRpc2FibGVkIGZvcm1Ob1ZhbGlkYXRlIGhpZGRlbiBsb29wIG5vTW9kdWxlIG5vVmFsaWRhdGUgb3BlbiBwbGF5c0lubGluZSByZWFkT25seSByZXF1aXJlZCByZXZlcnNlZCBzY29wZWQgc2VhbWxlc3MgaXRlbVNjb3BlXCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7RVthXT1uZXcgRChhLDMsITEsYS50b0xvd2VyQ2FzZSgpLG51bGwpfSk7W1wiY2hlY2tlZFwiLFwibXVsdGlwbGVcIixcIm11dGVkXCIsXCJzZWxlY3RlZFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe0VbYV09bmV3IEQoYSwzLCEwLGEsbnVsbCl9KTtcbltcImNhcHR1cmVcIixcImRvd25sb2FkXCJdLmZvckVhY2goZnVuY3Rpb24oYSl7RVthXT1uZXcgRChhLDQsITEsYSxudWxsKX0pO1tcImNvbHNcIixcInJvd3NcIixcInNpemVcIixcInNwYW5cIl0uZm9yRWFjaChmdW5jdGlvbihhKXtFW2FdPW5ldyBEKGEsNiwhMSxhLG51bGwpfSk7W1wicm93U3BhblwiLFwic3RhcnRcIl0uZm9yRWFjaChmdW5jdGlvbihhKXtFW2FdPW5ldyBEKGEsNSwhMSxhLnRvTG93ZXJDYXNlKCksbnVsbCl9KTt2YXIgdmM9L1tcXC06XShbYS16XSkvZztmdW5jdGlvbiB3YyhhKXtyZXR1cm4gYVsxXS50b1VwcGVyQ2FzZSgpfVxuXCJhY2NlbnQtaGVpZ2h0IGFsaWdubWVudC1iYXNlbGluZSBhcmFiaWMtZm9ybSBiYXNlbGluZS1zaGlmdCBjYXAtaGVpZ2h0IGNsaXAtcGF0aCBjbGlwLXJ1bGUgY29sb3ItaW50ZXJwb2xhdGlvbiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMgY29sb3ItcHJvZmlsZSBjb2xvci1yZW5kZXJpbmcgZG9taW5hbnQtYmFzZWxpbmUgZW5hYmxlLWJhY2tncm91bmQgZmlsbC1vcGFjaXR5IGZpbGwtcnVsZSBmbG9vZC1jb2xvciBmbG9vZC1vcGFjaXR5IGZvbnQtZmFtaWx5IGZvbnQtc2l6ZSBmb250LXNpemUtYWRqdXN0IGZvbnQtc3RyZXRjaCBmb250LXN0eWxlIGZvbnQtdmFyaWFudCBmb250LXdlaWdodCBnbHlwaC1uYW1lIGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwgZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwgaG9yaXotYWR2LXggaG9yaXotb3JpZ2luLXggaW1hZ2UtcmVuZGVyaW5nIGxldHRlci1zcGFjaW5nIGxpZ2h0aW5nLWNvbG9yIG1hcmtlci1lbmQgbWFya2VyLW1pZCBtYXJrZXItc3RhcnQgb3ZlcmxpbmUtcG9zaXRpb24gb3ZlcmxpbmUtdGhpY2tuZXNzIHBhaW50LW9yZGVyIHBhbm9zZS0xIHBvaW50ZXItZXZlbnRzIHJlbmRlcmluZy1pbnRlbnQgc2hhcGUtcmVuZGVyaW5nIHN0b3AtY29sb3Igc3RvcC1vcGFjaXR5IHN0cmlrZXRocm91Z2gtcG9zaXRpb24gc3RyaWtldGhyb3VnaC10aGlja25lc3Mgc3Ryb2tlLWRhc2hhcnJheSBzdHJva2UtZGFzaG9mZnNldCBzdHJva2UtbGluZWNhcCBzdHJva2UtbGluZWpvaW4gc3Ryb2tlLW1pdGVybGltaXQgc3Ryb2tlLW9wYWNpdHkgc3Ryb2tlLXdpZHRoIHRleHQtYW5jaG9yIHRleHQtZGVjb3JhdGlvbiB0ZXh0LXJlbmRlcmluZyB1bmRlcmxpbmUtcG9zaXRpb24gdW5kZXJsaW5lLXRoaWNrbmVzcyB1bmljb2RlLWJpZGkgdW5pY29kZS1yYW5nZSB1bml0cy1wZXItZW0gdi1hbHBoYWJldGljIHYtaGFuZ2luZyB2LWlkZW9ncmFwaGljIHYtbWF0aGVtYXRpY2FsIHZlY3Rvci1lZmZlY3QgdmVydC1hZHYteSB2ZXJ0LW9yaWdpbi14IHZlcnQtb3JpZ2luLXkgd29yZC1zcGFjaW5nIHdyaXRpbmctbW9kZSB4bWxuczp4bGluayB4LWhlaWdodFwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZSh2YyxcbndjKTtFW2JdPW5ldyBEKGIsMSwhMSxhLG51bGwpfSk7XCJ4bGluazphY3R1YXRlIHhsaW5rOmFyY3JvbGUgeGxpbms6aHJlZiB4bGluazpyb2xlIHhsaW5rOnNob3cgeGxpbms6dGl0bGUgeGxpbms6dHlwZVwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZSh2Yyx3Yyk7RVtiXT1uZXcgRChiLDEsITEsYSxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIil9KTtbXCJ4bWw6YmFzZVwiLFwieG1sOmxhbmdcIixcInhtbDpzcGFjZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZSh2Yyx3Yyk7RVtiXT1uZXcgRChiLDEsITEsYSxcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiKX0pO0UudGFiSW5kZXg9bmV3IEQoXCJ0YWJJbmRleFwiLDEsITEsXCJ0YWJpbmRleFwiLG51bGwpO1xuZnVuY3Rpb24geGMoYSxiLGMsZCl7dmFyIGU9RS5oYXNPd25Qcm9wZXJ0eShiKT9FW2JdOm51bGw7dmFyIGY9bnVsbCE9PWU/MD09PWUudHlwZTpkPyExOiEoMjxiLmxlbmd0aCl8fFwib1wiIT09YlswXSYmXCJPXCIhPT1iWzBdfHxcIm5cIiE9PWJbMV0mJlwiTlwiIT09YlsxXT8hMTohMDtmfHwodWMoYixjLGUsZCkmJihjPW51bGwpLGR8fG51bGw9PT1lP3NjKGIpJiYobnVsbD09PWM/YS5yZW1vdmVBdHRyaWJ1dGUoYik6YS5zZXRBdHRyaWJ1dGUoYixcIlwiK2MpKTplLm11c3RVc2VQcm9wZXJ0eT9hW2UucHJvcGVydHlOYW1lXT1udWxsPT09Yz8zPT09ZS50eXBlPyExOlwiXCI6YzooYj1lLmF0dHJpYnV0ZU5hbWUsZD1lLmF0dHJpYnV0ZU5hbWVzcGFjZSxudWxsPT09Yz9hLnJlbW92ZUF0dHJpYnV0ZShiKTooZT1lLnR5cGUsYz0zPT09ZXx8ND09PWUmJiEwPT09Yz9cIlwiOlwiXCIrYyxkP2Euc2V0QXR0cmlidXRlTlMoZCxiLGMpOmEuc2V0QXR0cmlidXRlKGIsYykpKSl9XG5mdW5jdGlvbiB5YyhhKXtzd2l0Y2godHlwZW9mIGEpe2Nhc2UgXCJib29sZWFuXCI6Y2FzZSBcIm51bWJlclwiOmNhc2UgXCJvYmplY3RcIjpjYXNlIFwic3RyaW5nXCI6Y2FzZSBcInVuZGVmaW5lZFwiOnJldHVybiBhO2RlZmF1bHQ6cmV0dXJuXCJcIn19ZnVuY3Rpb24gemMoYSxiKXt2YXIgYz1iLmNoZWNrZWQ7cmV0dXJuIG4oe30sYix7ZGVmYXVsdENoZWNrZWQ6dm9pZCAwLGRlZmF1bHRWYWx1ZTp2b2lkIDAsdmFsdWU6dm9pZCAwLGNoZWNrZWQ6bnVsbCE9Yz9jOmEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZH0pfVxuZnVuY3Rpb24gQmMoYSxiKXt2YXIgYz1udWxsPT1iLmRlZmF1bHRWYWx1ZT9cIlwiOmIuZGVmYXVsdFZhbHVlLGQ9bnVsbCE9Yi5jaGVja2VkP2IuY2hlY2tlZDpiLmRlZmF1bHRDaGVja2VkO2M9eWMobnVsbCE9Yi52YWx1ZT9iLnZhbHVlOmMpO2EuX3dyYXBwZXJTdGF0ZT17aW5pdGlhbENoZWNrZWQ6ZCxpbml0aWFsVmFsdWU6Yyxjb250cm9sbGVkOlwiY2hlY2tib3hcIj09PWIudHlwZXx8XCJyYWRpb1wiPT09Yi50eXBlP251bGwhPWIuY2hlY2tlZDpudWxsIT1iLnZhbHVlfX1mdW5jdGlvbiBDYyhhLGIpe2I9Yi5jaGVja2VkO251bGwhPWImJnhjKGEsXCJjaGVja2VkXCIsYiwhMSl9XG5mdW5jdGlvbiBEYyhhLGIpe0NjKGEsYik7dmFyIGM9eWMoYi52YWx1ZSksZD1iLnR5cGU7aWYobnVsbCE9YylpZihcIm51bWJlclwiPT09ZCl7aWYoMD09PWMmJlwiXCI9PT1hLnZhbHVlfHxhLnZhbHVlIT1jKWEudmFsdWU9XCJcIitjfWVsc2UgYS52YWx1ZSE9PVwiXCIrYyYmKGEudmFsdWU9XCJcIitjKTtlbHNlIGlmKFwic3VibWl0XCI9PT1kfHxcInJlc2V0XCI9PT1kKXthLnJlbW92ZUF0dHJpYnV0ZShcInZhbHVlXCIpO3JldHVybn1iLmhhc093blByb3BlcnR5KFwidmFsdWVcIik/RWMoYSxiLnR5cGUsYyk6Yi5oYXNPd25Qcm9wZXJ0eShcImRlZmF1bHRWYWx1ZVwiKSYmRWMoYSxiLnR5cGUseWMoYi5kZWZhdWx0VmFsdWUpKTtudWxsPT1iLmNoZWNrZWQmJm51bGwhPWIuZGVmYXVsdENoZWNrZWQmJihhLmRlZmF1bHRDaGVja2VkPSEhYi5kZWZhdWx0Q2hlY2tlZCl9XG5mdW5jdGlvbiBGYyhhLGIsYyl7aWYoYi5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpfHxiLmhhc093blByb3BlcnR5KFwiZGVmYXVsdFZhbHVlXCIpKXt2YXIgZD1iLnR5cGU7aWYoIShcInN1Ym1pdFwiIT09ZCYmXCJyZXNldFwiIT09ZHx8dm9pZCAwIT09Yi52YWx1ZSYmbnVsbCE9PWIudmFsdWUpKXJldHVybjtiPVwiXCIrYS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZTtjfHxiPT09YS52YWx1ZXx8KGEudmFsdWU9Yik7YS5kZWZhdWx0VmFsdWU9Yn1jPWEubmFtZTtcIlwiIT09YyYmKGEubmFtZT1cIlwiKTthLmRlZmF1bHRDaGVja2VkPSFhLmRlZmF1bHRDaGVja2VkO2EuZGVmYXVsdENoZWNrZWQ9ISFhLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQ7XCJcIiE9PWMmJihhLm5hbWU9Yyl9XG5mdW5jdGlvbiBFYyhhLGIsYyl7aWYoXCJudW1iZXJcIiE9PWJ8fGEub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50IT09YSludWxsPT1jP2EuZGVmYXVsdFZhbHVlPVwiXCIrYS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZTphLmRlZmF1bHRWYWx1ZSE9PVwiXCIrYyYmKGEuZGVmYXVsdFZhbHVlPVwiXCIrYyl9dmFyIEdjPXtjaGFuZ2U6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25DaGFuZ2VcIixjYXB0dXJlZDpcIm9uQ2hhbmdlQ2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJibHVyIGNoYW5nZSBjbGljayBmb2N1cyBpbnB1dCBrZXlkb3duIGtleXVwIHNlbGVjdGlvbmNoYW5nZVwiLnNwbGl0KFwiIFwiKX19O2Z1bmN0aW9uIEhjKGEsYixjKXthPXouZ2V0UG9vbGVkKEdjLmNoYW5nZSxhLGIsYyk7YS50eXBlPVwiY2hhbmdlXCI7SmIoYyk7VWEoYSk7cmV0dXJuIGF9dmFyIEljPW51bGwsSmM9bnVsbDtmdW5jdGlvbiBLYyhhKXtHYShhLCExKX1cbmZ1bmN0aW9uIExjKGEpe3ZhciBiPU1hKGEpO2lmKFhiKGIpKXJldHVybiBhfWZ1bmN0aW9uIE1jKGEsYil7aWYoXCJjaGFuZ2VcIj09PWEpcmV0dXJuIGJ9dmFyIE5jPSExO1ZhJiYoTmM9VGIoXCJpbnB1dFwiKSYmKCFkb2N1bWVudC5kb2N1bWVudE1vZGV8fDk8ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSk7ZnVuY3Rpb24gT2MoKXtJYyYmKEljLmRldGFjaEV2ZW50KFwib25wcm9wZXJ0eWNoYW5nZVwiLFBjKSxKYz1JYz1udWxsKX1mdW5jdGlvbiBQYyhhKXtcInZhbHVlXCI9PT1hLnByb3BlcnR5TmFtZSYmTGMoSmMpJiYoYT1IYyhKYyxhLFNiKGEpKSxQYihLYyxhKSl9ZnVuY3Rpb24gUWMoYSxiLGMpe1wiZm9jdXNcIj09PWE/KE9jKCksSWM9YixKYz1jLEljLmF0dGFjaEV2ZW50KFwib25wcm9wZXJ0eWNoYW5nZVwiLFBjKSk6XCJibHVyXCI9PT1hJiZPYygpfWZ1bmN0aW9uIFJjKGEpe2lmKFwic2VsZWN0aW9uY2hhbmdlXCI9PT1hfHxcImtleXVwXCI9PT1hfHxcImtleWRvd25cIj09PWEpcmV0dXJuIExjKEpjKX1cbmZ1bmN0aW9uIFNjKGEsYil7aWYoXCJjbGlja1wiPT09YSlyZXR1cm4gTGMoYil9ZnVuY3Rpb24gVGMoYSxiKXtpZihcImlucHV0XCI9PT1hfHxcImNoYW5nZVwiPT09YSlyZXR1cm4gTGMoYil9XG52YXIgVWM9e2V2ZW50VHlwZXM6R2MsX2lzSW5wdXRFdmVudFN1cHBvcnRlZDpOYyxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWI/TWEoYik6d2luZG93LGY9dm9pZCAwLGc9dm9pZCAwLGg9ZS5ub2RlTmFtZSYmZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1wic2VsZWN0XCI9PT1ofHxcImlucHV0XCI9PT1oJiZcImZpbGVcIj09PWUudHlwZT9mPU1jOlJiKGUpP05jP2Y9VGM6KGY9UmMsZz1RYyk6KGg9ZS5ub2RlTmFtZSkmJlwiaW5wdXRcIj09PWgudG9Mb3dlckNhc2UoKSYmKFwiY2hlY2tib3hcIj09PWUudHlwZXx8XCJyYWRpb1wiPT09ZS50eXBlKSYmKGY9U2MpO2lmKGYmJihmPWYoYSxiKSkpcmV0dXJuIEhjKGYsYyxkKTtnJiZnKGEsZSxiKTtcImJsdXJcIj09PWEmJihhPWUuX3dyYXBwZXJTdGF0ZSkmJmEuY29udHJvbGxlZCYmXCJudW1iZXJcIj09PWUudHlwZSYmRWMoZSxcIm51bWJlclwiLGUudmFsdWUpfX0sVmM9ei5leHRlbmQoe3ZpZXc6bnVsbCxkZXRhaWw6bnVsbH0pLFdjPXtBbHQ6XCJhbHRLZXlcIixcbkNvbnRyb2w6XCJjdHJsS2V5XCIsTWV0YTpcIm1ldGFLZXlcIixTaGlmdDpcInNoaWZ0S2V5XCJ9O2Z1bmN0aW9uIFhjKGEpe3ZhciBiPXRoaXMubmF0aXZlRXZlbnQ7cmV0dXJuIGIuZ2V0TW9kaWZpZXJTdGF0ZT9iLmdldE1vZGlmaWVyU3RhdGUoYSk6KGE9V2NbYV0pPyEhYlthXTohMX1mdW5jdGlvbiBZYygpe3JldHVybiBYY31cbnZhciBaYz0wLCRjPTAsYWQ9ITEsYmQ9ITEsY2Q9VmMuZXh0ZW5kKHtzY3JlZW5YOm51bGwsc2NyZWVuWTpudWxsLGNsaWVudFg6bnVsbCxjbGllbnRZOm51bGwscGFnZVg6bnVsbCxwYWdlWTpudWxsLGN0cmxLZXk6bnVsbCxzaGlmdEtleTpudWxsLGFsdEtleTpudWxsLG1ldGFLZXk6bnVsbCxnZXRNb2RpZmllclN0YXRlOlljLGJ1dHRvbjpudWxsLGJ1dHRvbnM6bnVsbCxyZWxhdGVkVGFyZ2V0OmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlbGF0ZWRUYXJnZXR8fChhLmZyb21FbGVtZW50PT09YS5zcmNFbGVtZW50P2EudG9FbGVtZW50OmEuZnJvbUVsZW1lbnQpfSxtb3ZlbWVudFg6ZnVuY3Rpb24oYSl7aWYoXCJtb3ZlbWVudFhcImluIGEpcmV0dXJuIGEubW92ZW1lbnRYO3ZhciBiPVpjO1pjPWEuc2NyZWVuWDtyZXR1cm4gYWQ/XCJtb3VzZW1vdmVcIj09PWEudHlwZT9hLnNjcmVlblgtYjowOihhZD0hMCwwKX0sbW92ZW1lbnRZOmZ1bmN0aW9uKGEpe2lmKFwibW92ZW1lbnRZXCJpbiBhKXJldHVybiBhLm1vdmVtZW50WTtcbnZhciBiPSRjOyRjPWEuc2NyZWVuWTtyZXR1cm4gYmQ/XCJtb3VzZW1vdmVcIj09PWEudHlwZT9hLnNjcmVlblktYjowOihiZD0hMCwwKX19KSxkZD1jZC5leHRlbmQoe3BvaW50ZXJJZDpudWxsLHdpZHRoOm51bGwsaGVpZ2h0Om51bGwscHJlc3N1cmU6bnVsbCx0YW5nZW50aWFsUHJlc3N1cmU6bnVsbCx0aWx0WDpudWxsLHRpbHRZOm51bGwsdHdpc3Q6bnVsbCxwb2ludGVyVHlwZTpudWxsLGlzUHJpbWFyeTpudWxsfSksZWQ9e21vdXNlRW50ZXI6e3JlZ2lzdHJhdGlvbk5hbWU6XCJvbk1vdXNlRW50ZXJcIixkZXBlbmRlbmNpZXM6W1wibW91c2VvdXRcIixcIm1vdXNlb3ZlclwiXX0sbW91c2VMZWF2ZTp7cmVnaXN0cmF0aW9uTmFtZTpcIm9uTW91c2VMZWF2ZVwiLGRlcGVuZGVuY2llczpbXCJtb3VzZW91dFwiLFwibW91c2VvdmVyXCJdfSxwb2ludGVyRW50ZXI6e3JlZ2lzdHJhdGlvbk5hbWU6XCJvblBvaW50ZXJFbnRlclwiLGRlcGVuZGVuY2llczpbXCJwb2ludGVyb3V0XCIsXCJwb2ludGVyb3ZlclwiXX0scG9pbnRlckxlYXZlOntyZWdpc3RyYXRpb25OYW1lOlwib25Qb2ludGVyTGVhdmVcIixcbmRlcGVuZGVuY2llczpbXCJwb2ludGVyb3V0XCIsXCJwb2ludGVyb3ZlclwiXX19LGZkPXtldmVudFR5cGVzOmVkLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9XCJtb3VzZW92ZXJcIj09PWF8fFwicG9pbnRlcm92ZXJcIj09PWEsZj1cIm1vdXNlb3V0XCI9PT1hfHxcInBvaW50ZXJvdXRcIj09PWE7aWYoZSYmKGMucmVsYXRlZFRhcmdldHx8Yy5mcm9tRWxlbWVudCl8fCFmJiYhZSlyZXR1cm4gbnVsbDtlPWQud2luZG93PT09ZD9kOihlPWQub3duZXJEb2N1bWVudCk/ZS5kZWZhdWx0Vmlld3x8ZS5wYXJlbnRXaW5kb3c6d2luZG93O2Y/KGY9YixiPShiPWMucmVsYXRlZFRhcmdldHx8Yy50b0VsZW1lbnQpP0thKGIpOm51bGwpOmY9bnVsbDtpZihmPT09YilyZXR1cm4gbnVsbDt2YXIgZz12b2lkIDAsaD12b2lkIDAsaz12b2lkIDAsbD12b2lkIDA7aWYoXCJtb3VzZW91dFwiPT09YXx8XCJtb3VzZW92ZXJcIj09PWEpZz1jZCxoPWVkLm1vdXNlTGVhdmUsaz1lZC5tb3VzZUVudGVyLGw9XCJtb3VzZVwiO1xuZWxzZSBpZihcInBvaW50ZXJvdXRcIj09PWF8fFwicG9pbnRlcm92ZXJcIj09PWEpZz1kZCxoPWVkLnBvaW50ZXJMZWF2ZSxrPWVkLnBvaW50ZXJFbnRlcixsPVwicG9pbnRlclwiO3ZhciBtPW51bGw9PWY/ZTpNYShmKTtlPW51bGw9PWI/ZTpNYShiKTthPWcuZ2V0UG9vbGVkKGgsZixjLGQpO2EudHlwZT1sK1wibGVhdmVcIjthLnRhcmdldD1tO2EucmVsYXRlZFRhcmdldD1lO2M9Zy5nZXRQb29sZWQoayxiLGMsZCk7Yy50eXBlPWwrXCJlbnRlclwiO2MudGFyZ2V0PWU7Yy5yZWxhdGVkVGFyZ2V0PW07ZD1iO2lmKGYmJmQpYTp7Yj1mO2U9ZDtsPTA7Zm9yKGc9YjtnO2c9T2EoZykpbCsrO2c9MDtmb3Ioaz1lO2s7az1PYShrKSlnKys7Zm9yKDswPGwtZzspYj1PYShiKSxsLS07Zm9yKDswPGctbDspZT1PYShlKSxnLS07Zm9yKDtsLS07KXtpZihiPT09ZXx8Yj09PWUuYWx0ZXJuYXRlKWJyZWFrIGE7Yj1PYShiKTtlPU9hKGUpfWI9bnVsbH1lbHNlIGI9bnVsbDtlPWI7Zm9yKGI9W107ZiYmZiE9PWU7KXtsPVxuZi5hbHRlcm5hdGU7aWYobnVsbCE9PWwmJmw9PT1lKWJyZWFrO2IucHVzaChmKTtmPU9hKGYpfWZvcihmPVtdO2QmJmQhPT1lOyl7bD1kLmFsdGVybmF0ZTtpZihudWxsIT09bCYmbD09PWUpYnJlYWs7Zi5wdXNoKGQpO2Q9T2EoZCl9Zm9yKGQ9MDtkPGIubGVuZ3RoO2QrKylSYShiW2RdLFwiYnViYmxlZFwiLGEpO2ZvcihkPWYubGVuZ3RoOzA8ZC0tOylSYShmW2RdLFwiY2FwdHVyZWRcIixjKTtyZXR1cm5bYSxjXX19LGdkPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gaGQoYSxiKXtyZXR1cm4gYT09PWI/MCE9PWF8fDAhPT1ifHwxL2E9PT0xL2I6YSE9PWEmJmIhPT1ifVxuZnVuY3Rpb24gaWQoYSxiKXtpZihoZChhLGIpKXJldHVybiEwO2lmKFwib2JqZWN0XCIhPT10eXBlb2YgYXx8bnVsbD09PWF8fFwib2JqZWN0XCIhPT10eXBlb2YgYnx8bnVsbD09PWIpcmV0dXJuITE7dmFyIGM9T2JqZWN0LmtleXMoYSksZD1PYmplY3Qua2V5cyhiKTtpZihjLmxlbmd0aCE9PWQubGVuZ3RoKXJldHVybiExO2ZvcihkPTA7ZDxjLmxlbmd0aDtkKyspaWYoIWdkLmNhbGwoYixjW2RdKXx8IWhkKGFbY1tkXV0sYltjW2RdXSkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gamQoYSl7dmFyIGI9YTtpZihhLmFsdGVybmF0ZSlmb3IoO2IucmV0dXJuOyliPWIucmV0dXJuO2Vsc2V7aWYoMCE9PShiLmVmZmVjdFRhZyYyKSlyZXR1cm4gMTtmb3IoO2IucmV0dXJuOylpZihiPWIucmV0dXJuLDAhPT0oYi5lZmZlY3RUYWcmMikpcmV0dXJuIDF9cmV0dXJuIDU9PT1iLnRhZz8yOjN9ZnVuY3Rpb24ga2QoYSl7MiE9PWpkKGEpP3QoXCIxODhcIik6dm9pZCAwfVxuZnVuY3Rpb24gbGQoYSl7dmFyIGI9YS5hbHRlcm5hdGU7aWYoIWIpcmV0dXJuIGI9amQoYSksMz09PWI/dChcIjE4OFwiKTp2b2lkIDAsMT09PWI/bnVsbDphO2Zvcih2YXIgYz1hLGQ9Yjs7KXt2YXIgZT1jLnJldHVybixmPWU/ZS5hbHRlcm5hdGU6bnVsbDtpZighZXx8IWYpYnJlYWs7aWYoZS5jaGlsZD09PWYuY2hpbGQpe2Zvcih2YXIgZz1lLmNoaWxkO2c7KXtpZihnPT09YylyZXR1cm4ga2QoZSksYTtpZihnPT09ZClyZXR1cm4ga2QoZSksYjtnPWcuc2libGluZ310KFwiMTg4XCIpfWlmKGMucmV0dXJuIT09ZC5yZXR1cm4pYz1lLGQ9ZjtlbHNle2c9ITE7Zm9yKHZhciBoPWUuY2hpbGQ7aDspe2lmKGg9PT1jKXtnPSEwO2M9ZTtkPWY7YnJlYWt9aWYoaD09PWQpe2c9ITA7ZD1lO2M9ZjticmVha31oPWguc2libGluZ31pZighZyl7Zm9yKGg9Zi5jaGlsZDtoOyl7aWYoaD09PWMpe2c9ITA7Yz1mO2Q9ZTticmVha31pZihoPT09ZCl7Zz0hMDtkPWY7Yz1lO2JyZWFrfWg9aC5zaWJsaW5nfWc/XG52b2lkIDA6dChcIjE4OVwiKX19Yy5hbHRlcm5hdGUhPT1kP3QoXCIxOTBcIik6dm9pZCAwfTUhPT1jLnRhZz90KFwiMTg4XCIpOnZvaWQgMDtyZXR1cm4gYy5zdGF0ZU5vZGUuY3VycmVudD09PWM/YTpifWZ1bmN0aW9uIG1kKGEpe2E9bGQoYSk7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKHZhciBiPWE7Oyl7aWYoNz09PWIudGFnfHw4PT09Yi50YWcpcmV0dXJuIGI7aWYoYi5jaGlsZCliLmNoaWxkLnJldHVybj1iLGI9Yi5jaGlsZDtlbHNle2lmKGI9PT1hKWJyZWFrO2Zvcig7IWIuc2libGluZzspe2lmKCFiLnJldHVybnx8Yi5yZXR1cm49PT1hKXJldHVybiBudWxsO2I9Yi5yZXR1cm59Yi5zaWJsaW5nLnJldHVybj1iLnJldHVybjtiPWIuc2libGluZ319cmV0dXJuIG51bGx9XG52YXIgbmQ9ei5leHRlbmQoe2FuaW1hdGlvbk5hbWU6bnVsbCxlbGFwc2VkVGltZTpudWxsLHBzZXVkb0VsZW1lbnQ6bnVsbH0pLG9kPXouZXh0ZW5kKHtjbGlwYm9hcmREYXRhOmZ1bmN0aW9uKGEpe3JldHVyblwiY2xpcGJvYXJkRGF0YVwiaW4gYT9hLmNsaXBib2FyZERhdGE6d2luZG93LmNsaXBib2FyZERhdGF9fSkscGQ9VmMuZXh0ZW5kKHtyZWxhdGVkVGFyZ2V0Om51bGx9KTtmdW5jdGlvbiBxZChhKXt2YXIgYj1hLmtleUNvZGU7XCJjaGFyQ29kZVwiaW4gYT8oYT1hLmNoYXJDb2RlLDA9PT1hJiYxMz09PWImJihhPTEzKSk6YT1iOzEwPT09YSYmKGE9MTMpO3JldHVybiAzMjw9YXx8MTM9PT1hP2E6MH1cbnZhciByZD17RXNjOlwiRXNjYXBlXCIsU3BhY2ViYXI6XCIgXCIsTGVmdDpcIkFycm93TGVmdFwiLFVwOlwiQXJyb3dVcFwiLFJpZ2h0OlwiQXJyb3dSaWdodFwiLERvd246XCJBcnJvd0Rvd25cIixEZWw6XCJEZWxldGVcIixXaW46XCJPU1wiLE1lbnU6XCJDb250ZXh0TWVudVwiLEFwcHM6XCJDb250ZXh0TWVudVwiLFNjcm9sbDpcIlNjcm9sbExvY2tcIixNb3pQcmludGFibGVLZXk6XCJVbmlkZW50aWZpZWRcIn0sc2Q9ezg6XCJCYWNrc3BhY2VcIiw5OlwiVGFiXCIsMTI6XCJDbGVhclwiLDEzOlwiRW50ZXJcIiwxNjpcIlNoaWZ0XCIsMTc6XCJDb250cm9sXCIsMTg6XCJBbHRcIiwxOTpcIlBhdXNlXCIsMjA6XCJDYXBzTG9ja1wiLDI3OlwiRXNjYXBlXCIsMzI6XCIgXCIsMzM6XCJQYWdlVXBcIiwzNDpcIlBhZ2VEb3duXCIsMzU6XCJFbmRcIiwzNjpcIkhvbWVcIiwzNzpcIkFycm93TGVmdFwiLDM4OlwiQXJyb3dVcFwiLDM5OlwiQXJyb3dSaWdodFwiLDQwOlwiQXJyb3dEb3duXCIsNDU6XCJJbnNlcnRcIiw0NjpcIkRlbGV0ZVwiLDExMjpcIkYxXCIsMTEzOlwiRjJcIiwxMTQ6XCJGM1wiLDExNTpcIkY0XCIsXG4xMTY6XCJGNVwiLDExNzpcIkY2XCIsMTE4OlwiRjdcIiwxMTk6XCJGOFwiLDEyMDpcIkY5XCIsMTIxOlwiRjEwXCIsMTIyOlwiRjExXCIsMTIzOlwiRjEyXCIsMTQ0OlwiTnVtTG9ja1wiLDE0NTpcIlNjcm9sbExvY2tcIiwyMjQ6XCJNZXRhXCJ9LHRkPVZjLmV4dGVuZCh7a2V5OmZ1bmN0aW9uKGEpe2lmKGEua2V5KXt2YXIgYj1yZFthLmtleV18fGEua2V5O2lmKFwiVW5pZGVudGlmaWVkXCIhPT1iKXJldHVybiBifXJldHVyblwia2V5cHJlc3NcIj09PWEudHlwZT8oYT1xZChhKSwxMz09PWE/XCJFbnRlclwiOlN0cmluZy5mcm9tQ2hhckNvZGUoYSkpOlwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/c2RbYS5rZXlDb2RlXXx8XCJVbmlkZW50aWZpZWRcIjpcIlwifSxsb2NhdGlvbjpudWxsLGN0cmxLZXk6bnVsbCxzaGlmdEtleTpudWxsLGFsdEtleTpudWxsLG1ldGFLZXk6bnVsbCxyZXBlYXQ6bnVsbCxsb2NhbGU6bnVsbCxnZXRNb2RpZmllclN0YXRlOlljLGNoYXJDb2RlOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5cHJlc3NcIj09PVxuYS50eXBlP3FkKGEpOjB9LGtleUNvZGU6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlkb3duXCI9PT1hLnR5cGV8fFwia2V5dXBcIj09PWEudHlwZT9hLmtleUNvZGU6MH0sd2hpY2g6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlwcmVzc1wiPT09YS50eXBlP3FkKGEpOlwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/YS5rZXlDb2RlOjB9fSksdWQ9Y2QuZXh0ZW5kKHtkYXRhVHJhbnNmZXI6bnVsbH0pLHZkPVZjLmV4dGVuZCh7dG91Y2hlczpudWxsLHRhcmdldFRvdWNoZXM6bnVsbCxjaGFuZ2VkVG91Y2hlczpudWxsLGFsdEtleTpudWxsLG1ldGFLZXk6bnVsbCxjdHJsS2V5Om51bGwsc2hpZnRLZXk6bnVsbCxnZXRNb2RpZmllclN0YXRlOlljfSksd2Q9ei5leHRlbmQoe3Byb3BlcnR5TmFtZTpudWxsLGVsYXBzZWRUaW1lOm51bGwscHNldWRvRWxlbWVudDpudWxsfSkseGQ9Y2QuZXh0ZW5kKHtkZWx0YVg6ZnVuY3Rpb24oYSl7cmV0dXJuXCJkZWx0YVhcImluIGE/YS5kZWx0YVg6XCJ3aGVlbERlbHRhWFwiaW5cbmE/LWEud2hlZWxEZWx0YVg6MH0sZGVsdGFZOmZ1bmN0aW9uKGEpe3JldHVyblwiZGVsdGFZXCJpbiBhP2EuZGVsdGFZOlwid2hlZWxEZWx0YVlcImluIGE/LWEud2hlZWxEZWx0YVk6XCJ3aGVlbERlbHRhXCJpbiBhPy1hLndoZWVsRGVsdGE6MH0sZGVsdGFaOm51bGwsZGVsdGFNb2RlOm51bGx9KSx5ZD1bW1wiYWJvcnRcIixcImFib3J0XCJdLFtiYixcImFuaW1hdGlvbkVuZFwiXSxbY2IsXCJhbmltYXRpb25JdGVyYXRpb25cIl0sW2RiLFwiYW5pbWF0aW9uU3RhcnRcIl0sW1wiY2FucGxheVwiLFwiY2FuUGxheVwiXSxbXCJjYW5wbGF5dGhyb3VnaFwiLFwiY2FuUGxheVRocm91Z2hcIl0sW1wiZHJhZ1wiLFwiZHJhZ1wiXSxbXCJkcmFnZW50ZXJcIixcImRyYWdFbnRlclwiXSxbXCJkcmFnZXhpdFwiLFwiZHJhZ0V4aXRcIl0sW1wiZHJhZ2xlYXZlXCIsXCJkcmFnTGVhdmVcIl0sW1wiZHJhZ292ZXJcIixcImRyYWdPdmVyXCJdLFtcImR1cmF0aW9uY2hhbmdlXCIsXCJkdXJhdGlvbkNoYW5nZVwiXSxbXCJlbXB0aWVkXCIsXCJlbXB0aWVkXCJdLFtcImVuY3J5cHRlZFwiLFwiZW5jcnlwdGVkXCJdLFxuW1wiZW5kZWRcIixcImVuZGVkXCJdLFtcImVycm9yXCIsXCJlcnJvclwiXSxbXCJnb3Rwb2ludGVyY2FwdHVyZVwiLFwiZ290UG9pbnRlckNhcHR1cmVcIl0sW1wibG9hZFwiLFwibG9hZFwiXSxbXCJsb2FkZWRkYXRhXCIsXCJsb2FkZWREYXRhXCJdLFtcImxvYWRlZG1ldGFkYXRhXCIsXCJsb2FkZWRNZXRhZGF0YVwiXSxbXCJsb2Fkc3RhcnRcIixcImxvYWRTdGFydFwiXSxbXCJsb3N0cG9pbnRlcmNhcHR1cmVcIixcImxvc3RQb2ludGVyQ2FwdHVyZVwiXSxbXCJtb3VzZW1vdmVcIixcIm1vdXNlTW92ZVwiXSxbXCJtb3VzZW91dFwiLFwibW91c2VPdXRcIl0sW1wibW91c2VvdmVyXCIsXCJtb3VzZU92ZXJcIl0sW1wicGxheWluZ1wiLFwicGxheWluZ1wiXSxbXCJwb2ludGVybW92ZVwiLFwicG9pbnRlck1vdmVcIl0sW1wicG9pbnRlcm91dFwiLFwicG9pbnRlck91dFwiXSxbXCJwb2ludGVyb3ZlclwiLFwicG9pbnRlck92ZXJcIl0sW1wicHJvZ3Jlc3NcIixcInByb2dyZXNzXCJdLFtcInNjcm9sbFwiLFwic2Nyb2xsXCJdLFtcInNlZWtpbmdcIixcInNlZWtpbmdcIl0sW1wic3RhbGxlZFwiLFwic3RhbGxlZFwiXSxcbltcInN1c3BlbmRcIixcInN1c3BlbmRcIl0sW1widGltZXVwZGF0ZVwiLFwidGltZVVwZGF0ZVwiXSxbXCJ0b2dnbGVcIixcInRvZ2dsZVwiXSxbXCJ0b3VjaG1vdmVcIixcInRvdWNoTW92ZVwiXSxbZWIsXCJ0cmFuc2l0aW9uRW5kXCJdLFtcIndhaXRpbmdcIixcIndhaXRpbmdcIl0sW1wid2hlZWxcIixcIndoZWVsXCJdXSx6ZD17fSxBZD17fTtmdW5jdGlvbiBCZChhLGIpe3ZhciBjPWFbMF07YT1hWzFdO3ZhciBkPVwib25cIisoYVswXS50b1VwcGVyQ2FzZSgpK2Euc2xpY2UoMSkpO2I9e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOmQsY2FwdHVyZWQ6ZCtcIkNhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOltjXSxpc0ludGVyYWN0aXZlOmJ9O3pkW2FdPWI7QWRbY109Yn1cbltbXCJibHVyXCIsXCJibHVyXCJdLFtcImNhbmNlbFwiLFwiY2FuY2VsXCJdLFtcImNsaWNrXCIsXCJjbGlja1wiXSxbXCJjbG9zZVwiLFwiY2xvc2VcIl0sW1wiY29udGV4dG1lbnVcIixcImNvbnRleHRNZW51XCJdLFtcImNvcHlcIixcImNvcHlcIl0sW1wiY3V0XCIsXCJjdXRcIl0sW1wiYXV4Y2xpY2tcIixcImF1eENsaWNrXCJdLFtcImRibGNsaWNrXCIsXCJkb3VibGVDbGlja1wiXSxbXCJkcmFnZW5kXCIsXCJkcmFnRW5kXCJdLFtcImRyYWdzdGFydFwiLFwiZHJhZ1N0YXJ0XCJdLFtcImRyb3BcIixcImRyb3BcIl0sW1wiZm9jdXNcIixcImZvY3VzXCJdLFtcImlucHV0XCIsXCJpbnB1dFwiXSxbXCJpbnZhbGlkXCIsXCJpbnZhbGlkXCJdLFtcImtleWRvd25cIixcImtleURvd25cIl0sW1wia2V5cHJlc3NcIixcImtleVByZXNzXCJdLFtcImtleXVwXCIsXCJrZXlVcFwiXSxbXCJtb3VzZWRvd25cIixcIm1vdXNlRG93blwiXSxbXCJtb3VzZXVwXCIsXCJtb3VzZVVwXCJdLFtcInBhc3RlXCIsXCJwYXN0ZVwiXSxbXCJwYXVzZVwiLFwicGF1c2VcIl0sW1wicGxheVwiLFwicGxheVwiXSxbXCJwb2ludGVyY2FuY2VsXCIsXCJwb2ludGVyQ2FuY2VsXCJdLFxuW1wicG9pbnRlcmRvd25cIixcInBvaW50ZXJEb3duXCJdLFtcInBvaW50ZXJ1cFwiLFwicG9pbnRlclVwXCJdLFtcInJhdGVjaGFuZ2VcIixcInJhdGVDaGFuZ2VcIl0sW1wicmVzZXRcIixcInJlc2V0XCJdLFtcInNlZWtlZFwiLFwic2Vla2VkXCJdLFtcInN1Ym1pdFwiLFwic3VibWl0XCJdLFtcInRvdWNoY2FuY2VsXCIsXCJ0b3VjaENhbmNlbFwiXSxbXCJ0b3VjaGVuZFwiLFwidG91Y2hFbmRcIl0sW1widG91Y2hzdGFydFwiLFwidG91Y2hTdGFydFwiXSxbXCJ2b2x1bWVjaGFuZ2VcIixcInZvbHVtZUNoYW5nZVwiXV0uZm9yRWFjaChmdW5jdGlvbihhKXtCZChhLCEwKX0pO3lkLmZvckVhY2goZnVuY3Rpb24oYSl7QmQoYSwhMSl9KTtcbnZhciBDZD17ZXZlbnRUeXBlczp6ZCxpc0ludGVyYWN0aXZlVG9wTGV2ZWxFdmVudFR5cGU6ZnVuY3Rpb24oYSl7YT1BZFthXTtyZXR1cm4gdm9pZCAwIT09YSYmITA9PT1hLmlzSW50ZXJhY3RpdmV9LGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9QWRbYV07aWYoIWUpcmV0dXJuIG51bGw7c3dpdGNoKGEpe2Nhc2UgXCJrZXlwcmVzc1wiOmlmKDA9PT1xZChjKSlyZXR1cm4gbnVsbDtjYXNlIFwia2V5ZG93blwiOmNhc2UgXCJrZXl1cFwiOmE9dGQ7YnJlYWs7Y2FzZSBcImJsdXJcIjpjYXNlIFwiZm9jdXNcIjphPXBkO2JyZWFrO2Nhc2UgXCJjbGlja1wiOmlmKDI9PT1jLmJ1dHRvbilyZXR1cm4gbnVsbDtjYXNlIFwiYXV4Y2xpY2tcIjpjYXNlIFwiZGJsY2xpY2tcIjpjYXNlIFwibW91c2Vkb3duXCI6Y2FzZSBcIm1vdXNlbW92ZVwiOmNhc2UgXCJtb3VzZXVwXCI6Y2FzZSBcIm1vdXNlb3V0XCI6Y2FzZSBcIm1vdXNlb3ZlclwiOmNhc2UgXCJjb250ZXh0bWVudVwiOmE9Y2Q7YnJlYWs7Y2FzZSBcImRyYWdcIjpjYXNlIFwiZHJhZ2VuZFwiOmNhc2UgXCJkcmFnZW50ZXJcIjpjYXNlIFwiZHJhZ2V4aXRcIjpjYXNlIFwiZHJhZ2xlYXZlXCI6Y2FzZSBcImRyYWdvdmVyXCI6Y2FzZSBcImRyYWdzdGFydFwiOmNhc2UgXCJkcm9wXCI6YT1cbnVkO2JyZWFrO2Nhc2UgXCJ0b3VjaGNhbmNlbFwiOmNhc2UgXCJ0b3VjaGVuZFwiOmNhc2UgXCJ0b3VjaG1vdmVcIjpjYXNlIFwidG91Y2hzdGFydFwiOmE9dmQ7YnJlYWs7Y2FzZSBiYjpjYXNlIGNiOmNhc2UgZGI6YT1uZDticmVhaztjYXNlIGViOmE9d2Q7YnJlYWs7Y2FzZSBcInNjcm9sbFwiOmE9VmM7YnJlYWs7Y2FzZSBcIndoZWVsXCI6YT14ZDticmVhaztjYXNlIFwiY29weVwiOmNhc2UgXCJjdXRcIjpjYXNlIFwicGFzdGVcIjphPW9kO2JyZWFrO2Nhc2UgXCJnb3Rwb2ludGVyY2FwdHVyZVwiOmNhc2UgXCJsb3N0cG9pbnRlcmNhcHR1cmVcIjpjYXNlIFwicG9pbnRlcmNhbmNlbFwiOmNhc2UgXCJwb2ludGVyZG93blwiOmNhc2UgXCJwb2ludGVybW92ZVwiOmNhc2UgXCJwb2ludGVyb3V0XCI6Y2FzZSBcInBvaW50ZXJvdmVyXCI6Y2FzZSBcInBvaW50ZXJ1cFwiOmE9ZGQ7YnJlYWs7ZGVmYXVsdDphPXp9Yj1hLmdldFBvb2xlZChlLGIsYyxkKTtVYShiKTtyZXR1cm4gYn19LERkPUNkLmlzSW50ZXJhY3RpdmVUb3BMZXZlbEV2ZW50VHlwZSxcbkVkPVtdO2Z1bmN0aW9uIEZkKGEpe3ZhciBiPWEudGFyZ2V0SW5zdCxjPWI7ZG97aWYoIWMpe2EuYW5jZXN0b3JzLnB1c2goYyk7YnJlYWt9dmFyIGQ7Zm9yKGQ9YztkLnJldHVybjspZD1kLnJldHVybjtkPTUhPT1kLnRhZz9udWxsOmQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87aWYoIWQpYnJlYWs7YS5hbmNlc3RvcnMucHVzaChjKTtjPUthKGQpfXdoaWxlKGMpO2ZvcihjPTA7YzxhLmFuY2VzdG9ycy5sZW5ndGg7YysrKXtiPWEuYW5jZXN0b3JzW2NdO3ZhciBlPVNiKGEubmF0aXZlRXZlbnQpO2Q9YS50b3BMZXZlbFR5cGU7Zm9yKHZhciBmPWEubmF0aXZlRXZlbnQsZz1udWxsLGg9MDtoPHBhLmxlbmd0aDtoKyspe3ZhciBrPXBhW2hdO2smJihrPWsuZXh0cmFjdEV2ZW50cyhkLGIsZixlKSkmJihnPXlhKGcsaykpfUdhKGcsITEpfX12YXIgR2Q9ITA7XG5mdW5jdGlvbiBGKGEsYil7aWYoIWIpcmV0dXJuIG51bGw7dmFyIGM9KERkKGEpP0hkOklkKS5iaW5kKG51bGwsYSk7Yi5hZGRFdmVudExpc3RlbmVyKGEsYywhMSl9ZnVuY3Rpb24gSmQoYSxiKXtpZighYilyZXR1cm4gbnVsbDt2YXIgYz0oRGQoYSk/SGQ6SWQpLmJpbmQobnVsbCxhKTtiLmFkZEV2ZW50TGlzdGVuZXIoYSxjLCEwKX1mdW5jdGlvbiBIZChhLGIpe01iKElkLGEsYil9XG5mdW5jdGlvbiBJZChhLGIpe2lmKEdkKXt2YXIgYz1TYihiKTtjPUthKGMpO251bGw9PT1jfHxcIm51bWJlclwiIT09dHlwZW9mIGMudGFnfHwyPT09amQoYyl8fChjPW51bGwpO2lmKEVkLmxlbmd0aCl7dmFyIGQ9RWQucG9wKCk7ZC50b3BMZXZlbFR5cGU9YTtkLm5hdGl2ZUV2ZW50PWI7ZC50YXJnZXRJbnN0PWM7YT1kfWVsc2UgYT17dG9wTGV2ZWxUeXBlOmEsbmF0aXZlRXZlbnQ6Yix0YXJnZXRJbnN0OmMsYW5jZXN0b3JzOltdfTt0cnl7UGIoRmQsYSl9ZmluYWxseXthLnRvcExldmVsVHlwZT1udWxsLGEubmF0aXZlRXZlbnQ9bnVsbCxhLnRhcmdldEluc3Q9bnVsbCxhLmFuY2VzdG9ycy5sZW5ndGg9MCwxMD5FZC5sZW5ndGgmJkVkLnB1c2goYSl9fX12YXIgS2Q9e30sTGQ9MCxNZD1cIl9yZWFjdExpc3RlbmVyc0lEXCIrKFwiXCIrTWF0aC5yYW5kb20oKSkuc2xpY2UoMik7XG5mdW5jdGlvbiBOZChhKXtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxNZCl8fChhW01kXT1MZCsrLEtkW2FbTWRdXT17fSk7cmV0dXJuIEtkW2FbTWRdXX1mdW5jdGlvbiBPZChhKXthPWF8fChcInVuZGVmaW5lZFwiIT09dHlwZW9mIGRvY3VtZW50P2RvY3VtZW50OnZvaWQgMCk7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhKXJldHVybiBudWxsO3RyeXtyZXR1cm4gYS5hY3RpdmVFbGVtZW50fHxhLmJvZHl9Y2F0Y2goYil7cmV0dXJuIGEuYm9keX19ZnVuY3Rpb24gUWQoYSl7Zm9yKDthJiZhLmZpcnN0Q2hpbGQ7KWE9YS5maXJzdENoaWxkO3JldHVybiBhfVxuZnVuY3Rpb24gUmQoYSxiKXt2YXIgYz1RZChhKTthPTA7Zm9yKHZhciBkO2M7KXtpZigzPT09Yy5ub2RlVHlwZSl7ZD1hK2MudGV4dENvbnRlbnQubGVuZ3RoO2lmKGE8PWImJmQ+PWIpcmV0dXJue25vZGU6YyxvZmZzZXQ6Yi1hfTthPWR9YTp7Zm9yKDtjOyl7aWYoYy5uZXh0U2libGluZyl7Yz1jLm5leHRTaWJsaW5nO2JyZWFrIGF9Yz1jLnBhcmVudE5vZGV9Yz12b2lkIDB9Yz1RZChjKX19ZnVuY3Rpb24gU2QoYSxiKXtyZXR1cm4gYSYmYj9hPT09Yj8hMDphJiYzPT09YS5ub2RlVHlwZT8hMTpiJiYzPT09Yi5ub2RlVHlwZT9TZChhLGIucGFyZW50Tm9kZSk6XCJjb250YWluc1wiaW4gYT9hLmNvbnRhaW5zKGIpOmEuY29tcGFyZURvY3VtZW50UG9zaXRpb24/ISEoYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSYxNik6ITE6ITF9XG5mdW5jdGlvbiBUZCgpe2Zvcih2YXIgYT13aW5kb3csYj1PZCgpO2IgaW5zdGFuY2VvZiBhLkhUTUxJRnJhbWVFbGVtZW50Oyl7dHJ5e2E9Yi5jb250ZW50RG9jdW1lbnQuZGVmYXVsdFZpZXd9Y2F0Y2goYyl7YnJlYWt9Yj1PZChhLmRvY3VtZW50KX1yZXR1cm4gYn1mdW5jdGlvbiBVZChhKXt2YXIgYj1hJiZhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGImJihcImlucHV0XCI9PT1iJiYoXCJ0ZXh0XCI9PT1hLnR5cGV8fFwic2VhcmNoXCI9PT1hLnR5cGV8fFwidGVsXCI9PT1hLnR5cGV8fFwidXJsXCI9PT1hLnR5cGV8fFwicGFzc3dvcmRcIj09PWEudHlwZSl8fFwidGV4dGFyZWFcIj09PWJ8fFwidHJ1ZVwiPT09YS5jb250ZW50RWRpdGFibGUpfVxudmFyIFZkPVZhJiZcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQmJjExPj1kb2N1bWVudC5kb2N1bWVudE1vZGUsV2Q9e3NlbGVjdDp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvblNlbGVjdFwiLGNhcHR1cmVkOlwib25TZWxlY3RDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcImJsdXIgY29udGV4dG1lbnUgZHJhZ2VuZCBmb2N1cyBrZXlkb3duIGtleXVwIG1vdXNlZG93biBtb3VzZXVwIHNlbGVjdGlvbmNoYW5nZVwiLnNwbGl0KFwiIFwiKX19LFhkPW51bGwsWWQ9bnVsbCxaZD1udWxsLCRkPSExO1xuZnVuY3Rpb24gYWUoYSxiKXt2YXIgYz1iLndpbmRvdz09PWI/Yi5kb2N1bWVudDo5PT09Yi5ub2RlVHlwZT9iOmIub3duZXJEb2N1bWVudDtpZigkZHx8bnVsbD09WGR8fFhkIT09T2QoYykpcmV0dXJuIG51bGw7Yz1YZDtcInNlbGVjdGlvblN0YXJ0XCJpbiBjJiZVZChjKT9jPXtzdGFydDpjLnNlbGVjdGlvblN0YXJ0LGVuZDpjLnNlbGVjdGlvbkVuZH06KGM9KGMub3duZXJEb2N1bWVudCYmYy5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3fHx3aW5kb3cpLmdldFNlbGVjdGlvbigpLGM9e2FuY2hvck5vZGU6Yy5hbmNob3JOb2RlLGFuY2hvck9mZnNldDpjLmFuY2hvck9mZnNldCxmb2N1c05vZGU6Yy5mb2N1c05vZGUsZm9jdXNPZmZzZXQ6Yy5mb2N1c09mZnNldH0pO3JldHVybiBaZCYmaWQoWmQsYyk/bnVsbDooWmQ9YyxhPXouZ2V0UG9vbGVkKFdkLnNlbGVjdCxZZCxhLGIpLGEudHlwZT1cInNlbGVjdFwiLGEudGFyZ2V0PVhkLFVhKGEpLGEpfVxudmFyIGJlPXtldmVudFR5cGVzOldkLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9ZC53aW5kb3c9PT1kP2QuZG9jdW1lbnQ6OT09PWQubm9kZVR5cGU/ZDpkLm93bmVyRG9jdW1lbnQsZjtpZighKGY9IWUpKXthOntlPU5kKGUpO2Y9dGEub25TZWxlY3Q7Zm9yKHZhciBnPTA7ZzxmLmxlbmd0aDtnKyspe3ZhciBoPWZbZ107aWYoIWUuaGFzT3duUHJvcGVydHkoaCl8fCFlW2hdKXtlPSExO2JyZWFrIGF9fWU9ITB9Zj0hZX1pZihmKXJldHVybiBudWxsO2U9Yj9NYShiKTp3aW5kb3c7c3dpdGNoKGEpe2Nhc2UgXCJmb2N1c1wiOmlmKFJiKGUpfHxcInRydWVcIj09PWUuY29udGVudEVkaXRhYmxlKVhkPWUsWWQ9YixaZD1udWxsO2JyZWFrO2Nhc2UgXCJibHVyXCI6WmQ9WWQ9WGQ9bnVsbDticmVhaztjYXNlIFwibW91c2Vkb3duXCI6JGQ9ITA7YnJlYWs7Y2FzZSBcImNvbnRleHRtZW51XCI6Y2FzZSBcIm1vdXNldXBcIjpjYXNlIFwiZHJhZ2VuZFwiOnJldHVybiAkZD0hMSxhZShjLGQpO2Nhc2UgXCJzZWxlY3Rpb25jaGFuZ2VcIjppZihWZClicmVhaztcbmNhc2UgXCJrZXlkb3duXCI6Y2FzZSBcImtleXVwXCI6cmV0dXJuIGFlKGMsZCl9cmV0dXJuIG51bGx9fTtFYS5pbmplY3RFdmVudFBsdWdpbk9yZGVyKFwiUmVzcG9uZGVyRXZlbnRQbHVnaW4gU2ltcGxlRXZlbnRQbHVnaW4gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luIENoYW5nZUV2ZW50UGx1Z2luIFNlbGVjdEV2ZW50UGx1Z2luIEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cIi5zcGxpdChcIiBcIikpO3VhPU5hO3ZhPUxhO3dhPU1hO0VhLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7U2ltcGxlRXZlbnRQbHVnaW46Q2QsRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOmZkLENoYW5nZUV2ZW50UGx1Z2luOlVjLFNlbGVjdEV2ZW50UGx1Z2luOmJlLEJlZm9yZUlucHV0RXZlbnRQbHVnaW46RWJ9KTtmdW5jdGlvbiBjZShhKXt2YXIgYj1cIlwiO2FhLkNoaWxkcmVuLmZvckVhY2goYSxmdW5jdGlvbihhKXtudWxsIT1hJiYoYis9YSl9KTtyZXR1cm4gYn1cbmZ1bmN0aW9uIGRlKGEsYil7YT1uKHtjaGlsZHJlbjp2b2lkIDB9LGIpO2lmKGI9Y2UoYi5jaGlsZHJlbikpYS5jaGlsZHJlbj1iO3JldHVybiBhfWZ1bmN0aW9uIGVlKGEsYixjLGQpe2E9YS5vcHRpb25zO2lmKGIpe2I9e307Zm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspYltcIiRcIitjW2VdXT0hMDtmb3IoYz0wO2M8YS5sZW5ndGg7YysrKWU9Yi5oYXNPd25Qcm9wZXJ0eShcIiRcIithW2NdLnZhbHVlKSxhW2NdLnNlbGVjdGVkIT09ZSYmKGFbY10uc2VsZWN0ZWQ9ZSksZSYmZCYmKGFbY10uZGVmYXVsdFNlbGVjdGVkPSEwKX1lbHNle2M9XCJcIit5YyhjKTtiPW51bGw7Zm9yKGU9MDtlPGEubGVuZ3RoO2UrKyl7aWYoYVtlXS52YWx1ZT09PWMpe2FbZV0uc2VsZWN0ZWQ9ITA7ZCYmKGFbZV0uZGVmYXVsdFNlbGVjdGVkPSEwKTtyZXR1cm59bnVsbCE9PWJ8fGFbZV0uZGlzYWJsZWR8fChiPWFbZV0pfW51bGwhPT1iJiYoYi5zZWxlY3RlZD0hMCl9fVxuZnVuY3Rpb24gZmUoYSxiKXtudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MP3QoXCI5MVwiKTp2b2lkIDA7cmV0dXJuIG4oe30sYix7dmFsdWU6dm9pZCAwLGRlZmF1bHRWYWx1ZTp2b2lkIDAsY2hpbGRyZW46XCJcIithLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlfSl9ZnVuY3Rpb24gZ2UoYSxiKXt2YXIgYz1iLnZhbHVlO251bGw9PWMmJihjPWIuZGVmYXVsdFZhbHVlLGI9Yi5jaGlsZHJlbixudWxsIT1iJiYobnVsbCE9Yz90KFwiOTJcIik6dm9pZCAwLEFycmF5LmlzQXJyYXkoYikmJigxPj1iLmxlbmd0aD92b2lkIDA6dChcIjkzXCIpLGI9YlswXSksYz1iKSxudWxsPT1jJiYoYz1cIlwiKSk7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsVmFsdWU6eWMoYyl9fVxuZnVuY3Rpb24gaGUoYSxiKXt2YXIgYz15YyhiLnZhbHVlKSxkPXljKGIuZGVmYXVsdFZhbHVlKTtudWxsIT1jJiYoYz1cIlwiK2MsYyE9PWEudmFsdWUmJihhLnZhbHVlPWMpLG51bGw9PWIuZGVmYXVsdFZhbHVlJiZhLmRlZmF1bHRWYWx1ZSE9PWMmJihhLmRlZmF1bHRWYWx1ZT1jKSk7bnVsbCE9ZCYmKGEuZGVmYXVsdFZhbHVlPVwiXCIrZCl9ZnVuY3Rpb24gaWUoYSl7dmFyIGI9YS50ZXh0Q29udGVudDtiPT09YS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSYmKGEudmFsdWU9Yil9dmFyIGplPXtodG1sOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLG1hdGhtbDpcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIixzdmc6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifTtcbmZ1bmN0aW9uIGtlKGEpe3N3aXRjaChhKXtjYXNlIFwic3ZnXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO2Nhc2UgXCJtYXRoXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7ZGVmYXVsdDpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIn19ZnVuY3Rpb24gbGUoYSxiKXtyZXR1cm4gbnVsbD09YXx8XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI9PT1hP2tlKGIpOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj09PWEmJlwiZm9yZWlnbk9iamVjdFwiPT09Yj9cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjphfVxudmFyIG1lPXZvaWQgMCxuZT1mdW5jdGlvbihhKXtyZXR1cm5cInVuZGVmaW5lZFwiIT09dHlwZW9mIE1TQXBwJiZNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbj9mdW5jdGlvbihiLGMsZCxlKXtNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbigpe3JldHVybiBhKGIsYyxkLGUpfSl9OmF9KGZ1bmN0aW9uKGEsYil7aWYoYS5uYW1lc3BhY2VVUkkhPT1qZS5zdmd8fFwiaW5uZXJIVE1MXCJpbiBhKWEuaW5uZXJIVE1MPWI7ZWxzZXttZT1tZXx8ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTttZS5pbm5lckhUTUw9XCI8c3ZnPlwiK2IrXCI8L3N2Zz5cIjtmb3IoYj1tZS5maXJzdENoaWxkO2EuZmlyc3RDaGlsZDspYS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpO2Zvcig7Yi5maXJzdENoaWxkOylhLmFwcGVuZENoaWxkKGIuZmlyc3RDaGlsZCl9fSk7XG5mdW5jdGlvbiBvZShhLGIpe2lmKGIpe3ZhciBjPWEuZmlyc3RDaGlsZDtpZihjJiZjPT09YS5sYXN0Q2hpbGQmJjM9PT1jLm5vZGVUeXBlKXtjLm5vZGVWYWx1ZT1iO3JldHVybn19YS50ZXh0Q29udGVudD1ifVxudmFyIHBlPXthbmltYXRpb25JdGVyYXRpb25Db3VudDohMCxib3JkZXJJbWFnZU91dHNldDohMCxib3JkZXJJbWFnZVNsaWNlOiEwLGJvcmRlckltYWdlV2lkdGg6ITAsYm94RmxleDohMCxib3hGbGV4R3JvdXA6ITAsYm94T3JkaW5hbEdyb3VwOiEwLGNvbHVtbkNvdW50OiEwLGNvbHVtbnM6ITAsZmxleDohMCxmbGV4R3JvdzohMCxmbGV4UG9zaXRpdmU6ITAsZmxleFNocmluazohMCxmbGV4TmVnYXRpdmU6ITAsZmxleE9yZGVyOiEwLGdyaWRBcmVhOiEwLGdyaWRSb3c6ITAsZ3JpZFJvd0VuZDohMCxncmlkUm93U3BhbjohMCxncmlkUm93U3RhcnQ6ITAsZ3JpZENvbHVtbjohMCxncmlkQ29sdW1uRW5kOiEwLGdyaWRDb2x1bW5TcGFuOiEwLGdyaWRDb2x1bW5TdGFydDohMCxmb250V2VpZ2h0OiEwLGxpbmVDbGFtcDohMCxsaW5lSGVpZ2h0OiEwLG9wYWNpdHk6ITAsb3JkZXI6ITAsb3JwaGFuczohMCx0YWJTaXplOiEwLHdpZG93czohMCx6SW5kZXg6ITAsem9vbTohMCxmaWxsT3BhY2l0eTohMCxcbmZsb29kT3BhY2l0eTohMCxzdG9wT3BhY2l0eTohMCxzdHJva2VEYXNoYXJyYXk6ITAsc3Ryb2tlRGFzaG9mZnNldDohMCxzdHJva2VNaXRlcmxpbWl0OiEwLHN0cm9rZU9wYWNpdHk6ITAsc3Ryb2tlV2lkdGg6ITB9LHFlPVtcIldlYmtpdFwiLFwibXNcIixcIk1velwiLFwiT1wiXTtPYmplY3Qua2V5cyhwZSkuZm9yRWFjaChmdW5jdGlvbihhKXtxZS5mb3JFYWNoKGZ1bmN0aW9uKGIpe2I9YithLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Euc3Vic3RyaW5nKDEpO3BlW2JdPXBlW2FdfSl9KTtcbmZ1bmN0aW9uIHJlKGEsYil7YT1hLnN0eWxlO2Zvcih2YXIgYyBpbiBiKWlmKGIuaGFzT3duUHJvcGVydHkoYykpe3ZhciBkPTA9PT1jLmluZGV4T2YoXCItLVwiKTt2YXIgZT1jO3ZhciBmPWJbY107ZT1udWxsPT1mfHxcImJvb2xlYW5cIj09PXR5cGVvZiBmfHxcIlwiPT09Zj9cIlwiOmR8fFwibnVtYmVyXCIhPT10eXBlb2YgZnx8MD09PWZ8fHBlLmhhc093blByb3BlcnR5KGUpJiZwZVtlXT8oXCJcIitmKS50cmltKCk6ZitcInB4XCI7XCJmbG9hdFwiPT09YyYmKGM9XCJjc3NGbG9hdFwiKTtkP2Euc2V0UHJvcGVydHkoYyxlKTphW2NdPWV9fXZhciBzZT1uKHttZW51aXRlbTohMH0se2FyZWE6ITAsYmFzZTohMCxicjohMCxjb2w6ITAsZW1iZWQ6ITAsaHI6ITAsaW1nOiEwLGlucHV0OiEwLGtleWdlbjohMCxsaW5rOiEwLG1ldGE6ITAscGFyYW06ITAsc291cmNlOiEwLHRyYWNrOiEwLHdicjohMH0pO1xuZnVuY3Rpb24gdGUoYSxiKXtiJiYoc2VbYV0mJihudWxsIT1iLmNoaWxkcmVufHxudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MP3QoXCIxMzdcIixhLFwiXCIpOnZvaWQgMCksbnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmKG51bGwhPWIuY2hpbGRyZW4/dChcIjYwXCIpOnZvaWQgMCxcIm9iamVjdFwiPT09dHlwZW9mIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJlwiX19odG1sXCJpbiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MP3ZvaWQgMDp0KFwiNjFcIikpLG51bGwhPWIuc3R5bGUmJlwib2JqZWN0XCIhPT10eXBlb2YgYi5zdHlsZT90KFwiNjJcIixcIlwiKTp2b2lkIDApfVxuZnVuY3Rpb24gdWUoYSxiKXtpZigtMT09PWEuaW5kZXhPZihcIi1cIikpcmV0dXJuXCJzdHJpbmdcIj09PXR5cGVvZiBiLmlzO3N3aXRjaChhKXtjYXNlIFwiYW5ub3RhdGlvbi14bWxcIjpjYXNlIFwiY29sb3ItcHJvZmlsZVwiOmNhc2UgXCJmb250LWZhY2VcIjpjYXNlIFwiZm9udC1mYWNlLXNyY1wiOmNhc2UgXCJmb250LWZhY2UtdXJpXCI6Y2FzZSBcImZvbnQtZmFjZS1mb3JtYXRcIjpjYXNlIFwiZm9udC1mYWNlLW5hbWVcIjpjYXNlIFwibWlzc2luZy1nbHlwaFwiOnJldHVybiExO2RlZmF1bHQ6cmV0dXJuITB9fVxuZnVuY3Rpb24gdmUoYSxiKXthPTk9PT1hLm5vZGVUeXBlfHwxMT09PWEubm9kZVR5cGU/YTphLm93bmVyRG9jdW1lbnQ7dmFyIGM9TmQoYSk7Yj10YVtiXTtmb3IodmFyIGQ9MDtkPGIubGVuZ3RoO2QrKyl7dmFyIGU9YltkXTtpZighYy5oYXNPd25Qcm9wZXJ0eShlKXx8IWNbZV0pe3N3aXRjaChlKXtjYXNlIFwic2Nyb2xsXCI6SmQoXCJzY3JvbGxcIixhKTticmVhaztjYXNlIFwiZm9jdXNcIjpjYXNlIFwiYmx1clwiOkpkKFwiZm9jdXNcIixhKTtKZChcImJsdXJcIixhKTtjLmJsdXI9ITA7Yy5mb2N1cz0hMDticmVhaztjYXNlIFwiY2FuY2VsXCI6Y2FzZSBcImNsb3NlXCI6VGIoZSkmJkpkKGUsYSk7YnJlYWs7Y2FzZSBcImludmFsaWRcIjpjYXNlIFwic3VibWl0XCI6Y2FzZSBcInJlc2V0XCI6YnJlYWs7ZGVmYXVsdDotMT09PWZiLmluZGV4T2YoZSkmJkYoZSxhKX1jW2VdPSEwfX19ZnVuY3Rpb24gd2UoKXt9dmFyIHhlPW51bGwseWU9bnVsbDtcbmZ1bmN0aW9uIHplKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJidXR0b25cIjpjYXNlIFwiaW5wdXRcIjpjYXNlIFwic2VsZWN0XCI6Y2FzZSBcInRleHRhcmVhXCI6cmV0dXJuISFiLmF1dG9Gb2N1c31yZXR1cm4hMX1mdW5jdGlvbiBBZShhLGIpe3JldHVyblwidGV4dGFyZWFcIj09PWF8fFwib3B0aW9uXCI9PT1hfHxcIm5vc2NyaXB0XCI9PT1hfHxcInN0cmluZ1wiPT09dHlwZW9mIGIuY2hpbGRyZW58fFwibnVtYmVyXCI9PT10eXBlb2YgYi5jaGlsZHJlbnx8XCJvYmplY3RcIj09PXR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZudWxsIT09Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmbnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWx9ZnVuY3Rpb24gQmUoYSl7Zm9yKGE9YS5uZXh0U2libGluZzthJiYxIT09YS5ub2RlVHlwZSYmMyE9PWEubm9kZVR5cGU7KWE9YS5uZXh0U2libGluZztyZXR1cm4gYX1cbmZ1bmN0aW9uIENlKGEpe2ZvcihhPWEuZmlyc3RDaGlsZDthJiYxIT09YS5ub2RlVHlwZSYmMyE9PWEubm9kZVR5cGU7KWE9YS5uZXh0U2libGluZztyZXR1cm4gYX1uZXcgU2V0O3ZhciBEZT1bXSxFZT0tMTtmdW5jdGlvbiBHKGEpezA+RWV8fChhLmN1cnJlbnQ9RGVbRWVdLERlW0VlXT1udWxsLEVlLS0pfWZ1bmN0aW9uIEgoYSxiKXtFZSsrO0RlW0VlXT1hLmN1cnJlbnQ7YS5jdXJyZW50PWJ9dmFyIEZlPXt9LEk9e2N1cnJlbnQ6RmV9LEo9e2N1cnJlbnQ6ITF9LEdlPUZlO1xuZnVuY3Rpb24gSGUoYSxiKXt2YXIgYz1hLnR5cGUuY29udGV4dFR5cGVzO2lmKCFjKXJldHVybiBGZTt2YXIgZD1hLnN0YXRlTm9kZTtpZihkJiZkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9PT1iKXJldHVybiBkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O3ZhciBlPXt9LGY7Zm9yKGYgaW4gYyllW2ZdPWJbZl07ZCYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWIsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1lKTtyZXR1cm4gZX1mdW5jdGlvbiBLKGEpe2E9YS5jaGlsZENvbnRleHRUeXBlcztyZXR1cm4gbnVsbCE9PWEmJnZvaWQgMCE9PWF9ZnVuY3Rpb24gSWUoYSl7RyhKLGEpO0coSSxhKX1mdW5jdGlvbiBKZShhKXtHKEosYSk7RyhJLGEpfVxuZnVuY3Rpb24gS2UoYSxiLGMpe0kuY3VycmVudCE9PUZlP3QoXCIxNjhcIik6dm9pZCAwO0goSSxiLGEpO0goSixjLGEpfWZ1bmN0aW9uIExlKGEsYixjKXt2YXIgZD1hLnN0YXRlTm9kZTthPWIuY2hpbGRDb250ZXh0VHlwZXM7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIGQuZ2V0Q2hpbGRDb250ZXh0KXJldHVybiBjO2Q9ZC5nZXRDaGlsZENvbnRleHQoKTtmb3IodmFyIGUgaW4gZCllIGluIGE/dm9pZCAwOnQoXCIxMDhcIixsYyhiKXx8XCJVbmtub3duXCIsZSk7cmV0dXJuIG4oe30sYyxkKX1mdW5jdGlvbiBNZShhKXt2YXIgYj1hLnN0YXRlTm9kZTtiPWImJmIuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHR8fEZlO0dlPUkuY3VycmVudDtIKEksYixhKTtIKEosSi5jdXJyZW50LGEpO3JldHVybiEwfVxuZnVuY3Rpb24gTmUoYSxiLGMpe3ZhciBkPWEuc3RhdGVOb2RlO2Q/dm9pZCAwOnQoXCIxNjlcIik7Yz8oYj1MZShhLGIsR2UpLGQuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ9YixHKEosYSksRyhJLGEpLEgoSSxiLGEpKTpHKEosYSk7SChKLGMsYSl9dmFyIE9lPW51bGwsUGU9bnVsbDtmdW5jdGlvbiBRZShhKXtyZXR1cm4gZnVuY3Rpb24oYil7dHJ5e3JldHVybiBhKGIpfWNhdGNoKGMpe319fVxuZnVuY3Rpb24gUmUoYSl7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pcmV0dXJuITE7dmFyIGI9X19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO2lmKGIuaXNEaXNhYmxlZHx8IWIuc3VwcG9ydHNGaWJlcilyZXR1cm4hMDt0cnl7dmFyIGM9Yi5pbmplY3QoYSk7T2U9UWUoZnVuY3Rpb24oYSl7cmV0dXJuIGIub25Db21taXRGaWJlclJvb3QoYyxhKX0pO1BlPVFlKGZ1bmN0aW9uKGEpe3JldHVybiBiLm9uQ29tbWl0RmliZXJVbm1vdW50KGMsYSl9KX1jYXRjaChkKXt9cmV0dXJuITB9XG5mdW5jdGlvbiBTZShhLGIsYyxkKXt0aGlzLnRhZz1hO3RoaXMua2V5PWM7dGhpcy5zaWJsaW5nPXRoaXMuY2hpbGQ9dGhpcy5yZXR1cm49dGhpcy5zdGF0ZU5vZGU9dGhpcy50eXBlPW51bGw7dGhpcy5pbmRleD0wO3RoaXMucmVmPW51bGw7dGhpcy5wZW5kaW5nUHJvcHM9Yjt0aGlzLmZpcnN0Q29udGV4dERlcGVuZGVuY3k9dGhpcy5tZW1vaXplZFN0YXRlPXRoaXMudXBkYXRlUXVldWU9dGhpcy5tZW1vaXplZFByb3BzPW51bGw7dGhpcy5tb2RlPWQ7dGhpcy5lZmZlY3RUYWc9MDt0aGlzLmxhc3RFZmZlY3Q9dGhpcy5maXJzdEVmZmVjdD10aGlzLm5leHRFZmZlY3Q9bnVsbDt0aGlzLmNoaWxkRXhwaXJhdGlvblRpbWU9dGhpcy5leHBpcmF0aW9uVGltZT0wO3RoaXMuYWx0ZXJuYXRlPW51bGx9ZnVuY3Rpb24gVGUoYSl7YT1hLnByb3RvdHlwZTtyZXR1cm4hKCFhfHwhYS5pc1JlYWN0Q29tcG9uZW50KX1cbmZ1bmN0aW9uIFVlKGEsYixjKXt2YXIgZD1hLmFsdGVybmF0ZTtudWxsPT09ZD8oZD1uZXcgU2UoYS50YWcsYixhLmtleSxhLm1vZGUpLGQudHlwZT1hLnR5cGUsZC5zdGF0ZU5vZGU9YS5zdGF0ZU5vZGUsZC5hbHRlcm5hdGU9YSxhLmFsdGVybmF0ZT1kKTooZC5wZW5kaW5nUHJvcHM9YixkLmVmZmVjdFRhZz0wLGQubmV4dEVmZmVjdD1udWxsLGQuZmlyc3RFZmZlY3Q9bnVsbCxkLmxhc3RFZmZlY3Q9bnVsbCk7ZC5jaGlsZEV4cGlyYXRpb25UaW1lPWEuY2hpbGRFeHBpcmF0aW9uVGltZTtkLmV4cGlyYXRpb25UaW1lPWIhPT1hLnBlbmRpbmdQcm9wcz9jOmEuZXhwaXJhdGlvblRpbWU7ZC5jaGlsZD1hLmNoaWxkO2QubWVtb2l6ZWRQcm9wcz1hLm1lbW9pemVkUHJvcHM7ZC5tZW1vaXplZFN0YXRlPWEubWVtb2l6ZWRTdGF0ZTtkLnVwZGF0ZVF1ZXVlPWEudXBkYXRlUXVldWU7ZC5maXJzdENvbnRleHREZXBlbmRlbmN5PWEuZmlyc3RDb250ZXh0RGVwZW5kZW5jeTtkLnNpYmxpbmc9YS5zaWJsaW5nO1xuZC5pbmRleD1hLmluZGV4O2QucmVmPWEucmVmO3JldHVybiBkfVxuZnVuY3Rpb24gVmUoYSxiLGMpe3ZhciBkPWEudHlwZSxlPWEua2V5O2E9YS5wcm9wczt2YXIgZj12b2lkIDA7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGQpZj1UZShkKT8yOjQ7ZWxzZSBpZihcInN0cmluZ1wiPT09dHlwZW9mIGQpZj03O2Vsc2UgYTpzd2l0Y2goZCl7Y2FzZSBiYzpyZXR1cm4gV2UoYS5jaGlsZHJlbixiLGMsZSk7Y2FzZSBnYzpmPTEwO2J8PTM7YnJlYWs7Y2FzZSBjYzpmPTEwO2J8PTI7YnJlYWs7Y2FzZSBkYzpyZXR1cm4gZD1uZXcgU2UoMTUsYSxlLGJ8NCksZC50eXBlPWRjLGQuZXhwaXJhdGlvblRpbWU9YyxkO2Nhc2UgaWM6Zj0xNjticmVhaztkZWZhdWx0OmlmKFwib2JqZWN0XCI9PT10eXBlb2YgZCYmbnVsbCE9PWQpc3dpdGNoKGQuJCR0eXBlb2Ype2Nhc2UgZWM6Zj0xMjticmVhayBhO2Nhc2UgZmM6Zj0xMTticmVhayBhO2Nhc2UgaGM6Zj0xMzticmVhayBhO2RlZmF1bHQ6aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGQudGhlbil7Zj00O2JyZWFrIGF9fXQoXCIxMzBcIixcbm51bGw9PWQ/ZDp0eXBlb2YgZCxcIlwiKX1iPW5ldyBTZShmLGEsZSxiKTtiLnR5cGU9ZDtiLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGJ9ZnVuY3Rpb24gV2UoYSxiLGMsZCl7YT1uZXcgU2UoOSxhLGQsYik7YS5leHBpcmF0aW9uVGltZT1jO3JldHVybiBhfWZ1bmN0aW9uIFhlKGEsYixjKXthPW5ldyBTZSg4LGEsbnVsbCxiKTthLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGF9ZnVuY3Rpb24gWWUoYSxiLGMpe2I9bmV3IFNlKDYsbnVsbCE9PWEuY2hpbGRyZW4/YS5jaGlsZHJlbjpbXSxhLmtleSxiKTtiLmV4cGlyYXRpb25UaW1lPWM7Yi5zdGF0ZU5vZGU9e2NvbnRhaW5lckluZm86YS5jb250YWluZXJJbmZvLHBlbmRpbmdDaGlsZHJlbjpudWxsLGltcGxlbWVudGF0aW9uOmEuaW1wbGVtZW50YXRpb259O3JldHVybiBifVxuZnVuY3Rpb24gWmUoYSxiKXthLmRpZEVycm9yPSExO3ZhciBjPWEuZWFybGllc3RQZW5kaW5nVGltZTswPT09Yz9hLmVhcmxpZXN0UGVuZGluZ1RpbWU9YS5sYXRlc3RQZW5kaW5nVGltZT1iOmM+Yj9hLmVhcmxpZXN0UGVuZGluZ1RpbWU9YjphLmxhdGVzdFBlbmRpbmdUaW1lPGImJihhLmxhdGVzdFBlbmRpbmdUaW1lPWIpOyRlKGIsYSl9ZnVuY3Rpb24gJGUoYSxiKXt2YXIgYz1iLmVhcmxpZXN0U3VzcGVuZGVkVGltZSxkPWIubGF0ZXN0U3VzcGVuZGVkVGltZSxlPWIuZWFybGllc3RQZW5kaW5nVGltZSxmPWIubGF0ZXN0UGluZ2VkVGltZTtlPTAhPT1lP2U6ZjswPT09ZSYmKDA9PT1hfHxkPmEpJiYoZT1kKTthPWU7MCE9PWEmJjAhPT1jJiZjPGEmJihhPWMpO2IubmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT249ZTtiLmV4cGlyYXRpb25UaW1lPWF9dmFyIGFmPSExO1xuZnVuY3Rpb24gYmYoYSl7cmV0dXJue2Jhc2VTdGF0ZTphLGZpcnN0VXBkYXRlOm51bGwsbGFzdFVwZGF0ZTpudWxsLGZpcnN0Q2FwdHVyZWRVcGRhdGU6bnVsbCxsYXN0Q2FwdHVyZWRVcGRhdGU6bnVsbCxmaXJzdEVmZmVjdDpudWxsLGxhc3RFZmZlY3Q6bnVsbCxmaXJzdENhcHR1cmVkRWZmZWN0Om51bGwsbGFzdENhcHR1cmVkRWZmZWN0Om51bGx9fWZ1bmN0aW9uIGNmKGEpe3JldHVybntiYXNlU3RhdGU6YS5iYXNlU3RhdGUsZmlyc3RVcGRhdGU6YS5maXJzdFVwZGF0ZSxsYXN0VXBkYXRlOmEubGFzdFVwZGF0ZSxmaXJzdENhcHR1cmVkVXBkYXRlOm51bGwsbGFzdENhcHR1cmVkVXBkYXRlOm51bGwsZmlyc3RFZmZlY3Q6bnVsbCxsYXN0RWZmZWN0Om51bGwsZmlyc3RDYXB0dXJlZEVmZmVjdDpudWxsLGxhc3RDYXB0dXJlZEVmZmVjdDpudWxsfX1cbmZ1bmN0aW9uIGRmKGEpe3JldHVybntleHBpcmF0aW9uVGltZTphLHRhZzowLHBheWxvYWQ6bnVsbCxjYWxsYmFjazpudWxsLG5leHQ6bnVsbCxuZXh0RWZmZWN0Om51bGx9fWZ1bmN0aW9uIGVmKGEsYil7bnVsbD09PWEubGFzdFVwZGF0ZT9hLmZpcnN0VXBkYXRlPWEubGFzdFVwZGF0ZT1iOihhLmxhc3RVcGRhdGUubmV4dD1iLGEubGFzdFVwZGF0ZT1iKX1cbmZ1bmN0aW9uIGZmKGEsYil7dmFyIGM9YS5hbHRlcm5hdGU7aWYobnVsbD09PWMpe3ZhciBkPWEudXBkYXRlUXVldWU7dmFyIGU9bnVsbDtudWxsPT09ZCYmKGQ9YS51cGRhdGVRdWV1ZT1iZihhLm1lbW9pemVkU3RhdGUpKX1lbHNlIGQ9YS51cGRhdGVRdWV1ZSxlPWMudXBkYXRlUXVldWUsbnVsbD09PWQ/bnVsbD09PWU/KGQ9YS51cGRhdGVRdWV1ZT1iZihhLm1lbW9pemVkU3RhdGUpLGU9Yy51cGRhdGVRdWV1ZT1iZihjLm1lbW9pemVkU3RhdGUpKTpkPWEudXBkYXRlUXVldWU9Y2YoZSk6bnVsbD09PWUmJihlPWMudXBkYXRlUXVldWU9Y2YoZCkpO251bGw9PT1lfHxkPT09ZT9lZihkLGIpOm51bGw9PT1kLmxhc3RVcGRhdGV8fG51bGw9PT1lLmxhc3RVcGRhdGU/KGVmKGQsYiksZWYoZSxiKSk6KGVmKGQsYiksZS5sYXN0VXBkYXRlPWIpfVxuZnVuY3Rpb24gZ2YoYSxiKXt2YXIgYz1hLnVwZGF0ZVF1ZXVlO2M9bnVsbD09PWM/YS51cGRhdGVRdWV1ZT1iZihhLm1lbW9pemVkU3RhdGUpOmhmKGEsYyk7bnVsbD09PWMubGFzdENhcHR1cmVkVXBkYXRlP2MuZmlyc3RDYXB0dXJlZFVwZGF0ZT1jLmxhc3RDYXB0dXJlZFVwZGF0ZT1iOihjLmxhc3RDYXB0dXJlZFVwZGF0ZS5uZXh0PWIsYy5sYXN0Q2FwdHVyZWRVcGRhdGU9Yil9ZnVuY3Rpb24gaGYoYSxiKXt2YXIgYz1hLmFsdGVybmF0ZTtudWxsIT09YyYmYj09PWMudXBkYXRlUXVldWUmJihiPWEudXBkYXRlUXVldWU9Y2YoYikpO3JldHVybiBifVxuZnVuY3Rpb24gamYoYSxiLGMsZCxlLGYpe3N3aXRjaChjLnRhZyl7Y2FzZSAxOnJldHVybiBhPWMucGF5bG9hZCxcImZ1bmN0aW9uXCI9PT10eXBlb2YgYT9hLmNhbGwoZixkLGUpOmE7Y2FzZSAzOmEuZWZmZWN0VGFnPWEuZWZmZWN0VGFnJi0xMDI1fDY0O2Nhc2UgMDphPWMucGF5bG9hZDtlPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2EuY2FsbChmLGQsZSk6YTtpZihudWxsPT09ZXx8dm9pZCAwPT09ZSlicmVhaztyZXR1cm4gbih7fSxkLGUpO2Nhc2UgMjphZj0hMH1yZXR1cm4gZH1cbmZ1bmN0aW9uIGtmKGEsYixjLGQsZSl7YWY9ITE7Yj1oZihhLGIpO2Zvcih2YXIgZj1iLmJhc2VTdGF0ZSxnPW51bGwsaD0wLGs9Yi5maXJzdFVwZGF0ZSxsPWY7bnVsbCE9PWs7KXt2YXIgbT1rLmV4cGlyYXRpb25UaW1lO2lmKG0+ZSl7aWYobnVsbD09PWcmJihnPWssZj1sKSwwPT09aHx8aD5tKWg9bX1lbHNlIGw9amYoYSxiLGssbCxjLGQpLG51bGwhPT1rLmNhbGxiYWNrJiYoYS5lZmZlY3RUYWd8PTMyLGsubmV4dEVmZmVjdD1udWxsLG51bGw9PT1iLmxhc3RFZmZlY3Q/Yi5maXJzdEVmZmVjdD1iLmxhc3RFZmZlY3Q9azooYi5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9ayxiLmxhc3RFZmZlY3Q9aykpO2s9ay5uZXh0fW09bnVsbDtmb3Ioaz1iLmZpcnN0Q2FwdHVyZWRVcGRhdGU7bnVsbCE9PWs7KXt2YXIgcj1rLmV4cGlyYXRpb25UaW1lO2lmKHI+ZSl7aWYobnVsbD09PW0mJihtPWssbnVsbD09PWcmJihmPWwpKSwwPT09aHx8aD5yKWg9cn1lbHNlIGw9amYoYSxiLGssbCxjLGQpLFxubnVsbCE9PWsuY2FsbGJhY2smJihhLmVmZmVjdFRhZ3w9MzIsay5uZXh0RWZmZWN0PW51bGwsbnVsbD09PWIubGFzdENhcHR1cmVkRWZmZWN0P2IuZmlyc3RDYXB0dXJlZEVmZmVjdD1iLmxhc3RDYXB0dXJlZEVmZmVjdD1rOihiLmxhc3RDYXB0dXJlZEVmZmVjdC5uZXh0RWZmZWN0PWssYi5sYXN0Q2FwdHVyZWRFZmZlY3Q9aykpO2s9ay5uZXh0fW51bGw9PT1nJiYoYi5sYXN0VXBkYXRlPW51bGwpO251bGw9PT1tP2IubGFzdENhcHR1cmVkVXBkYXRlPW51bGw6YS5lZmZlY3RUYWd8PTMyO251bGw9PT1nJiZudWxsPT09bSYmKGY9bCk7Yi5iYXNlU3RhdGU9ZjtiLmZpcnN0VXBkYXRlPWc7Yi5maXJzdENhcHR1cmVkVXBkYXRlPW07YS5leHBpcmF0aW9uVGltZT1oO2EubWVtb2l6ZWRTdGF0ZT1sfVxuZnVuY3Rpb24gbGYoYSxiLGMpe251bGwhPT1iLmZpcnN0Q2FwdHVyZWRVcGRhdGUmJihudWxsIT09Yi5sYXN0VXBkYXRlJiYoYi5sYXN0VXBkYXRlLm5leHQ9Yi5maXJzdENhcHR1cmVkVXBkYXRlLGIubGFzdFVwZGF0ZT1iLmxhc3RDYXB0dXJlZFVwZGF0ZSksYi5maXJzdENhcHR1cmVkVXBkYXRlPWIubGFzdENhcHR1cmVkVXBkYXRlPW51bGwpO21mKGIuZmlyc3RFZmZlY3QsYyk7Yi5maXJzdEVmZmVjdD1iLmxhc3RFZmZlY3Q9bnVsbDttZihiLmZpcnN0Q2FwdHVyZWRFZmZlY3QsYyk7Yi5maXJzdENhcHR1cmVkRWZmZWN0PWIubGFzdENhcHR1cmVkRWZmZWN0PW51bGx9ZnVuY3Rpb24gbWYoYSxiKXtmb3IoO251bGwhPT1hOyl7dmFyIGM9YS5jYWxsYmFjaztpZihudWxsIT09Yyl7YS5jYWxsYmFjaz1udWxsO3ZhciBkPWI7XCJmdW5jdGlvblwiIT09dHlwZW9mIGM/dChcIjE5MVwiLGMpOnZvaWQgMDtjLmNhbGwoZCl9YT1hLm5leHRFZmZlY3R9fVxuZnVuY3Rpb24gbmYoYSxiKXtyZXR1cm57dmFsdWU6YSxzb3VyY2U6YixzdGFjazptYyhiKX19dmFyIG9mPXtjdXJyZW50Om51bGx9LHBmPW51bGwscWY9bnVsbCxyZj1udWxsO2Z1bmN0aW9uIHNmKGEsYil7dmFyIGM9YS50eXBlLl9jb250ZXh0O0gob2YsYy5fY3VycmVudFZhbHVlLGEpO2MuX2N1cnJlbnRWYWx1ZT1ifWZ1bmN0aW9uIHRmKGEpe3ZhciBiPW9mLmN1cnJlbnQ7RyhvZixhKTthLnR5cGUuX2NvbnRleHQuX2N1cnJlbnRWYWx1ZT1ifWZ1bmN0aW9uIHVmKGEpe3BmPWE7cmY9cWY9bnVsbDthLmZpcnN0Q29udGV4dERlcGVuZGVuY3k9bnVsbH1cbmZ1bmN0aW9uIHZmKGEsYil7aWYocmYhPT1hJiYhMSE9PWImJjAhPT1iKXtpZihcIm51bWJlclwiIT09dHlwZW9mIGJ8fDEwNzM3NDE4MjM9PT1iKXJmPWEsYj0xMDczNzQxODIzO2I9e2NvbnRleHQ6YSxvYnNlcnZlZEJpdHM6YixuZXh0Om51bGx9O251bGw9PT1xZj8obnVsbD09PXBmP3QoXCIyNzdcIik6dm9pZCAwLHBmLmZpcnN0Q29udGV4dERlcGVuZGVuY3k9cWY9Yik6cWY9cWYubmV4dD1ifXJldHVybiBhLl9jdXJyZW50VmFsdWV9dmFyIHdmPXt9LEw9e2N1cnJlbnQ6d2Z9LHhmPXtjdXJyZW50OndmfSx5Zj17Y3VycmVudDp3Zn07ZnVuY3Rpb24gemYoYSl7YT09PXdmP3QoXCIxNzRcIik6dm9pZCAwO3JldHVybiBhfVxuZnVuY3Rpb24gQWYoYSxiKXtIKHlmLGIsYSk7SCh4ZixhLGEpO0goTCx3ZixhKTt2YXIgYz1iLm5vZGVUeXBlO3N3aXRjaChjKXtjYXNlIDk6Y2FzZSAxMTpiPShiPWIuZG9jdW1lbnRFbGVtZW50KT9iLm5hbWVzcGFjZVVSSTpsZShudWxsLFwiXCIpO2JyZWFrO2RlZmF1bHQ6Yz04PT09Yz9iLnBhcmVudE5vZGU6YixiPWMubmFtZXNwYWNlVVJJfHxudWxsLGM9Yy50YWdOYW1lLGI9bGUoYixjKX1HKEwsYSk7SChMLGIsYSl9ZnVuY3Rpb24gQmYoYSl7RyhMLGEpO0coeGYsYSk7Ryh5ZixhKX1mdW5jdGlvbiBDZihhKXt6Zih5Zi5jdXJyZW50KTt2YXIgYj16ZihMLmN1cnJlbnQpO3ZhciBjPWxlKGIsYS50eXBlKTtiIT09YyYmKEgoeGYsYSxhKSxIKEwsYyxhKSl9ZnVuY3Rpb24gRGYoYSl7eGYuY3VycmVudD09PWEmJihHKEwsYSksRyh4ZixhKSl9dmFyIEVmPShuZXcgYWEuQ29tcG9uZW50KS5yZWZzO1xuZnVuY3Rpb24gRmYoYSxiLGMsZCl7Yj1hLm1lbW9pemVkU3RhdGU7Yz1jKGQsYik7Yz1udWxsPT09Y3x8dm9pZCAwPT09Yz9iOm4oe30sYixjKTthLm1lbW9pemVkU3RhdGU9YztkPWEudXBkYXRlUXVldWU7bnVsbCE9PWQmJjA9PT1hLmV4cGlyYXRpb25UaW1lJiYoZC5iYXNlU3RhdGU9Yyl9XG52YXIgSmY9e2lzTW91bnRlZDpmdW5jdGlvbihhKXtyZXR1cm4oYT1hLl9yZWFjdEludGVybmFsRmliZXIpPzI9PT1qZChhKTohMX0sZW5xdWV1ZVNldFN0YXRlOmZ1bmN0aW9uKGEsYixjKXthPWEuX3JlYWN0SW50ZXJuYWxGaWJlcjt2YXIgZD1HZigpO2Q9SGYoZCxhKTt2YXIgZT1kZihkKTtlLnBheWxvYWQ9Yjt2b2lkIDAhPT1jJiZudWxsIT09YyYmKGUuY2FsbGJhY2s9Yyk7ZmYoYSxlKTtJZihhLGQpfSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKGEsYixjKXthPWEuX3JlYWN0SW50ZXJuYWxGaWJlcjt2YXIgZD1HZigpO2Q9SGYoZCxhKTt2YXIgZT1kZihkKTtlLnRhZz0xO2UucGF5bG9hZD1iO3ZvaWQgMCE9PWMmJm51bGwhPT1jJiYoZS5jYWxsYmFjaz1jKTtmZihhLGUpO0lmKGEsZCl9LGVucXVldWVGb3JjZVVwZGF0ZTpmdW5jdGlvbihhLGIpe2E9YS5fcmVhY3RJbnRlcm5hbEZpYmVyO3ZhciBjPUdmKCk7Yz1IZihjLGEpO3ZhciBkPWRmKGMpO2QudGFnPTI7dm9pZCAwIT09XG5iJiZudWxsIT09YiYmKGQuY2FsbGJhY2s9Yik7ZmYoYSxkKTtJZihhLGMpfX07ZnVuY3Rpb24gS2YoYSxiLGMsZCxlLGYsZyl7YT1hLnN0YXRlTm9kZTtyZXR1cm5cImZ1bmN0aW9uXCI9PT10eXBlb2YgYS5zaG91bGRDb21wb25lbnRVcGRhdGU/YS5zaG91bGRDb21wb25lbnRVcGRhdGUoZCxmLGcpOmIucHJvdG90eXBlJiZiLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudD8haWQoYyxkKXx8IWlkKGUsZik6ITB9ZnVuY3Rpb24gTGYoYSxiLGMsZCl7YT1iLnN0YXRlO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBiLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJmIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhjLGQpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBiLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZiLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKGMsZCk7Yi5zdGF0ZSE9PWEmJkpmLmVucXVldWVSZXBsYWNlU3RhdGUoYixiLnN0YXRlLG51bGwpfVxuZnVuY3Rpb24gTWYoYSxiLGMsZCl7dmFyIGU9YS5zdGF0ZU5vZGUsZj1LKGIpP0dlOkkuY3VycmVudDtlLnByb3BzPWM7ZS5zdGF0ZT1hLm1lbW9pemVkU3RhdGU7ZS5yZWZzPUVmO2UuY29udGV4dD1IZShhLGYpO2Y9YS51cGRhdGVRdWV1ZTtudWxsIT09ZiYmKGtmKGEsZixjLGUsZCksZS5zdGF0ZT1hLm1lbW9pemVkU3RhdGUpO2Y9Yi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XCJmdW5jdGlvblwiPT09dHlwZW9mIGYmJihGZihhLGIsZixjKSxlLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZSk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGIuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzfHxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8XCJmdW5jdGlvblwiIT09dHlwZW9mIGUuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGUuY29tcG9uZW50V2lsbE1vdW50fHwoYj1lLnN0YXRlLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBlLmNvbXBvbmVudFdpbGxNb3VudCYmXG5lLmNvbXBvbmVudFdpbGxNb3VudCgpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQmJmUuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpLGIhPT1lLnN0YXRlJiZKZi5lbnF1ZXVlUmVwbGFjZVN0YXRlKGUsZS5zdGF0ZSxudWxsKSxmPWEudXBkYXRlUXVldWUsbnVsbCE9PWYmJihrZihhLGYsYyxlLGQpLGUuc3RhdGU9YS5tZW1vaXplZFN0YXRlKSk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGUuY29tcG9uZW50RGlkTW91bnQmJihhLmVmZmVjdFRhZ3w9NCl9dmFyIE5mPUFycmF5LmlzQXJyYXk7XG5mdW5jdGlvbiBPZihhLGIsYyl7YT1jLnJlZjtpZihudWxsIT09YSYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGEmJlwib2JqZWN0XCIhPT10eXBlb2YgYSl7aWYoYy5fb3duZXIpe2M9Yy5fb3duZXI7dmFyIGQ9dm9pZCAwO2MmJigyIT09Yy50YWcmJjMhPT1jLnRhZz90KFwiMTEwXCIpOnZvaWQgMCxkPWMuc3RhdGVOb2RlKTtkP3ZvaWQgMDp0KFwiMTQ3XCIsYSk7dmFyIGU9XCJcIithO2lmKG51bGwhPT1iJiZudWxsIT09Yi5yZWYmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBiLnJlZiYmYi5yZWYuX3N0cmluZ1JlZj09PWUpcmV0dXJuIGIucmVmO2I9ZnVuY3Rpb24oYSl7dmFyIGI9ZC5yZWZzO2I9PT1FZiYmKGI9ZC5yZWZzPXt9KTtudWxsPT09YT9kZWxldGUgYltlXTpiW2VdPWF9O2IuX3N0cmluZ1JlZj1lO3JldHVybiBifVwic3RyaW5nXCIhPT10eXBlb2YgYT90KFwiMjg0XCIpOnZvaWQgMDtjLl9vd25lcj92b2lkIDA6dChcIjI1NFwiLGEpfXJldHVybiBhfVxuZnVuY3Rpb24gUGYoYSxiKXtcInRleHRhcmVhXCIhPT1hLnR5cGUmJnQoXCIzMVwiLFwiW29iamVjdCBPYmplY3RdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYik/XCJvYmplY3Qgd2l0aCBrZXlzIHtcIitPYmplY3Qua2V5cyhiKS5qb2luKFwiLCBcIikrXCJ9XCI6YixcIlwiKX1cbmZ1bmN0aW9uIFFmKGEpe2Z1bmN0aW9uIGIoYixjKXtpZihhKXt2YXIgZD1iLmxhc3RFZmZlY3Q7bnVsbCE9PWQ/KGQubmV4dEVmZmVjdD1jLGIubGFzdEVmZmVjdD1jKTpiLmZpcnN0RWZmZWN0PWIubGFzdEVmZmVjdD1jO2MubmV4dEVmZmVjdD1udWxsO2MuZWZmZWN0VGFnPTh9fWZ1bmN0aW9uIGMoYyxkKXtpZighYSlyZXR1cm4gbnVsbDtmb3IoO251bGwhPT1kOyliKGMsZCksZD1kLnNpYmxpbmc7cmV0dXJuIG51bGx9ZnVuY3Rpb24gZChhLGIpe2ZvcihhPW5ldyBNYXA7bnVsbCE9PWI7KW51bGwhPT1iLmtleT9hLnNldChiLmtleSxiKTphLnNldChiLmluZGV4LGIpLGI9Yi5zaWJsaW5nO3JldHVybiBhfWZ1bmN0aW9uIGUoYSxiLGMpe2E9VWUoYSxiLGMpO2EuaW5kZXg9MDthLnNpYmxpbmc9bnVsbDtyZXR1cm4gYX1mdW5jdGlvbiBmKGIsYyxkKXtiLmluZGV4PWQ7aWYoIWEpcmV0dXJuIGM7ZD1iLmFsdGVybmF0ZTtpZihudWxsIT09ZClyZXR1cm4gZD1kLmluZGV4LGQ8Yz8oYi5lZmZlY3RUYWc9XG4yLGMpOmQ7Yi5lZmZlY3RUYWc9MjtyZXR1cm4gY31mdW5jdGlvbiBnKGIpe2EmJm51bGw9PT1iLmFsdGVybmF0ZSYmKGIuZWZmZWN0VGFnPTIpO3JldHVybiBifWZ1bmN0aW9uIGgoYSxiLGMsZCl7aWYobnVsbD09PWJ8fDghPT1iLnRhZylyZXR1cm4gYj1YZShjLGEubW9kZSxkKSxiLnJldHVybj1hLGI7Yj1lKGIsYyxkKTtiLnJldHVybj1hO3JldHVybiBifWZ1bmN0aW9uIGsoYSxiLGMsZCl7aWYobnVsbCE9PWImJmIudHlwZT09PWMudHlwZSlyZXR1cm4gZD1lKGIsYy5wcm9wcyxkKSxkLnJlZj1PZihhLGIsYyksZC5yZXR1cm49YSxkO2Q9VmUoYyxhLm1vZGUsZCk7ZC5yZWY9T2YoYSxiLGMpO2QucmV0dXJuPWE7cmV0dXJuIGR9ZnVuY3Rpb24gbChhLGIsYyxkKXtpZihudWxsPT09Ynx8NiE9PWIudGFnfHxiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvIT09Yy5jb250YWluZXJJbmZvfHxiLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiE9PWMuaW1wbGVtZW50YXRpb24pcmV0dXJuIGI9XG5ZZShjLGEubW9kZSxkKSxiLnJldHVybj1hLGI7Yj1lKGIsYy5jaGlsZHJlbnx8W10sZCk7Yi5yZXR1cm49YTtyZXR1cm4gYn1mdW5jdGlvbiBtKGEsYixjLGQsZil7aWYobnVsbD09PWJ8fDkhPT1iLnRhZylyZXR1cm4gYj1XZShjLGEubW9kZSxkLGYpLGIucmV0dXJuPWEsYjtiPWUoYixjLGQpO2IucmV0dXJuPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gcihhLGIsYyl7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBifHxcIm51bWJlclwiPT09dHlwZW9mIGIpcmV0dXJuIGI9WGUoXCJcIitiLGEubW9kZSxjKSxiLnJldHVybj1hLGI7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBiJiZudWxsIT09Yil7c3dpdGNoKGIuJCR0eXBlb2Ype2Nhc2UgJGI6cmV0dXJuIGM9VmUoYixhLm1vZGUsYyksYy5yZWY9T2YoYSxudWxsLGIpLGMucmV0dXJuPWEsYztjYXNlIGFjOnJldHVybiBiPVllKGIsYS5tb2RlLGMpLGIucmV0dXJuPWEsYn1pZihOZihiKXx8a2MoYikpcmV0dXJuIGI9V2UoYixhLm1vZGUsYyxudWxsKSxiLnJldHVybj1cbmEsYjtQZihhLGIpfXJldHVybiBudWxsfWZ1bmN0aW9uIEEoYSxiLGMsZCl7dmFyIGU9bnVsbCE9PWI/Yi5rZXk6bnVsbDtpZihcInN0cmluZ1wiPT09dHlwZW9mIGN8fFwibnVtYmVyXCI9PT10eXBlb2YgYylyZXR1cm4gbnVsbCE9PWU/bnVsbDpoKGEsYixcIlwiK2MsZCk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBjJiZudWxsIT09Yyl7c3dpdGNoKGMuJCR0eXBlb2Ype2Nhc2UgJGI6cmV0dXJuIGMua2V5PT09ZT9jLnR5cGU9PT1iYz9tKGEsYixjLnByb3BzLmNoaWxkcmVuLGQsZSk6ayhhLGIsYyxkKTpudWxsO2Nhc2UgYWM6cmV0dXJuIGMua2V5PT09ZT9sKGEsYixjLGQpOm51bGx9aWYoTmYoYyl8fGtjKGMpKXJldHVybiBudWxsIT09ZT9udWxsOm0oYSxiLGMsZCxudWxsKTtQZihhLGMpfXJldHVybiBudWxsfWZ1bmN0aW9uIFMoYSxiLGMsZCxlKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIGR8fFwibnVtYmVyXCI9PT10eXBlb2YgZClyZXR1cm4gYT1hLmdldChjKXx8bnVsbCxoKGIsYSxcIlwiK2QsZSk7XG5pZihcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kKXtzd2l0Y2goZC4kJHR5cGVvZil7Y2FzZSAkYjpyZXR1cm4gYT1hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwsZC50eXBlPT09YmM/bShiLGEsZC5wcm9wcy5jaGlsZHJlbixlLGQua2V5KTprKGIsYSxkLGUpO2Nhc2UgYWM6cmV0dXJuIGE9YS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLGwoYixhLGQsZSl9aWYoTmYoZCl8fGtjKGQpKXJldHVybiBhPWEuZ2V0KGMpfHxudWxsLG0oYixhLGQsZSxudWxsKTtQZihiLGQpfXJldHVybiBudWxsfWZ1bmN0aW9uIEIoZSxnLGgsayl7Zm9yKHZhciBsPW51bGwsbT1udWxsLHA9Zyx1PWc9MCxxPW51bGw7bnVsbCE9PXAmJnU8aC5sZW5ndGg7dSsrKXtwLmluZGV4PnU/KHE9cCxwPW51bGwpOnE9cC5zaWJsaW5nO3ZhciB2PUEoZSxwLGhbdV0sayk7aWYobnVsbD09PXYpe251bGw9PT1wJiYocD1xKTticmVha31hJiZwJiZudWxsPT09di5hbHRlcm5hdGUmJmIoZSxcbnApO2c9Zih2LGcsdSk7bnVsbD09PW0/bD12Om0uc2libGluZz12O209djtwPXF9aWYodT09PWgubGVuZ3RoKXJldHVybiBjKGUscCksbDtpZihudWxsPT09cCl7Zm9yKDt1PGgubGVuZ3RoO3UrKylpZihwPXIoZSxoW3VdLGspKWc9ZihwLGcsdSksbnVsbD09PW0/bD1wOm0uc2libGluZz1wLG09cDtyZXR1cm4gbH1mb3IocD1kKGUscCk7dTxoLmxlbmd0aDt1KyspaWYocT1TKHAsZSx1LGhbdV0saykpYSYmbnVsbCE9PXEuYWx0ZXJuYXRlJiZwLmRlbGV0ZShudWxsPT09cS5rZXk/dTpxLmtleSksZz1mKHEsZyx1KSxudWxsPT09bT9sPXE6bS5zaWJsaW5nPXEsbT1xO2EmJnAuZm9yRWFjaChmdW5jdGlvbihhKXtyZXR1cm4gYihlLGEpfSk7cmV0dXJuIGx9ZnVuY3Rpb24gUChlLGcsaCxrKXt2YXIgbD1rYyhoKTtcImZ1bmN0aW9uXCIhPT10eXBlb2YgbD90KFwiMTUwXCIpOnZvaWQgMDtoPWwuY2FsbChoKTtudWxsPT1oP3QoXCIxNTFcIik6dm9pZCAwO2Zvcih2YXIgbT1sPW51bGwscD1nLHU9Zz1cbjAscT1udWxsLHY9aC5uZXh0KCk7bnVsbCE9PXAmJiF2LmRvbmU7dSsrLHY9aC5uZXh0KCkpe3AuaW5kZXg+dT8ocT1wLHA9bnVsbCk6cT1wLnNpYmxpbmc7dmFyIHg9QShlLHAsdi52YWx1ZSxrKTtpZihudWxsPT09eCl7cHx8KHA9cSk7YnJlYWt9YSYmcCYmbnVsbD09PXguYWx0ZXJuYXRlJiZiKGUscCk7Zz1mKHgsZyx1KTtudWxsPT09bT9sPXg6bS5zaWJsaW5nPXg7bT14O3A9cX1pZih2LmRvbmUpcmV0dXJuIGMoZSxwKSxsO2lmKG51bGw9PT1wKXtmb3IoOyF2LmRvbmU7dSsrLHY9aC5uZXh0KCkpdj1yKGUsdi52YWx1ZSxrKSxudWxsIT09diYmKGc9Zih2LGcsdSksbnVsbD09PW0/bD12Om0uc2libGluZz12LG09dik7cmV0dXJuIGx9Zm9yKHA9ZChlLHApOyF2LmRvbmU7dSsrLHY9aC5uZXh0KCkpdj1TKHAsZSx1LHYudmFsdWUsayksbnVsbCE9PXYmJihhJiZudWxsIT09di5hbHRlcm5hdGUmJnAuZGVsZXRlKG51bGw9PT12LmtleT91OnYua2V5KSxnPWYodixnLHUpLG51bGw9PT1cbm0/bD12Om0uc2libGluZz12LG09dik7YSYmcC5mb3JFYWNoKGZ1bmN0aW9uKGEpe3JldHVybiBiKGUsYSl9KTtyZXR1cm4gbH1yZXR1cm4gZnVuY3Rpb24oYSxkLGYsaCl7dmFyIGs9XCJvYmplY3RcIj09PXR5cGVvZiBmJiZudWxsIT09ZiYmZi50eXBlPT09YmMmJm51bGw9PT1mLmtleTtrJiYoZj1mLnByb3BzLmNoaWxkcmVuKTt2YXIgbD1cIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mO2lmKGwpc3dpdGNoKGYuJCR0eXBlb2Ype2Nhc2UgJGI6YTp7bD1mLmtleTtmb3Ioaz1kO251bGwhPT1rOyl7aWYoay5rZXk9PT1sKWlmKDk9PT1rLnRhZz9mLnR5cGU9PT1iYzprLnR5cGU9PT1mLnR5cGUpe2MoYSxrLnNpYmxpbmcpO2Q9ZShrLGYudHlwZT09PWJjP2YucHJvcHMuY2hpbGRyZW46Zi5wcm9wcyxoKTtkLnJlZj1PZihhLGssZik7ZC5yZXR1cm49YTthPWQ7YnJlYWsgYX1lbHNle2MoYSxrKTticmVha31lbHNlIGIoYSxrKTtrPWsuc2libGluZ31mLnR5cGU9PT1iYz8oZD1XZShmLnByb3BzLmNoaWxkcmVuLFxuYS5tb2RlLGgsZi5rZXkpLGQucmV0dXJuPWEsYT1kKTooaD1WZShmLGEubW9kZSxoKSxoLnJlZj1PZihhLGQsZiksaC5yZXR1cm49YSxhPWgpfXJldHVybiBnKGEpO2Nhc2UgYWM6YTp7Zm9yKGs9Zi5rZXk7bnVsbCE9PWQ7KXtpZihkLmtleT09PWspaWYoNj09PWQudGFnJiZkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvPT09Zi5jb250YWluZXJJbmZvJiZkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbj09PWYuaW1wbGVtZW50YXRpb24pe2MoYSxkLnNpYmxpbmcpO2Q9ZShkLGYuY2hpbGRyZW58fFtdLGgpO2QucmV0dXJuPWE7YT1kO2JyZWFrIGF9ZWxzZXtjKGEsZCk7YnJlYWt9ZWxzZSBiKGEsZCk7ZD1kLnNpYmxpbmd9ZD1ZZShmLGEubW9kZSxoKTtkLnJldHVybj1hO2E9ZH1yZXR1cm4gZyhhKX1pZihcInN0cmluZ1wiPT09dHlwZW9mIGZ8fFwibnVtYmVyXCI9PT10eXBlb2YgZilyZXR1cm4gZj1cIlwiK2YsbnVsbCE9PWQmJjg9PT1kLnRhZz8oYyhhLGQuc2libGluZyksZD1lKGQsZixoKSxkLnJldHVybj1cbmEsYT1kKTooYyhhLGQpLGQ9WGUoZixhLm1vZGUsaCksZC5yZXR1cm49YSxhPWQpLGcoYSk7aWYoTmYoZikpcmV0dXJuIEIoYSxkLGYsaCk7aWYoa2MoZikpcmV0dXJuIFAoYSxkLGYsaCk7bCYmUGYoYSxmKTtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIGYmJiFrKXN3aXRjaChhLnRhZyl7Y2FzZSAyOmNhc2UgMzpjYXNlIDA6aD1hLnR5cGUsdChcIjE1MlwiLGguZGlzcGxheU5hbWV8fGgubmFtZXx8XCJDb21wb25lbnRcIil9cmV0dXJuIGMoYSxkKX19dmFyIFJmPVFmKCEwKSxTZj1RZighMSksVGY9bnVsbCxVZj1udWxsLFZmPSExO2Z1bmN0aW9uIFdmKGEsYil7dmFyIGM9bmV3IFNlKDcsbnVsbCxudWxsLDApO2MudHlwZT1cIkRFTEVURURcIjtjLnN0YXRlTm9kZT1iO2MucmV0dXJuPWE7Yy5lZmZlY3RUYWc9ODtudWxsIT09YS5sYXN0RWZmZWN0PyhhLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1jLGEubGFzdEVmZmVjdD1jKTphLmZpcnN0RWZmZWN0PWEubGFzdEVmZmVjdD1jfVxuZnVuY3Rpb24gWGYoYSxiKXtzd2l0Y2goYS50YWcpe2Nhc2UgNzp2YXIgYz1hLnR5cGU7Yj0xIT09Yi5ub2RlVHlwZXx8Yy50b0xvd2VyQ2FzZSgpIT09Yi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpP251bGw6YjtyZXR1cm4gbnVsbCE9PWI/KGEuc3RhdGVOb2RlPWIsITApOiExO2Nhc2UgODpyZXR1cm4gYj1cIlwiPT09YS5wZW5kaW5nUHJvcHN8fDMhPT1iLm5vZGVUeXBlP251bGw6YixudWxsIT09Yj8oYS5zdGF0ZU5vZGU9YiwhMCk6ITE7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gWWYoYSl7aWYoVmYpe3ZhciBiPVVmO2lmKGIpe3ZhciBjPWI7aWYoIVhmKGEsYikpe2I9QmUoYyk7aWYoIWJ8fCFYZihhLGIpKXthLmVmZmVjdFRhZ3w9MjtWZj0hMTtUZj1hO3JldHVybn1XZihUZixjKX1UZj1hO1VmPUNlKGIpfWVsc2UgYS5lZmZlY3RUYWd8PTIsVmY9ITEsVGY9YX19XG5mdW5jdGlvbiBaZihhKXtmb3IoYT1hLnJldHVybjtudWxsIT09YSYmNyE9PWEudGFnJiY1IT09YS50YWc7KWE9YS5yZXR1cm47VGY9YX1mdW5jdGlvbiAkZihhKXtpZihhIT09VGYpcmV0dXJuITE7aWYoIVZmKXJldHVybiBaZihhKSxWZj0hMCwhMTt2YXIgYj1hLnR5cGU7aWYoNyE9PWEudGFnfHxcImhlYWRcIiE9PWImJlwiYm9keVwiIT09YiYmIUFlKGIsYS5tZW1vaXplZFByb3BzKSlmb3IoYj1VZjtiOylXZihhLGIpLGI9QmUoYik7WmYoYSk7VWY9VGY/QmUoYS5zdGF0ZU5vZGUpOm51bGw7cmV0dXJuITB9ZnVuY3Rpb24gYWcoKXtVZj1UZj1udWxsO1ZmPSExfVxuZnVuY3Rpb24gYmcoYSl7c3dpdGNoKGEuX3JlYWN0U3RhdHVzKXtjYXNlIDE6cmV0dXJuIGEuX3JlYWN0UmVzdWx0O2Nhc2UgMjp0aHJvdyBhLl9yZWFjdFJlc3VsdDtjYXNlIDA6dGhyb3cgYTtkZWZhdWx0OnRocm93IGEuX3JlYWN0U3RhdHVzPTAsYS50aGVuKGZ1bmN0aW9uKGIpe2lmKDA9PT1hLl9yZWFjdFN0YXR1cyl7YS5fcmVhY3RTdGF0dXM9MTtpZihcIm9iamVjdFwiPT09dHlwZW9mIGImJm51bGwhPT1iKXt2YXIgYz1iLmRlZmF1bHQ7Yj12b2lkIDAhPT1jJiZudWxsIT09Yz9jOmJ9YS5fcmVhY3RSZXN1bHQ9Yn19LGZ1bmN0aW9uKGIpezA9PT1hLl9yZWFjdFN0YXR1cyYmKGEuX3JlYWN0U3RhdHVzPTIsYS5fcmVhY3RSZXN1bHQ9Yil9KSxhO319dmFyIGNnPVliLlJlYWN0Q3VycmVudE93bmVyO2Z1bmN0aW9uIE0oYSxiLGMsZCl7Yi5jaGlsZD1udWxsPT09YT9TZihiLG51bGwsYyxkKTpSZihiLGEuY2hpbGQsYyxkKX1cbmZ1bmN0aW9uIGRnKGEsYixjLGQsZSl7Yz1jLnJlbmRlcjt2YXIgZj1iLnJlZjtpZighSi5jdXJyZW50JiZiLm1lbW9pemVkUHJvcHM9PT1kJiZmPT09KG51bGwhPT1hP2EucmVmOm51bGwpKXJldHVybiBlZyhhLGIsZSk7Yz1jKGQsZik7TShhLGIsYyxlKTtiLm1lbW9pemVkUHJvcHM9ZDtyZXR1cm4gYi5jaGlsZH1mdW5jdGlvbiBmZyhhLGIpe3ZhciBjPWIucmVmO2lmKG51bGw9PT1hJiZudWxsIT09Y3x8bnVsbCE9PWEmJmEucmVmIT09YyliLmVmZmVjdFRhZ3w9MTI4fWZ1bmN0aW9uIGdnKGEsYixjLGQsZSl7dmFyIGY9SyhjKT9HZTpJLmN1cnJlbnQ7Zj1IZShiLGYpO3VmKGIsZSk7Yz1jKGQsZik7Yi5lZmZlY3RUYWd8PTE7TShhLGIsYyxlKTtiLm1lbW9pemVkUHJvcHM9ZDtyZXR1cm4gYi5jaGlsZH1cbmZ1bmN0aW9uIGhnKGEsYixjLGQsZSl7aWYoSyhjKSl7dmFyIGY9ITA7TWUoYil9ZWxzZSBmPSExO3VmKGIsZSk7aWYobnVsbD09PWEpaWYobnVsbD09PWIuc3RhdGVOb2RlKXt2YXIgZz1LKGMpP0dlOkkuY3VycmVudCxoPWMuY29udGV4dFR5cGVzLGs9bnVsbCE9PWgmJnZvaWQgMCE9PWg7aD1rP0hlKGIsZyk6RmU7dmFyIGw9bmV3IGMoZCxoKTtiLm1lbW9pemVkU3RhdGU9bnVsbCE9PWwuc3RhdGUmJnZvaWQgMCE9PWwuc3RhdGU/bC5zdGF0ZTpudWxsO2wudXBkYXRlcj1KZjtiLnN0YXRlTm9kZT1sO2wuX3JlYWN0SW50ZXJuYWxGaWJlcj1iO2smJihrPWIuc3RhdGVOb2RlLGsuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD1nLGsuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ9aCk7TWYoYixjLGQsZSk7ZD0hMH1lbHNle2c9Yi5zdGF0ZU5vZGU7aD1iLm1lbW9pemVkUHJvcHM7Zy5wcm9wcz1oO3ZhciBtPWcuY29udGV4dDtcbms9SyhjKT9HZTpJLmN1cnJlbnQ7az1IZShiLGspO3ZhciByPWMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOyhsPVwiZnVuY3Rpb25cIj09PXR5cGVvZiByfHxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSl8fFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzfHwoaCE9PWR8fG0hPT1rKSYmTGYoYixnLGQsayk7YWY9ITE7dmFyIEE9Yi5tZW1vaXplZFN0YXRlO209Zy5zdGF0ZT1BO3ZhciBTPWIudXBkYXRlUXVldWU7bnVsbCE9PVMmJihrZihiLFMsZCxnLGUpLG09Yi5tZW1vaXplZFN0YXRlKTtoIT09ZHx8QSE9PW18fEouY3VycmVudHx8YWY/KFwiZnVuY3Rpb25cIj09PXR5cGVvZiByJiYoRmYoYixjLHIsZCksbT1iLm1lbW9pemVkU3RhdGUpLChoPWFmfHxLZihiLGMsaCxkLEEsbSxrKSk/KGx8fFwiZnVuY3Rpb25cIiE9PVxudHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50V2lsbE1vdW50fHwoXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50V2lsbE1vdW50JiZnLmNvbXBvbmVudFdpbGxNb3VudCgpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQmJmcuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRNb3VudCYmKGIuZWZmZWN0VGFnfD00KSk6KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudERpZE1vdW50JiYoYi5lZmZlY3RUYWd8PTQpLGIubWVtb2l6ZWRQcm9wcz1kLGIubWVtb2l6ZWRTdGF0ZT1tKSxnLnByb3BzPWQsZy5zdGF0ZT1tLGcuY29udGV4dD1rLGQ9aCk6KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudERpZE1vdW50JiYoYi5lZmZlY3RUYWd8PTQpLGQ9ITEpfWVsc2UgZz1iLnN0YXRlTm9kZSxoPVxuYi5tZW1vaXplZFByb3BzLGcucHJvcHM9aCxtPWcuY29udGV4dCxrPUsoYyk/R2U6SS5jdXJyZW50LGs9SGUoYixrKSxyPWMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLChsPVwiZnVuY3Rpb25cIj09PXR5cGVvZiByfHxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSl8fFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzfHwoaCE9PWR8fG0hPT1rKSYmTGYoYixnLGQsayksYWY9ITEsbT1iLm1lbW9pemVkU3RhdGUsQT1nLnN0YXRlPW0sUz1iLnVwZGF0ZVF1ZXVlLG51bGwhPT1TJiYoa2YoYixTLGQsZyxlKSxBPWIubWVtb2l6ZWRTdGF0ZSksaCE9PWR8fG0hPT1BfHxKLmN1cnJlbnR8fGFmPyhcImZ1bmN0aW9uXCI9PT10eXBlb2YgciYmKEZmKGIsYyxyLGQpLEE9Yi5tZW1vaXplZFN0YXRlKSwocj1hZnx8S2YoYixjLGgsZCxcbm0sQSxrKSk/KGx8fFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnRXaWxsVXBkYXRlfHwoXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50V2lsbFVwZGF0ZSYmZy5jb21wb25lbnRXaWxsVXBkYXRlKGQsQSxrKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSYmZy5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZShkLEEsaykpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudERpZFVwZGF0ZSYmKGIuZWZmZWN0VGFnfD00KSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSYmKGIuZWZmZWN0VGFnfD0yNTYpKTooXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlfHxoPT09YS5tZW1vaXplZFByb3BzJiZtPT09YS5tZW1vaXplZFN0YXRlfHwoYi5lZmZlY3RUYWd8PTQpLFwiZnVuY3Rpb25cIiE9PVxudHlwZW9mIGcuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGV8fGg9PT1hLm1lbW9pemVkUHJvcHMmJm09PT1hLm1lbW9pemVkU3RhdGV8fChiLmVmZmVjdFRhZ3w9MjU2KSxiLm1lbW9pemVkUHJvcHM9ZCxiLm1lbW9pemVkU3RhdGU9QSksZy5wcm9wcz1kLGcuc3RhdGU9QSxnLmNvbnRleHQ9ayxkPXIpOihcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fGg9PT1hLm1lbW9pemVkUHJvcHMmJm09PT1hLm1lbW9pemVkU3RhdGV8fChiLmVmZmVjdFRhZ3w9NCksXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGV8fGg9PT1hLm1lbW9pemVkUHJvcHMmJm09PT1hLm1lbW9pemVkU3RhdGV8fChiLmVmZmVjdFRhZ3w9MjU2KSxkPSExKTtyZXR1cm4gaWcoYSxiLGMsZCxmLGUpfVxuZnVuY3Rpb24gaWcoYSxiLGMsZCxlLGYpe2ZnKGEsYik7dmFyIGc9MCE9PShiLmVmZmVjdFRhZyY2NCk7aWYoIWQmJiFnKXJldHVybiBlJiZOZShiLGMsITEpLGVnKGEsYixmKTtkPWIuc3RhdGVOb2RlO2NnLmN1cnJlbnQ9Yjt2YXIgaD1nP251bGw6ZC5yZW5kZXIoKTtiLmVmZmVjdFRhZ3w9MTtudWxsIT09YSYmZyYmKE0oYSxiLG51bGwsZiksYi5jaGlsZD1udWxsKTtNKGEsYixoLGYpO2IubWVtb2l6ZWRTdGF0ZT1kLnN0YXRlO2IubWVtb2l6ZWRQcm9wcz1kLnByb3BzO2UmJk5lKGIsYywhMCk7cmV0dXJuIGIuY2hpbGR9ZnVuY3Rpb24gamcoYSl7dmFyIGI9YS5zdGF0ZU5vZGU7Yi5wZW5kaW5nQ29udGV4dD9LZShhLGIucGVuZGluZ0NvbnRleHQsYi5wZW5kaW5nQ29udGV4dCE9PWIuY29udGV4dCk6Yi5jb250ZXh0JiZLZShhLGIuY29udGV4dCwhMSk7QWYoYSxiLmNvbnRhaW5lckluZm8pfVxuZnVuY3Rpb24gbmcoYSxiKXtpZihhJiZhLmRlZmF1bHRQcm9wcyl7Yj1uKHt9LGIpO2E9YS5kZWZhdWx0UHJvcHM7Zm9yKHZhciBjIGluIGEpdm9pZCAwPT09YltjXSYmKGJbY109YVtjXSl9cmV0dXJuIGJ9XG5mdW5jdGlvbiBvZyhhLGIsYyxkKXtudWxsIT09YT90KFwiMTU1XCIpOnZvaWQgMDt2YXIgZT1iLnBlbmRpbmdQcm9wcztpZihcIm9iamVjdFwiPT09dHlwZW9mIGMmJm51bGwhPT1jJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy50aGVuKXtjPWJnKGMpO3ZhciBmPWM7Zj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgZj9UZShmKT8zOjE6dm9pZCAwIT09ZiYmbnVsbCE9PWYmJmYuJCR0eXBlb2Y/MTQ6NDtmPWIudGFnPWY7dmFyIGc9bmcoYyxlKTtzd2l0Y2goZil7Y2FzZSAxOnJldHVybiBnZyhhLGIsYyxnLGQpO2Nhc2UgMzpyZXR1cm4gaGcoYSxiLGMsZyxkKTtjYXNlIDE0OnJldHVybiBkZyhhLGIsYyxnLGQpO2RlZmF1bHQ6dChcIjI4M1wiLGMpfX1mPUhlKGIsSS5jdXJyZW50KTt1ZihiLGQpO2Y9YyhlLGYpO2IuZWZmZWN0VGFnfD0xO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWYmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBmLnJlbmRlciYmdm9pZCAwPT09Zi4kJHR5cGVvZil7Yi50YWc9MjtLKGMpP1xuKGc9ITAsTWUoYikpOmc9ITE7Yi5tZW1vaXplZFN0YXRlPW51bGwhPT1mLnN0YXRlJiZ2b2lkIDAhPT1mLnN0YXRlP2Yuc3RhdGU6bnVsbDt2YXIgaD1jLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcImZ1bmN0aW9uXCI9PT10eXBlb2YgaCYmRmYoYixjLGgsZSk7Zi51cGRhdGVyPUpmO2Iuc3RhdGVOb2RlPWY7Zi5fcmVhY3RJbnRlcm5hbEZpYmVyPWI7TWYoYixjLGUsZCk7cmV0dXJuIGlnKGEsYixjLCEwLGcsZCl9Yi50YWc9MDtNKGEsYixmLGQpO2IubWVtb2l6ZWRQcm9wcz1lO3JldHVybiBiLmNoaWxkfVxuZnVuY3Rpb24gZWcoYSxiLGMpe251bGwhPT1hJiYoYi5maXJzdENvbnRleHREZXBlbmRlbmN5PWEuZmlyc3RDb250ZXh0RGVwZW5kZW5jeSk7dmFyIGQ9Yi5jaGlsZEV4cGlyYXRpb25UaW1lO2lmKDA9PT1kfHxkPmMpcmV0dXJuIG51bGw7bnVsbCE9PWEmJmIuY2hpbGQhPT1hLmNoaWxkP3QoXCIxNTNcIik6dm9pZCAwO2lmKG51bGwhPT1iLmNoaWxkKXthPWIuY2hpbGQ7Yz1VZShhLGEucGVuZGluZ1Byb3BzLGEuZXhwaXJhdGlvblRpbWUpO2IuY2hpbGQ9Yztmb3IoYy5yZXR1cm49YjtudWxsIT09YS5zaWJsaW5nOylhPWEuc2libGluZyxjPWMuc2libGluZz1VZShhLGEucGVuZGluZ1Byb3BzLGEuZXhwaXJhdGlvblRpbWUpLGMucmV0dXJuPWI7Yy5zaWJsaW5nPW51bGx9cmV0dXJuIGIuY2hpbGR9XG5mdW5jdGlvbiBwZyhhLGIsYyl7dmFyIGQ9Yi5leHBpcmF0aW9uVGltZTtpZighSi5jdXJyZW50JiYoMD09PWR8fGQ+Yykpe3N3aXRjaChiLnRhZyl7Y2FzZSA1OmpnKGIpO2FnKCk7YnJlYWs7Y2FzZSA3OkNmKGIpO2JyZWFrO2Nhc2UgMjpLKGIudHlwZSkmJk1lKGIpO2JyZWFrO2Nhc2UgMzpLKGIudHlwZS5fcmVhY3RSZXN1bHQpJiZNZShiKTticmVhaztjYXNlIDY6QWYoYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTticmVhaztjYXNlIDEyOnNmKGIsYi5tZW1vaXplZFByb3BzLnZhbHVlKX1yZXR1cm4gZWcoYSxiLGMpfWIuZXhwaXJhdGlvblRpbWU9MDtzd2l0Y2goYi50YWcpe2Nhc2UgNDpyZXR1cm4gb2coYSxiLGIudHlwZSxjKTtjYXNlIDA6cmV0dXJuIGdnKGEsYixiLnR5cGUsYi5wZW5kaW5nUHJvcHMsYyk7Y2FzZSAxOnZhciBlPWIudHlwZS5fcmVhY3RSZXN1bHQ7ZD1iLnBlbmRpbmdQcm9wczthPWdnKGEsYixlLG5nKGUsZCksYyk7Yi5tZW1vaXplZFByb3BzPWQ7cmV0dXJuIGE7XG5jYXNlIDI6cmV0dXJuIGhnKGEsYixiLnR5cGUsYi5wZW5kaW5nUHJvcHMsYyk7Y2FzZSAzOnJldHVybiBlPWIudHlwZS5fcmVhY3RSZXN1bHQsZD1iLnBlbmRpbmdQcm9wcyxhPWhnKGEsYixlLG5nKGUsZCksYyksYi5tZW1vaXplZFByb3BzPWQsYTtjYXNlIDU6amcoYik7ZD1iLnVwZGF0ZVF1ZXVlO251bGw9PT1kP3QoXCIyODJcIik6dm9pZCAwO2U9Yi5tZW1vaXplZFN0YXRlO2U9bnVsbCE9PWU/ZS5lbGVtZW50Om51bGw7a2YoYixkLGIucGVuZGluZ1Byb3BzLG51bGwsYyk7ZD1iLm1lbW9pemVkU3RhdGUuZWxlbWVudDtpZihkPT09ZSlhZygpLGI9ZWcoYSxiLGMpO2Vsc2V7ZT1iLnN0YXRlTm9kZTtpZihlPShudWxsPT09YXx8bnVsbD09PWEuY2hpbGQpJiZlLmh5ZHJhdGUpVWY9Q2UoYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyksVGY9YixlPVZmPSEwO2U/KGIuZWZmZWN0VGFnfD0yLGIuY2hpbGQ9U2YoYixudWxsLGQsYykpOihNKGEsYixkLGMpLGFnKCkpO2I9Yi5jaGlsZH1yZXR1cm4gYjtcbmNhc2UgNzpDZihiKTtudWxsPT09YSYmWWYoYik7ZD1iLnR5cGU7ZT1iLnBlbmRpbmdQcm9wczt2YXIgZj1udWxsIT09YT9hLm1lbW9pemVkUHJvcHM6bnVsbCxnPWUuY2hpbGRyZW47QWUoZCxlKT9nPW51bGw6bnVsbCE9PWYmJkFlKGQsZikmJihiLmVmZmVjdFRhZ3w9MTYpO2ZnKGEsYik7MTA3Mzc0MTgyMyE9PWMmJmIubW9kZSYxJiZlLmhpZGRlbj8oYi5leHBpcmF0aW9uVGltZT0xMDczNzQxODIzLGIubWVtb2l6ZWRQcm9wcz1lLGI9bnVsbCk6KE0oYSxiLGcsYyksYi5tZW1vaXplZFByb3BzPWUsYj1iLmNoaWxkKTtyZXR1cm4gYjtjYXNlIDg6cmV0dXJuIG51bGw9PT1hJiZZZihiKSxiLm1lbW9pemVkUHJvcHM9Yi5wZW5kaW5nUHJvcHMsbnVsbDtjYXNlIDE2OnJldHVybiBudWxsO2Nhc2UgNjpyZXR1cm4gQWYoYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxkPWIucGVuZGluZ1Byb3BzLG51bGw9PT1hP2IuY2hpbGQ9UmYoYixudWxsLGQsYyk6TShhLGIsZCxjKSxiLm1lbW9pemVkUHJvcHM9XG5kLGIuY2hpbGQ7Y2FzZSAxMzpyZXR1cm4gZGcoYSxiLGIudHlwZSxiLnBlbmRpbmdQcm9wcyxjKTtjYXNlIDE0OnJldHVybiBlPWIudHlwZS5fcmVhY3RSZXN1bHQsZD1iLnBlbmRpbmdQcm9wcyxhPWRnKGEsYixlLG5nKGUsZCksYyksYi5tZW1vaXplZFByb3BzPWQsYTtjYXNlIDk6cmV0dXJuIGQ9Yi5wZW5kaW5nUHJvcHMsTShhLGIsZCxjKSxiLm1lbW9pemVkUHJvcHM9ZCxiLmNoaWxkO2Nhc2UgMTA6cmV0dXJuIGQ9Yi5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sTShhLGIsZCxjKSxiLm1lbW9pemVkUHJvcHM9ZCxiLmNoaWxkO2Nhc2UgMTU6cmV0dXJuIGQ9Yi5wZW5kaW5nUHJvcHMsTShhLGIsZC5jaGlsZHJlbixjKSxiLm1lbW9pemVkUHJvcHM9ZCxiLmNoaWxkO2Nhc2UgMTI6YTp7ZD1iLnR5cGUuX2NvbnRleHQ7ZT1iLnBlbmRpbmdQcm9wcztnPWIubWVtb2l6ZWRQcm9wcztmPWUudmFsdWU7Yi5tZW1vaXplZFByb3BzPWU7c2YoYixmKTtpZihudWxsIT09Zyl7dmFyIGg9Zy52YWx1ZTtcbmY9aD09PWYmJigwIT09aHx8MS9oPT09MS9mKXx8aCE9PWgmJmYhPT1mPzA6KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLl9jYWxjdWxhdGVDaGFuZ2VkQml0cz9kLl9jYWxjdWxhdGVDaGFuZ2VkQml0cyhoLGYpOjEwNzM3NDE4MjMpfDA7aWYoMD09PWYpe2lmKGcuY2hpbGRyZW49PT1lLmNoaWxkcmVuJiYhSi5jdXJyZW50KXtiPWVnKGEsYixjKTticmVhayBhfX1lbHNlIGZvcihnPWIuY2hpbGQsbnVsbCE9PWcmJihnLnJldHVybj1iKTtudWxsIT09Zzspe2g9Zy5maXJzdENvbnRleHREZXBlbmRlbmN5O2lmKG51bGwhPT1oKXtkb3tpZihoLmNvbnRleHQ9PT1kJiYwIT09KGgub2JzZXJ2ZWRCaXRzJmYpKXtpZigyPT09Zy50YWd8fDM9PT1nLnRhZyl7dmFyIGs9ZGYoYyk7ay50YWc9MjtmZihnLGspfWlmKDA9PT1nLmV4cGlyYXRpb25UaW1lfHxnLmV4cGlyYXRpb25UaW1lPmMpZy5leHBpcmF0aW9uVGltZT1jO2s9Zy5hbHRlcm5hdGU7bnVsbCE9PWsmJigwPT09ay5leHBpcmF0aW9uVGltZXx8XG5rLmV4cGlyYXRpb25UaW1lPmMpJiYoay5leHBpcmF0aW9uVGltZT1jKTtmb3IodmFyIGw9Zy5yZXR1cm47bnVsbCE9PWw7KXtrPWwuYWx0ZXJuYXRlO2lmKDA9PT1sLmNoaWxkRXhwaXJhdGlvblRpbWV8fGwuY2hpbGRFeHBpcmF0aW9uVGltZT5jKWwuY2hpbGRFeHBpcmF0aW9uVGltZT1jLG51bGwhPT1rJiYoMD09PWsuY2hpbGRFeHBpcmF0aW9uVGltZXx8ay5jaGlsZEV4cGlyYXRpb25UaW1lPmMpJiYoay5jaGlsZEV4cGlyYXRpb25UaW1lPWMpO2Vsc2UgaWYobnVsbCE9PWsmJigwPT09ay5jaGlsZEV4cGlyYXRpb25UaW1lfHxrLmNoaWxkRXhwaXJhdGlvblRpbWU+Yykpay5jaGlsZEV4cGlyYXRpb25UaW1lPWM7ZWxzZSBicmVhaztsPWwucmV0dXJufX1rPWcuY2hpbGQ7aD1oLm5leHR9d2hpbGUobnVsbCE9PWgpfWVsc2Ugaz0xMj09PWcudGFnP2cudHlwZT09PWIudHlwZT9udWxsOmcuY2hpbGQ6Zy5jaGlsZDtpZihudWxsIT09aylrLnJldHVybj1nO2Vsc2UgZm9yKGs9ZztudWxsIT09XG5rOyl7aWYoaz09PWIpe2s9bnVsbDticmVha31nPWsuc2libGluZztpZihudWxsIT09Zyl7Zy5yZXR1cm49ay5yZXR1cm47az1nO2JyZWFrfWs9ay5yZXR1cm59Zz1rfX1NKGEsYixlLmNoaWxkcmVuLGMpO2I9Yi5jaGlsZH1yZXR1cm4gYjtjYXNlIDExOnJldHVybiBmPWIudHlwZSxkPWIucGVuZGluZ1Byb3BzLGU9ZC5jaGlsZHJlbix1ZihiLGMpLGY9dmYoZixkLnVuc3RhYmxlX29ic2VydmVkQml0cyksZT1lKGYpLGIuZWZmZWN0VGFnfD0xLE0oYSxiLGUsYyksYi5tZW1vaXplZFByb3BzPWQsYi5jaGlsZDtkZWZhdWx0OnQoXCIxNTZcIil9fWZ1bmN0aW9uIHFnKGEpe2EuZWZmZWN0VGFnfD00fXZhciByZz12b2lkIDAsc2c9dm9pZCAwLHRnPXZvaWQgMDtyZz1mdW5jdGlvbigpe307XG5zZz1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPWEubWVtb2l6ZWRQcm9wcztpZihmIT09ZCl7dmFyIGc9Yi5zdGF0ZU5vZGU7emYoTC5jdXJyZW50KTthPW51bGw7c3dpdGNoKGMpe2Nhc2UgXCJpbnB1dFwiOmY9emMoZyxmKTtkPXpjKGcsZCk7YT1bXTticmVhaztjYXNlIFwib3B0aW9uXCI6Zj1kZShnLGYpO2Q9ZGUoZyxkKTthPVtdO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpmPW4oe30sZix7dmFsdWU6dm9pZCAwfSk7ZD1uKHt9LGQse3ZhbHVlOnZvaWQgMH0pO2E9W107YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6Zj1mZShnLGYpO2Q9ZmUoZyxkKTthPVtdO2JyZWFrO2RlZmF1bHQ6XCJmdW5jdGlvblwiIT09dHlwZW9mIGYub25DbGljayYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGQub25DbGljayYmKGcub25jbGljaz13ZSl9dGUoYyxkKTtnPWM9dm9pZCAwO3ZhciBoPW51bGw7Zm9yKGMgaW4gZilpZighZC5oYXNPd25Qcm9wZXJ0eShjKSYmZi5oYXNPd25Qcm9wZXJ0eShjKSYmbnVsbCE9ZltjXSlpZihcInN0eWxlXCI9PT1cbmMpe3ZhciBrPWZbY107Zm9yKGcgaW4gaylrLmhhc093blByb3BlcnR5KGcpJiYoaHx8KGg9e30pLGhbZ109XCJcIil9ZWxzZVwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIiE9PWMmJlwiY2hpbGRyZW5cIiE9PWMmJlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1jJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09YyYmXCJhdXRvRm9jdXNcIiE9PWMmJihzYS5oYXNPd25Qcm9wZXJ0eShjKT9hfHwoYT1bXSk6KGE9YXx8W10pLnB1c2goYyxudWxsKSk7Zm9yKGMgaW4gZCl7dmFyIGw9ZFtjXTtrPW51bGwhPWY/ZltjXTp2b2lkIDA7aWYoZC5oYXNPd25Qcm9wZXJ0eShjKSYmbCE9PWsmJihudWxsIT1sfHxudWxsIT1rKSlpZihcInN0eWxlXCI9PT1jKWlmKGspe2ZvcihnIGluIGspIWsuaGFzT3duUHJvcGVydHkoZyl8fGwmJmwuaGFzT3duUHJvcGVydHkoZyl8fChofHwoaD17fSksaFtnXT1cIlwiKTtmb3IoZyBpbiBsKWwuaGFzT3duUHJvcGVydHkoZykmJmtbZ10hPT1sW2ddJiYoaHx8XG4oaD17fSksaFtnXT1sW2ddKX1lbHNlIGh8fChhfHwoYT1bXSksYS5wdXNoKGMsaCkpLGg9bDtlbHNlXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiPT09Yz8obD1sP2wuX19odG1sOnZvaWQgMCxrPWs/ay5fX2h0bWw6dm9pZCAwLG51bGwhPWwmJmshPT1sJiYoYT1hfHxbXSkucHVzaChjLFwiXCIrbCkpOlwiY2hpbGRyZW5cIj09PWM/az09PWx8fFwic3RyaW5nXCIhPT10eXBlb2YgbCYmXCJudW1iZXJcIiE9PXR5cGVvZiBsfHwoYT1hfHxbXSkucHVzaChjLFwiXCIrbCk6XCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIiE9PWMmJlwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCIhPT1jJiYoc2EuaGFzT3duUHJvcGVydHkoYyk/KG51bGwhPWwmJnZlKGUsYyksYXx8az09PWx8fChhPVtdKSk6KGE9YXx8W10pLnB1c2goYyxsKSl9aCYmKGE9YXx8W10pLnB1c2goXCJzdHlsZVwiLGgpO2U9YTsoYi51cGRhdGVRdWV1ZT1lKSYmcWcoYil9fTt0Zz1mdW5jdGlvbihhLGIsYyxkKXtjIT09ZCYmcWcoYil9O1xuZnVuY3Rpb24gdWcoYSxiKXt2YXIgYz1iLnNvdXJjZSxkPWIuc3RhY2s7bnVsbD09PWQmJm51bGwhPT1jJiYoZD1tYyhjKSk7bnVsbCE9PWMmJmxjKGMudHlwZSk7Yj1iLnZhbHVlO251bGwhPT1hJiYyPT09YS50YWcmJmxjKGEudHlwZSk7dHJ5e2NvbnNvbGUuZXJyb3IoYil9Y2F0Y2goZSl7c2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGU7fSl9fWZ1bmN0aW9uIHZnKGEpe3ZhciBiPWEucmVmO2lmKG51bGwhPT1iKWlmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiKXRyeXtiKG51bGwpfWNhdGNoKGMpe3dnKGEsYyl9ZWxzZSBiLmN1cnJlbnQ9bnVsbH1cbmZ1bmN0aW9uIHhnKGEpe1wiZnVuY3Rpb25cIj09PXR5cGVvZiBQZSYmUGUoYSk7c3dpdGNoKGEudGFnKXtjYXNlIDI6Y2FzZSAzOnZnKGEpO3ZhciBiPWEuc3RhdGVOb2RlO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiLmNvbXBvbmVudFdpbGxVbm1vdW50KXRyeXtiLnByb3BzPWEubWVtb2l6ZWRQcm9wcyxiLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZSxiLmNvbXBvbmVudFdpbGxVbm1vdW50KCl9Y2F0Y2goYyl7d2coYSxjKX1icmVhaztjYXNlIDc6dmcoYSk7YnJlYWs7Y2FzZSA2OnlnKGEpfX1mdW5jdGlvbiB6ZyhhKXtyZXR1cm4gNz09PWEudGFnfHw1PT09YS50YWd8fDY9PT1hLnRhZ31cbmZ1bmN0aW9uIEFnKGEpe2E6e2Zvcih2YXIgYj1hLnJldHVybjtudWxsIT09Yjspe2lmKHpnKGIpKXt2YXIgYz1iO2JyZWFrIGF9Yj1iLnJldHVybn10KFwiMTYwXCIpO2M9dm9pZCAwfXZhciBkPWI9dm9pZCAwO3N3aXRjaChjLnRhZyl7Y2FzZSA3OmI9Yy5zdGF0ZU5vZGU7ZD0hMTticmVhaztjYXNlIDU6Yj1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2Q9ITA7YnJlYWs7Y2FzZSA2OmI9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2RlZmF1bHQ6dChcIjE2MVwiKX1jLmVmZmVjdFRhZyYxNiYmKG9lKGIsXCJcIiksYy5lZmZlY3RUYWcmPS0xNyk7YTpiOmZvcihjPWE7Oyl7Zm9yKDtudWxsPT09Yy5zaWJsaW5nOyl7aWYobnVsbD09PWMucmV0dXJufHx6ZyhjLnJldHVybikpe2M9bnVsbDticmVhayBhfWM9Yy5yZXR1cm59Yy5zaWJsaW5nLnJldHVybj1jLnJldHVybjtmb3IoYz1jLnNpYmxpbmc7NyE9PWMudGFnJiY4IT09Yy50YWc7KXtpZihjLmVmZmVjdFRhZyYyKWNvbnRpbnVlIGI7XG5pZihudWxsPT09Yy5jaGlsZHx8Nj09PWMudGFnKWNvbnRpbnVlIGI7ZWxzZSBjLmNoaWxkLnJldHVybj1jLGM9Yy5jaGlsZH1pZighKGMuZWZmZWN0VGFnJjIpKXtjPWMuc3RhdGVOb2RlO2JyZWFrIGF9fWZvcih2YXIgZT1hOzspe2lmKDc9PT1lLnRhZ3x8OD09PWUudGFnKWlmKGMpaWYoZCl7dmFyIGY9YixnPWUuc3RhdGVOb2RlLGg9Yzs4PT09Zi5ub2RlVHlwZT9mLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGcsaCk6Zi5pbnNlcnRCZWZvcmUoZyxoKX1lbHNlIGIuaW5zZXJ0QmVmb3JlKGUuc3RhdGVOb2RlLGMpO2Vsc2UgZD8oZj1iLGc9ZS5zdGF0ZU5vZGUsOD09PWYubm9kZVR5cGU/KGg9Zi5wYXJlbnROb2RlLGguaW5zZXJ0QmVmb3JlKGcsZikpOihoPWYsaC5hcHBlbmRDaGlsZChnKSksbnVsbD09PWgub25jbGljayYmKGgub25jbGljaz13ZSkpOmIuYXBwZW5kQ2hpbGQoZS5zdGF0ZU5vZGUpO2Vsc2UgaWYoNiE9PWUudGFnJiZudWxsIT09ZS5jaGlsZCl7ZS5jaGlsZC5yZXR1cm49XG5lO2U9ZS5jaGlsZDtjb250aW51ZX1pZihlPT09YSlicmVhaztmb3IoO251bGw9PT1lLnNpYmxpbmc7KXtpZihudWxsPT09ZS5yZXR1cm58fGUucmV0dXJuPT09YSlyZXR1cm47ZT1lLnJldHVybn1lLnNpYmxpbmcucmV0dXJuPWUucmV0dXJuO2U9ZS5zaWJsaW5nfX1cbmZ1bmN0aW9uIHlnKGEpe2Zvcih2YXIgYj1hLGM9ITEsZD12b2lkIDAsZT12b2lkIDA7Oyl7aWYoIWMpe2M9Yi5yZXR1cm47YTpmb3IoOzspe251bGw9PT1jP3QoXCIxNjBcIik6dm9pZCAwO3N3aXRjaChjLnRhZyl7Y2FzZSA3OmQ9Yy5zdGF0ZU5vZGU7ZT0hMTticmVhayBhO2Nhc2UgNTpkPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87ZT0hMDticmVhayBhO2Nhc2UgNjpkPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87ZT0hMDticmVhayBhfWM9Yy5yZXR1cm59Yz0hMH1pZig3PT09Yi50YWd8fDg9PT1iLnRhZyl7YTpmb3IodmFyIGY9YixnPWY7OylpZih4ZyhnKSxudWxsIT09Zy5jaGlsZCYmNiE9PWcudGFnKWcuY2hpbGQucmV0dXJuPWcsZz1nLmNoaWxkO2Vsc2V7aWYoZz09PWYpYnJlYWs7Zm9yKDtudWxsPT09Zy5zaWJsaW5nOyl7aWYobnVsbD09PWcucmV0dXJufHxnLnJldHVybj09PWYpYnJlYWsgYTtnPWcucmV0dXJufWcuc2libGluZy5yZXR1cm49Zy5yZXR1cm47Zz1nLnNpYmxpbmd9ZT9cbihmPWQsZz1iLnN0YXRlTm9kZSw4PT09Zi5ub2RlVHlwZT9mLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZyk6Zi5yZW1vdmVDaGlsZChnKSk6ZC5yZW1vdmVDaGlsZChiLnN0YXRlTm9kZSl9ZWxzZSBpZig2PT09Yi50YWc/KGQ9Yi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyxlPSEwKTp4ZyhiKSxudWxsIT09Yi5jaGlsZCl7Yi5jaGlsZC5yZXR1cm49YjtiPWIuY2hpbGQ7Y29udGludWV9aWYoYj09PWEpYnJlYWs7Zm9yKDtudWxsPT09Yi5zaWJsaW5nOyl7aWYobnVsbD09PWIucmV0dXJufHxiLnJldHVybj09PWEpcmV0dXJuO2I9Yi5yZXR1cm47Nj09PWIudGFnJiYoYz0hMSl9Yi5zaWJsaW5nLnJldHVybj1iLnJldHVybjtiPWIuc2libGluZ319XG5mdW5jdGlvbiBCZyhhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAyOmNhc2UgMzpicmVhaztjYXNlIDc6dmFyIGM9Yi5zdGF0ZU5vZGU7aWYobnVsbCE9Yyl7dmFyIGQ9Yi5tZW1vaXplZFByb3BzLGU9bnVsbCE9PWE/YS5tZW1vaXplZFByb3BzOmQ7YT1iLnR5cGU7dmFyIGY9Yi51cGRhdGVRdWV1ZTtiLnVwZGF0ZVF1ZXVlPW51bGw7aWYobnVsbCE9PWYpe2NbSmFdPWQ7XCJpbnB1dFwiPT09YSYmXCJyYWRpb1wiPT09ZC50eXBlJiZudWxsIT1kLm5hbWUmJkNjKGMsZCk7dWUoYSxlKTtiPXVlKGEsZCk7Zm9yKGU9MDtlPGYubGVuZ3RoO2UrPTIpe3ZhciBnPWZbZV0saD1mW2UrMV07XCJzdHlsZVwiPT09Zz9yZShjLGgpOlwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWc/bmUoYyxoKTpcImNoaWxkcmVuXCI9PT1nP29lKGMsaCk6eGMoYyxnLGgsYil9c3dpdGNoKGEpe2Nhc2UgXCJpbnB1dFwiOkRjKGMsZCk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6aGUoYyxkKTticmVhaztjYXNlIFwic2VsZWN0XCI6YT1jLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUsXG5jLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU9ISFkLm11bHRpcGxlLGY9ZC52YWx1ZSxudWxsIT1mP2VlKGMsISFkLm11bHRpcGxlLGYsITEpOmEhPT0hIWQubXVsdGlwbGUmJihudWxsIT1kLmRlZmF1bHRWYWx1ZT9lZShjLCEhZC5tdWx0aXBsZSxkLmRlZmF1bHRWYWx1ZSwhMCk6ZWUoYywhIWQubXVsdGlwbGUsZC5tdWx0aXBsZT9bXTpcIlwiLCExKSl9fX1icmVhaztjYXNlIDg6bnVsbD09PWIuc3RhdGVOb2RlP3QoXCIxNjJcIik6dm9pZCAwO2Iuc3RhdGVOb2RlLm5vZGVWYWx1ZT1iLm1lbW9pemVkUHJvcHM7YnJlYWs7Y2FzZSA1OmJyZWFrO2Nhc2UgMTU6YnJlYWs7Y2FzZSAxNjpicmVhaztkZWZhdWx0OnQoXCIxNjNcIil9fWZ1bmN0aW9uIENnKGEsYixjKXtjPWRmKGMpO2MudGFnPTM7Yy5wYXlsb2FkPXtlbGVtZW50Om51bGx9O3ZhciBkPWIudmFsdWU7Yy5jYWxsYmFjaz1mdW5jdGlvbigpe0RnKGQpO3VnKGEsYil9O3JldHVybiBjfVxuZnVuY3Rpb24gRWcoYSxiLGMpe2M9ZGYoYyk7Yy50YWc9Mzt2YXIgZD1hLnN0YXRlTm9kZTtudWxsIT09ZCYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50RGlkQ2F0Y2gmJihjLmNhbGxiYWNrPWZ1bmN0aW9uKCl7bnVsbD09PUZnP0ZnPW5ldyBTZXQoW3RoaXNdKTpGZy5hZGQodGhpcyk7dmFyIGM9Yi52YWx1ZSxkPWIuc3RhY2s7dWcoYSxiKTt0aGlzLmNvbXBvbmVudERpZENhdGNoKGMse2NvbXBvbmVudFN0YWNrOm51bGwhPT1kP2Q6XCJcIn0pfSk7cmV0dXJuIGN9XG5mdW5jdGlvbiBHZyhhKXtzd2l0Y2goYS50YWcpe2Nhc2UgMjpLKGEudHlwZSkmJkllKGEpO3ZhciBiPWEuZWZmZWN0VGFnO3JldHVybiBiJjEwMjQ/KGEuZWZmZWN0VGFnPWImLTEwMjV8NjQsYSk6bnVsbDtjYXNlIDM6cmV0dXJuIEsoYS50eXBlLl9yZWFjdFJlc3VsdCkmJkllKGEpLGI9YS5lZmZlY3RUYWcsYiYxMDI0PyhhLmVmZmVjdFRhZz1iJi0xMDI1fDY0LGEpOm51bGw7Y2FzZSA1OnJldHVybiBCZihhKSxKZShhKSxiPWEuZWZmZWN0VGFnLDAhPT0oYiY2NCk/dChcIjI4NVwiKTp2b2lkIDAsYS5lZmZlY3RUYWc9YiYtMTAyNXw2NCxhO2Nhc2UgNzpyZXR1cm4gRGYoYSksbnVsbDtjYXNlIDE2OnJldHVybiBiPWEuZWZmZWN0VGFnLGImMTAyND8oYS5lZmZlY3RUYWc9YiYtMTAyNXw2NCxhKTpudWxsO2Nhc2UgNjpyZXR1cm4gQmYoYSksbnVsbDtjYXNlIDEyOnJldHVybiB0ZihhKSxudWxsO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxudmFyIEhnPXtyZWFkQ29udGV4dDp2Zn0sSWc9WWIuUmVhY3RDdXJyZW50T3duZXIsSmc9MCxLZz0wLExnPSExLE49bnVsbCxNZz1udWxsLE89MCxOZz0hMSxRPW51bGwsT2c9ITEsRmc9bnVsbDtmdW5jdGlvbiBQZygpe2lmKG51bGwhPT1OKWZvcih2YXIgYT1OLnJldHVybjtudWxsIT09YTspe3ZhciBiPWE7c3dpdGNoKGIudGFnKXtjYXNlIDI6dmFyIGM9Yi50eXBlLmNoaWxkQ29udGV4dFR5cGVzO251bGwhPT1jJiZ2b2lkIDAhPT1jJiZJZShiKTticmVhaztjYXNlIDM6Yz1iLnR5cGUuX3JlYWN0UmVzdWx0LmNoaWxkQ29udGV4dFR5cGVzO251bGwhPT1jJiZ2b2lkIDAhPT1jJiZJZShiKTticmVhaztjYXNlIDU6QmYoYik7SmUoYik7YnJlYWs7Y2FzZSA3OkRmKGIpO2JyZWFrO2Nhc2UgNjpCZihiKTticmVhaztjYXNlIDEyOnRmKGIpfWE9YS5yZXR1cm59TWc9bnVsbDtPPTA7Tmc9ITE7Tj1udWxsfVxuZnVuY3Rpb24gUWcoYSl7Zm9yKDs7KXt2YXIgYj1hLmFsdGVybmF0ZSxjPWEucmV0dXJuLGQ9YS5zaWJsaW5nO2lmKDA9PT0oYS5lZmZlY3RUYWcmNTEyKSl7dmFyIGU9YjtiPWE7dmFyIGY9Yi5wZW5kaW5nUHJvcHM7c3dpdGNoKGIudGFnKXtjYXNlIDA6Y2FzZSAxOmJyZWFrO2Nhc2UgMjpLKGIudHlwZSkmJkllKGIpO2JyZWFrO2Nhc2UgMzpLKGIudHlwZS5fcmVhY3RSZXN1bHQpJiZJZShiKTticmVhaztjYXNlIDU6QmYoYik7SmUoYik7Zj1iLnN0YXRlTm9kZTtmLnBlbmRpbmdDb250ZXh0JiYoZi5jb250ZXh0PWYucGVuZGluZ0NvbnRleHQsZi5wZW5kaW5nQ29udGV4dD1udWxsKTtpZihudWxsPT09ZXx8bnVsbD09PWUuY2hpbGQpJGYoYiksYi5lZmZlY3RUYWcmPS0zO3JnKGIpO2JyZWFrO2Nhc2UgNzpEZihiKTt2YXIgZz16Zih5Zi5jdXJyZW50KSxoPWIudHlwZTtpZihudWxsIT09ZSYmbnVsbCE9Yi5zdGF0ZU5vZGUpc2coZSxiLGgsZixnKSxlLnJlZiE9PWIucmVmJiYoYi5lZmZlY3RUYWd8PVxuMTI4KTtlbHNlIGlmKGYpe3ZhciBrPXpmKEwuY3VycmVudCk7aWYoJGYoYikpe2Y9YjtlPWYuc3RhdGVOb2RlO3ZhciBsPWYudHlwZSxtPWYubWVtb2l6ZWRQcm9wcyxyPWc7ZVtJYV09ZjtlW0phXT1tO2g9dm9pZCAwO2c9bDtzd2l0Y2goZyl7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpGKFwibG9hZFwiLGUpO2JyZWFrO2Nhc2UgXCJ2aWRlb1wiOmNhc2UgXCJhdWRpb1wiOmZvcihsPTA7bDxmYi5sZW5ndGg7bCsrKUYoZmJbbF0sZSk7YnJlYWs7Y2FzZSBcInNvdXJjZVwiOkYoXCJlcnJvclwiLGUpO2JyZWFrO2Nhc2UgXCJpbWdcIjpjYXNlIFwiaW1hZ2VcIjpjYXNlIFwibGlua1wiOkYoXCJlcnJvclwiLGUpO0YoXCJsb2FkXCIsZSk7YnJlYWs7Y2FzZSBcImZvcm1cIjpGKFwicmVzZXRcIixlKTtGKFwic3VibWl0XCIsZSk7YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpGKFwidG9nZ2xlXCIsZSk7YnJlYWs7Y2FzZSBcImlucHV0XCI6QmMoZSxtKTtGKFwiaW52YWxpZFwiLGUpO3ZlKHIsXCJvbkNoYW5nZVwiKTticmVhaztjYXNlIFwic2VsZWN0XCI6ZS5fd3JhcHBlclN0YXRlPVxue3dhc011bHRpcGxlOiEhbS5tdWx0aXBsZX07RihcImludmFsaWRcIixlKTt2ZShyLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6Z2UoZSxtKSxGKFwiaW52YWxpZFwiLGUpLHZlKHIsXCJvbkNoYW5nZVwiKX10ZShnLG0pO2w9bnVsbDtmb3IoaCBpbiBtKW0uaGFzT3duUHJvcGVydHkoaCkmJihrPW1baF0sXCJjaGlsZHJlblwiPT09aD9cInN0cmluZ1wiPT09dHlwZW9mIGs/ZS50ZXh0Q29udGVudCE9PWsmJihsPVtcImNoaWxkcmVuXCIsa10pOlwibnVtYmVyXCI9PT10eXBlb2YgayYmZS50ZXh0Q29udGVudCE9PVwiXCIrayYmKGw9W1wiY2hpbGRyZW5cIixcIlwiK2tdKTpzYS5oYXNPd25Qcm9wZXJ0eShoKSYmbnVsbCE9ayYmdmUocixoKSk7c3dpdGNoKGcpe2Nhc2UgXCJpbnB1dFwiOldiKGUpO0ZjKGUsbSwhMCk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6V2IoZSk7aWUoZSxtKTticmVhaztjYXNlIFwic2VsZWN0XCI6Y2FzZSBcIm9wdGlvblwiOmJyZWFrO2RlZmF1bHQ6XCJmdW5jdGlvblwiPT09dHlwZW9mIG0ub25DbGljayYmXG4oZS5vbmNsaWNrPXdlKX1oPWw7Zi51cGRhdGVRdWV1ZT1oO2Y9bnVsbCE9PWg/ITA6ITE7ZiYmcWcoYil9ZWxzZXttPWI7ZT1oO3I9ZjtsPTk9PT1nLm5vZGVUeXBlP2c6Zy5vd25lckRvY3VtZW50O2s9PT1qZS5odG1sJiYoaz1rZShlKSk7az09PWplLmh0bWw/XCJzY3JpcHRcIj09PWU/KGU9bC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGUuaW5uZXJIVE1MPVwiPHNjcmlwdD5cXHgzYy9zY3JpcHQ+XCIsbD1lLnJlbW92ZUNoaWxkKGUuZmlyc3RDaGlsZCkpOlwic3RyaW5nXCI9PT10eXBlb2Ygci5pcz9sPWwuY3JlYXRlRWxlbWVudChlLHtpczpyLmlzfSk6KGw9bC5jcmVhdGVFbGVtZW50KGUpLFwic2VsZWN0XCI9PT1lJiZyLm11bHRpcGxlJiYobC5tdWx0aXBsZT0hMCkpOmw9bC5jcmVhdGVFbGVtZW50TlMoayxlKTtlPWw7ZVtJYV09bTtlW0phXT1mO2E6Zm9yKG09ZSxyPWIsbD1yLmNoaWxkO251bGwhPT1sOyl7aWYoNz09PWwudGFnfHw4PT09bC50YWcpbS5hcHBlbmRDaGlsZChsLnN0YXRlTm9kZSk7XG5lbHNlIGlmKDYhPT1sLnRhZyYmbnVsbCE9PWwuY2hpbGQpe2wuY2hpbGQucmV0dXJuPWw7bD1sLmNoaWxkO2NvbnRpbnVlfWlmKGw9PT1yKWJyZWFrO2Zvcig7bnVsbD09PWwuc2libGluZzspe2lmKG51bGw9PT1sLnJldHVybnx8bC5yZXR1cm49PT1yKWJyZWFrIGE7bD1sLnJldHVybn1sLnNpYmxpbmcucmV0dXJuPWwucmV0dXJuO2w9bC5zaWJsaW5nfXI9ZTtsPWg7bT1mO3ZhciBBPWcsUz11ZShsLG0pO3N3aXRjaChsKXtjYXNlIFwiaWZyYW1lXCI6Y2FzZSBcIm9iamVjdFwiOkYoXCJsb2FkXCIscik7Zz1tO2JyZWFrO2Nhc2UgXCJ2aWRlb1wiOmNhc2UgXCJhdWRpb1wiOmZvcihnPTA7ZzxmYi5sZW5ndGg7ZysrKUYoZmJbZ10scik7Zz1tO2JyZWFrO2Nhc2UgXCJzb3VyY2VcIjpGKFwiZXJyb3JcIixyKTtnPW07YnJlYWs7Y2FzZSBcImltZ1wiOmNhc2UgXCJpbWFnZVwiOmNhc2UgXCJsaW5rXCI6RihcImVycm9yXCIscik7RihcImxvYWRcIixyKTtnPW07YnJlYWs7Y2FzZSBcImZvcm1cIjpGKFwicmVzZXRcIixyKTtGKFwic3VibWl0XCIsXG5yKTtnPW07YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpGKFwidG9nZ2xlXCIscik7Zz1tO2JyZWFrO2Nhc2UgXCJpbnB1dFwiOkJjKHIsbSk7Zz16YyhyLG0pO0YoXCJpbnZhbGlkXCIscik7dmUoQSxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjpnPWRlKHIsbSk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOnIuX3dyYXBwZXJTdGF0ZT17d2FzTXVsdGlwbGU6ISFtLm11bHRpcGxlfTtnPW4oe30sbSx7dmFsdWU6dm9pZCAwfSk7RihcImludmFsaWRcIixyKTt2ZShBLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6Z2UocixtKTtnPWZlKHIsbSk7RihcImludmFsaWRcIixyKTt2ZShBLFwib25DaGFuZ2VcIik7YnJlYWs7ZGVmYXVsdDpnPW19dGUobCxnKTtrPXZvaWQgMDt2YXIgQj1sLFA9cix2PWc7Zm9yKGsgaW4gdilpZih2Lmhhc093blByb3BlcnR5KGspKXt2YXIgcD12W2tdO1wic3R5bGVcIj09PWs/cmUoUCxwKTpcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1rPyhwPXA/cC5fX2h0bWw6dm9pZCAwLFxubnVsbCE9cCYmbmUoUCxwKSk6XCJjaGlsZHJlblwiPT09az9cInN0cmluZ1wiPT09dHlwZW9mIHA/KFwidGV4dGFyZWFcIiE9PUJ8fFwiXCIhPT1wKSYmb2UoUCxwKTpcIm51bWJlclwiPT09dHlwZW9mIHAmJm9lKFAsXCJcIitwKTpcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09ayYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWsmJlwiYXV0b0ZvY3VzXCIhPT1rJiYoc2EuaGFzT3duUHJvcGVydHkoayk/bnVsbCE9cCYmdmUoQSxrKTpudWxsIT1wJiZ4YyhQLGsscCxTKSl9c3dpdGNoKGwpe2Nhc2UgXCJpbnB1dFwiOldiKHIpO0ZjKHIsbSwhMSk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6V2Iocik7aWUocixtKTticmVhaztjYXNlIFwib3B0aW9uXCI6bnVsbCE9bS52YWx1ZSYmci5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLFwiXCIreWMobS52YWx1ZSkpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpnPXI7Zy5tdWx0aXBsZT0hIW0ubXVsdGlwbGU7cj1tLnZhbHVlO251bGwhPXI/ZWUoZywhIW0ubXVsdGlwbGUsXG5yLCExKTpudWxsIT1tLmRlZmF1bHRWYWx1ZSYmZWUoZywhIW0ubXVsdGlwbGUsbS5kZWZhdWx0VmFsdWUsITApO2JyZWFrO2RlZmF1bHQ6XCJmdW5jdGlvblwiPT09dHlwZW9mIGcub25DbGljayYmKHIub25jbGljaz13ZSl9KGY9emUoaCxmKSkmJnFnKGIpO2Iuc3RhdGVOb2RlPWV9bnVsbCE9PWIucmVmJiYoYi5lZmZlY3RUYWd8PTEyOCl9ZWxzZSBudWxsPT09Yi5zdGF0ZU5vZGU/dChcIjE2NlwiKTp2b2lkIDA7YnJlYWs7Y2FzZSA4OmUmJm51bGwhPWIuc3RhdGVOb2RlP3RnKGUsYixlLm1lbW9pemVkUHJvcHMsZik6KFwic3RyaW5nXCIhPT10eXBlb2YgZiYmKG51bGw9PT1iLnN0YXRlTm9kZT90KFwiMTY2XCIpOnZvaWQgMCksZT16Zih5Zi5jdXJyZW50KSx6ZihMLmN1cnJlbnQpLCRmKGIpPyhmPWIsaD1mLnN0YXRlTm9kZSxlPWYubWVtb2l6ZWRQcm9wcyxoW0lhXT1mLChmPWgubm9kZVZhbHVlIT09ZSkmJnFnKGIpKTooaD1iLGY9KDk9PT1lLm5vZGVUeXBlP2U6ZS5vd25lckRvY3VtZW50KS5jcmVhdGVUZXh0Tm9kZShmKSxcbmZbSWFdPWgsYi5zdGF0ZU5vZGU9ZikpO2JyZWFrO2Nhc2UgMTM6Y2FzZSAxNDpicmVhaztjYXNlIDE2OmJyZWFrO2Nhc2UgOTpicmVhaztjYXNlIDEwOmJyZWFrO2Nhc2UgMTU6YnJlYWs7Y2FzZSA2OkJmKGIpO3JnKGIpO2JyZWFrO2Nhc2UgMTI6dGYoYik7YnJlYWs7Y2FzZSAxMTpicmVhaztjYXNlIDQ6dChcIjE2N1wiKTtkZWZhdWx0OnQoXCIxNTZcIil9Yj1OPW51bGw7Zj1hO2lmKDEwNzM3NDE4MjM9PT1PfHwxMDczNzQxODIzIT09Zi5jaGlsZEV4cGlyYXRpb25UaW1lKXtoPTA7Zm9yKGU9Zi5jaGlsZDtudWxsIT09ZTspe2c9ZS5leHBpcmF0aW9uVGltZTttPWUuY2hpbGRFeHBpcmF0aW9uVGltZTtpZigwPT09aHx8MCE9PWcmJmc8aCloPWc7aWYoMD09PWh8fDAhPT1tJiZtPGgpaD1tO2U9ZS5zaWJsaW5nfWYuY2hpbGRFeHBpcmF0aW9uVGltZT1ofWlmKG51bGwhPT1iKXJldHVybiBiO251bGwhPT1jJiYwPT09KGMuZWZmZWN0VGFnJjUxMikmJihudWxsPT09Yy5maXJzdEVmZmVjdCYmXG4oYy5maXJzdEVmZmVjdD1hLmZpcnN0RWZmZWN0KSxudWxsIT09YS5sYXN0RWZmZWN0JiYobnVsbCE9PWMubGFzdEVmZmVjdCYmKGMubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWEuZmlyc3RFZmZlY3QpLGMubGFzdEVmZmVjdD1hLmxhc3RFZmZlY3QpLDE8YS5lZmZlY3RUYWcmJihudWxsIT09Yy5sYXN0RWZmZWN0P2MubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWE6Yy5maXJzdEVmZmVjdD1hLGMubGFzdEVmZmVjdD1hKSl9ZWxzZXthPUdnKGEsTyk7aWYobnVsbCE9PWEpcmV0dXJuIGEuZWZmZWN0VGFnJj01MTEsYTtudWxsIT09YyYmKGMuZmlyc3RFZmZlY3Q9Yy5sYXN0RWZmZWN0PW51bGwsYy5lZmZlY3RUYWd8PTUxMil9aWYobnVsbCE9PWQpcmV0dXJuIGQ7aWYobnVsbCE9PWMpYT1jO2Vsc2UgYnJlYWt9cmV0dXJuIG51bGx9ZnVuY3Rpb24gUmcoYSl7dmFyIGI9cGcoYS5hbHRlcm5hdGUsYSxPKTtudWxsPT09YiYmKGI9UWcoYSkpO0lnLmN1cnJlbnQ9bnVsbDtyZXR1cm4gYn1cbmZ1bmN0aW9uIFNnKGEsYixjKXtMZz90KFwiMjQzXCIpOnZvaWQgMDtMZz0hMDtJZy5jdXJyZW50RGlzcGF0Y2hlcj1IZzt2YXIgZD1hLm5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uO2lmKGQhPT1PfHxhIT09TWd8fG51bGw9PT1OKVBnKCksTWc9YSxPPWQsTj1VZShNZy5jdXJyZW50LG51bGwsTyksYS5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWU9MDt2YXIgZT0hMTtkb3t0cnl7aWYoYilmb3IoO251bGwhPT1OJiYhVGcoKTspTj1SZyhOKTtlbHNlIGZvcig7bnVsbCE9PU47KU49UmcoTil9Y2F0Y2gocil7aWYobnVsbD09PU4pZT0hMCxEZyhyKTtlbHNle251bGw9PT1OP3QoXCIyNzFcIik6dm9pZCAwO3ZhciBmPU4sZz1mLnJldHVybjtpZihudWxsPT09ZyllPSEwLERnKHIpO2Vsc2V7YTp7dmFyIGg9ZyxrPWYsbD1yO2c9TztrLmVmZmVjdFRhZ3w9NTEyO2suZmlyc3RFZmZlY3Q9ay5sYXN0RWZmZWN0PW51bGw7Tmc9ITA7bD1uZihsLGspO2Rve3N3aXRjaChoLnRhZyl7Y2FzZSA1OmguZWZmZWN0VGFnfD1cbjEwMjQ7aC5leHBpcmF0aW9uVGltZT1nO2c9Q2coaCxsLGcpO2dmKGgsZyk7YnJlYWsgYTtjYXNlIDI6Y2FzZSAzOms9bDt2YXIgbT1oLnN0YXRlTm9kZTtpZigwPT09KGguZWZmZWN0VGFnJjY0KSYmbnVsbCE9PW0mJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBtLmNvbXBvbmVudERpZENhdGNoJiYobnVsbD09PUZnfHwhRmcuaGFzKG0pKSl7aC5lZmZlY3RUYWd8PTEwMjQ7aC5leHBpcmF0aW9uVGltZT1nO2c9RWcoaCxrLGcpO2dmKGgsZyk7YnJlYWsgYX19aD1oLnJldHVybn13aGlsZShudWxsIT09aCl9Tj1RZyhmKTtjb250aW51ZX19fWJyZWFrfXdoaWxlKDEpO0xnPSExO3JmPXFmPXBmPUlnLmN1cnJlbnREaXNwYXRjaGVyPW51bGw7aWYoZSlNZz1udWxsLGEuZmluaXNoZWRXb3JrPW51bGw7ZWxzZSBpZihudWxsIT09TilhLmZpbmlzaGVkV29yaz1udWxsO2Vsc2V7Yj1hLmN1cnJlbnQuYWx0ZXJuYXRlO251bGw9PT1iP3QoXCIyODFcIik6dm9pZCAwO01nPW51bGw7aWYoTmcpe2U9YS5sYXRlc3RQZW5kaW5nVGltZTtcbmY9YS5sYXRlc3RTdXNwZW5kZWRUaW1lO2c9YS5sYXRlc3RQaW5nZWRUaW1lO2lmKDAhPT1lJiZlPmR8fDAhPT1mJiZmPmR8fDAhPT1nJiZnPmQpe2EuZGlkRXJyb3I9ITE7Yz1hLmxhdGVzdFBpbmdlZFRpbWU7MCE9PWMmJmM8PWQmJihhLmxhdGVzdFBpbmdlZFRpbWU9MCk7Yz1hLmVhcmxpZXN0UGVuZGluZ1RpbWU7Yj1hLmxhdGVzdFBlbmRpbmdUaW1lO2M9PT1kP2EuZWFybGllc3RQZW5kaW5nVGltZT1iPT09ZD9hLmxhdGVzdFBlbmRpbmdUaW1lPTA6YjpiPT09ZCYmKGEubGF0ZXN0UGVuZGluZ1RpbWU9Yyk7Yz1hLmVhcmxpZXN0U3VzcGVuZGVkVGltZTtiPWEubGF0ZXN0U3VzcGVuZGVkVGltZTswPT09Yz9hLmVhcmxpZXN0U3VzcGVuZGVkVGltZT1hLmxhdGVzdFN1c3BlbmRlZFRpbWU9ZDpjPmQ/YS5lYXJsaWVzdFN1c3BlbmRlZFRpbWU9ZDpiPGQmJihhLmxhdGVzdFN1c3BlbmRlZFRpbWU9ZCk7JGUoZCxhKTthLmV4cGlyYXRpb25UaW1lPWEuZXhwaXJhdGlvblRpbWU7cmV0dXJufWlmKCFhLmRpZEVycm9yJiZcbiFjKXthLmRpZEVycm9yPSEwO2EubmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT249ZDtkPWEuZXhwaXJhdGlvblRpbWU9MTthLmV4cGlyYXRpb25UaW1lPWQ7cmV0dXJufX1hLnBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZT1kO2EuZmluaXNoZWRXb3JrPWJ9fVxuZnVuY3Rpb24gd2coYSxiKXt2YXIgYzthOntMZyYmIU9nP3QoXCIyNjNcIik6dm9pZCAwO2ZvcihjPWEucmV0dXJuO251bGwhPT1jOyl7c3dpdGNoKGMudGFnKXtjYXNlIDI6Y2FzZSAzOnZhciBkPWMuc3RhdGVOb2RlO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBjLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNofHxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5jb21wb25lbnREaWRDYXRjaCYmKG51bGw9PT1GZ3x8IUZnLmhhcyhkKSkpe2E9bmYoYixhKTthPUVnKGMsYSwxKTtmZihjLGEpO0lmKGMsMSk7Yz12b2lkIDA7YnJlYWsgYX1icmVhaztjYXNlIDU6YT1uZihiLGEpO2E9Q2coYyxhLDEpO2ZmKGMsYSk7SWYoYywxKTtjPXZvaWQgMDticmVhayBhfWM9Yy5yZXR1cm59NT09PWEudGFnJiYoYz1uZihiLGEpLGM9Q2coYSxjLDEpLGZmKGEsYyksSWYoYSwxKSk7Yz12b2lkIDB9cmV0dXJuIGN9XG5mdW5jdGlvbiBIZihhLGIpezAhPT1LZz9hPUtnOkxnP2E9T2c/MTpPOmIubW9kZSYxPyhhPVVnPzIrMTAqKCgoYS0yKzE1KS8xMHwwKSsxKToyKzI1KigoKGEtMis1MDApLzI1fDApKzEpLG51bGwhPT1NZyYmYT09PU8mJihhKz0xKSk6YT0xO1VnJiYoMD09PVZnfHxhPlZnKSYmKFZnPWEpO3JldHVybiBhfVxuZnVuY3Rpb24gSWYoYSxiKXthOntpZigwPT09YS5leHBpcmF0aW9uVGltZXx8YS5leHBpcmF0aW9uVGltZT5iKWEuZXhwaXJhdGlvblRpbWU9Yjt2YXIgYz1hLmFsdGVybmF0ZTtudWxsIT09YyYmKDA9PT1jLmV4cGlyYXRpb25UaW1lfHxjLmV4cGlyYXRpb25UaW1lPmIpJiYoYy5leHBpcmF0aW9uVGltZT1iKTt2YXIgZD1hLnJldHVybjtpZihudWxsPT09ZCYmNT09PWEudGFnKWE9YS5zdGF0ZU5vZGU7ZWxzZXtmb3IoO251bGwhPT1kOyl7Yz1kLmFsdGVybmF0ZTtpZigwPT09ZC5jaGlsZEV4cGlyYXRpb25UaW1lfHxkLmNoaWxkRXhwaXJhdGlvblRpbWU+YilkLmNoaWxkRXhwaXJhdGlvblRpbWU9YjtudWxsIT09YyYmKDA9PT1jLmNoaWxkRXhwaXJhdGlvblRpbWV8fGMuY2hpbGRFeHBpcmF0aW9uVGltZT5iKSYmKGMuY2hpbGRFeHBpcmF0aW9uVGltZT1iKTtpZihudWxsPT09ZC5yZXR1cm4mJjU9PT1kLnRhZyl7YT1kLnN0YXRlTm9kZTticmVhayBhfWQ9ZC5yZXR1cm59YT1udWxsfX1pZihudWxsIT09XG5hKXshTGcmJjAhPT1PJiZiPE8mJlBnKCk7WmUoYSxiKTtpZighTGd8fE9nfHxNZyE9PWEpe2I9YTthPWEuZXhwaXJhdGlvblRpbWU7aWYobnVsbD09PWIubmV4dFNjaGVkdWxlZFJvb3QpYi5leHBpcmF0aW9uVGltZT1hLG51bGw9PT1UPyhVPVQ9YixiLm5leHRTY2hlZHVsZWRSb290PWIpOihUPVQubmV4dFNjaGVkdWxlZFJvb3Q9YixULm5leHRTY2hlZHVsZWRSb290PVUpO2Vsc2UgaWYoYz1iLmV4cGlyYXRpb25UaW1lLDA9PT1jfHxhPGMpYi5leHBpcmF0aW9uVGltZT1hO1Z8fChXP1dnJiYoWT1iLFo9MSxYZyhiLDEsITApKToxPT09YT9ZZygxLG51bGwpOlpnKGIsYSkpfSRnPmFoJiYoJGc9MCx0KFwiMTg1XCIpKX19ZnVuY3Rpb24gYmgoYSxiLGMsZCxlKXt2YXIgZj1LZztLZz0xO3RyeXtyZXR1cm4gYShiLGMsZCxlKX1maW5hbGx5e0tnPWZ9fVxudmFyIFU9bnVsbCxUPW51bGwsY2g9MCxkaD12b2lkIDAsVj0hMSxZPW51bGwsWj0wLFZnPTAsZWg9ITEsZmg9ITEsZ2g9bnVsbCxoaD1udWxsLFc9ITEsV2c9ITEsVWc9ITEsaWg9bnVsbCxqaD1iYS51bnN0YWJsZV9ub3coKSxraD0oamgvMTB8MCkrMixsaD1raCxhaD01MCwkZz0wLG1oPW51bGwsbmg9MTtmdW5jdGlvbiBvaCgpe2toPSgoYmEudW5zdGFibGVfbm93KCktamgpLzEwfDApKzJ9ZnVuY3Rpb24gWmcoYSxiKXtpZigwIT09Y2gpe2lmKGI+Y2gpcmV0dXJuO251bGwhPT1kaCYmYmEudW5zdGFibGVfY2FuY2VsU2NoZWR1bGVkV29yayhkaCl9Y2g9YjthPWJhLnVuc3RhYmxlX25vdygpLWpoO2RoPWJhLnVuc3RhYmxlX3NjaGVkdWxlV29yayhwaCx7dGltZW91dDoxMCooYi0yKS1hfSl9ZnVuY3Rpb24gR2YoKXtpZihWKXJldHVybiBsaDtxaCgpO2lmKDA9PT1afHwxMDczNzQxODIzPT09WilvaCgpLGxoPWtoO3JldHVybiBsaH1cbmZ1bmN0aW9uIHFoKCl7dmFyIGE9MCxiPW51bGw7aWYobnVsbCE9PVQpZm9yKHZhciBjPVQsZD1VO251bGwhPT1kOyl7dmFyIGU9ZC5leHBpcmF0aW9uVGltZTtpZigwPT09ZSl7bnVsbD09PWN8fG51bGw9PT1UP3QoXCIyNDRcIik6dm9pZCAwO2lmKGQ9PT1kLm5leHRTY2hlZHVsZWRSb290KXtVPVQ9ZC5uZXh0U2NoZWR1bGVkUm9vdD1udWxsO2JyZWFrfWVsc2UgaWYoZD09PVUpVT1lPWQubmV4dFNjaGVkdWxlZFJvb3QsVC5uZXh0U2NoZWR1bGVkUm9vdD1lLGQubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDtlbHNlIGlmKGQ9PT1UKXtUPWM7VC5uZXh0U2NoZWR1bGVkUm9vdD1VO2QubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDticmVha31lbHNlIGMubmV4dFNjaGVkdWxlZFJvb3Q9ZC5uZXh0U2NoZWR1bGVkUm9vdCxkLm5leHRTY2hlZHVsZWRSb290PW51bGw7ZD1jLm5leHRTY2hlZHVsZWRSb290fWVsc2V7aWYoMD09PWF8fGU8YSlhPWUsYj1kO2lmKGQ9PT1UKWJyZWFrO2lmKDE9PT1hKWJyZWFrO1xuYz1kO2Q9ZC5uZXh0U2NoZWR1bGVkUm9vdH19WT1iO1o9YX1mdW5jdGlvbiBwaChhKXtpZihhLmRpZFRpbWVvdXQmJm51bGwhPT1VKXtvaCgpO3ZhciBiPVU7ZG97dmFyIGM9Yi5leHBpcmF0aW9uVGltZTswIT09YyYma2g+PWMmJihiLm5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uPWtoKTtiPWIubmV4dFNjaGVkdWxlZFJvb3R9d2hpbGUoYiE9PVUpfVlnKDAsYSl9XG5mdW5jdGlvbiBZZyhhLGIpe2hoPWI7cWgoKTtpZihudWxsIT09aGgpZm9yKG9oKCksbGg9a2g7bnVsbCE9PVkmJjAhPT1aJiYoMD09PWF8fGE+PVopJiYoIWVofHxraD49Wik7KVhnKFksWixraD49WikscWgoKSxvaCgpLGxoPWtoO2Vsc2UgZm9yKDtudWxsIT09WSYmMCE9PVomJigwPT09YXx8YT49Wik7KVhnKFksWiwhMCkscWgoKTtudWxsIT09aGgmJihjaD0wLGRoPW51bGwpOzAhPT1aJiZaZyhZLFopO2hoPW51bGw7ZWg9ITE7JGc9MDttaD1udWxsO2lmKG51bGwhPT1paClmb3IoYT1paCxpaD1udWxsLGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGM9YVtiXTt0cnl7Yy5fb25Db21wbGV0ZSgpfWNhdGNoKGQpe2ZofHwoZmg9ITAsZ2g9ZCl9fWlmKGZoKXRocm93IGE9Z2gsZ2g9bnVsbCxmaD0hMSxhO31cbmZ1bmN0aW9uIFhnKGEsYixjKXtWP3QoXCIyNDVcIik6dm9pZCAwO1Y9ITA7aWYobnVsbD09PWhofHxjKXt2YXIgZD1hLmZpbmlzaGVkV29yaztudWxsIT09ZD9yaChhLGQsYik6KGEuZmluaXNoZWRXb3JrPW51bGwsU2coYSwhMSxjKSxkPWEuZmluaXNoZWRXb3JrLG51bGwhPT1kJiZyaChhLGQsYikpfWVsc2UgZD1hLmZpbmlzaGVkV29yayxudWxsIT09ZD9yaChhLGQsYik6KGEuZmluaXNoZWRXb3JrPW51bGwsU2coYSwhMCxjKSxkPWEuZmluaXNoZWRXb3JrLG51bGwhPT1kJiYoVGcoKT9hLmZpbmlzaGVkV29yaz1kOnJoKGEsZCxiKSkpO1Y9ITF9XG5mdW5jdGlvbiByaChhLGIsYyl7dmFyIGQ9YS5maXJzdEJhdGNoO2lmKG51bGwhPT1kJiZkLl9leHBpcmF0aW9uVGltZTw9YyYmKG51bGw9PT1paD9paD1bZF06aWgucHVzaChkKSxkLl9kZWZlcikpe2EuZmluaXNoZWRXb3JrPWI7YS5leHBpcmF0aW9uVGltZT0wO3JldHVybn1hLmZpbmlzaGVkV29yaz1udWxsO2E9PT1taD8kZysrOihtaD1hLCRnPTApO09nPUxnPSEwO2EuY3VycmVudD09PWI/dChcIjE3N1wiKTp2b2lkIDA7Yz1hLnBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZTswPT09Yz90KFwiMjYxXCIpOnZvaWQgMDthLnBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZT0wO2Q9Yi5leHBpcmF0aW9uVGltZTt2YXIgZT1iLmNoaWxkRXhwaXJhdGlvblRpbWU7ZD0wPT09ZHx8MCE9PWUmJmU8ZD9lOmQ7YS5kaWRFcnJvcj0hMTswPT09ZD8oYS5lYXJsaWVzdFBlbmRpbmdUaW1lPTAsYS5sYXRlc3RQZW5kaW5nVGltZT0wLGEuZWFybGllc3RTdXNwZW5kZWRUaW1lPTAsYS5sYXRlc3RTdXNwZW5kZWRUaW1lPVxuMCxhLmxhdGVzdFBpbmdlZFRpbWU9MCk6KGU9YS5sYXRlc3RQZW5kaW5nVGltZSwwIT09ZSYmKGU8ZD9hLmVhcmxpZXN0UGVuZGluZ1RpbWU9YS5sYXRlc3RQZW5kaW5nVGltZT0wOmEuZWFybGllc3RQZW5kaW5nVGltZTxkJiYoYS5lYXJsaWVzdFBlbmRpbmdUaW1lPWEubGF0ZXN0UGVuZGluZ1RpbWUpKSxlPWEuZWFybGllc3RTdXNwZW5kZWRUaW1lLDA9PT1lP1plKGEsZCk6ZD5hLmxhdGVzdFN1c3BlbmRlZFRpbWU/KGEuZWFybGllc3RTdXNwZW5kZWRUaW1lPTAsYS5sYXRlc3RTdXNwZW5kZWRUaW1lPTAsYS5sYXRlc3RQaW5nZWRUaW1lPTAsWmUoYSxkKSk6ZDxlJiZaZShhLGQpKTskZSgwLGEpO0lnLmN1cnJlbnQ9bnVsbDsxPGIuZWZmZWN0VGFnP251bGwhPT1iLmxhc3RFZmZlY3Q/KGIubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWIsZD1iLmZpcnN0RWZmZWN0KTpkPWI6ZD1iLmZpcnN0RWZmZWN0O3hlPUdkO2U9VGQoKTtpZihVZChlKSl7aWYoXCJzZWxlY3Rpb25TdGFydFwiaW4gZSl2YXIgZj1cbntzdGFydDplLnNlbGVjdGlvblN0YXJ0LGVuZDplLnNlbGVjdGlvbkVuZH07ZWxzZSBhOntmPShmPWUub3duZXJEb2N1bWVudCkmJmYuZGVmYXVsdFZpZXd8fHdpbmRvdzt2YXIgZz1mLmdldFNlbGVjdGlvbiYmZi5nZXRTZWxlY3Rpb24oKTtpZihnJiYwIT09Zy5yYW5nZUNvdW50KXtmPWcuYW5jaG9yTm9kZTt2YXIgaD1nLmFuY2hvck9mZnNldCxrPWcuZm9jdXNOb2RlO2c9Zy5mb2N1c09mZnNldDt0cnl7Zi5ub2RlVHlwZSxrLm5vZGVUeXBlfWNhdGNoKFhhKXtmPW51bGw7YnJlYWsgYX12YXIgbD0wLG09LTEscj0tMSxBPTAsUz0wLEI9ZSxQPW51bGw7Yjpmb3IoOzspe2Zvcih2YXIgdjs7KXtCIT09Znx8MCE9PWgmJjMhPT1CLm5vZGVUeXBlfHwobT1sK2gpO0IhPT1rfHwwIT09ZyYmMyE9PUIubm9kZVR5cGV8fChyPWwrZyk7Mz09PUIubm9kZVR5cGUmJihsKz1CLm5vZGVWYWx1ZS5sZW5ndGgpO2lmKG51bGw9PT0odj1CLmZpcnN0Q2hpbGQpKWJyZWFrO1A9QjtCPXZ9Zm9yKDs7KXtpZihCPT09XG5lKWJyZWFrIGI7UD09PWYmJisrQT09PWgmJihtPWwpO1A9PT1rJiYrK1M9PT1nJiYocj1sKTtpZihudWxsIT09KHY9Qi5uZXh0U2libGluZykpYnJlYWs7Qj1QO1A9Qi5wYXJlbnROb2RlfUI9dn1mPS0xPT09bXx8LTE9PT1yP251bGw6e3N0YXJ0Om0sZW5kOnJ9fWVsc2UgZj1udWxsfWY9Znx8e3N0YXJ0OjAsZW5kOjB9fWVsc2UgZj1udWxsO3llPXtmb2N1c2VkRWxlbTplLHNlbGVjdGlvblJhbmdlOmZ9O0dkPSExO2ZvcihRPWQ7bnVsbCE9PVE7KXtlPSExO2Y9dm9pZCAwO3RyeXtmb3IoO251bGwhPT1ROyl7aWYoUS5lZmZlY3RUYWcmMjU2KXt2YXIgcD1RLmFsdGVybmF0ZTthOnN3aXRjaChoPVEsaC50YWcpe2Nhc2UgMjpjYXNlIDM6aWYoaC5lZmZlY3RUYWcmMjU2JiZudWxsIT09cCl7dmFyIHU9cC5tZW1vaXplZFByb3BzLHg9cC5tZW1vaXplZFN0YXRlLFI9aC5zdGF0ZU5vZGU7Ui5wcm9wcz1oLm1lbW9pemVkUHJvcHM7Ui5zdGF0ZT1oLm1lbW9pemVkU3RhdGU7dmFyIHloPVIuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUodSxcbngpO1IuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGU9eWh9YnJlYWsgYTtjYXNlIDU6Y2FzZSA3OmNhc2UgODpjYXNlIDY6YnJlYWsgYTtkZWZhdWx0OnQoXCIxNjNcIil9fVE9US5uZXh0RWZmZWN0fX1jYXRjaChYYSl7ZT0hMCxmPVhhfWUmJihudWxsPT09UT90KFwiMTc4XCIpOnZvaWQgMCx3ZyhRLGYpLG51bGwhPT1RJiYoUT1RLm5leHRFZmZlY3QpKX1mb3IoUT1kO251bGwhPT1ROyl7cD0hMTt1PXZvaWQgMDt0cnl7Zm9yKDtudWxsIT09UTspe3ZhciB3PVEuZWZmZWN0VGFnO3cmMTYmJm9lKFEuc3RhdGVOb2RlLFwiXCIpO2lmKHcmMTI4KXt2YXIgeT1RLmFsdGVybmF0ZTtpZihudWxsIT09eSl7dmFyIHE9eS5yZWY7bnVsbCE9PXEmJihcImZ1bmN0aW9uXCI9PT10eXBlb2YgcT9xKG51bGwpOnEuY3VycmVudD1udWxsKX19c3dpdGNoKHcmMTQpe2Nhc2UgMjpBZyhRKTtRLmVmZmVjdFRhZyY9LTM7YnJlYWs7Y2FzZSA2OkFnKFEpO1EuZWZmZWN0VGFnJj0tMztCZyhRLmFsdGVybmF0ZSxcblEpO2JyZWFrO2Nhc2UgNDpCZyhRLmFsdGVybmF0ZSxRKTticmVhaztjYXNlIDg6eD1RLHlnKHgpLHgucmV0dXJuPW51bGwseC5jaGlsZD1udWxsLHguYWx0ZXJuYXRlJiYoeC5hbHRlcm5hdGUuY2hpbGQ9bnVsbCx4LmFsdGVybmF0ZS5yZXR1cm49bnVsbCl9UT1RLm5leHRFZmZlY3R9fWNhdGNoKFhhKXtwPSEwLHU9WGF9cCYmKG51bGw9PT1RP3QoXCIxNzhcIik6dm9pZCAwLHdnKFEsdSksbnVsbCE9PVEmJihRPVEubmV4dEVmZmVjdCkpfXE9eWU7eT1UZCgpO3c9cS5mb2N1c2VkRWxlbTt1PXEuc2VsZWN0aW9uUmFuZ2U7aWYoeSE9PXcmJncmJncub3duZXJEb2N1bWVudCYmU2Qody5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCx3KSl7bnVsbCE9PXUmJlVkKHcpJiYoeT11LnN0YXJ0LHE9dS5lbmQsdm9pZCAwPT09cSYmKHE9eSksXCJzZWxlY3Rpb25TdGFydFwiaW4gdz8ody5zZWxlY3Rpb25TdGFydD15LHcuc2VsZWN0aW9uRW5kPU1hdGgubWluKHEsdy52YWx1ZS5sZW5ndGgpKTpcbihwPXcub3duZXJEb2N1bWVudHx8ZG9jdW1lbnQseT0ocCYmcC5kZWZhdWx0Vmlld3x8d2luZG93KS5nZXRTZWxlY3Rpb24oKSx4PXcudGV4dENvbnRlbnQubGVuZ3RoLHE9TWF0aC5taW4odS5zdGFydCx4KSx1PXZvaWQgMD09PXUuZW5kP3E6TWF0aC5taW4odS5lbmQseCksIXkuZXh0ZW5kJiZxPnUmJih4PXUsdT1xLHE9eCkseD1SZCh3LHEpLFI9UmQodyx1KSx4JiZSJiYoMSE9PXkucmFuZ2VDb3VudHx8eS5hbmNob3JOb2RlIT09eC5ub2RlfHx5LmFuY2hvck9mZnNldCE9PXgub2Zmc2V0fHx5LmZvY3VzTm9kZSE9PVIubm9kZXx8eS5mb2N1c09mZnNldCE9PVIub2Zmc2V0KSYmKHA9cC5jcmVhdGVSYW5nZSgpLHAuc2V0U3RhcnQoeC5ub2RlLHgub2Zmc2V0KSx5LnJlbW92ZUFsbFJhbmdlcygpLHE+dT8oeS5hZGRSYW5nZShwKSx5LmV4dGVuZChSLm5vZGUsUi5vZmZzZXQpKToocC5zZXRFbmQoUi5ub2RlLFIub2Zmc2V0KSx5LmFkZFJhbmdlKHApKSkpKTt5PVtdO2ZvcihxPXc7cT1cbnEucGFyZW50Tm9kZTspMT09PXEubm9kZVR5cGUmJnkucHVzaCh7ZWxlbWVudDpxLGxlZnQ6cS5zY3JvbGxMZWZ0LHRvcDpxLnNjcm9sbFRvcH0pO1wiZnVuY3Rpb25cIj09PXR5cGVvZiB3LmZvY3VzJiZ3LmZvY3VzKCk7Zm9yKHc9MDt3PHkubGVuZ3RoO3crKylxPXlbd10scS5lbGVtZW50LnNjcm9sbExlZnQ9cS5sZWZ0LHEuZWxlbWVudC5zY3JvbGxUb3A9cS50b3B9eWU9bnVsbDtHZD0hIXhlO3hlPW51bGw7YS5jdXJyZW50PWI7Zm9yKFE9ZDtudWxsIT09UTspe2Q9ITE7dz12b2lkIDA7dHJ5e2Zvcih5PWM7bnVsbCE9PVE7KXt2YXIgU2E9US5lZmZlY3RUYWc7aWYoU2EmMzYpe3ZhciBvYz1RLmFsdGVybmF0ZTtxPVE7cD15O3N3aXRjaChxLnRhZyl7Y2FzZSAyOmNhc2UgMzp2YXIgWD1xLnN0YXRlTm9kZTtpZihxLmVmZmVjdFRhZyY0KWlmKG51bGw9PT1vYylYLnByb3BzPXEubWVtb2l6ZWRQcm9wcyxYLnN0YXRlPXEubWVtb2l6ZWRTdGF0ZSxYLmNvbXBvbmVudERpZE1vdW50KCk7XG5lbHNle3ZhciBJaD1vYy5tZW1vaXplZFByb3BzLEpoPW9jLm1lbW9pemVkU3RhdGU7WC5wcm9wcz1xLm1lbW9pemVkUHJvcHM7WC5zdGF0ZT1xLm1lbW9pemVkU3RhdGU7WC5jb21wb25lbnREaWRVcGRhdGUoSWgsSmgsWC5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSl9dmFyIGtnPXEudXBkYXRlUXVldWU7bnVsbCE9PWtnJiYoWC5wcm9wcz1xLm1lbW9pemVkUHJvcHMsWC5zdGF0ZT1xLm1lbW9pemVkU3RhdGUsbGYocSxrZyxYLHApKTticmVhaztjYXNlIDU6dmFyIGxnPXEudXBkYXRlUXVldWU7aWYobnVsbCE9PWxnKXt1PW51bGw7aWYobnVsbCE9PXEuY2hpbGQpc3dpdGNoKHEuY2hpbGQudGFnKXtjYXNlIDc6dT1xLmNoaWxkLnN0YXRlTm9kZTticmVhaztjYXNlIDI6Y2FzZSAzOnU9cS5jaGlsZC5zdGF0ZU5vZGV9bGYocSxsZyx1LHApfWJyZWFrO2Nhc2UgNzp2YXIgS2g9cS5zdGF0ZU5vZGU7bnVsbD09PW9jJiZxLmVmZmVjdFRhZyY0JiZ6ZShxLnR5cGUscS5tZW1vaXplZFByb3BzKSYmXG5LaC5mb2N1cygpO2JyZWFrO2Nhc2UgODpicmVhaztjYXNlIDY6YnJlYWs7Y2FzZSAxNTpicmVhaztjYXNlIDE2OmJyZWFrO2RlZmF1bHQ6dChcIjE2M1wiKX19aWYoU2EmMTI4KXt2YXIgQWM9US5yZWY7aWYobnVsbCE9PUFjKXt2YXIgbWc9US5zdGF0ZU5vZGU7c3dpdGNoKFEudGFnKXtjYXNlIDc6dmFyIFBkPW1nO2JyZWFrO2RlZmF1bHQ6UGQ9bWd9XCJmdW5jdGlvblwiPT09dHlwZW9mIEFjP0FjKFBkKTpBYy5jdXJyZW50PVBkfX12YXIgTGg9US5uZXh0RWZmZWN0O1EubmV4dEVmZmVjdD1udWxsO1E9TGh9fWNhdGNoKFhhKXtkPSEwLHc9WGF9ZCYmKG51bGw9PT1RP3QoXCIxNzhcIik6dm9pZCAwLHdnKFEsdyksbnVsbCE9PVEmJihRPVEubmV4dEVmZmVjdCkpfUxnPU9nPSExO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBPZSYmT2UoYi5zdGF0ZU5vZGUpO1NhPWIuZXhwaXJhdGlvblRpbWU7Yj1iLmNoaWxkRXhwaXJhdGlvblRpbWU7Yj0wPT09U2F8fDAhPT1iJiZiPFNhP2I6U2E7MD09PWImJihGZz1cbm51bGwpO2EuZXhwaXJhdGlvblRpbWU9YjthLmZpbmlzaGVkV29yaz1udWxsfWZ1bmN0aW9uIFRnKCl7cmV0dXJuIGVoPyEwOm51bGw9PT1oaHx8aGgudGltZVJlbWFpbmluZygpPm5oPyExOmVoPSEwfWZ1bmN0aW9uIERnKGEpe251bGw9PT1ZP3QoXCIyNDZcIik6dm9pZCAwO1kuZXhwaXJhdGlvblRpbWU9MDtmaHx8KGZoPSEwLGdoPWEpfWZ1bmN0aW9uIHNoKGEsYil7dmFyIGM9VztXPSEwO3RyeXtyZXR1cm4gYShiKX1maW5hbGx5eyhXPWMpfHxWfHxZZygxLG51bGwpfX1mdW5jdGlvbiB0aChhLGIpe2lmKFcmJiFXZyl7V2c9ITA7dHJ5e3JldHVybiBhKGIpfWZpbmFsbHl7V2c9ITF9fXJldHVybiBhKGIpfWZ1bmN0aW9uIHVoKGEsYixjKXtpZihVZylyZXR1cm4gYShiLGMpO1d8fFZ8fDA9PT1WZ3x8KFlnKFZnLG51bGwpLFZnPTApO3ZhciBkPVVnLGU9VztXPVVnPSEwO3RyeXtyZXR1cm4gYShiLGMpfWZpbmFsbHl7VWc9ZCwoVz1lKXx8Vnx8WWcoMSxudWxsKX19XG5mdW5jdGlvbiB2aChhKXtpZighYSlyZXR1cm4gRmU7YT1hLl9yZWFjdEludGVybmFsRmliZXI7YTp7MiE9PWpkKGEpfHwyIT09YS50YWcmJjMhPT1hLnRhZz90KFwiMTcwXCIpOnZvaWQgMDt2YXIgYj1hO2Rve3N3aXRjaChiLnRhZyl7Y2FzZSA1OmI9Yi5zdGF0ZU5vZGUuY29udGV4dDticmVhayBhO2Nhc2UgMjppZihLKGIudHlwZSkpe2I9Yi5zdGF0ZU5vZGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ7YnJlYWsgYX1icmVhaztjYXNlIDM6aWYoSyhiLnR5cGUuX3JlYWN0UmVzdWx0KSl7Yj1iLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDticmVhayBhfX1iPWIucmV0dXJufXdoaWxlKG51bGwhPT1iKTt0KFwiMTcxXCIpO2I9dm9pZCAwfWlmKDI9PT1hLnRhZyl7dmFyIGM9YS50eXBlO2lmKEsoYykpcmV0dXJuIExlKGEsYyxiKX1lbHNlIGlmKDM9PT1hLnRhZyYmKGM9YS50eXBlLl9yZWFjdFJlc3VsdCxLKGMpKSlyZXR1cm4gTGUoYSxcbmMsYik7cmV0dXJuIGJ9ZnVuY3Rpb24gd2goYSxiLGMsZCxlKXt2YXIgZj1iLmN1cnJlbnQ7Yz12aChjKTtudWxsPT09Yi5jb250ZXh0P2IuY29udGV4dD1jOmIucGVuZGluZ0NvbnRleHQ9YztiPWU7ZT1kZihkKTtlLnBheWxvYWQ9e2VsZW1lbnQ6YX07Yj12b2lkIDA9PT1iP251bGw6YjtudWxsIT09YiYmKGUuY2FsbGJhY2s9Yik7ZmYoZixlKTtJZihmLGQpO3JldHVybiBkfWZ1bmN0aW9uIHhoKGEsYixjLGQpe3ZhciBlPWIuY3VycmVudCxmPUdmKCk7ZT1IZihmLGUpO3JldHVybiB3aChhLGIsYyxlLGQpfWZ1bmN0aW9uIHpoKGEpe2E9YS5jdXJyZW50O2lmKCFhLmNoaWxkKXJldHVybiBudWxsO3N3aXRjaChhLmNoaWxkLnRhZyl7Y2FzZSA3OnJldHVybiBhLmNoaWxkLnN0YXRlTm9kZTtkZWZhdWx0OnJldHVybiBhLmNoaWxkLnN0YXRlTm9kZX19XG5mdW5jdGlvbiBBaChhLGIsYyl7dmFyIGQ9Mzxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOm51bGw7cmV0dXJueyQkdHlwZW9mOmFjLGtleTpudWxsPT1kP251bGw6XCJcIitkLGNoaWxkcmVuOmEsY29udGFpbmVySW5mbzpiLGltcGxlbWVudGF0aW9uOmN9fVxuRmI9ZnVuY3Rpb24oYSxiLGMpe3N3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjpEYyhhLGMpO2I9Yy5uYW1lO2lmKFwicmFkaW9cIj09PWMudHlwZSYmbnVsbCE9Yil7Zm9yKGM9YTtjLnBhcmVudE5vZGU7KWM9Yy5wYXJlbnROb2RlO2M9Yy5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRbbmFtZT1cIitKU09OLnN0cmluZ2lmeShcIlwiK2IpKyddW3R5cGU9XCJyYWRpb1wiXScpO2ZvcihiPTA7YjxjLmxlbmd0aDtiKyspe3ZhciBkPWNbYl07aWYoZCE9PWEmJmQuZm9ybT09PWEuZm9ybSl7dmFyIGU9TmEoZCk7ZT92b2lkIDA6dChcIjkwXCIpO1hiKGQpO0RjKGQsZSl9fX1icmVhaztjYXNlIFwidGV4dGFyZWFcIjpoZShhLGMpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpiPWMudmFsdWUsbnVsbCE9YiYmZWUoYSwhIWMubXVsdGlwbGUsYiwhMSl9fTtcbmZ1bmN0aW9uIEJoKGEpe3ZhciBiPTIrMjUqKCgoR2YoKS0yKzUwMCkvMjV8MCkrMSk7Yjw9SmcmJihiPUpnKzEpO3RoaXMuX2V4cGlyYXRpb25UaW1lPUpnPWI7dGhpcy5fcm9vdD1hO3RoaXMuX2NhbGxiYWNrcz10aGlzLl9uZXh0PW51bGw7dGhpcy5faGFzQ2hpbGRyZW49dGhpcy5fZGlkQ29tcGxldGU9ITE7dGhpcy5fY2hpbGRyZW49bnVsbDt0aGlzLl9kZWZlcj0hMH1CaC5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGEpe3RoaXMuX2RlZmVyP3ZvaWQgMDp0KFwiMjUwXCIpO3RoaXMuX2hhc0NoaWxkcmVuPSEwO3RoaXMuX2NoaWxkcmVuPWE7dmFyIGI9dGhpcy5fcm9vdC5faW50ZXJuYWxSb290LGM9dGhpcy5fZXhwaXJhdGlvblRpbWUsZD1uZXcgQ2g7d2goYSxiLG51bGwsYyxkLl9vbkNvbW1pdCk7cmV0dXJuIGR9O1xuQmgucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24oYSl7aWYodGhpcy5fZGlkQ29tcGxldGUpYSgpO2Vsc2V7dmFyIGI9dGhpcy5fY2FsbGJhY2tzO251bGw9PT1iJiYoYj10aGlzLl9jYWxsYmFja3M9W10pO2IucHVzaChhKX19O1xuQmgucHJvdG90eXBlLmNvbW1pdD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuX3Jvb3QuX2ludGVybmFsUm9vdCxiPWEuZmlyc3RCYXRjaDt0aGlzLl9kZWZlciYmbnVsbCE9PWI/dm9pZCAwOnQoXCIyNTFcIik7aWYodGhpcy5faGFzQ2hpbGRyZW4pe3ZhciBjPXRoaXMuX2V4cGlyYXRpb25UaW1lO2lmKGIhPT10aGlzKXt0aGlzLl9oYXNDaGlsZHJlbiYmKGM9dGhpcy5fZXhwaXJhdGlvblRpbWU9Yi5fZXhwaXJhdGlvblRpbWUsdGhpcy5yZW5kZXIodGhpcy5fY2hpbGRyZW4pKTtmb3IodmFyIGQ9bnVsbCxlPWI7ZSE9PXRoaXM7KWQ9ZSxlPWUuX25leHQ7bnVsbD09PWQ/dChcIjI1MVwiKTp2b2lkIDA7ZC5fbmV4dD1lLl9uZXh0O3RoaXMuX25leHQ9YjthLmZpcnN0QmF0Y2g9dGhpc310aGlzLl9kZWZlcj0hMTtiPWM7Vj90KFwiMjUzXCIpOnZvaWQgMDtZPWE7Wj1iO1hnKGEsYiwhMCk7WWcoMSxudWxsKTtiPXRoaXMuX25leHQ7dGhpcy5fbmV4dD1udWxsO2I9YS5maXJzdEJhdGNoPWI7bnVsbCE9PVxuYiYmYi5faGFzQ2hpbGRyZW4mJmIucmVuZGVyKGIuX2NoaWxkcmVuKX1lbHNlIHRoaXMuX25leHQ9bnVsbCx0aGlzLl9kZWZlcj0hMX07QmgucHJvdG90eXBlLl9vbkNvbXBsZXRlPWZ1bmN0aW9uKCl7aWYoIXRoaXMuX2RpZENvbXBsZXRlKXt0aGlzLl9kaWRDb21wbGV0ZT0hMDt2YXIgYT10aGlzLl9jYWxsYmFja3M7aWYobnVsbCE9PWEpZm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspKDAsYVtiXSkoKX19O2Z1bmN0aW9uIENoKCl7dGhpcy5fY2FsbGJhY2tzPW51bGw7dGhpcy5fZGlkQ29tbWl0PSExO3RoaXMuX29uQ29tbWl0PXRoaXMuX29uQ29tbWl0LmJpbmQodGhpcyl9Q2gucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24oYSl7aWYodGhpcy5fZGlkQ29tbWl0KWEoKTtlbHNle3ZhciBiPXRoaXMuX2NhbGxiYWNrcztudWxsPT09YiYmKGI9dGhpcy5fY2FsbGJhY2tzPVtdKTtiLnB1c2goYSl9fTtcbkNoLnByb3RvdHlwZS5fb25Db21taXQ9ZnVuY3Rpb24oKXtpZighdGhpcy5fZGlkQ29tbWl0KXt0aGlzLl9kaWRDb21taXQ9ITA7dmFyIGE9dGhpcy5fY2FsbGJhY2tzO2lmKG51bGwhPT1hKWZvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgYz1hW2JdO1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBjP3QoXCIxOTFcIixjKTp2b2lkIDA7YygpfX19O1xuZnVuY3Rpb24gRGgoYSxiLGMpe2I9bmV3IFNlKDUsbnVsbCxudWxsLGI/MzowKTthPXtjdXJyZW50OmIsY29udGFpbmVySW5mbzphLHBlbmRpbmdDaGlsZHJlbjpudWxsLGVhcmxpZXN0UGVuZGluZ1RpbWU6MCxsYXRlc3RQZW5kaW5nVGltZTowLGVhcmxpZXN0U3VzcGVuZGVkVGltZTowLGxhdGVzdFN1c3BlbmRlZFRpbWU6MCxsYXRlc3RQaW5nZWRUaW1lOjAsZGlkRXJyb3I6ITEscGVuZGluZ0NvbW1pdEV4cGlyYXRpb25UaW1lOjAsZmluaXNoZWRXb3JrOm51bGwsdGltZW91dEhhbmRsZTotMSxjb250ZXh0Om51bGwscGVuZGluZ0NvbnRleHQ6bnVsbCxoeWRyYXRlOmMsbmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT246MCxleHBpcmF0aW9uVGltZTowLGZpcnN0QmF0Y2g6bnVsbCxuZXh0U2NoZWR1bGVkUm9vdDpudWxsfTt0aGlzLl9pbnRlcm5hbFJvb3Q9Yi5zdGF0ZU5vZGU9YX1cbkRoLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLl9pbnRlcm5hbFJvb3QsZD1uZXcgQ2g7Yj12b2lkIDA9PT1iP251bGw6YjtudWxsIT09YiYmZC50aGVuKGIpO3hoKGEsYyxudWxsLGQuX29uQ29tbWl0KTtyZXR1cm4gZH07RGgucHJvdG90eXBlLnVubW91bnQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5faW50ZXJuYWxSb290LGM9bmV3IENoO2E9dm9pZCAwPT09YT9udWxsOmE7bnVsbCE9PWEmJmMudGhlbihhKTt4aChudWxsLGIsbnVsbCxjLl9vbkNvbW1pdCk7cmV0dXJuIGN9O0RoLnByb3RvdHlwZS5sZWdhY3lfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuX2ludGVybmFsUm9vdCxlPW5ldyBDaDtjPXZvaWQgMD09PWM/bnVsbDpjO251bGwhPT1jJiZlLnRoZW4oYyk7eGgoYixkLGEsZS5fb25Db21taXQpO3JldHVybiBlfTtcbkRoLnByb3RvdHlwZS5jcmVhdGVCYXRjaD1mdW5jdGlvbigpe3ZhciBhPW5ldyBCaCh0aGlzKSxiPWEuX2V4cGlyYXRpb25UaW1lLGM9dGhpcy5faW50ZXJuYWxSb290LGQ9Yy5maXJzdEJhdGNoO2lmKG51bGw9PT1kKWMuZmlyc3RCYXRjaD1hLGEuX25leHQ9bnVsbDtlbHNle2ZvcihjPW51bGw7bnVsbCE9PWQmJmQuX2V4cGlyYXRpb25UaW1lPD1iOyljPWQsZD1kLl9uZXh0O2EuX25leHQ9ZDtudWxsIT09YyYmKGMuX25leHQ9YSl9cmV0dXJuIGF9O2Z1bmN0aW9uIEVoKGEpe3JldHVybiEoIWF8fDEhPT1hLm5vZGVUeXBlJiY5IT09YS5ub2RlVHlwZSYmMTEhPT1hLm5vZGVUeXBlJiYoOCE9PWEubm9kZVR5cGV8fFwiIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlIFwiIT09YS5ub2RlVmFsdWUpKX1MYj1zaDtNYj11aDtOYj1mdW5jdGlvbigpe1Z8fDA9PT1WZ3x8KFlnKFZnLG51bGwpLFZnPTApfTtcbmZ1bmN0aW9uIEZoKGEsYil7Ynx8KGI9YT85PT09YS5ub2RlVHlwZT9hLmRvY3VtZW50RWxlbWVudDphLmZpcnN0Q2hpbGQ6bnVsbCxiPSEoIWJ8fDEhPT1iLm5vZGVUeXBlfHwhYi5oYXNBdHRyaWJ1dGUoXCJkYXRhLXJlYWN0cm9vdFwiKSkpO2lmKCFiKWZvcih2YXIgYztjPWEubGFzdENoaWxkOylhLnJlbW92ZUNoaWxkKGMpO3JldHVybiBuZXcgRGgoYSwhMSxiKX1cbmZ1bmN0aW9uIEdoKGEsYixjLGQsZSl7RWgoYyk/dm9pZCAwOnQoXCIyMDBcIik7dmFyIGY9Yy5fcmVhY3RSb290Q29udGFpbmVyO2lmKGYpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBlKXt2YXIgZz1lO2U9ZnVuY3Rpb24oKXt2YXIgYT16aChmLl9pbnRlcm5hbFJvb3QpO2cuY2FsbChhKX19bnVsbCE9YT9mLmxlZ2FjeV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihhLGIsZSk6Zi5yZW5kZXIoYixlKX1lbHNle2Y9Yy5fcmVhY3RSb290Q29udGFpbmVyPUZoKGMsZCk7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGUpe3ZhciBoPWU7ZT1mdW5jdGlvbigpe3ZhciBhPXpoKGYuX2ludGVybmFsUm9vdCk7aC5jYWxsKGEpfX10aChmdW5jdGlvbigpe251bGwhPWE/Zi5sZWdhY3lfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIoYSxiLGUpOmYucmVuZGVyKGIsZSl9KX1yZXR1cm4gemgoZi5faW50ZXJuYWxSb290KX1cbmZ1bmN0aW9uIEhoKGEsYil7dmFyIGM9Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGw7RWgoYik/dm9pZCAwOnQoXCIyMDBcIik7cmV0dXJuIEFoKGEsYixudWxsLGMpfVxudmFyIE1oPXtjcmVhdGVQb3J0YWw6SGgsZmluZERPTU5vZGU6ZnVuY3Rpb24oYSl7aWYobnVsbD09YSlyZXR1cm4gbnVsbDtpZigxPT09YS5ub2RlVHlwZSlyZXR1cm4gYTt2YXIgYj1hLl9yZWFjdEludGVybmFsRmliZXI7dm9pZCAwPT09YiYmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhLnJlbmRlcj90KFwiMTg4XCIpOnQoXCIyNjhcIixPYmplY3Qua2V5cyhhKSkpO2E9bWQoYik7YT1udWxsPT09YT9udWxsOmEuc3RhdGVOb2RlO3JldHVybiBhfSxoeWRyYXRlOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gR2gobnVsbCxhLGIsITAsYyl9LHJlbmRlcjpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIEdoKG51bGwsYSxiLCExLGMpfSx1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjpmdW5jdGlvbihhLGIsYyxkKXtudWxsPT1hfHx2b2lkIDA9PT1hLl9yZWFjdEludGVybmFsRmliZXI/dChcIjM4XCIpOnZvaWQgMDtyZXR1cm4gR2goYSxiLGMsITEsZCl9LHVubW91bnRDb21wb25lbnRBdE5vZGU6ZnVuY3Rpb24oYSl7RWgoYSk/XG52b2lkIDA6dChcIjQwXCIpO3JldHVybiBhLl9yZWFjdFJvb3RDb250YWluZXI/KHRoKGZ1bmN0aW9uKCl7R2gobnVsbCxudWxsLGEsITEsZnVuY3Rpb24oKXthLl9yZWFjdFJvb3RDb250YWluZXI9bnVsbH0pfSksITApOiExfSx1bnN0YWJsZV9jcmVhdGVQb3J0YWw6ZnVuY3Rpb24oKXtyZXR1cm4gSGguYXBwbHkodm9pZCAwLGFyZ3VtZW50cyl9LHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOnNoLHVuc3RhYmxlX2ludGVyYWN0aXZlVXBkYXRlczp1aCxmbHVzaFN5bmM6ZnVuY3Rpb24oYSxiKXtWP3QoXCIxODdcIik6dm9pZCAwO3ZhciBjPVc7Vz0hMDt0cnl7cmV0dXJuIGJoKGEsYil9ZmluYWxseXtXPWMsWWcoMSxudWxsKX19LHVuc3RhYmxlX2ZsdXNoQ29udHJvbGxlZDpmdW5jdGlvbihhKXt2YXIgYj1XO1c9ITA7dHJ5e2JoKGEpfWZpbmFsbHl7KFc9Yil8fFZ8fFlnKDEsbnVsbCl9fSxfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDp7RXZlbnRzOltMYSxcbk1hLE5hLEVhLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSxxYSxVYSxmdW5jdGlvbihhKXt6YShhLFRhKX0sSmIsS2IsSWQsR2FdfSx1bnN0YWJsZV9jcmVhdGVSb290OmZ1bmN0aW9uKGEsYil7RWgoYSk/dm9pZCAwOnQoXCIyNzhcIik7cmV0dXJuIG5ldyBEaChhLCEwLG51bGwhPWImJiEwPT09Yi5oeWRyYXRlKX19OyhmdW5jdGlvbihhKXt2YXIgYj1hLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO3JldHVybiBSZShuKHt9LGEse2ZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOmZ1bmN0aW9uKGEpe2E9bWQoYSk7cmV0dXJuIG51bGw9PT1hP251bGw6YS5zdGF0ZU5vZGV9LGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOmZ1bmN0aW9uKGEpe3JldHVybiBiP2IoYSk6bnVsbH19KSl9KSh7ZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6S2EsYnVuZGxlVHlwZTowLHZlcnNpb246XCIxNi41LjJcIixyZW5kZXJlclBhY2thZ2VOYW1lOlwicmVhY3QtZG9tXCJ9KTtcbnZhciBOaD17ZGVmYXVsdDpNaH0sT2g9TmgmJk1ofHxOaDttb2R1bGUuZXhwb3J0cz1PaC5kZWZhdWx0fHxPaDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcyIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuNS4yXG4gKiBzY2hlZHVsZS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYz1udWxsLGU9ITEsZj0hMSxnPVwib2JqZWN0XCI9PT10eXBlb2YgcGVyZm9ybWFuY2UmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBwZXJmb3JtYW5jZS5ub3csbD17dGltZVJlbWFpbmluZzpnP2Z1bmN0aW9uKCl7dmFyIGE9aCgpLXBlcmZvcm1hbmNlLm5vdygpO3JldHVybiAwPGE/YTowfTpmdW5jdGlvbigpe3ZhciBhPWgoKS1EYXRlLm5vdygpO3JldHVybiAwPGE/YTowfSxkaWRUaW1lb3V0OiExfTtmdW5jdGlvbiBtKCl7aWYoIWUpe3ZhciBhPWMudGltZXNPdXRBdDtmP24oKTpmPSEwO3AocSxhKX19ZnVuY3Rpb24gcigpe3ZhciBhPWMsYj1jLm5leHQ7aWYoYz09PWIpYz1udWxsO2Vsc2V7dmFyIGQ9Yy5wcmV2aW91cztjPWQubmV4dD1iO2IucHJldmlvdXM9ZH1hLm5leHQ9YS5wcmV2aW91cz1udWxsO2E9YS5jYWxsYmFjazthKGwpfVxuZnVuY3Rpb24gcShhKXtlPSEwO2wuZGlkVGltZW91dD1hO3RyeXtpZihhKWZvcig7bnVsbCE9PWM7KXt2YXIgYj1leHBvcnRzLnVuc3RhYmxlX25vdygpO2lmKGMudGltZXNPdXRBdDw9Yil7ZG8gcigpO3doaWxlKG51bGwhPT1jJiZjLnRpbWVzT3V0QXQ8PWIpfWVsc2UgYnJlYWt9ZWxzZSBpZihudWxsIT09Yyl7ZG8gcigpO3doaWxlKG51bGwhPT1jJiYwPGgoKS1leHBvcnRzLnVuc3RhYmxlX25vdygpKX19ZmluYWxseXtlPSExLG51bGwhPT1jP20oYyk6Zj0hMX19XG52YXIgdD1EYXRlLHU9XCJmdW5jdGlvblwiPT09dHlwZW9mIHNldFRpbWVvdXQ/c2V0VGltZW91dDp2b2lkIDAsdj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDp2b2lkIDAsdz1cImZ1bmN0aW9uXCI9PT10eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lP3JlcXVlc3RBbmltYXRpb25GcmFtZTp2b2lkIDAseD1cImZ1bmN0aW9uXCI9PT10eXBlb2YgY2FuY2VsQW5pbWF0aW9uRnJhbWU/Y2FuY2VsQW5pbWF0aW9uRnJhbWU6dm9pZCAwLHksejtmdW5jdGlvbiBBKGEpe3k9dyhmdW5jdGlvbihiKXt2KHopO2EoYil9KTt6PXUoZnVuY3Rpb24oKXt4KHkpO2EoZXhwb3J0cy51bnN0YWJsZV9ub3coKSl9LDEwMCl9aWYoZyl7dmFyIEI9cGVyZm9ybWFuY2U7ZXhwb3J0cy51bnN0YWJsZV9ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gQi5ub3coKX19ZWxzZSBleHBvcnRzLnVuc3RhYmxlX25vdz1mdW5jdGlvbigpe3JldHVybiB0Lm5vdygpfTt2YXIgcCxuLGg7XG5pZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvdyl7dmFyIEM9LTE7cD1mdW5jdGlvbihhKXtDPXNldFRpbWVvdXQoYSwwLCEwKX07bj1mdW5jdGlvbigpe2NsZWFyVGltZW91dChDKX07aD1mdW5jdGlvbigpe3JldHVybiAwfX1lbHNlIGlmKHdpbmRvdy5fc2NoZWRNb2NrKXt2YXIgRD13aW5kb3cuX3NjaGVkTW9jaztwPURbMF07bj1EWzFdO2g9RFsyXX1lbHNle1widW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSYmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiB3JiZjb25zb2xlLmVycm9yKFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgcG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vZmIubWUvcmVhY3QtcG9seWZpbGxzXCIpLFwiZnVuY3Rpb25cIiE9PXR5cGVvZiB4JiZjb25zb2xlLmVycm9yKFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBjYW5jZWxBbmltYXRpb25GcmFtZS4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSBwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHNcIikpO1xudmFyIEU9bnVsbCxGPSExLEc9LTEsSD0hMSxJPSExLEo9MCxLPTMzLEw9MzM7aD1mdW5jdGlvbigpe3JldHVybiBKfTt2YXIgTT1cIl9fcmVhY3RJZGxlQ2FsbGJhY2skXCIrTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsZnVuY3Rpb24oYSl7aWYoYS5zb3VyY2U9PT13aW5kb3cmJmEuZGF0YT09PU0pe0Y9ITE7dmFyIGI9ZXhwb3J0cy51bnN0YWJsZV9ub3coKTthPSExO2lmKDA+PUotYilpZigtMSE9PUcmJkc8PWIpYT0hMDtlbHNle0h8fChIPSEwLEEoTikpO3JldHVybn1HPS0xO2I9RTtFPW51bGw7aWYobnVsbCE9PWIpe0k9ITA7dHJ5e2IoYSl9ZmluYWxseXtJPSExfX19fSwhMSk7dmFyIE49ZnVuY3Rpb24oYSl7SD0hMTt2YXIgYj1hLUorTDtiPEwmJks8TD8oOD5iJiYoYj04KSxMPWI8Sz9LOmIpOks9YjtKPWErTDtGfHwoRj0hMCx3aW5kb3cucG9zdE1lc3NhZ2UoTSxcIipcIikpfTtwPWZ1bmN0aW9uKGEsXG5iKXtFPWE7Rz1iO0k/d2luZG93LnBvc3RNZXNzYWdlKE0sXCIqXCIpOkh8fChIPSEwLEEoTikpfTtuPWZ1bmN0aW9uKCl7RT1udWxsO0Y9ITE7Rz0tMX19ZXhwb3J0cy51bnN0YWJsZV9zY2hlZHVsZVdvcms9ZnVuY3Rpb24oYSxiKXt2YXIgZD1leHBvcnRzLnVuc3RhYmxlX25vdygpO2I9dm9pZCAwIT09YiYmbnVsbCE9PWImJm51bGwhPT1iLnRpbWVvdXQmJnZvaWQgMCE9PWIudGltZW91dD9kK2IudGltZW91dDpkKzVFMzthPXtjYWxsYmFjazphLHRpbWVzT3V0QXQ6YixuZXh0Om51bGwscHJldmlvdXM6bnVsbH07aWYobnVsbD09PWMpYz1hLm5leHQ9YS5wcmV2aW91cz1hLG0oYyk7ZWxzZXtkPW51bGw7dmFyIGs9Yztkb3tpZihrLnRpbWVzT3V0QXQ+Yil7ZD1rO2JyZWFrfWs9ay5uZXh0fXdoaWxlKGshPT1jKTtudWxsPT09ZD9kPWM6ZD09PWMmJihjPWEsbShjKSk7Yj1kLnByZXZpb3VzO2IubmV4dD1kLnByZXZpb3VzPWE7YS5uZXh0PWQ7YS5wcmV2aW91cz1ifXJldHVybiBhfTtcbmV4cG9ydHMudW5zdGFibGVfY2FuY2VsU2NoZWR1bGVkV29yaz1mdW5jdGlvbihhKXt2YXIgYj1hLm5leHQ7aWYobnVsbCE9PWIpe2lmKGI9PT1hKWM9bnVsbDtlbHNle2E9PT1jJiYoYz1iKTt2YXIgZD1hLnByZXZpb3VzO2QubmV4dD1iO2IucHJldmlvdXM9ZH1hLm5leHQ9YS5wcmV2aW91cz1udWxsfX07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvc2NoZWR1bGUvY2pzL3NjaGVkdWxlLnByb2R1Y3Rpb24ubWluLmpzIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi41LjJcbiAqIHNjaGVkdWxlLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuXG4vLyBUT0RPOiBDdXJyZW50bHkgdGhlcmUncyBvbmx5IGEgc2luZ2xlIHByaW9yaXR5IGxldmVsLCBEZWZlcnJlZC4gV2lsbCBhZGRcbi8vIGFkZGl0aW9uYWwgcHJpb3JpdGllcy5cbnZhciBERUZFUlJFRF9USU1FT1VUID0gNTAwMDtcblxuLy8gQ2FsbGJhY2tzIGFyZSBzdG9yZWQgYXMgYSBjaXJjdWxhciwgZG91Ymx5IGxpbmtlZCBsaXN0LlxudmFyIGZpcnN0Q2FsbGJhY2tOb2RlID0gbnVsbDtcblxudmFyIGlzUGVyZm9ybWluZ1dvcmsgPSBmYWxzZTtcblxudmFyIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG5cbnZhciBoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdyA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIHRpbWVSZW1haW5pbmc7XG5pZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgdGltZVJlbWFpbmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBXZSBhc3N1bWUgdGhhdCBpZiB3ZSBoYXZlIGEgcGVyZm9ybWFuY2UgdGltZXIgdGhhdCB0aGUgckFGIGNhbGxiYWNrXG4gICAgLy8gZ2V0cyBhIHBlcmZvcm1hbmNlIHRpbWVyIHZhbHVlLiBOb3Qgc3VyZSBpZiB0aGlzIGlzIGFsd2F5cyB0cnVlLlxuICAgIHZhciByZW1haW5pbmcgPSBnZXRGcmFtZURlYWRsaW5lKCkgLSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICByZXR1cm4gcmVtYWluaW5nID4gMCA/IHJlbWFpbmluZyA6IDA7XG4gIH07XG59IGVsc2Uge1xuICB0aW1lUmVtYWluaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEZhbGxiYWNrIHRvIERhdGUubm93KClcbiAgICB2YXIgcmVtYWluaW5nID0gZ2V0RnJhbWVEZWFkbGluZSgpIC0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gcmVtYWluaW5nID4gMCA/IHJlbWFpbmluZyA6IDA7XG4gIH07XG59XG5cbnZhciBkZWFkbGluZU9iamVjdCA9IHtcbiAgdGltZVJlbWFpbmluZzogdGltZVJlbWFpbmluZyxcbiAgZGlkVGltZW91dDogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIGVuc3VyZUhvc3RDYWxsYmFja0lzU2NoZWR1bGVkKCkge1xuICBpZiAoaXNQZXJmb3JtaW5nV29yaykge1xuICAgIC8vIERvbid0IHNjaGVkdWxlIHdvcmsgeWV0OyB3YWl0IHVudGlsIHRoZSBuZXh0IHRpbWUgd2UgeWllbGQuXG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFNjaGVkdWxlIHRoZSBob3N0IGNhbGxiYWNrIHVzaW5nIHRoZSBlYXJsaWVzdCB0aW1lb3V0IGluIHRoZSBsaXN0LlxuICB2YXIgdGltZXNPdXRBdCA9IGZpcnN0Q2FsbGJhY2tOb2RlLnRpbWVzT3V0QXQ7XG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQpIHtcbiAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FuY2VsIHRoZSBleGlzdGluZyBob3N0IGNhbGxiYWNrLlxuICAgIGNhbmNlbENhbGxiYWNrKCk7XG4gIH1cbiAgcmVxdWVzdENhbGxiYWNrKGZsdXNoV29yaywgdGltZXNPdXRBdCk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoRmlyc3RDYWxsYmFjayhub2RlKSB7XG4gIHZhciBmbHVzaGVkTm9kZSA9IGZpcnN0Q2FsbGJhY2tOb2RlO1xuXG4gIC8vIFJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSBsaXN0IGJlZm9yZSBjYWxsaW5nIHRoZSBjYWxsYmFjay4gVGhhdCB3YXkgdGhlXG4gIC8vIGxpc3QgaXMgaW4gYSBjb25zaXN0ZW50IHN0YXRlIGV2ZW4gaWYgdGhlIGNhbGxiYWNrIHRocm93cy5cbiAgdmFyIG5leHQgPSBmaXJzdENhbGxiYWNrTm9kZS5uZXh0O1xuICBpZiAoZmlyc3RDYWxsYmFja05vZGUgPT09IG5leHQpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBsYXN0IGNhbGxiYWNrIGluIHRoZSBsaXN0LlxuICAgIGZpcnN0Q2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgICBuZXh0ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcHJldmlvdXMgPSBmaXJzdENhbGxiYWNrTm9kZS5wcmV2aW91cztcbiAgICBmaXJzdENhbGxiYWNrTm9kZSA9IHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgfVxuXG4gIGZsdXNoZWROb2RlLm5leHQgPSBmbHVzaGVkTm9kZS5wcmV2aW91cyA9IG51bGw7XG5cbiAgLy8gTm93IGl0J3Mgc2FmZSB0byBjYWxsIHRoZSBjYWxsYmFjay5cbiAgdmFyIGNhbGxiYWNrID0gZmx1c2hlZE5vZGUuY2FsbGJhY2s7XG4gIGNhbGxiYWNrKGRlYWRsaW5lT2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gZmx1c2hXb3JrKGRpZFRpbWVvdXQpIHtcbiAgaXNQZXJmb3JtaW5nV29yayA9IHRydWU7XG4gIGRlYWRsaW5lT2JqZWN0LmRpZFRpbWVvdXQgPSBkaWRUaW1lb3V0O1xuICB0cnkge1xuICAgIGlmIChkaWRUaW1lb3V0KSB7XG4gICAgICAvLyBGbHVzaCBhbGwgdGhlIHRpbWVkIG91dCBjYWxsYmFja3Mgd2l0aG91dCB5aWVsZGluZy5cbiAgICAgIHdoaWxlIChmaXJzdENhbGxiYWNrTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBSZWFkIHRoZSBjdXJyZW50IHRpbWUuIEZsdXNoIGFsbCB0aGUgY2FsbGJhY2tzIHRoYXQgZXhwaXJlIGF0IG9yXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGF0IHRpbWUuIFRoZW4gcmVhZCB0aGUgY3VycmVudCB0aW1lIGFnYWluIGFuZCByZXBlYXQuXG4gICAgICAgIC8vIFRoaXMgb3B0aW1pemVzIGZvciBhcyBmZXcgcGVyZm9ybWFuY2Uubm93IGNhbGxzIGFzIHBvc3NpYmxlLlxuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgICBpZiAoZmlyc3RDYWxsYmFja05vZGUudGltZXNPdXRBdCA8PSBjdXJyZW50VGltZSkge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGZsdXNoRmlyc3RDYWxsYmFjaygpO1xuICAgICAgICAgIH0gd2hpbGUgKGZpcnN0Q2FsbGJhY2tOb2RlICE9PSBudWxsICYmIGZpcnN0Q2FsbGJhY2tOb2RlLnRpbWVzT3V0QXQgPD0gY3VycmVudFRpbWUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBLZWVwIGZsdXNoaW5nIGNhbGxiYWNrcyB1bnRpbCB3ZSBydW4gb3V0IG9mIHRpbWUgaW4gdGhlIGZyYW1lLlxuICAgICAgaWYgKGZpcnN0Q2FsbGJhY2tOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBmbHVzaEZpcnN0Q2FsbGJhY2soKTtcbiAgICAgICAgfSB3aGlsZSAoZmlyc3RDYWxsYmFja05vZGUgIT09IG51bGwgJiYgZ2V0RnJhbWVEZWFkbGluZSgpIC0gZXhwb3J0cy51bnN0YWJsZV9ub3coKSA+IDApO1xuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBpc1BlcmZvcm1pbmdXb3JrID0gZmFsc2U7XG4gICAgaWYgKGZpcnN0Q2FsbGJhY2tOb2RlICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGVyZSdzIHN0aWxsIHdvcmsgcmVtYWluaW5nLiBSZXF1ZXN0IGFub3RoZXIgY2FsbGJhY2suXG4gICAgICBlbnN1cmVIb3N0Q2FsbGJhY2tJc1NjaGVkdWxlZChmaXJzdENhbGxiYWNrTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3NjaGVkdWxlV29yayhjYWxsYmFjaywgb3B0aW9ucykge1xuICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuXG4gIHZhciB0aW1lc091dEF0O1xuICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucy50aW1lb3V0ICE9PSBudWxsICYmIG9wdGlvbnMudGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gQ2hlY2sgZm9yIGFuIGV4cGxpY2l0IHRpbWVvdXRcbiAgICB0aW1lc091dEF0ID0gY3VycmVudFRpbWUgKyBvcHRpb25zLnRpbWVvdXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcHV0ZSBhbiBhYnNvbHV0ZSB0aW1lb3V0IHVzaW5nIHRoZSBkZWZhdWx0IGNvbnN0YW50LlxuICAgIHRpbWVzT3V0QXQgPSBjdXJyZW50VGltZSArIERFRkVSUkVEX1RJTUVPVVQ7XG4gIH1cblxuICB2YXIgbmV3Tm9kZSA9IHtcbiAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgdGltZXNPdXRBdDogdGltZXNPdXRBdCxcbiAgICBuZXh0OiBudWxsLFxuICAgIHByZXZpb3VzOiBudWxsXG4gIH07XG5cbiAgLy8gSW5zZXJ0IHRoZSBuZXcgY2FsbGJhY2sgaW50byB0aGUgbGlzdCwgc29ydGVkIGJ5IGl0cyB0aW1lb3V0LlxuICBpZiAoZmlyc3RDYWxsYmFja05vZGUgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBjYWxsYmFjayBpbiB0aGUgbGlzdC5cbiAgICBmaXJzdENhbGxiYWNrTm9kZSA9IG5ld05vZGUubmV4dCA9IG5ld05vZGUucHJldmlvdXMgPSBuZXdOb2RlO1xuICAgIGVuc3VyZUhvc3RDYWxsYmFja0lzU2NoZWR1bGVkKGZpcnN0Q2FsbGJhY2tOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV4dCA9IG51bGw7XG4gICAgdmFyIG5vZGUgPSBmaXJzdENhbGxiYWNrTm9kZTtcbiAgICBkbyB7XG4gICAgICBpZiAobm9kZS50aW1lc091dEF0ID4gdGltZXNPdXRBdCkge1xuICAgICAgICAvLyBUaGUgbmV3IGNhbGxiYWNrIHRpbWVzIG91dCBiZWZvcmUgdGhpcyBvbmUuXG4gICAgICAgIG5leHQgPSBub2RlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfSB3aGlsZSAobm9kZSAhPT0gZmlyc3RDYWxsYmFja05vZGUpO1xuXG4gICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgIC8vIE5vIGNhbGxiYWNrIHdpdGggYSBsYXRlciB0aW1lb3V0IHdhcyBmb3VuZCwgd2hpY2ggbWVhbnMgdGhlIG5ld1xuICAgICAgLy8gY2FsbGJhY2sgaGFzIHRoZSBsYXRlc3QgdGltZW91dCBpbiB0aGUgbGlzdC5cbiAgICAgIG5leHQgPSBmaXJzdENhbGxiYWNrTm9kZTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IGZpcnN0Q2FsbGJhY2tOb2RlKSB7XG4gICAgICAvLyBUaGUgbmV3IGNhbGxiYWNrIGhhcyB0aGUgZWFybGllc3QgdGltZW91dCBpbiB0aGUgZW50aXJlIGxpc3QuXG4gICAgICBmaXJzdENhbGxiYWNrTm9kZSA9IG5ld05vZGU7XG4gICAgICBlbnN1cmVIb3N0Q2FsbGJhY2tJc1NjaGVkdWxlZChmaXJzdENhbGxiYWNrTm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzID0gbmV4dC5wcmV2aW91cztcbiAgICBwcmV2aW91cy5uZXh0ID0gbmV4dC5wcmV2aW91cyA9IG5ld05vZGU7XG4gICAgbmV3Tm9kZS5uZXh0ID0gbmV4dDtcbiAgICBuZXdOb2RlLnByZXZpb3VzID0gcHJldmlvdXM7XG4gIH1cblxuICByZXR1cm4gbmV3Tm9kZTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfY2FuY2VsU2NoZWR1bGVkV29yayhjYWxsYmFja05vZGUpIHtcbiAgdmFyIG5leHQgPSBjYWxsYmFja05vZGUubmV4dDtcbiAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAvLyBBbHJlYWR5IGNhbmNlbGxlZC5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAobmV4dCA9PT0gY2FsbGJhY2tOb2RlKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgb25seSBzY2hlZHVsZWQgY2FsbGJhY2suIENsZWFyIHRoZSBsaXN0LlxuICAgIGZpcnN0Q2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gaXRzIHBvc2l0aW9uIGluIHRoZSBsaXN0LlxuICAgIGlmIChjYWxsYmFja05vZGUgPT09IGZpcnN0Q2FsbGJhY2tOb2RlKSB7XG4gICAgICBmaXJzdENhbGxiYWNrTm9kZSA9IG5leHQ7XG4gICAgfVxuICAgIHZhciBwcmV2aW91cyA9IGNhbGxiYWNrTm9kZS5wcmV2aW91cztcbiAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcbiAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG4gIH1cblxuICBjYWxsYmFja05vZGUubmV4dCA9IGNhbGxiYWNrTm9kZS5wcmV2aW91cyA9IG51bGw7XG59XG5cbi8vIFRoZSByZW1haW5pbmcgY29kZSBpcyBlc3NlbnRpYWxseSBhIHBvbHlmaWxsIGZvciByZXF1ZXN0SWRsZUNhbGxiYWNrLiBJdFxuLy8gd29ya3MgYnkgc2NoZWR1bGluZyBhIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgc3RvcmluZyB0aGUgdGltZSBmb3IgdGhlIHN0YXJ0XG4vLyBvZiB0aGUgZnJhbWUsIHRoZW4gc2NoZWR1bGluZyBhIHBvc3RNZXNzYWdlIHdoaWNoIGdldHMgc2NoZWR1bGVkIGFmdGVyIHBhaW50LlxuLy8gV2l0aGluIHRoZSBwb3N0TWVzc2FnZSBoYW5kbGVyIGRvIGFzIG11Y2ggd29yayBhcyBwb3NzaWJsZSB1bnRpbCB0aW1lICsgZnJhbWVcbi8vIHJhdGUuIEJ5IHNlcGFyYXRpbmcgdGhlIGlkbGUgY2FsbCBpbnRvIGEgc2VwYXJhdGUgZXZlbnQgdGljayB3ZSBlbnN1cmUgdGhhdFxuLy8gbGF5b3V0LCBwYWludCBhbmQgb3RoZXIgYnJvd3NlciB3b3JrIGlzIGNvdW50ZWQgYWdhaW5zdCB0aGUgYXZhaWxhYmxlIHRpbWUuXG4vLyBUaGUgZnJhbWUgcmF0ZSBpcyBkeW5hbWljYWxseSBhZGp1c3RlZC5cblxuLy8gV2UgY2FwdHVyZSBhIGxvY2FsIHJlZmVyZW5jZSB0byBhbnkgZ2xvYmFsLCBpbiBjYXNlIGl0IGdldHMgcG9seWZpbGxlZCBhZnRlclxuLy8gdGhpcyBtb2R1bGUgaXMgaW5pdGlhbGx5IGV2YWx1YXRlZC4gV2Ugd2FudCB0byBiZSB1c2luZyBhXG4vLyBjb25zaXN0ZW50IGltcGxlbWVudGF0aW9uLlxudmFyIGxvY2FsRGF0ZSA9IERhdGU7XG5cbi8vIFRoaXMgaW5pdGlhbGl6YXRpb24gY29kZSBtYXkgcnVuIGV2ZW4gb24gc2VydmVyIGVudmlyb25tZW50cyBpZiBhIGNvbXBvbmVudFxuLy8ganVzdCBpbXBvcnRzIFJlYWN0RE9NIChlLmcuIGZvciBmaW5kRE9NTm9kZSkuIFNvbWUgZW52aXJvbm1lbnRzIG1pZ2h0IG5vdFxuLy8gaGF2ZSBzZXRUaW1lb3V0IG9yIGNsZWFyVGltZW91dC4gSG93ZXZlciwgd2UgYWx3YXlzIGV4cGVjdCB0aGVtIHRvIGJlIGRlZmluZWRcbi8vIG9uIHRoZSBjbGllbnQuIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEzMDg4XG52YXIgbG9jYWxTZXRUaW1lb3V0ID0gdHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBzZXRUaW1lb3V0IDogdW5kZWZpbmVkO1xudmFyIGxvY2FsQ2xlYXJUaW1lb3V0ID0gdHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IGNsZWFyVGltZW91dCA6IHVuZGVmaW5lZDtcblxuLy8gV2UgZG9uJ3QgZXhwZWN0IGVpdGhlciBvZiB0aGVzZSB0byBuZWNlc3NhcmlseSBiZSBkZWZpbmVkLCBidXQgd2Ugd2lsbCBlcnJvclxuLy8gbGF0ZXIgaWYgdGhleSBhcmUgbWlzc2luZyBvbiB0aGUgY2xpZW50LlxudmFyIGxvY2FsUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJyA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHVuZGVmaW5lZDtcbnZhciBsb2NhbENhbmNlbEFuaW1hdGlvbkZyYW1lID0gdHlwZW9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nID8gY2FuY2VsQW5pbWF0aW9uRnJhbWUgOiB1bmRlZmluZWQ7XG5cbi8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSBkb2VzIG5vdCBydW4gd2hlbiB0aGUgdGFiIGlzIGluIHRoZSBiYWNrZ3JvdW5kLiBJZlxuLy8gd2UncmUgYmFja2dyb3VuZGVkIHdlIHByZWZlciBmb3IgdGhhdCB3b3JrIHRvIGhhcHBlbiBzbyB0aGF0IHRoZSBwYWdlXG4vLyBjb250aW51ZXMgdG8gbG9hZCBpbiB0aGUgYmFja2dyb3VuZC4gU28gd2UgYWxzbyBzY2hlZHVsZSBhICdzZXRUaW1lb3V0JyBhc1xuLy8gYSBmYWxsYmFjay5cbi8vIFRPRE86IE5lZWQgYSBiZXR0ZXIgaGV1cmlzdGljIGZvciBiYWNrZ3JvdW5kZWQgd29yay5cbnZhciBBTklNQVRJT05fRlJBTUVfVElNRU9VVCA9IDEwMDtcbnZhciByQUZJRDtcbnZhciByQUZUaW1lb3V0SUQ7XG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lV2l0aFRpbWVvdXQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgLy8gc2NoZWR1bGUgckFGIGFuZCBhbHNvIGEgc2V0VGltZW91dFxuICByQUZJRCA9IGxvY2FsUmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgICAvLyBjYW5jZWwgdGhlIHNldFRpbWVvdXRcbiAgICBsb2NhbENsZWFyVGltZW91dChyQUZUaW1lb3V0SUQpO1xuICAgIGNhbGxiYWNrKHRpbWVzdGFtcCk7XG4gIH0pO1xuICByQUZUaW1lb3V0SUQgPSBsb2NhbFNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIC8vIGNhbmNlbCB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgbG9jYWxDYW5jZWxBbmltYXRpb25GcmFtZShyQUZJRCk7XG4gICAgY2FsbGJhY2soZXhwb3J0cy51bnN0YWJsZV9ub3coKSk7XG4gIH0sIEFOSU1BVElPTl9GUkFNRV9USU1FT1VUKTtcbn07XG5cbmlmIChoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdykge1xuICB2YXIgUGVyZm9ybWFuY2UgPSBwZXJmb3JtYW5jZTtcbiAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxvY2FsRGF0ZS5ub3coKTtcbiAgfTtcbn1cblxudmFyIHJlcXVlc3RDYWxsYmFjaztcbnZhciBjYW5jZWxDYWxsYmFjaztcbnZhciBnZXRGcmFtZURlYWRsaW5lO1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gSWYgdGhpcyBhY2NpZGVudGFsbHkgZ2V0cyBpbXBvcnRlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LCBmYWxsYmFja1xuICAvLyB0byBhIG5haXZlIGltcGxlbWVudGF0aW9uLlxuICB2YXIgdGltZW91dElEID0gLTE7XG4gIHJlcXVlc3RDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgYWJzb2x1dGVUaW1lb3V0KSB7XG4gICAgdGltZW91dElEID0gc2V0VGltZW91dChjYWxsYmFjaywgMCwgdHJ1ZSk7XG4gIH07XG4gIGNhbmNlbENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICB9O1xuICBnZXRGcmFtZURlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAwO1xuICB9O1xufSBlbHNlIGlmICh3aW5kb3cuX3NjaGVkTW9jaykge1xuICAvLyBEeW5hbWljIGluamVjdGlvbiwgb25seSBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAgdmFyIGltcGwgPSB3aW5kb3cuX3NjaGVkTW9jaztcbiAgcmVxdWVzdENhbGxiYWNrID0gaW1wbFswXTtcbiAgY2FuY2VsQ2FsbGJhY2sgPSBpbXBsWzFdO1xuICBnZXRGcmFtZURlYWRsaW5lID0gaW1wbFsyXTtcbn0gZWxzZSB7XG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIGxvY2FsUmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIFwiICsgJ01ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsb2NhbENhbmNlbEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBjYW5jZWxBbmltYXRpb25GcmFtZS4gXCIgKyAnTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzY2hlZHVsZWRDYWxsYmFjayA9IG51bGw7XG4gIHZhciBpc0lkbGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdmFyIHRpbWVvdXRUaW1lID0gLTE7XG5cbiAgdmFyIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICB2YXIgaXNQZXJmb3JtaW5nSWRsZVdvcmsgPSBmYWxzZTtcblxuICB2YXIgZnJhbWVEZWFkbGluZSA9IDA7XG4gIC8vIFdlIHN0YXJ0IG91dCBhc3N1bWluZyB0aGF0IHdlIHJ1biBhdCAzMGZwcyBidXQgdGhlbiB0aGUgaGV1cmlzdGljIHRyYWNraW5nXG4gIC8vIHdpbGwgYWRqdXN0IHRoaXMgdmFsdWUgdG8gYSBmYXN0ZXIgZnBzIGlmIHdlIGdldCBtb3JlIGZyZXF1ZW50IGFuaW1hdGlvblxuICAvLyBmcmFtZXMuXG4gIHZhciBwcmV2aW91c0ZyYW1lVGltZSA9IDMzO1xuICB2YXIgYWN0aXZlRnJhbWVUaW1lID0gMzM7XG5cbiAgZ2V0RnJhbWVEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnJhbWVEZWFkbGluZTtcbiAgfTtcblxuICAvLyBXZSB1c2UgdGhlIHBvc3RNZXNzYWdlIHRyaWNrIHRvIGRlZmVyIGlkbGUgd29yayB1bnRpbCBhZnRlciB0aGUgcmVwYWludC5cbiAgdmFyIG1lc3NhZ2VLZXkgPSAnX19yZWFjdElkbGVDYWxsYmFjayQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG4gIHZhciBpZGxlVGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5zb3VyY2UgIT09IHdpbmRvdyB8fCBldmVudC5kYXRhICE9PSBtZXNzYWdlS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuXG4gICAgdmFyIGRpZFRpbWVvdXQgPSBmYWxzZTtcbiAgICBpZiAoZnJhbWVEZWFkbGluZSAtIGN1cnJlbnRUaW1lIDw9IDApIHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0IGluIHRoaXMgaWRsZSBwZXJpb2QuIENoZWNrIGlmIHRoZSBjYWxsYmFjayBoYXNcbiAgICAgIC8vIGEgdGltZW91dCBhbmQgd2hldGhlciBpdCdzIGJlZW4gZXhjZWVkZWQuXG4gICAgICBpZiAodGltZW91dFRpbWUgIT09IC0xICYmIHRpbWVvdXRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIC8vIEV4Y2VlZGVkIHRoZSB0aW1lb3V0LiBJbnZva2UgdGhlIGNhbGxiYWNrIGV2ZW4gdGhvdWdoIHRoZXJlJ3Mgbm9cbiAgICAgICAgLy8gdGltZSBsZWZ0LlxuICAgICAgICBkaWRUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIHRpbWVvdXQuXG4gICAgICAgIGlmICghaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCkge1xuICAgICAgICAgIC8vIFNjaGVkdWxlIGFub3RoZXIgYW5pbWF0aW9uIGNhbGxiYWNrIHNvIHdlIHJldHJ5IGxhdGVyLlxuICAgICAgICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZVdpdGhUaW1lb3V0KGFuaW1hdGlvblRpY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4aXQgd2l0aG91dCBpbnZva2luZyB0aGUgY2FsbGJhY2suXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aW1lb3V0VGltZSA9IC0xO1xuICAgIHZhciBjYWxsYmFjayA9IHNjaGVkdWxlZENhbGxiYWNrO1xuICAgIHNjaGVkdWxlZENhbGxiYWNrID0gbnVsbDtcbiAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIGlzUGVyZm9ybWluZ0lkbGVXb3JrID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNhbGxiYWNrKGRpZFRpbWVvdXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaXNQZXJmb3JtaW5nSWRsZVdvcmsgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIEFzc3VtZXMgdGhhdCB3ZSBoYXZlIGFkZEV2ZW50TGlzdGVuZXIgaW4gdGhpcyBlbnZpcm9ubWVudC4gTWlnaHQgbmVlZFxuICAvLyBzb21ldGhpbmcgYmV0dGVyIGZvciBvbGQgSUUuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaWRsZVRpY2ssIGZhbHNlKTtcblxuICB2YXIgYW5pbWF0aW9uVGljayA9IGZ1bmN0aW9uIChyYWZUaW1lKSB7XG4gICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0RnJhbWVUaW1lID0gcmFmVGltZSAtIGZyYW1lRGVhZGxpbmUgKyBhY3RpdmVGcmFtZVRpbWU7XG4gICAgaWYgKG5leHRGcmFtZVRpbWUgPCBhY3RpdmVGcmFtZVRpbWUgJiYgcHJldmlvdXNGcmFtZVRpbWUgPCBhY3RpdmVGcmFtZVRpbWUpIHtcbiAgICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgOCkge1xuICAgICAgICAvLyBEZWZlbnNpdmUgY29kaW5nLiBXZSBkb24ndCBzdXBwb3J0IGhpZ2hlciBmcmFtZSByYXRlcyB0aGFuIDEyMGh6LlxuICAgICAgICAvLyBJZiB3ZSBnZXQgbG93ZXIgdGhhbiB0aGF0LCBpdCBpcyBwcm9iYWJseSBhIGJ1Zy5cbiAgICAgICAgbmV4dEZyYW1lVGltZSA9IDg7XG4gICAgICB9XG4gICAgICAvLyBJZiBvbmUgZnJhbWUgZ29lcyBsb25nLCB0aGVuIHRoZSBuZXh0IG9uZSBjYW4gYmUgc2hvcnQgdG8gY2F0Y2ggdXAuXG4gICAgICAvLyBJZiB0d28gZnJhbWVzIGFyZSBzaG9ydCBpbiBhIHJvdywgdGhlbiB0aGF0J3MgYW4gaW5kaWNhdGlvbiB0aGF0IHdlXG4gICAgICAvLyBhY3R1YWxseSBoYXZlIGEgaGlnaGVyIGZyYW1lIHJhdGUgdGhhbiB3aGF0IHdlJ3JlIGN1cnJlbnRseSBvcHRpbWl6aW5nLlxuICAgICAgLy8gV2UgYWRqdXN0IG91ciBoZXVyaXN0aWMgZHluYW1pY2FsbHkgYWNjb3JkaW5nbHkuIEZvciBleGFtcGxlLCBpZiB3ZSdyZVxuICAgICAgLy8gcnVubmluZyBvbiAxMjBoeiBkaXNwbGF5IG9yIDkwaHogVlIgZGlzcGxheS5cbiAgICAgIC8vIFRha2UgdGhlIG1heCBvZiB0aGUgdHdvIGluIGNhc2Ugb25lIG9mIHRoZW0gd2FzIGFuIGFub21hbHkgZHVlIHRvXG4gICAgICAvLyBtaXNzZWQgZnJhbWUgZGVhZGxpbmVzLlxuICAgICAgYWN0aXZlRnJhbWVUaW1lID0gbmV4dEZyYW1lVGltZSA8IHByZXZpb3VzRnJhbWVUaW1lID8gcHJldmlvdXNGcmFtZVRpbWUgOiBuZXh0RnJhbWVUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2aW91c0ZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWU7XG4gICAgfVxuICAgIGZyYW1lRGVhZGxpbmUgPSByYWZUaW1lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmICghaXNJZGxlU2NoZWR1bGVkKSB7XG4gICAgICBpc0lkbGVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgd2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2VLZXksICcqJyk7XG4gICAgfVxuICB9O1xuXG4gIHJlcXVlc3RDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgYWJzb2x1dGVUaW1lb3V0KSB7XG4gICAgc2NoZWR1bGVkQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aW1lb3V0VGltZSA9IGFic29sdXRlVGltZW91dDtcbiAgICBpZiAoaXNQZXJmb3JtaW5nSWRsZVdvcmspIHtcbiAgICAgIC8vIElmIHdlJ3JlIGFscmVhZHkgcGVyZm9ybWluZyBpZGxlIHdvcmssIGFuIGVycm9yIG11c3QgaGF2ZSBiZWVuIHRocm93bi5cbiAgICAgIC8vIERvbid0IHdhaXQgZm9yIHRoZSBuZXh0IGZyYW1lLiBDb250aW51ZSB3b3JraW5nIEFTQVAsIGluIGEgbmV3IGV2ZW50LlxuICAgICAgd2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2VLZXksICcqJyk7XG4gICAgfSBlbHNlIGlmICghaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCkge1xuICAgICAgLy8gSWYgckFGIGRpZG4ndCBhbHJlYWR5IHNjaGVkdWxlIG9uZSwgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGZyYW1lLlxuICAgICAgLy8gVE9ETzogSWYgdGhpcyByQUYgZG9lc24ndCBtYXRlcmlhbGl6ZSBiZWNhdXNlIHRoZSBicm93c2VyIHRocm90dGxlcywgd2VcbiAgICAgIC8vIG1pZ2h0IHdhbnQgdG8gc3RpbGwgaGF2ZSBzZXRUaW1lb3V0IHRyaWdnZXIgcklDIGFzIGEgYmFja3VwIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB3ZSBrZWVwIHBlcmZvcm1pbmcgd29yay5cbiAgICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lV2l0aFRpbWVvdXQoYW5pbWF0aW9uVGljayk7XG4gICAgfVxuICB9O1xuXG4gIGNhbmNlbENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIHNjaGVkdWxlZENhbGxiYWNrID0gbnVsbDtcbiAgICBpc0lkbGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB0aW1lb3V0VGltZSA9IC0xO1xuICB9O1xufVxuXG5leHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlV29yayA9IHVuc3RhYmxlX3NjaGVkdWxlV29yaztcbmV4cG9ydHMudW5zdGFibGVfY2FuY2VsU2NoZWR1bGVkV29yayA9IHVuc3RhYmxlX2NhbmNlbFNjaGVkdWxlZFdvcms7XG4gIH0pKCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvc2NoZWR1bGUvY2pzL3NjaGVkdWxlLmRldmVsb3BtZW50LmpzIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi41LjJcbiAqIHJlYWN0LWRvbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzJyk7XG52YXIgc2NoZWR1bGUgPSByZXF1aXJlKCdzY2hlZHVsZScpO1xudmFyIHRyYWNpbmcgPSByZXF1aXJlKCdzY2hlZHVsZS90cmFjaW5nJyk7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIFJlbHlpbmcgb24gdGhlIGBpbnZhcmlhbnQoKWAgaW1wbGVtZW50YXRpb24gbGV0cyB1c1xuLy8gcHJlc2VydmUgdGhlIGZvcm1hdCBhbmQgcGFyYW1zIGluIHRoZSB3d3cgYnVpbGRzLlxuXG4hUmVhY3QgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTSB3YXMgbG9hZGVkIGJlZm9yZSBSZWFjdC4gTWFrZSBzdXJlIHlvdSBsb2FkIHRoZSBSZWFjdCBwYWNrYWdlIGJlZm9yZSBsb2FkaW5nIFJlYWN0RE9NLicpIDogdm9pZCAwO1xuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG4gIHRyeSB7XG4gICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgfVxufTtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bnRpbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuICAvLyB0aGUgZGV2ZWxvcGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBlcnJvciBpcyB1bmNhdWdodC5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuICAvLyB0cnktY2F0Y2ggaW4gREVWLiBJbnN0ZWFkLCB3ZSBzeW5jaHJvbm91c2x5IGRpc3BhdGNoIGEgZmFrZSBldmVudCB0byBhIGZha2VcbiAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbiAgLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuICAvLyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLiBCdXQgYmVjYXVzZSB0aGUgZXJyb3IgaGFwcGVucyBpbiBhIGRpZmZlcmVudFxuICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbiAgLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbiAgLy8gdHJ5LWNhdGNoLiBOZWF0IVxuXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgdmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0RldiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBJZiBkb2N1bWVudCBkb2Vzbid0IGV4aXN0IHdlIGtub3cgZm9yIHN1cmUgd2Ugd2lsbCBjcmFzaCBpbiB0aGlzIG1ldGhvZFxuICAgICAgLy8gd2hlbiB3ZSBjYWxsIGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkuIEhvd2V2ZXIgdGhpcyBjYW4gY2F1c2UgY29uZnVzaW5nXG4gICAgICAvLyBlcnJvcnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2luY3ViYXRvci9jcmVhdGUtcmVhY3QtYXBwL2lzc3Vlcy8zNDgyXG4gICAgICAvLyBTbyB3ZSBwcmVlbXB0aXZlbHkgdGhyb3cgd2l0aCBhIGJldHRlciBtZXNzYWdlIGluc3RlYWQuXG4gICAgICAhKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBkb2N1bWVudGAgZ2xvYmFsIHdhcyBkZWZpbmVkIHdoZW4gUmVhY3Qgd2FzIGluaXRpYWxpemVkLCBidXQgaXMgbm90IGRlZmluZWQgYW55bW9yZS4gVGhpcyBjYW4gaGFwcGVuIGluIGEgdGVzdCBlbnZpcm9ubWVudCBpZiBhIGNvbXBvbmVudCBzY2hlZHVsZXMgYW4gdXBkYXRlIGZyb20gYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrLCBidXQgdGhlIHRlc3QgaGFzIGFscmVhZHkgZmluaXNoZWQgcnVubmluZy4gVG8gc29sdmUgdGhpcywgeW91IGNhbiBlaXRoZXIgdW5tb3VudCB0aGUgY29tcG9uZW50IGF0IHRoZSBlbmQgb2YgeW91ciB0ZXN0IChhbmQgZW5zdXJlIHRoYXQgYW55IGFzeW5jaHJvbm91cyBvcGVyYXRpb25zIGdldCBjYW5jZWxlZCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgKSwgb3IgeW91IGNhbiBjaGFuZ2UgdGhlIHRlc3QgaXRzZWxmIHRvIGJlIGFzeW5jaHJvbm91cy4nKSA6IHZvaWQgMDtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcblxuICAgICAgLy8gS2VlcHMgdHJhY2sgb2Ygd2hldGhlciB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjayB0aHJldyBhbiBlcnJvci4gV2VcbiAgICAgIC8vIHNldCB0aGlzIHRvIHRydWUgYXQgdGhlIGJlZ2lubmluZywgdGhlbiBzZXQgaXQgdG8gZmFsc2UgcmlnaHQgYWZ0ZXJcbiAgICAgIC8vIGNhbGxpbmcgdGhlIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gZXJyb3JzLCBgZGlkRXJyb3JgIHdpbGwgbmV2ZXIgYmVcbiAgICAgIC8vIHNldCB0byBmYWxzZS4gVGhpcyBzdHJhdGVneSB3b3JrcyBldmVuIGlmIHRoZSBicm93c2VyIGlzIGZsYWt5IGFuZFxuICAgICAgLy8gZmFpbHMgdG8gY2FsbCBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIsIGJlY2F1c2UgaXQgZG9lc24ndCByZWx5IG9uXG4gICAgICAvLyB0aGUgZXJyb3IgZXZlbnQgYXQgYWxsLlxuICAgICAgdmFyIGRpZEVycm9yID0gdHJ1ZTtcblxuICAgICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHZhbHVlIG9mIHdpbmRvdy5ldmVudCBzbyB0aGF0IHdlIGNhbiByZXNldCBpdFxuICAgICAgLy8gZHVyaW5nIHRoZSBjYWxsYmFjayB0byBsZXQgdXNlciBjb2RlIGFjY2VzcyB3aW5kb3cuZXZlbnQgaW4gdGhlXG4gICAgICAvLyBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQuXG4gICAgICB2YXIgd2luZG93RXZlbnQgPSB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgIC8vIENyZWF0ZSBhbiBldmVudCBoYW5kbGVyIGZvciBvdXIgZmFrZSBldmVudC4gV2Ugd2lsbCBzeW5jaHJvbm91c2x5XG4gICAgICAvLyBkaXNwYXRjaCBvdXIgZmFrZSBldmVudCB1c2luZyBgZGlzcGF0Y2hFdmVudGAuIEluc2lkZSB0aGUgaGFuZGxlciwgd2VcbiAgICAgIC8vIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2suXG4gICAgICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICAgICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrKCkge1xuICAgICAgICAvLyBXZSBpbW1lZGlhdGVseSByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXRcbiAgICAgICAgLy8gbmVzdGVkIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIGNhbGxzIGRvIG5vdCBjbGFzaC4gT3RoZXJ3aXNlLCBhXG4gICAgICAgIC8vIG5lc3RlZCBjYWxsIHdvdWxkIHRyaWdnZXIgdGhlIGZha2UgZXZlbnQgaGFuZGxlcnMgb2YgYW55IGNhbGwgaGlnaGVyXG4gICAgICAgIC8vIGluIHRoZSBzdGFjay5cbiAgICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTtcblxuICAgICAgICAvLyBXZSBjaGVjayBmb3Igd2luZG93Lmhhc093blByb3BlcnR5KCdldmVudCcpIHRvIHByZXZlbnQgdGhlXG4gICAgICAgIC8vIHdpbmRvdy5ldmVudCBhc3NpZ25tZW50IGluIGJvdGggSUUgPD0gMTAgYXMgdGhleSB0aHJvdyBhbiBlcnJvclxuICAgICAgICAvLyBcIk1lbWJlciBub3QgZm91bmRcIiBpbiBzdHJpY3QgbW9kZSwgYW5kIGluIEZpcmVmb3ggd2hpY2ggZG9lcyBub3RcbiAgICAgICAgLy8gc3VwcG9ydCB3aW5kb3cuZXZlbnQuXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2V2ZW50JykpIHtcbiAgICAgICAgICB3aW5kb3cuZXZlbnQgPSB3aW5kb3dFdmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICAgICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBnbG9iYWwgZXJyb3IgZXZlbnQgaGFuZGxlci4gV2UgdXNlIHRoaXMgdG8gY2FwdHVyZSB0aGUgdmFsdWVcbiAgICAgIC8vIHRoYXQgd2FzIHRocm93bi4gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXMgZXJyb3IgaGFuZGxlciB3aWxsIGZpcmUgbW9yZVxuICAgICAgLy8gdGhhbiBvbmNlOyBmb3IgZXhhbXBsZSwgaWYgbm9uLVJlYWN0IGNvZGUgYWxzbyBjYWxscyBgZGlzcGF0Y2hFdmVudGBcbiAgICAgIC8vIGFuZCBhIGhhbmRsZXIgZm9yIHRoYXQgZXZlbnQgdGhyb3dzLiBXZSBzaG91bGQgYmUgcmVzaWxpZW50IHRvIG1vc3Qgb2ZcbiAgICAgIC8vIHRob3NlIGNhc2VzLiBFdmVuIGlmIG91ciBlcnJvciBldmVudCBoYW5kbGVyIGZpcmVzIG1vcmUgdGhhbiBvbmNlLCB0aGVcbiAgICAgIC8vIGxhc3QgZXJyb3IgZXZlbnQgaXMgYWx3YXlzIHVzZWQuIElmIHRoZSBjYWxsYmFjayBhY3R1YWxseSBkb2VzIGVycm9yLFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBsYXN0IGVycm9yIGV2ZW50IGlzIHRoZSBjb3JyZWN0IG9uZSwgYmVjYXVzZSBpdCdzIG5vdFxuICAgICAgLy8gcG9zc2libGUgZm9yIGFueXRoaW5nIGVsc2UgdG8gaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIG91ciBjYWxsYmFja1xuICAgICAgLy8gZXJyb3JpbmcgYW5kIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgYGRpc3BhdGNoRXZlbnRgIGNhbGwgYmVsb3cuIElmXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgZG9lc24ndCBlcnJvciwgYnV0IHRoZSBlcnJvciBldmVudCB3YXMgZmlyZWQsIHdlIGtub3cgdG9cbiAgICAgIC8vIGlnbm9yZSBpdCBiZWNhdXNlIGBkaWRFcnJvcmAgd2lsbCBiZSBmYWxzZSwgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgICAgdmFyIGVycm9yID0gdm9pZCAwO1xuICAgICAgLy8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG4gICAgICB2YXIgZGlkU2V0RXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBpc0Nyb3NzT3JpZ2luRXJyb3IgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlV2luZG93RXJyb3IoZXZlbnQpIHtcbiAgICAgICAgZXJyb3IgPSBldmVudC5lcnJvcjtcbiAgICAgICAgZGlkU2V0RXJyb3IgPSB0cnVlO1xuICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwgJiYgZXZlbnQuY29sbm8gPT09IDAgJiYgZXZlbnQubGluZW5vID09PSAwKSB7XG4gICAgICAgICAgaXNDcm9zc09yaWdpbkVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIC8vIFNvbWUgb3RoZXIgZXJyb3IgaGFuZGxlciBoYXMgcHJldmVudGVkIGRlZmF1bHQuXG4gICAgICAgICAgLy8gQnJvd3NlcnMgc2lsZW5jZSB0aGUgZXJyb3IgcmVwb3J0IGlmIHRoaXMgaGFwcGVucy5cbiAgICAgICAgICAvLyBXZSdsbCByZW1lbWJlciB0aGlzIHRvIGxhdGVyIGRlY2lkZSB3aGV0aGVyIHRvIGxvZyBpdCBvciBub3QuXG4gICAgICAgICAgaWYgKGVycm9yICE9IG51bGwgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZXJyb3IuX3N1cHByZXNzTG9nZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChpbm5lcikge1xuICAgICAgICAgICAgICAvLyBJZ25vcmUuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGZha2UgZXZlbnQgdHlwZS5cbiAgICAgIHZhciBldnRUeXBlID0gJ3JlYWN0LScgKyAobmFtZSA/IG5hbWUgOiAnaW52b2tlZ3VhcmRlZGNhbGxiYWNrJyk7XG5cbiAgICAgIC8vIEF0dGFjaCBvdXIgZXZlbnQgaGFuZGxlcnNcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVdpbmRvd0Vycm9yKTtcbiAgICAgIGZha2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7XG5cbiAgICAgIC8vIFN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQuIElmIHRoZSB1c2VyLXByb3ZpZGVkIGZ1bmN0aW9uXG4gICAgICAvLyBlcnJvcnMsIGl0IHdpbGwgdHJpZ2dlciBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIuXG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cbiAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICBpZiAoIWRpZFNldEVycm9yKSB7XG4gICAgICAgICAgLy8gVGhlIGNhbGxiYWNrIGVycm9yZWQsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgbmV2ZXIgZmlyZWQuXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIG9uZSBvZiB5b3VyIGNvbXBvbmVudHMsIGJ1dCBSZWFjdCAnICsgXCJkb2Vzbid0IGtub3cgd2hhdCBpdCB3YXMuIFRoaXMgaXMgbGlrZWx5IGR1ZSB0byBicm93c2VyIFwiICsgJ2ZsYWtpbmVzcy4gUmVhY3QgZG9lcyBpdHMgYmVzdCB0byBwcmVzZXJ2ZSB0aGUgXCJQYXVzZSBvbiAnICsgJ2V4Y2VwdGlvbnNcIiBiZWhhdmlvciBvZiB0aGUgRGV2VG9vbHMsIHdoaWNoIHJlcXVpcmVzIHNvbWUgJyArIFwiREVWLW1vZGUgb25seSB0cmlja3MuIEl0J3MgcG9zc2libGUgdGhhdCB0aGVzZSBkb24ndCB3b3JrIGluIFwiICsgJ3lvdXIgYnJvd3Nlci4gVHJ5IHRyaWdnZXJpbmcgdGhlIGVycm9yIGluIHByb2R1Y3Rpb24gbW9kZSwgJyArICdvciBzd2l0Y2hpbmcgdG8gYSBtb2Rlcm4gYnJvd3Nlci4gSWYgeW91IHN1c3BlY3QgdGhhdCB0aGlzIGlzICcgKyAnYWN0dWFsbHkgYW4gaXNzdWUgd2l0aCBSZWFjdCwgcGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDcm9zc09yaWdpbkVycm9yKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJBIGNyb3NzLW9yaWdpbiBlcnJvciB3YXMgdGhyb3duLiBSZWFjdCBkb2Vzbid0IGhhdmUgYWNjZXNzIHRvIFwiICsgJ3RoZSBhY3R1YWwgZXJyb3Igb2JqZWN0IGluIGRldmVsb3BtZW50LiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWNyb3Nzb3JpZ2luLWVycm9yIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25FcnJvcihlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG4gICAgfTtcblxuICAgIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwgPSBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXY7XG4gIH1cbn1cblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwkMSA9IGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGw7XG5cbi8vIFVzZWQgYnkgRmliZXIgdG8gc2ltdWxhdGUgYSB0cnktY2F0Y2guXG52YXIgaGFzRXJyb3IgPSBmYWxzZTtcbnZhciBjYXVnaHRFcnJvciA9IG51bGw7XG5cbi8vIFVzZWQgYnkgZXZlbnQgc3lzdGVtIHRvIGNhcHR1cmUvcmV0aHJvdyB0aGUgZmlyc3QgZXJyb3IuXG52YXIgaGFzUmV0aHJvd0Vycm9yID0gZmFsc2U7XG52YXIgcmV0aHJvd0Vycm9yID0gbnVsbDtcblxudmFyIHJlcG9ydGVyID0ge1xuICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAqIFJldHVybnMgYW4gZXJyb3IgaWYgaXQgdGhyb3dzLCBvdGhlcndpc2UgbnVsbC5cbiAqXG4gKiBJbiBwcm9kdWN0aW9uLCB0aGlzIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgdHJ5LWNhdGNoLiBUaGUgcmVhc29uIHdlIGRvbid0XG4gKiB1c2UgYSB0cnktY2F0Y2ggZGlyZWN0bHkgaXMgc28gdGhhdCB3ZSBjYW4gc3dhcCBvdXQgYSBkaWZmZXJlbnRcbiAqIGltcGxlbWVudGF0aW9uIGluIERFViBtb2RlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEuYXBwbHkocmVwb3J0ZXIsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gKiBpdCBpbiBhIGdsb2JhbCBzbyBpdCBjYW4gYmUgcmV0aHJvd24gYnkgYHJldGhyb3dDYXVnaHRFcnJvcmAgbGF0ZXIuXG4gKiBUT0RPOiBTZWUgaWYgY2F1Z2h0RXJyb3IgYW5kIHJldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcihuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBpZiAoaGFzRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgaWYgKCFoYXNSZXRocm93RXJyb3IpIHtcbiAgICAgIGhhc1JldGhyb3dFcnJvciA9IHRydWU7XG4gICAgICByZXRocm93RXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAqL1xuZnVuY3Rpb24gcmV0aHJvd0NhdWdodEVycm9yKCkge1xuICBpZiAoaGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gcmV0aHJvd0Vycm9yO1xuICAgIGhhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xuICAgIHJldGhyb3dFcnJvciA9IG51bGw7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzQ2F1Z2h0RXJyb3IoKSB7XG4gIHJldHVybiBoYXNFcnJvcjtcbn1cblxuZnVuY3Rpb24gY2xlYXJDYXVnaHRFcnJvcigpIHtcbiAgaWYgKGhhc0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gY2F1Z2h0RXJyb3I7XG4gICAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9IGVsc2Uge1xuICAgIGludmFyaWFudChmYWxzZSwgJ2NsZWFyQ2F1Z2h0RXJyb3Igd2FzIGNhbGxlZCBidXQgbm8gZXJyb3Igd2FzIGNhcHR1cmVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG59XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxuICovXG52YXIgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXG4gKi9cbnZhciBuYW1lc1RvUGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIFJlY29tcHV0ZXMgdGhlIHBsdWdpbiBsaXN0IHVzaW5nIHRoZSBpbmplY3RlZCBwbHVnaW5zIGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XG4gIGlmICghZXZlbnRQbHVnaW5PcmRlcikge1xuICAgIC8vIFdhaXQgdW50aWwgYW4gYGV2ZW50UGx1Z2luT3JkZXJgIGlzIGluamVjdGVkLlxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIHZhciBwbHVnaW5JbmRleCA9IGV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcbiAgICAhKHBsdWdpbkluZGV4ID4gLTEpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgaWYgKHBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgIXBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnQgcGx1Z2lucyBtdXN0IGltcGxlbWVudCBhbiBgZXh0cmFjdEV2ZW50c2AgbWV0aG9kLCBidXQgYCVzYCBkb2VzIG5vdC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBwbHVnaW5zW3BsdWdpbkluZGV4XSA9IHBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgZGlzcGF0Y2hlZCBieSB0aGUgc3VwcGxpZWQgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBEaXNwYXRjaCBjb25maWd1cmF0aW9uIGZvciB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaEV2ZW50Rm9yUGx1Z2luKGRpc3BhdGNoQ29uZmlnLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIWV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIGV2ZW50IG5hbWUsIGAlc2AuJywgZXZlbnROYW1lKSA6IHZvaWQgMDtcbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV0gPSBkaXNwYXRjaENvbmZpZztcblxuICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcbiAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgZm9yICh2YXIgcGhhc2VOYW1lIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2VOYW1lKSkge1xuICAgICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZSA9IHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlTmFtZV07XG4gICAgICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGEgcmVnaXN0cmF0aW9uIG5hbWUgdGhhdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGRpc3BhdGNoZWQgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFyZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSByZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IHZvaWQgMDtcbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcblxuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcmVnaXN0cmF0aW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdID0gcmVnaXN0cmF0aW9uTmFtZTtcblxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25Eb3VibGVDbGljaycpIHtcbiAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cblxuLyoqXG4gKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAqL1xudmFyIHBsdWdpbnMgPSBbXTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAqL1xudmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gKi9cbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gKi9cbnZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzID0ge307XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gKiBvbmx5IGluIHRydWUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IHt9O1xuLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIHRydWVcblxuLyoqXG4gKiBJbmplY3RzIGFuIG9yZGVyaW5nIG9mIHBsdWdpbnMgKGJ5IHBsdWdpbiBuYW1lKS4gVGhpcyBhbGxvd3MgdGhlIG9yZGVyaW5nXG4gKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAqIGFsd2F5cyBkZXRlcm1pbmlzdGljIHJlZ2FyZGxlc3Mgb2YgcGFja2FnaW5nLCBvbi10aGUtZmx5IGluamVjdGlvbiwgZXRjLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcn1cbiAqL1xuZnVuY3Rpb24gaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgISFldmVudFBsdWdpbk9yZGVyID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW4gb3JkZXJpbmcgbW9yZSB0aGFuIG9uY2UuIFlvdSBhcmUgbGlrZWx5IHRyeWluZyB0byBsb2FkIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdC4nKSA6IHZvaWQgMDtcbiAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICBldmVudFBsdWdpbk9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKTtcbiAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbn1cblxuLyoqXG4gKiBJbmplY3RzIHBsdWdpbnMgdG8gYmUgdXNlZCBieSBgRXZlbnRQbHVnaW5IdWJgLiBUaGUgcGx1Z2luIG5hbWVzIG11c3QgYmVcbiAqIGluIHRoZSBvcmRlcmluZyBpbmplY3RlZCBieSBgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcmAuXG4gKlxuICogUGx1Z2lucyBjYW4gYmUgaW5qZWN0ZWQgYXMgcGFydCBvZiBwYWdlIGluaXRpYWxpemF0aW9uIG9yIG9uLXRoZS1mbHkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gKiBAaW50ZXJuYWxcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWV9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZShpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgaWYgKCFpbmplY3RlZE5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IGluamVjdGVkTmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gcGx1Z2luTW9kdWxlKSB7XG4gICAgICAhIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICAgICAgaXNPcmRlcmluZ0RpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzT3JkZXJpbmdEaXJ0eSkge1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmdXaXRob3V0U3RhY2sgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB3YXJuaW5nV2l0aG91dFN0YWNrID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmdXaXRob3V0U3RhY2soY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA+IDgpIHtcbiAgICAgIC8vIENoZWNrIGJlZm9yZSB0aGUgY29uZGl0aW9uIHRvIGNhdGNoIHZpb2xhdGlvbnMgZWFybHkuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dhcm5pbmdXaXRob3V0U3RhY2soKSBjdXJyZW50bHkgc3VwcG9ydHMgYXQgbW9zdCA4IGFyZ3VtZW50cy4nKTtcbiAgICB9XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgX2FyZ3MkbWFwID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICAgIH0pLFxuICAgICAgICAgIGEgPSBfYXJncyRtYXBbMF0sXG4gICAgICAgICAgYiA9IF9hcmdzJG1hcFsxXSxcbiAgICAgICAgICBjID0gX2FyZ3MkbWFwWzJdLFxuICAgICAgICAgIGQgPSBfYXJncyRtYXBbM10sXG4gICAgICAgICAgZSA9IF9hcmdzJG1hcFs0XSxcbiAgICAgICAgICBmID0gX2FyZ3MkbWFwWzVdLFxuICAgICAgICAgIGcgPSBfYXJncyRtYXBbNl0sXG4gICAgICAgICAgaCA9IF9hcmdzJG1hcFs3XTtcblxuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdDtcblxuICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGJlY2F1c2UgaXQgYnJlYWtzIElFOTpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCBhLCBiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSwgYSwgYiwgYyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGEsIGIsIGMsIGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCBhLCBiLCBjLCBkLCBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSwgYSwgYiwgYywgZCwgZSwgZik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGEsIGIsIGMsIGQsIGUsIGYsIGcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCBhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dhcm5pbmdXaXRob3V0U3RhY2soKSBjdXJyZW50bHkgc3VwcG9ydHMgYXQgbW9zdCA4IGFyZ3VtZW50cy4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIF9tZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKF9tZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG52YXIgd2FybmluZ1dpdGhvdXRTdGFjayQxID0gd2FybmluZ1dpdGhvdXRTdGFjaztcblxudmFyIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldEluc3RhbmNlRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiBzZXRDb21wb25lbnRUcmVlKGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGVJbXBsLCBnZXRJbnN0YW5jZUZyb21Ob2RlSW1wbCwgZ2V0Tm9kZUZyb21JbnN0YW5jZUltcGwpIHtcbiAgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGVJbXBsO1xuICBnZXRJbnN0YW5jZUZyb21Ob2RlID0gZ2V0SW5zdGFuY2VGcm9tTm9kZUltcGw7XG4gIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBnZXROb2RlRnJvbUluc3RhbmNlSW1wbDtcbiAge1xuICAgICEoZ2V0Tm9kZUZyb21JbnN0YW5jZSAmJiBnZXRJbnN0YW5jZUZyb21Ob2RlKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0V2ZW50UGx1Z2luVXRpbHMuc2V0Q29tcG9uZW50VHJlZSguLi4pOiBJbmplY3RlZCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGdldE5vZGVGcm9tSW5zdGFuY2Ugb3IgZ2V0SW5zdGFuY2VGcm9tTm9kZS4nKSA6IHZvaWQgMDtcbiAgfVxufVxuXG52YXIgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSB2b2lkIDA7XG57XG4gIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICAgIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcblxuICAgIHZhciBsaXN0ZW5lcnNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpO1xuICAgIHZhciBsaXN0ZW5lcnNMZW4gPSBsaXN0ZW5lcnNJc0FyciA/IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aCA6IGRpc3BhdGNoTGlzdGVuZXJzID8gMSA6IDA7XG5cbiAgICB2YXIgaW5zdGFuY2VzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgICB2YXIgaW5zdGFuY2VzTGVuID0gaW5zdGFuY2VzSXNBcnIgPyBkaXNwYXRjaEluc3RhbmNlcy5sZW5ndGggOiBkaXNwYXRjaEluc3RhbmNlcyA/IDEgOiAwO1xuXG4gICAgIShpbnN0YW5jZXNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgaW5zdGFuY2VzTGVuID09PSBsaXN0ZW5lcnNMZW4pID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnRXZlbnRQbHVnaW5VdGlsczogSW52YWxpZCBgZXZlbnRgLicpIDogdm9pZCAwO1xuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIHRoZSBldmVudCB0byB0aGUgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBTeW50aGV0aWNFdmVudCB0byBoYW5kbGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gaW5zdCBJbnRlcm5hbCBjb21wb25lbnQgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGxpc3RlbmVyLCBpbnN0KSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCAndW5rbm93bi1ldmVudCc7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBnZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IodHlwZSwgbGlzdGVuZXIsIHVuZGVmaW5lZCwgZXZlbnQpO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBkaXNwYXRjaExpc3RlbmVyc1tpXSwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBkaXNwYXRjaExpc3RlbmVycywgZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICB9XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG59XG5cbi8qKlxuICogQHNlZSBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbFxuICovXG5cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZmYgbnVtYmVyIG9mIGRpc3BhdGNoZXMgYWNjdW11bGF0ZWQgaXMgZ3JlYXRlciB0aGFuIDAuXG4gKi9cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBpdGVtcyB0aGF0IG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGludG8gdGhlIGZpcnN0IG9uZS4gVGhpc1xuICogaXMgdXNlZCB0byBjb25zZXJ2ZSBtZW1vcnkgYnkgYXZvaWRpbmcgYXJyYXkgYWxsb2NhdGlvbnMsIGFuZCB0aHVzIHNhY3JpZmljZXNcbiAqIEFQSSBjbGVhbm5lc3MuIFNpbmNlIGBjdXJyZW50YCBjYW4gYmUgbnVsbCBiZWZvcmUgYmVpbmcgcGFzc2VkIGluIGFuZCBub3RcbiAqIG51bGwgYWZ0ZXIgdGhpcyBmdW5jdGlvbiwgbWFrZSBzdXJlIHRvIGFzc2lnbiBpdCBiYWNrIHRvIGBjdXJyZW50YDpcbiAqXG4gKiBgYSA9IGFjY3VtdWxhdGVJbnRvKGEsIGIpO2BcbiAqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgc3BhcmluZ2x5IHVzZWQuIFRyeSBgYWNjdW11bGF0ZWAgZm9yIHNvbWV0aGluZyBjbGVhbmVyLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBhY2N1bXVsYXRlSW50byhjdXJyZW50LCBuZXh0KSB7XG4gICEobmV4dCAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ2FjY3VtdWxhdGVJbnRvKC4uLik6IEFjY3VtdWxhdGVkIGl0ZW1zIG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkLicpIDogdm9pZCAwO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XG4gIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XG59XG5cbi8qKlxuICogQHBhcmFtIHthcnJheX0gYXJyIGFuIFwiYWNjdW11bGF0aW9uXCIgb2YgaXRlbXMgd2hpY2ggaXMgZWl0aGVyIGFuIEFycmF5IG9yXG4gKiBhIHNpbmdsZSBpdGVtLiBVc2VmdWwgd2hlbiBwYWlyZWQgd2l0aCB0aGUgYGFjY3VtdWxhdGVgIG1vZHVsZS4gVGhpcyBpcyBhXG4gKiBzaW1wbGUgdXRpbGl0eSB0aGF0IGFsbG93cyB1cyB0byByZWFzb24gYWJvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLCBidXRcbiAqIGhhbmRsaW5nIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgZXhhY3RseSBvbmUgaXRlbSAoYW5kIHdlIGRvIG5vdCBuZWVkIHRvXG4gKiBhbGxvY2F0ZSBhbiBhcnJheSkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayBpbnZva2VkIHdpdGggZWFjaCBlbGVtZW50IG9yIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7P30gW3Njb3BlXSBTY29wZSB1c2VkIGFzIGB0aGlzYCBpbiBhIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQWNjdW11bGF0ZWQoYXJyLCBjYiwgc2NvcGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGFyci5mb3JFYWNoKGNiLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAoYXJyKSB7XG4gICAgY2IuY2FsbChzY29wZSwgYXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIEludGVybmFsIHF1ZXVlIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgdGhlaXIgZGlzcGF0Y2hlcyBhbmQgYXJlXG4gKiB3YWl0aW5nIHRvIGhhdmUgdGhlaXIgZGlzcGF0Y2hlcyBleGVjdXRlZC5cbiAqL1xudmFyIGV2ZW50UXVldWUgPSBudWxsO1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIHJlbGVhc2VzIGl0IGJhY2sgaW50byB0aGUgcG9vbCwgdW5sZXNzIHBlcnNpc3RlbnQuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBldmVudCBTeW50aGV0aWMgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHByaXZhdGVcbiAqL1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSA9IGZ1bmN0aW9uIChldmVudCwgc2ltdWxhdGVkKSB7XG4gIGlmIChldmVudCkge1xuICAgIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKTtcblxuICAgIGlmICghZXZlbnQuaXNQZXJzaXN0ZW50KCkpIHtcbiAgICAgIGV2ZW50LmNvbnN0cnVjdG9yLnJlbGVhc2UoZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIHRydWUpO1xufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnO1xufVxuXG5mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChuYW1lLCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdvbkNsaWNrJzpcbiAgICBjYXNlICdvbkNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGljayc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VEb3duJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bkNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZUNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VVcCc6XG4gICAgY2FzZSAnb25Nb3VzZVVwQ2FwdHVyZSc6XG4gICAgICByZXR1cm4gISEocHJvcHMuZGlzYWJsZWQgJiYgaXNJbnRlcmFjdGl2ZSh0eXBlKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZXZlbnQgcGx1Z2lucyB0byBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gKlxuICogRXZlbnQgcGx1Z2lucyBjYW4gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIGBleHRyYWN0RXZlbnRzYCB7ZnVuY3Rpb24oc3RyaW5nLCBET01FdmVudFRhcmdldCwgc3RyaW5nLCBvYmplY3QpOiAqfVxuICogICAgIFJlcXVpcmVkLiBXaGVuIGEgdG9wLWxldmVsIGV2ZW50IGlzIGZpcmVkLCB0aGlzIG1ldGhvZCBpcyBleHBlY3RlZCB0b1xuICogICAgIGV4dHJhY3Qgc3ludGhldGljIGV2ZW50cyB0aGF0IHdpbGwgaW4gdHVybiBiZSBxdWV1ZWQgYW5kIGRpc3BhdGNoZWQuXG4gKlxuICogICBgZXZlbnRUeXBlc2Age29iamVjdH1cbiAqICAgICBPcHRpb25hbCwgcGx1Z2lucyB0aGF0IGZpcmUgZXZlbnRzIG11c3QgcHVibGlzaCBhIG1hcHBpbmcgb2YgcmVnaXN0cmF0aW9uXG4gKiAgICAgbmFtZXMgdGhhdCBhcmUgdXNlZCB0byByZWdpc3RlciBsaXN0ZW5lcnMuIFZhbHVlcyBvZiB0aGlzIG1hcHBpbmcgbXVzdFxuICogICAgIGJlIG9iamVjdHMgdGhhdCBjb250YWluIGByZWdpc3RyYXRpb25OYW1lYCBvciBgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNgLlxuICpcbiAqICAgYGV4ZWN1dGVEaXNwYXRjaGAge2Z1bmN0aW9uKG9iamVjdCwgZnVuY3Rpb24sIHN0cmluZyl9XG4gKiAgICAgT3B0aW9uYWwsIGFsbG93cyBwbHVnaW5zIHRvIG92ZXJyaWRlIGhvdyBhbiBldmVudCBnZXRzIGRpc3BhdGNoZWQuIEJ5XG4gKiAgICAgZGVmYXVsdCwgdGhlIGxpc3RlbmVyIGlzIHNpbXBseSBpbnZva2VkLlxuICpcbiAqIEVhY2ggcGx1Z2luIHRoYXQgaXMgaW5qZWN0ZWQgaW50byBgRXZlbnRzUGx1Z2luSHViYCBpcyBpbW1lZGlhdGVseSBvcGVyYWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxuLyoqXG4gKiBNZXRob2RzIGZvciBpbmplY3RpbmcgZGVwZW5kZW5jaWVzLlxuICovXG52YXIgaW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICB2YXIgbGlzdGVuZXIgPSB2b2lkIDA7XG5cbiAgLy8gVE9ETzogc2hvdWxkUHJldmVudE1vdXNlRXZlbnQgaXMgRE9NLXNwZWNpZmljIGFuZCBkZWZpbml0ZWx5IHNob3VsZCBub3RcbiAgLy8gbGl2ZSBoZXJlOyBuZWVkcyB0byBiZSBtb3ZlZCB0byBhIGJldHRlciBwbGFjZSBzb29uXG4gIHZhciBzdGF0ZU5vZGUgPSBpbnN0LnN0YXRlTm9kZTtcbiAgaWYgKCFzdGF0ZU5vZGUpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzIChleDogb25sb2FkIGV2ZW50cyBpbiBpbmNyZW1lbnRhbCBtb2RlKS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKHN0YXRlTm9kZSk7XG4gIGlmICghcHJvcHMpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxpc3RlbmVyID0gcHJvcHNbcmVnaXN0cmF0aW9uTmFtZV07XG4gIGlmIChzaG91bGRQcmV2ZW50TW91c2VFdmVudChyZWdpc3RyYXRpb25OYW1lLCBpbnN0LnR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gICEoIWxpc3RlbmVyIHx8IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLicsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiB2b2lkIDA7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxuLyoqXG4gKiBBbGxvd3MgcmVnaXN0ZXJlZCBwbHVnaW5zIGFuIG9wcG9ydHVuaXR5IHRvIGV4dHJhY3QgZXZlbnRzIGZyb20gdG9wLWxldmVsXG4gKiBuYXRpdmUgYnJvd3NlciBldmVudHMuXG4gKlxuICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRzID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICBpZiAoZXh0cmFjdGVkRXZlbnRzKSB7XG4gICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50cztcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRzSW5CYXRjaChldmVudHMsIHNpbXVsYXRlZCkge1xuICBpZiAoZXZlbnRzICE9PSBudWxsKSB7XG4gICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gIH1cblxuICAvLyBTZXQgYGV2ZW50UXVldWVgIHRvIG51bGwgYmVmb3JlIHByb2Nlc3NpbmcgaXQgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBtb3JlXG4gIC8vIGV2ZW50cyBnZXQgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZy5cbiAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcbiAgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbiAgaWYgKCFwcm9jZXNzaW5nRXZlbnRRdWV1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzaW11bGF0ZWQpIHtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCk7XG4gIH1cbiAgISFldmVudFF1ZXVlID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc0V2ZW50UXVldWUoKTogQWRkaXRpb25hbCBldmVudHMgd2VyZSBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nIGFuIGV2ZW50IHF1ZXVlLiBTdXBwb3J0IGZvciB0aGlzIGhhcyBub3QgeWV0IGJlZW4gaW1wbGVtZW50ZWQuJykgOiB2b2lkIDA7XG4gIC8vIFRoaXMgd291bGQgYmUgYSBnb29kIHRpbWUgdG8gcmV0aHJvdyBpZiBhbnkgb2YgdGhlIGV2ZW50IGhhbmRsZXJzIHRocmV3LlxuICByZXRocm93Q2F1Z2h0RXJyb3IoKTtcbn1cblxuZnVuY3Rpb24gcnVuRXh0cmFjdGVkRXZlbnRzSW5CYXRjaCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRzID0gZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIHJ1bkV2ZW50c0luQmF0Y2goZXZlbnRzLCBmYWxzZSk7XG59XG5cbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50ID0gMDtcbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50TGF6eSA9IDE7XG52YXIgQ2xhc3NDb21wb25lbnQgPSAyO1xudmFyIENsYXNzQ29tcG9uZW50TGF6eSA9IDM7XG52YXIgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCA9IDQ7IC8vIEJlZm9yZSB3ZSBrbm93IHdoZXRoZXIgaXQgaXMgZnVuY3Rpb25hbCBvciBjbGFzc1xudmFyIEhvc3RSb290ID0gNTsgLy8gUm9vdCBvZiBhIGhvc3QgdHJlZS4gQ291bGQgYmUgbmVzdGVkIGluc2lkZSBhbm90aGVyIG5vZGUuXG52YXIgSG9zdFBvcnRhbCA9IDY7IC8vIEEgc3VidHJlZS4gQ291bGQgYmUgYW4gZW50cnkgcG9pbnQgdG8gYSBkaWZmZXJlbnQgcmVuZGVyZXIuXG52YXIgSG9zdENvbXBvbmVudCA9IDc7XG52YXIgSG9zdFRleHQgPSA4O1xudmFyIEZyYWdtZW50ID0gOTtcbnZhciBNb2RlID0gMTA7XG52YXIgQ29udGV4dENvbnN1bWVyID0gMTE7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gMTI7XG52YXIgRm9yd2FyZFJlZiA9IDEzO1xudmFyIEZvcndhcmRSZWZMYXp5ID0gMTQ7XG52YXIgUHJvZmlsZXIgPSAxNTtcbnZhciBQbGFjZWhvbGRlckNvbXBvbmVudCA9IDE2O1xuXG52YXIgcmFuZG9tS2V5ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsRXZlbnRIYW5kbGVyc0tleSA9ICdfX3JlYWN0RXZlbnRIYW5kbGVycyQnICsgcmFuZG9tS2V5O1xuXG5mdW5jdGlvbiBwcmVjYWNoZUZpYmVyTm9kZShob3N0SW5zdCwgbm9kZSkge1xuICBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldID0gaG9zdEluc3Q7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBjbG9zZXN0IFJlYWN0RE9NQ29tcG9uZW50IG9yXG4gKiBSZWFjdERPTVRleHRDb21wb25lbnQgaW5zdGFuY2UgYW5jZXN0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgaWYgKG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICByZXR1cm4gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgfVxuXG4gIHdoaWxlICghbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRvcCBvZiB0aGUgdHJlZS4gVGhpcyBub2RlIG11c3Qgbm90IGJlIHBhcnQgb2YgYSBSZWFjdCB0cmVlIChvciBpc1xuICAgICAgLy8gdW5tb3VudGVkLCBwb3RlbnRpYWxseSkuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciwgdGhpcyB3aWxsIGFsd2F5cyBiZSB0aGUgZGVlcGVzdCByb290LlxuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIGluc3RhbmNlLCBvciBudWxsIGlmIHRoZSBub2RlIHdhcyBub3QgcmVuZGVyZWQgYnkgdGhpcyBSZWFjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKG5vZGUpIHtcbiAgdmFyIGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICBpZiAoaW5zdCkge1xuICAgIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBpbnN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnQsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xuICogRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UkMShpbnN0KSB7XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciB0aGlzLCBpcyBqdXN0IHRoZSBzdGF0ZSBub2RlIHJpZ2h0IG5vdy4gV2UgYXNzdW1lIGl0IHdpbGwgYmVcbiAgICAvLyBhIGhvc3QgY29tcG9uZW50IG9yIGhvc3QgdGV4dC5cbiAgICByZXR1cm4gaW5zdC5zdGF0ZU5vZGU7XG4gIH1cblxuICAvLyBXaXRob3V0IHRoaXMgZmlyc3QgaW52YXJpYW50LCBwYXNzaW5nIGEgbm9uLURPTS1jb21wb25lbnQgdHJpZ2dlcnMgdGhlIG5leHRcbiAgLy8gaW52YXJpYW50IGZvciBhIG1pc3NpbmcgcGFyZW50LCB3aGljaCBpcyBzdXBlciBjb25mdXNpbmcuXG4gIGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJyk7XG59XG5cbmZ1bmN0aW9uIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMShub2RlKSB7XG4gIHJldHVybiBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRmliZXJQcm9wcyhub2RlLCBwcm9wcykge1xuICBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gPSBwcm9wcztcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgZG8ge1xuICAgIGluc3QgPSBpbnN0LnJldHVybjtcbiAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgSG9zdFJvb3Qgd2UgbWlnaHQgd2FudCB0byBiYWlsIG91dC5cbiAgICAvLyBUaGF0IGlzIGRlcGVuZGluZyBvbiBpZiB3ZSB3YW50IG5lc3RlZCBzdWJ0cmVlcyAobGF5ZXJzKSB0byBidWJibGVcbiAgICAvLyBldmVudHMgdG8gdGhlaXIgcGFyZW50LiBXZSBjb3VsZCBhbHNvIGdvIHRocm91Z2ggcGFyZW50Tm9kZSBvbiB0aGVcbiAgICAvLyBob3N0IG5vZGUgYnV0IHRoYXQgd291bGRuJ3Qgd29yayBmb3IgUmVhY3QgTmF0aXZlIGFuZCBkb2Vzbid0IGxldCB1c1xuICAgIC8vIGRvIHRoZSBwb3J0YWwgZmVhdHVyZS5cbiAgfSB3aGlsZSAoaW5zdCAmJiBpbnN0LnRhZyAhPT0gSG9zdENvbXBvbmVudCk7XG4gIGlmIChpbnN0KSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSBnZXRQYXJlbnQodGVtcEEpKSB7XG4gICAgZGVwdGhBKys7XG4gIH1cbiAgdmFyIGRlcHRoQiA9IDA7XG4gIGZvciAodmFyIHRlbXBCID0gaW5zdEI7IHRlbXBCOyB0ZW1wQiA9IGdldFBhcmVudCh0ZW1wQikpIHtcbiAgICBkZXB0aEIrKztcbiAgfVxuXG4gIC8vIElmIEEgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICAgIGRlcHRoQi0tO1xuICB9XG5cbiAgLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG4gIHZhciBkZXB0aCA9IGRlcHRoQTtcbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCIHx8IGluc3RBID09PSBpbnN0Qi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBpbnN0QTtcbiAgICB9XG4gICAgaW5zdEEgPSBnZXRQYXJlbnQoaW5zdEEpO1xuICAgIGluc3RCID0gZ2V0UGFyZW50KGluc3RCKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gaWYgQSBpcyBhbiBhbmNlc3RvciBvZiBCLlxuICovXG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHBhcmVudCBpbnN0YW5jZSBvZiB0aGUgcGFzc2VkLWluIGluc3RhbmNlLlxuICovXG5cblxuLyoqXG4gKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlVHdvUGhhc2UoaW5zdCwgZm4sIGFyZykge1xuICB2YXIgcGF0aCA9IFtdO1xuICB3aGlsZSAoaW5zdCkge1xuICAgIHBhdGgucHVzaChpbnN0KTtcbiAgICBpbnN0ID0gZ2V0UGFyZW50KGluc3QpO1xuICB9XG4gIHZhciBpID0gdm9pZCAwO1xuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoW2ldLCAnY2FwdHVyZWQnLCBhcmcpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgJ2J1YmJsZWQnLCBhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gKlxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcbiAgdmFyIHBhdGhGcm9tID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCFmcm9tKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGZyb20gPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBhbHRlcm5hdGUgPSBmcm9tLmFsdGVybmF0ZTtcbiAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aEZyb20ucHVzaChmcm9tKTtcbiAgICBmcm9tID0gZ2V0UGFyZW50KGZyb20pO1xuICB9XG4gIHZhciBwYXRoVG8gPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIXRvKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRvID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgX2FsdGVybmF0ZSA9IHRvLmFsdGVybmF0ZTtcbiAgICBpZiAoX2FsdGVybmF0ZSAhPT0gbnVsbCAmJiBfYWx0ZXJuYXRlID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXRoVG8ucHVzaCh0byk7XG4gICAgdG8gPSBnZXRQYXJlbnQodG8pO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aEZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoRnJvbVtpXSwgJ2J1YmJsZWQnLCBhcmdGcm9tKTtcbiAgfVxuICBmb3IgKHZhciBfaSA9IHBhdGhUby5sZW5ndGg7IF9pLS0gPiAwOykge1xuICAgIGZuKHBhdGhUb1tfaV0sICdjYXB0dXJlZCcsIGFyZ1RvKTtcbiAgfVxufVxuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3Byb3BhZ2F0aW9uUGhhc2VdO1xuICByZXR1cm4gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcHJvcGFnYXRpb24gcGF0dGVybnMsIGVhY2ggb2Ygd2hpY2ggd2lsbCBhY2NlcHQgYSBzbWFsbCBhbW91bnRcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxuICogbGlzdGVuZXIgZnVuY3Rpb25zL2lkcy4gVGhlIEFQSSBpcyBkZXNpZ25lZCB0aGlzIHdheSB0byBkaXNjb3VyYWdlIHRoZXNlXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbiBhXG4gKiBzaW5nbGUgb25lLlxuICovXG5cbi8qKlxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cbiAqIE11dGF0aW5nIHRoZSBldmVudCdzIG1lbWJlcnMgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBhIHdyYXBwaW5nXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGluc3QsIHBoYXNlLCBldmVudCkge1xuICB7XG4gICAgIWluc3QgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdEaXNwYXRjaGluZyBpbnN0IG11c3Qgbm90IGJlIG51bGwnKSA6IHZvaWQgMDtcbiAgfVxuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICB0cmF2ZXJzZVR3b1BoYXNlKGV2ZW50Ll90YXJnZXRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyB3aXRob3V0IHJlZ2FyZCB0byBkaXJlY3Rpb24sIGRvZXMgbm90IGxvb2sgZm9yIHBoYXNlZFxuICogcmVnaXN0cmF0aW9uIG5hbWVzLiBTYW1lIGFzIGBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZWAgYnV0IHdpdGhvdXRcbiAqIHJlcXVpcmluZyB0aGF0IHRoZSBgZGlzcGF0Y2hNYXJrZXJgIGJlIHRoZSBzYW1lIGFzIHRoZSBkaXNwYXRjaGVkIElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpbnN0LCBpZ25vcmVkRGlyZWN0aW9uLCBldmVudCkge1xuICBpZiAoaW5zdCAmJiBldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuX3RhcmdldEluc3QsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKSB7XG4gIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG4vLyBEbyBub3QgdXNlcyB0aGUgYmVsb3cgdHdvIG1ldGhvZHMgZGlyZWN0bHkhXG4vLyBJbnN0ZWFkIHVzZSBjb25zdGFudHMgZXhwb3J0ZWQgZnJvbSBET01Ub3BMZXZlbEV2ZW50VHlwZXMgaW4gUmVhY3RET00uXG4vLyAoSXQgaXMgdGhlIG9ubHkgbW9kdWxlIHRoYXQgaXMgYWxsb3dlZCB0byBhY2Nlc3MgdGhlc2UgbWV0aG9kcy4pXG5cbmZ1bmN0aW9uIHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZTtcbn1cblxuZnVuY3Rpb24gdW5zYWZlQ2FzdERPTVRvcExldmVsVHlwZVRvU3RyaW5nKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgbWFwcGluZyBvZiBzdGFuZGFyZCB2ZW5kb3IgcHJlZml4ZXMgdXNpbmcgdGhlIGRlZmluZWQgc3R5bGUgcHJvcGVydHkgYW5kIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlUHJvcFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xuICB2YXIgcHJlZml4ZXMgPSB7fTtcblxuICBwcmVmaXhlc1tzdHlsZVByb3AudG9Mb3dlckNhc2UoKV0gPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcHJlZml4ZXNbJ1dlYmtpdCcgKyBzdHlsZVByb3BdID0gJ3dlYmtpdCcgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydNb3onICsgc3R5bGVQcm9wXSA9ICdtb3onICsgZXZlbnROYW1lO1xuXG4gIHJldHVybiBwcmVmaXhlcztcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXG59O1xuXG4vKipcbiAqIEV2ZW50IG5hbWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGV0ZWN0ZWQgYW5kIHByZWZpeGVkIChpZiBhcHBsaWNhYmxlKS5cbiAqL1xudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuXG4vKipcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxuICovXG52YXIgc3R5bGUgPSB7fTtcblxuLyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovXG5pZiAoY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2FibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbWFwLlxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9XG5cbiAgLy8gU2FtZSBhcyBhYm92ZVxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgaWYgKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICB9IGVsc2UgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgfVxuXG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdO1xuXG4gIGZvciAodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApIHtcbiAgICBpZiAocHJlZml4TWFwLmhhc093blByb3BlcnR5KHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0gPSBwcmVmaXhNYXBbc3R5bGVQcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnROYW1lO1xufVxuXG4vKipcbiAqIFRvIGlkZW50aWZ5IHRvcCBsZXZlbCBldmVudHMgaW4gUmVhY3RET00sIHdlIHVzZSBjb25zdGFudHMgZGVmaW5lZCBieSB0aGlzXG4gKiBtb2R1bGUuIFRoaXMgaXMgdGhlIG9ubHkgbW9kdWxlIHRoYXQgdXNlcyB0aGUgdW5zYWZlKiBtZXRob2RzIHRvIGV4cHJlc3NcbiAqIHRoYXQgdGhlIGNvbnN0YW50cyBhY3R1YWxseSBjb3JyZXNwb25kIHRvIHRoZSBicm93c2VyIGV2ZW50IG5hbWVzLiBUaGlzIGxldHNcbiAqIHVzIHNhdmUgc29tZSBidW5kbGUgc2l6ZSBieSBhdm9pZGluZyBhIHRvcCBsZXZlbCB0eXBlIC0+IGV2ZW50IG5hbWUgbWFwLlxuICogVGhlIHJlc3Qgb2YgUmVhY3RET00gY29kZSBzaG91bGQgaW1wb3J0IHRvcCBsZXZlbCB0eXBlcyBmcm9tIHRoaXMgZmlsZS5cbiAqL1xudmFyIFRPUF9BQk9SVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnYWJvcnQnKTtcbnZhciBUT1BfQU5JTUFUSU9OX0VORCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZShnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uZW5kJykpO1xudmFyIFRPUF9BTklNQVRJT05fSVRFUkFUSU9OID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25pdGVyYXRpb24nKSk7XG52YXIgVE9QX0FOSU1BVElPTl9TVEFSVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZShnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uc3RhcnQnKSk7XG52YXIgVE9QX0JMVVIgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2JsdXInKTtcbnZhciBUT1BfQ0FOX1BMQVkgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2NhbnBsYXknKTtcbnZhciBUT1BfQ0FOX1BMQVlfVEhST1VHSCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY2FucGxheXRocm91Z2gnKTtcbnZhciBUT1BfQ0FOQ0VMID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjYW5jZWwnKTtcbnZhciBUT1BfQ0hBTkdFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjaGFuZ2UnKTtcbnZhciBUT1BfQ0xJQ0sgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2NsaWNrJyk7XG52YXIgVE9QX0NMT1NFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjbG9zZScpO1xudmFyIFRPUF9DT01QT1NJVElPTl9FTkQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2NvbXBvc2l0aW9uZW5kJyk7XG52YXIgVE9QX0NPTVBPU0lUSU9OX1NUQVJUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjb21wb3NpdGlvbnN0YXJ0Jyk7XG52YXIgVE9QX0NPTVBPU0lUSU9OX1VQREFURSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY29tcG9zaXRpb251cGRhdGUnKTtcbnZhciBUT1BfQ09OVEVYVF9NRU5VID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjb250ZXh0bWVudScpO1xudmFyIFRPUF9DT1BZID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjb3B5Jyk7XG52YXIgVE9QX0NVVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY3V0Jyk7XG52YXIgVE9QX0RPVUJMRV9DTElDSyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZGJsY2xpY2snKTtcbnZhciBUT1BfQVVYX0NMSUNLID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdhdXhjbGljaycpO1xudmFyIFRPUF9EUkFHID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdkcmFnJyk7XG52YXIgVE9QX0RSQUdfRU5EID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdkcmFnZW5kJyk7XG52YXIgVE9QX0RSQUdfRU5URVIgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RyYWdlbnRlcicpO1xudmFyIFRPUF9EUkFHX0VYSVQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RyYWdleGl0Jyk7XG52YXIgVE9QX0RSQUdfTEVBVkUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RyYWdsZWF2ZScpO1xudmFyIFRPUF9EUkFHX09WRVIgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RyYWdvdmVyJyk7XG52YXIgVE9QX0RSQUdfU1RBUlQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RyYWdzdGFydCcpO1xudmFyIFRPUF9EUk9QID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdkcm9wJyk7XG52YXIgVE9QX0RVUkFUSU9OX0NIQU5HRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHVyYXRpb25jaGFuZ2UnKTtcbnZhciBUT1BfRU1QVElFRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZW1wdGllZCcpO1xudmFyIFRPUF9FTkNSWVBURUQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2VuY3J5cHRlZCcpO1xudmFyIFRPUF9FTkRFRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZW5kZWQnKTtcbnZhciBUT1BfRVJST1IgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2Vycm9yJyk7XG52YXIgVE9QX0ZPQ1VTID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdmb2N1cycpO1xudmFyIFRPUF9HT1RfUE9JTlRFUl9DQVBUVVJFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdnb3Rwb2ludGVyY2FwdHVyZScpO1xudmFyIFRPUF9JTlBVVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnaW5wdXQnKTtcbnZhciBUT1BfSU5WQUxJRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnaW52YWxpZCcpO1xudmFyIFRPUF9LRVlfRE9XTiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgna2V5ZG93bicpO1xudmFyIFRPUF9LRVlfUFJFU1MgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2tleXByZXNzJyk7XG52YXIgVE9QX0tFWV9VUCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgna2V5dXAnKTtcbnZhciBUT1BfTE9BRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnbG9hZCcpO1xudmFyIFRPUF9MT0FEX1NUQVJUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdsb2Fkc3RhcnQnKTtcbnZhciBUT1BfTE9BREVEX0RBVEEgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2xvYWRlZGRhdGEnKTtcbnZhciBUT1BfTE9BREVEX01FVEFEQVRBID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdsb2FkZWRtZXRhZGF0YScpO1xudmFyIFRPUF9MT1NUX1BPSU5URVJfQ0FQVFVSRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnbG9zdHBvaW50ZXJjYXB0dXJlJyk7XG52YXIgVE9QX01PVVNFX0RPV04gPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ21vdXNlZG93bicpO1xudmFyIFRPUF9NT1VTRV9NT1ZFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdtb3VzZW1vdmUnKTtcbnZhciBUT1BfTU9VU0VfT1VUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdtb3VzZW91dCcpO1xudmFyIFRPUF9NT1VTRV9PVkVSID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdtb3VzZW92ZXInKTtcbnZhciBUT1BfTU9VU0VfVVAgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ21vdXNldXAnKTtcbnZhciBUT1BfUEFTVEUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3Bhc3RlJyk7XG52YXIgVE9QX1BBVVNFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdwYXVzZScpO1xudmFyIFRPUF9QTEFZID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdwbGF5Jyk7XG52YXIgVE9QX1BMQVlJTkcgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BsYXlpbmcnKTtcbnZhciBUT1BfUE9JTlRFUl9DQU5DRUwgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BvaW50ZXJjYW5jZWwnKTtcbnZhciBUT1BfUE9JTlRFUl9ET1dOID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdwb2ludGVyZG93bicpO1xuXG5cbnZhciBUT1BfUE9JTlRFUl9NT1ZFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdwb2ludGVybW92ZScpO1xudmFyIFRPUF9QT0lOVEVSX09VVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncG9pbnRlcm91dCcpO1xudmFyIFRPUF9QT0lOVEVSX09WRVIgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BvaW50ZXJvdmVyJyk7XG52YXIgVE9QX1BPSU5URVJfVVAgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BvaW50ZXJ1cCcpO1xudmFyIFRPUF9QUk9HUkVTUyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncHJvZ3Jlc3MnKTtcbnZhciBUT1BfUkFURV9DSEFOR0UgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3JhdGVjaGFuZ2UnKTtcbnZhciBUT1BfUkVTRVQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3Jlc2V0Jyk7XG52YXIgVE9QX1NDUk9MTCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnc2Nyb2xsJyk7XG52YXIgVE9QX1NFRUtFRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnc2Vla2VkJyk7XG52YXIgVE9QX1NFRUtJTkcgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3NlZWtpbmcnKTtcbnZhciBUT1BfU0VMRUNUSU9OX0NIQU5HRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnc2VsZWN0aW9uY2hhbmdlJyk7XG52YXIgVE9QX1NUQUxMRUQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3N0YWxsZWQnKTtcbnZhciBUT1BfU1VCTUlUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdzdWJtaXQnKTtcbnZhciBUT1BfU1VTUEVORCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnc3VzcGVuZCcpO1xudmFyIFRPUF9URVhUX0lOUFVUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCd0ZXh0SW5wdXQnKTtcbnZhciBUT1BfVElNRV9VUERBVEUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3RpbWV1cGRhdGUnKTtcbnZhciBUT1BfVE9HR0xFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCd0b2dnbGUnKTtcbnZhciBUT1BfVE9VQ0hfQ0FOQ0VMID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCd0b3VjaGNhbmNlbCcpO1xudmFyIFRPUF9UT1VDSF9FTkQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3RvdWNoZW5kJyk7XG52YXIgVE9QX1RPVUNIX01PVkUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3RvdWNobW92ZScpO1xudmFyIFRPUF9UT1VDSF9TVEFSVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgndG91Y2hzdGFydCcpO1xudmFyIFRPUF9UUkFOU0lUSU9OX0VORCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZShnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgndHJhbnNpdGlvbmVuZCcpKTtcbnZhciBUT1BfVk9MVU1FX0NIQU5HRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgndm9sdW1lY2hhbmdlJyk7XG52YXIgVE9QX1dBSVRJTkcgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3dhaXRpbmcnKTtcbnZhciBUT1BfV0hFRUwgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3doZWVsJyk7XG5cbi8vIExpc3Qgb2YgZXZlbnRzIHRoYXQgbmVlZCB0byBiZSBpbmRpdmlkdWFsbHkgYXR0YWNoZWQgdG8gbWVkaWEgZWxlbWVudHMuXG4vLyBOb3RlIHRoYXQgZXZlbnRzIGluIHRoaXMgbGlzdCB3aWxsICpub3QqIGJlIGxpc3RlbmVkIHRvIGF0IHRoZSB0b3AgbGV2ZWxcbi8vIHVubGVzcyB0aGV5J3JlIGV4cGxpY2l0bHkgd2hpdGVsaXN0ZWQgaW4gYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5saXN0ZW5Ub2AuXG52YXIgbWVkaWFFdmVudFR5cGVzID0gW1RPUF9BQk9SVCwgVE9QX0NBTl9QTEFZLCBUT1BfQ0FOX1BMQVlfVEhST1VHSCwgVE9QX0RVUkFUSU9OX0NIQU5HRSwgVE9QX0VNUFRJRUQsIFRPUF9FTkNSWVBURUQsIFRPUF9FTkRFRCwgVE9QX0VSUk9SLCBUT1BfTE9BREVEX0RBVEEsIFRPUF9MT0FERURfTUVUQURBVEEsIFRPUF9MT0FEX1NUQVJULCBUT1BfUEFVU0UsIFRPUF9QTEFZLCBUT1BfUExBWUlORywgVE9QX1BST0dSRVNTLCBUT1BfUkFURV9DSEFOR0UsIFRPUF9TRUVLRUQsIFRPUF9TRUVLSU5HLCBUT1BfU1RBTExFRCwgVE9QX1NVU1BFTkQsIFRPUF9USU1FX1VQREFURSwgVE9QX1ZPTFVNRV9DSEFOR0UsIFRPUF9XQUlUSU5HXTtcblxuZnVuY3Rpb24gZ2V0UmF3RXZlbnROYW1lKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdW5zYWZlQ2FzdERPTVRvcExldmVsVHlwZVRvU3RyaW5nKHRvcExldmVsVHlwZSk7XG59XG5cbi8qKlxuICogVGhlc2UgdmFyaWFibGVzIHN0b3JlIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICpcbiAqL1xuXG52YXIgcm9vdCA9IG51bGw7XG52YXIgc3RhcnRUZXh0ID0gbnVsbDtcbnZhciBmYWxsYmFja1RleHQgPSBudWxsO1xuXG5mdW5jdGlvbiBpbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJvb3QgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgc3RhcnRUZXh0ID0gZ2V0VGV4dCgpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHJvb3QgPSBudWxsO1xuICBzdGFydFRleHQgPSBudWxsO1xuICBmYWxsYmFja1RleHQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhKCkge1xuICBpZiAoZmFsbGJhY2tUZXh0KSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrVGV4dDtcbiAgfVxuXG4gIHZhciBzdGFydCA9IHZvaWQgMDtcbiAgdmFyIHN0YXJ0VmFsdWUgPSBzdGFydFRleHQ7XG4gIHZhciBzdGFydExlbmd0aCA9IHN0YXJ0VmFsdWUubGVuZ3RoO1xuICB2YXIgZW5kID0gdm9pZCAwO1xuICB2YXIgZW5kVmFsdWUgPSBnZXRUZXh0KCk7XG4gIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgc3RhcnRMZW5ndGg7IHN0YXJ0KyspIHtcbiAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydF0gIT09IGVuZFZhbHVlW3N0YXJ0XSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gIGZvciAoZW5kID0gMTsgZW5kIDw9IG1pbkVuZDsgZW5kKyspIHtcbiAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gIT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgZmFsbGJhY2tUZXh0ID0gZW5kVmFsdWUuc2xpY2Uoc3RhcnQsIHNsaWNlVGFpbCk7XG4gIHJldHVybiBmYWxsYmFja1RleHQ7XG59XG5cbmZ1bmN0aW9uIGdldFRleHQoKSB7XG4gIGlmICgndmFsdWUnIGluIHJvb3QpIHtcbiAgICByZXR1cm4gcm9vdC52YWx1ZTtcbiAgfVxuICByZXR1cm4gcm9vdC50ZXh0Q29udGVudDtcbn1cblxuLyogZXNsaW50IHZhbGlkLXR5cGVvZjogMCAqL1xuXG52YXIgRVZFTlRfUE9PTF9TSVpFID0gMTA7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgdHlwZTogbnVsbCxcbiAgdGFyZ2V0OiBudWxsLFxuICAvLyBjdXJyZW50VGFyZ2V0IGlzIHNldCB3aGVuIGRpc3BhdGNoaW5nOyBubyB1c2UgaW4gY29weWluZyBpdCBoZXJlXG4gIGN1cnJlbnRUYXJnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuZnVuY3Rpb24gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICAgIGRlbGV0ZSB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZDtcbiAgICBkZWxldGUgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZDtcbiAgfVxuXG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcbiAgdGhpcy5fdGFyZ2V0SW5zdCA9IHRhcmdldEluc3Q7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblxuICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgIGlmICghSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHtcbiAgICAgIGRlbGV0ZSB0aGlzW3Byb3BOYW1lXTsgLy8gdGhpcyBoYXMgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW3Byb3BOYW1lXTtcbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmF0aXZlRXZlbnRbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcbiAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICB9XG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2U7XG4gIHJldHVybiB0aGlzO1xufVxuXG5fYXNzaWduKFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZSwge1xuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LnJldHVyblZhbHVlICE9PSAndW5rbm93bicpIHtcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQuY2FuY2VsQnViYmxlICE9PSAndW5rbm93bicpIHtcbiAgICAgIC8vIFRoZSBDaGFuZ2VFdmVudFBsdWdpbiByZWdpc3RlcnMgYSBcInByb3BlcnR5Y2hhbmdlXCIgZXZlbnQgZm9yXG4gICAgICAvLyBJRS4gVGhpcyBldmVudCBkb2VzIG5vdCBzdXBwb3J0IGJ1YmJsaW5nIG9yIGNhbmNlbGxpbmcsIGFuZFxuICAgICAgLy8gYW55IHJlZmVyZW5jZXMgdG8gY2FuY2VsQnViYmxlIHRocm93IFwiTWVtYmVyIG5vdCBmb3VuZFwiLiAgQVxuICAgICAgLy8gdHlwZW9mIGNoZWNrIG9mIFwidW5rbm93blwiIGNpcmN1bXZlbnRzIHRoaXMgaXNzdWUgKGFuZCBpcyBhbHNvXG4gICAgICAvLyBJRSBzcGVjaWZpYykuXG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKi9cbiAgcGVyc2lzdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQZXJzaXN0ZW50ID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1BlcnNpc3RlbnQ6IGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcE5hbWUsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIEludGVyZmFjZVtwcm9wTmFtZV0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5fdGFyZ2V0SW5zdCA9IG51bGw7XG4gICAgdGhpcy5uYXRpdmVFdmVudCA9IG51bGw7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2U7XG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZTtcbiAgICB0aGlzLl9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gICAgdGhpcy5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xuICAgIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaXNEZWZhdWx0UHJldmVudGVkJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignaXNEZWZhdWx0UHJldmVudGVkJywgZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lzUHJvcGFnYXRpb25TdG9wcGVkJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignaXNQcm9wYWdhdGlvblN0b3BwZWQnLCBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0b3BQcm9wYWdhdGlvbicsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3N0b3BQcm9wYWdhdGlvbicsIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgfVxuICB9XG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbi8qKlxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXG4gKi9cblN5bnRoZXRpY0V2ZW50LmV4dGVuZCA9IGZ1bmN0aW9uIChJbnRlcmZhY2UpIHtcbiAgdmFyIFN1cGVyID0gdGhpcztcblxuICB2YXIgRSA9IGZ1bmN0aW9uICgpIHt9O1xuICBFLnByb3RvdHlwZSA9IFN1cGVyLnByb3RvdHlwZTtcbiAgdmFyIHByb3RvdHlwZSA9IG5ldyBFKCk7XG5cbiAgZnVuY3Rpb24gQ2xhc3MoKSB7XG4gICAgcmV0dXJuIFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2Fzc2lnbihwcm90b3R5cGUsIENsYXNzLnByb3RvdHlwZSk7XG4gIENsYXNzLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3M7XG5cbiAgQ2xhc3MuSW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgU3VwZXIuSW50ZXJmYWNlLCBJbnRlcmZhY2UpO1xuICBDbGFzcy5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gIGFkZEV2ZW50UG9vbGluZ1RvKENsYXNzKTtcblxuICByZXR1cm4gQ2xhc3M7XG59O1xuXG5hZGRFdmVudFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCk7XG5cbi8qKlxuICogSGVscGVyIHRvIG51bGxpZnkgc3ludGhldGljRXZlbnQgaW5zdGFuY2UgcHJvcGVydGllcyB3aGVuIGRlc3RydWN0aW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gKiBAcGFyYW0gez9vYmplY3R9IGdldFZhbFxuICogQHJldHVybiB7b2JqZWN0fSBkZWZpbmVQcm9wZXJ0eSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgZ2V0VmFsKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIGdldFZhbCA9PT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBzZXQsXG4gICAgZ2V0OiBnZXRcbiAgfTtcblxuICBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnc2V0dGluZyB0aGUgbWV0aG9kJyA6ICdzZXR0aW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgd2FybihhY3Rpb24sICdUaGlzIGlzIGVmZmVjdGl2ZWx5IGEgbm8tb3AnKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ2FjY2Vzc2luZyB0aGUgbWV0aG9kJyA6ICdhY2Nlc3NpbmcgdGhlIHByb3BlcnR5JztcbiAgICB2YXIgcmVzdWx0ID0gaXNGdW5jdGlvbiA/ICdUaGlzIGlzIGEgbm8tb3AgZnVuY3Rpb24nIDogJ1RoaXMgaXMgc2V0IHRvIG51bGwnO1xuICAgIHdhcm4oYWN0aW9uLCByZXN1bHQpO1xuICAgIHJldHVybiBnZXRWYWw7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKGFjdGlvbiwgcmVzdWx0KSB7XG4gICAgdmFyIHdhcm5pbmdDb25kaXRpb24gPSBmYWxzZTtcbiAgICAhd2FybmluZ0NvbmRpdGlvbiA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgXCJUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgXCIgKyBcInlvdSdyZSAlcyBgJXNgIG9uIGEgcmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gJXMuIFwiICsgJ0lmIHlvdSBtdXN0IGtlZXAgdGhlIG9yaWdpbmFsIHN5bnRoZXRpYyBldmVudCBhcm91bmQsIHVzZSBldmVudC5wZXJzaXN0KCkuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBhY3Rpb24sIHByb3BOYW1lLCByZXN1bHQpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBvb2xlZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCkge1xuICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIGlmIChFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wb3AoKTtcbiAgICBFdmVudENvbnN0cnVjdG9yLmNhbGwoaW5zdGFuY2UsIGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIHJldHVybiBuZXcgRXZlbnRDb25zdHJ1Y3RvcihkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlUG9vbGVkRXZlbnQoZXZlbnQpIHtcbiAgdmFyIEV2ZW50Q29uc3RydWN0b3IgPSB0aGlzO1xuICAhKGV2ZW50IGluc3RhbmNlb2YgRXZlbnRDb25zdHJ1Y3RvcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBldmVudCBpbnN0YW5jZSBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLicpIDogdm9pZCAwO1xuICBldmVudC5kZXN0cnVjdG9yKCk7XG4gIGlmIChFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5sZW5ndGggPCBFVkVOVF9QT09MX1NJWkUpIHtcbiAgICBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wdXNoKGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRFdmVudFBvb2xpbmdUbyhFdmVudENvbnN0cnVjdG9yKSB7XG4gIEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sID0gW107XG4gIEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkID0gZ2V0UG9vbGVkRXZlbnQ7XG4gIEV2ZW50Q29uc3RydWN0b3IucmVsZWFzZSA9IHJlbGVhc2VQb29sZWRFdmVudDtcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50ID0gU3ludGhldGljRXZlbnQuZXh0ZW5kKHtcbiAgZGF0YTogbnVsbFxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG52YXIgU3ludGhldGljSW5wdXRFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmV4dGVuZCh7XG4gIGRhdGE6IG51bGxcbn0pO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKGNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBjYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBjYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbnZhciBTUEFDRUJBUl9DT0RFID0gMzI7XG52YXIgU1BBQ0VCQVJfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7XG5cbi8vIEV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcy5cbnZhciBldmVudFR5cGVzID0ge1xuICBiZWZvcmVJbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25CZWZvcmVJbnB1dCcsXG4gICAgICBjYXB0dXJlZDogJ29uQmVmb3JlSW5wdXRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX0NPTVBPU0lUSU9OX0VORCwgVE9QX0tFWV9QUkVTUywgVE9QX1RFWFRfSU5QVVQsIFRPUF9QQVNURV1cbiAgfSxcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25FbmQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9CTFVSLCBUT1BfQ09NUE9TSVRJT05fRU5ELCBUT1BfS0VZX0RPV04sIFRPUF9LRVlfUFJFU1MsIFRPUF9LRVlfVVAsIFRPUF9NT1VTRV9ET1dOXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX0JMVVIsIFRPUF9DT01QT1NJVElPTl9TVEFSVCwgVE9QX0tFWV9ET1dOLCBUT1BfS0VZX1BSRVNTLCBUT1BfS0VZX1VQLCBUT1BfTU9VU0VfRE9XTl1cbiAgfSxcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25VcGRhdGUnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9CTFVSLCBUT1BfQ09NUE9TSVRJT05fVVBEQVRFLCBUT1BfS0VZX0RPV04sIFRPUF9LRVlfUFJFU1MsIFRPUF9LRVlfVVAsIFRPUF9NT1VTRV9ET1dOXVxuICB9XG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgVE9QX0NPTVBPU0lUSU9OX1NUQVJUOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlIFRPUF9DT01QT1NJVElPTl9FTkQ6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlIFRPUF9DT01QT1NJVElPTl9VUERBVEU6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSBUT1BfS0VZX0RPV04gJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIFRPUF9LRVlfVVA6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG4gICAgY2FzZSBUT1BfS0VZX0RPV046XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgIGNhc2UgVE9QX0tFWV9QUkVTUzpcbiAgICBjYXNlIFRPUF9NT1VTRV9ET1dOOlxuICAgIGNhc2UgVE9QX0JMVVI6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY29tcG9zaXRpb24gZXZlbnQgd2FzIHRyaWdnZXJlZCBieSBLb3JlYW4gSU1FLlxuICogT3VyIGZhbGxiYWNrIG1vZGUgZG9lcyBub3Qgd29yayB3ZWxsIHdpdGggSUUncyBLb3JlYW4gSU1FLFxuICogc28ganVzdCB1c2UgbmF0aXZlIGNvbXBvc2l0aW9uIGV2ZW50cyB3aGVuIEtvcmVhbiBJTUUgaXMgdXNlZC5cbiAqIEFsdGhvdWdoIENvbXBvc2l0aW9uRXZlbnQubG9jYWxlIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQsXG4gKiBpdCBpcyBhdmFpbGFibGUgaW4gSUUsIHdoZXJlIG91ciBmYWxsYmFjayBtb2RlIGlzIGVuYWJsZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBuYXRpdmVFdmVudC5sb2NhbGUgPT09ICdrbyc7XG59XG5cbi8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBzdGF0dXMsIGlmIGFueS5cbnZhciBpc0NvbXBvc2luZyA9IGZhbHNlO1xuXG4vKipcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50VHlwZSA9IHZvaWQgMDtcbiAgdmFyIGZhbGxiYWNrRGF0YSA9IHZvaWQgMDtcblxuICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudCkge1xuICAgIGV2ZW50VHlwZSA9IGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSk7XG4gIH0gZWxzZSBpZiAoIWlzQ29tcG9zaW5nKSB7XG4gICAgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gIH1cblxuICBpZiAoIWV2ZW50VHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhICYmICFpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWlzQ29tcG9zaW5nICYmIGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0KSB7XG4gICAgICBpc0NvbXBvc2luZyA9IGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgLy8gSW5qZWN0IGRhdGEgZ2VuZXJhdGVkIGZyb20gZmFsbGJhY2sgcGF0aCBpbnRvIHRoZSBzeW50aGV0aWMgZXZlbnQuXG4gICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgaWYgKGN1c3RvbURhdGEgIT09IG51bGwpIHtcbiAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgIH1cbiAgfVxuXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUb3BMZXZlbFR5cGV9IHRvcExldmVsVHlwZSBOdW1iZXIgZnJvbSBgVG9wTGV2ZWxUeXBlYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgVE9QX0NPTVBPU0lUSU9OX0VORDpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlIFRPUF9LRVlfUFJFU1M6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgVE9QX1RFWFRfSU5QVVQ6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gaWdub3JlIGl0LlxuICAgICAgaWYgKGNoYXJzID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFycztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3BMZXZlbFR5cGUgTnVtYmVyIGZyb20gYFRvcExldmVsRXZlbnRUeXBlc2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgZmFsbGJhY2sgc3RyaW5nIGZvciB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgY29tcG9zaW5nIChJTUUpIGFuZCB1c2luZyBhIGZhbGxiYWNrIHRvIGRvIHNvLFxuICAvLyB0cnkgdG8gZXh0cmFjdCB0aGUgY29tcG9zZWQgY2hhcmFjdGVycyBmcm9tIHRoZSBmYWxsYmFjayBvYmplY3QuXG4gIC8vIElmIGNvbXBvc2l0aW9uIGV2ZW50IGlzIGF2YWlsYWJsZSwgd2UgZXh0cmFjdCBhIHN0cmluZyBvbmx5IGF0XG4gIC8vIGNvbXBvc2l0aW9uZXZlbnQsIG90aGVyd2lzZSBleHRyYWN0IGl0IGF0IGZhbGxiYWNrIGV2ZW50cy5cbiAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX0NPTVBPU0lUSU9OX0VORCB8fCAhY2FuVXNlQ29tcG9zaXRpb25FdmVudCAmJiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGdldERhdGEoKTtcbiAgICAgIHJlc2V0KCk7XG4gICAgICBpc0NvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGNoYXJzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSBUT1BfUEFTVEU6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIFRPUF9LRVlfUFJFU1M6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAoIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAvLyBJRSBmaXJlcyB0aGUgYGtleXByZXNzYCBldmVudCB3aGVuIGEgdXNlciB0eXBlcyBhbiBlbW9qaSB2aWFcbiAgICAgICAgLy8gVG91Y2gga2V5Ym9hcmQgb2YgV2luZG93cy4gIEluIHN1Y2ggYSBjYXNlLCB0aGUgYGNoYXJgIHByb3BlcnR5XG4gICAgICAgIC8vIGhvbGRzIGFuIGVtb2ppIGNoYXJhY3RlciBsaWtlIGBcXHVEODNEXFx1REUwQWAuICBCZWNhdXNlIGl0cyBsZW5ndGhcbiAgICAgICAgLy8gaXMgMiwgdGhlIHByb3BlcnR5IGB3aGljaGAgZG9lcyBub3QgcmVwcmVzZW50IGFuIGVtb2ppIGNvcnJlY3RseS5cbiAgICAgICAgLy8gSW4gc3VjaCBhIGNhc2UsIHdlIGRpcmVjdGx5IHJldHVybiB0aGUgYGNoYXJgIHByb3BlcnR5IGluc3RlYWQgb2ZcbiAgICAgICAgLy8gdXNpbmcgYHdoaWNoYC5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmNoYXIgJiYgbmF0aXZlRXZlbnQuY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAobmF0aXZlRXZlbnQud2hpY2gpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgVE9QX0NPTVBPU0lUSU9OX0VORDpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSAmJiAhaXNVc2luZ0tvcmVhbklNRShuYXRpdmVFdmVudCkgPyBudWxsIDogbmF0aXZlRXZlbnQuZGF0YTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IGEgU3ludGhldGljSW5wdXRFdmVudCBmb3IgYGJlZm9yZUlucHV0YCwgYmFzZWQgb24gZWl0aGVyIG5hdGl2ZVxuICogYHRleHRJbnB1dGAgb3IgZmFsbGJhY2sgYmVoYXZpb3IuXG4gKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgY2hhcnMgPSB2b2lkIDA7XG5cbiAgaWYgKGNhblVzZVRleHRJbnB1dEV2ZW50KSB7XG4gICAgY2hhcnMgPSBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJzID0gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9XG5cbiAgLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuICAvLyBiZSBmaXJlZC5cbiAgaWYgKCFjaGFycykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljSW5wdXRFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5iZWZvcmVJbnB1dCwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBldmVudC5kYXRhID0gY2hhcnM7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGBvbkJlZm9yZUlucHV0YCBldmVudCB0byBtYXRjaFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDUvI2V2ZW50cy1pbnB1dGV2ZW50cy5cbiAqXG4gKiBUaGlzIGV2ZW50IHBsdWdpbiBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50XG4gKiBhdmFpbGFibGUgaW4gQ2hyb21lLCBTYWZhcmksIE9wZXJhLCBhbmQgSUUuIFRoaXMgZXZlbnQgZmlyZXMgYWZ0ZXJcbiAqIGBvbktleVByZXNzYCBhbmQgYG9uQ29tcG9zaXRpb25FbmRgLCBidXQgYmVmb3JlIGBvbklucHV0YC5cbiAqXG4gKiBgYmVmb3JlSW5wdXRgIGlzIHNwZWMnZCBidXQgbm90IGltcGxlbWVudGVkIGluIGFueSBicm93c2VycywgYW5kXG4gKiB0aGUgYGlucHV0YCBldmVudCBkb2VzIG5vdCBwcm92aWRlIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBoYXNcbiAqIGFjdHVhbGx5IGJlZW4gYWRkZWQsIGNvbnRyYXJ5IHRvIHRoZSBzcGVjLiBUaHVzLCBgdGV4dElucHV0YCBpcyB0aGUgYmVzdFxuICogYXZhaWxhYmxlIGV2ZW50IHRvIGlkZW50aWZ5IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGluc2VydGVkXG4gKiBpbnRvIHRoZSB0YXJnZXQgbm9kZS5cbiAqXG4gKiBUaGlzIHBsdWdpbiBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBlbWl0dGluZyBgY29tcG9zaXRpb25gIGV2ZW50cywgdGh1c1xuICogYWxsb3dpbmcgdXMgdG8gc2hhcmUgY29tcG9zaXRpb24gZmFsbGJhY2sgY29kZSBmb3IgYm90aCBgYmVmb3JlSW5wdXRgIGFuZFxuICogYGNvbXBvc2l0aW9uYCBldmVudCB0eXBlcy5cbiAqL1xudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGNvbXBvc2l0aW9uID0gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgdmFyIGJlZm9yZUlucHV0ID0gZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgaWYgKGNvbXBvc2l0aW9uID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYmVmb3JlSW5wdXQ7XG4gICAgfVxuXG4gICAgaWYgKGJlZm9yZUlucHV0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29tcG9zaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIFtjb21wb3NpdGlvbiwgYmVmb3JlSW5wdXRdO1xuICB9XG59O1xuXG4vLyBVc2UgdG8gcmVzdG9yZSBjb250cm9sbGVkIHN0YXRlIGFmdGVyIGEgY2hhbmdlIGV2ZW50IGhhcyBmaXJlZC5cblxudmFyIHJlc3RvcmVJbXBsID0gbnVsbDtcbnZhciByZXN0b3JlVGFyZ2V0ID0gbnVsbDtcbnZhciByZXN0b3JlUXVldWUgPSBudWxsO1xuXG5mdW5jdGlvbiByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpIHtcbiAgLy8gV2UgcGVyZm9ybSB0aGlzIHRyYW5zbGF0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGV2ZW50IGxvb3Agc28gdGhhdCB3ZVxuICAvLyBhbHdheXMgcmVjZWl2ZSB0aGUgY29ycmVjdCBmaWJlciBoZXJlXG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW5zdGFuY2VGcm9tTm9kZSh0YXJnZXQpO1xuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAvLyBVbm1vdW50ZWRcbiAgICByZXR1cm47XG4gIH1cbiAgISh0eXBlb2YgcmVzdG9yZUltcGwgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnc2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKCkgbmVlZHMgdG8gYmUgY2FsbGVkIHRvIGhhbmRsZSBhIHRhcmdldCBmb3IgY29udHJvbGxlZCBldmVudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUpO1xuICByZXN0b3JlSW1wbChpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSwgaW50ZXJuYWxJbnN0YW5jZS50eXBlLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHNldFJlc3RvcmVJbXBsZW1lbnRhdGlvbihpbXBsKSB7XG4gIHJlc3RvcmVJbXBsID0gaW1wbDtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpIHtcbiAgaWYgKHJlc3RvcmVUYXJnZXQpIHtcbiAgICBpZiAocmVzdG9yZVF1ZXVlKSB7XG4gICAgICByZXN0b3JlUXVldWUucHVzaCh0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0b3JlUXVldWUgPSBbdGFyZ2V0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdG9yZVRhcmdldCA9IHRhcmdldDtcbiAgfVxufVxuXG5mdW5jdGlvbiBuZWVkc1N0YXRlUmVzdG9yZSgpIHtcbiAgcmV0dXJuIHJlc3RvcmVUYXJnZXQgIT09IG51bGwgfHwgcmVzdG9yZVF1ZXVlICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiByZXN0b3JlU3RhdGVJZk5lZWRlZCgpIHtcbiAgaWYgKCFyZXN0b3JlVGFyZ2V0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0YXJnZXQgPSByZXN0b3JlVGFyZ2V0O1xuICB2YXIgcXVldWVkVGFyZ2V0cyA9IHJlc3RvcmVRdWV1ZTtcbiAgcmVzdG9yZVRhcmdldCA9IG51bGw7XG4gIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbiAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KTtcbiAgaWYgKHF1ZXVlZFRhcmdldHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlZFRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHF1ZXVlZFRhcmdldHNbaV0pO1xuICAgIH1cbiAgfVxufVxuXG4vLyBVc2VkIGFzIGEgd2F5IHRvIGNhbGwgYmF0Y2hlZFVwZGF0ZXMgd2hlbiB3ZSBkb24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvXG4vLyB0aGUgcmVuZGVyZXIuIFN1Y2ggYXMgd2hlbiB3ZSdyZSBkaXNwYXRjaGluZyBldmVudHMgb3IgaWYgdGhpcmQgcGFydHlcbi8vIGxpYnJhcmllcyBuZWVkIHRvIGNhbGwgYmF0Y2hlZFVwZGF0ZXMuIEV2ZW50dWFsbHksIHRoaXMgQVBJIHdpbGwgZ28gYXdheSB3aGVuXG4vLyBldmVyeXRoaW5nIGlzIGJhdGNoZWQgYnkgZGVmYXVsdC4gV2UnbGwgdGhlbiBoYXZlIGEgc2ltaWxhciBBUEkgdG8gb3B0LW91dCBvZlxuLy8gc2NoZWR1bGVkIHdvcmsgYW5kIGluc3RlYWQgZG8gc3luY2hyb25vdXMgd29yay5cblxuLy8gRGVmYXVsdHNcbnZhciBfYmF0Y2hlZFVwZGF0ZXNJbXBsID0gZnVuY3Rpb24gKGZuLCBib29ra2VlcGluZykge1xuICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xufTtcbnZhciBfaW50ZXJhY3RpdmVVcGRhdGVzSW1wbCA9IGZ1bmN0aW9uIChmbiwgYSwgYikge1xuICByZXR1cm4gZm4oYSwgYik7XG59O1xudmFyIF9mbHVzaEludGVyYWN0aXZlVXBkYXRlc0ltcGwgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIGlzQmF0Y2hpbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZykge1xuICBpZiAoaXNCYXRjaGluZykge1xuICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgaW5zaWRlIGFub3RoZXIgYmF0Y2gsIHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdFxuICAgIC8vIGZ1bGx5IGNvbXBsZXRlcyBiZWZvcmUgcmVzdG9yaW5nIHN0YXRlLlxuICAgIHJldHVybiBmbihib29ra2VlcGluZyk7XG4gIH1cbiAgaXNCYXRjaGluZyA9IHRydWU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIF9iYXRjaGVkVXBkYXRlc0ltcGwoZm4sIGJvb2trZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBIZXJlIHdlIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaCBpcyBpbXBvcnRhbnRcbiAgICAvLyB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICAgIC8vIFRoZW4gd2UgcmVzdG9yZSBzdGF0ZSBvZiBhbnkgY29udHJvbGxlZCBjb21wb25lbnQuXG4gICAgaXNCYXRjaGluZyA9IGZhbHNlO1xuICAgIHZhciBjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcyA9IG5lZWRzU3RhdGVSZXN0b3JlKCk7XG4gICAgaWYgKGNvbnRyb2xsZWRDb21wb25lbnRzSGF2ZVBlbmRpbmdVcGRhdGVzKSB7XG4gICAgICAvLyBJZiBhIGNvbnRyb2xsZWQgZXZlbnQgd2FzIGZpcmVkLCB3ZSBtYXkgbmVlZCB0byByZXN0b3JlIHRoZSBzdGF0ZSBvZlxuICAgICAgLy8gdGhlIERPTSBub2RlIGJhY2sgdG8gdGhlIGNvbnRyb2xsZWQgdmFsdWUuIFRoaXMgaXMgbmVjZXNzYXJ5IHdoZW4gUmVhY3RcbiAgICAgIC8vIGJhaWxzIG91dCBvZiB0aGUgdXBkYXRlIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbiAgICAgIF9mbHVzaEludGVyYWN0aXZlVXBkYXRlc0ltcGwoKTtcbiAgICAgIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGludGVyYWN0aXZlVXBkYXRlcyhmbiwgYSwgYikge1xuICByZXR1cm4gX2ludGVyYWN0aXZlVXBkYXRlc0ltcGwoZm4sIGEsIGIpO1xufVxuXG5cblxuZnVuY3Rpb24gc2V0QmF0Y2hpbmdJbXBsZW1lbnRhdGlvbihiYXRjaGVkVXBkYXRlc0ltcGwsIGludGVyYWN0aXZlVXBkYXRlc0ltcGwsIGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzSW1wbCkge1xuICBfYmF0Y2hlZFVwZGF0ZXNJbXBsID0gYmF0Y2hlZFVwZGF0ZXNJbXBsO1xuICBfaW50ZXJhY3RpdmVVcGRhdGVzSW1wbCA9IGludGVyYWN0aXZlVXBkYXRlc0ltcGw7XG4gIF9mbHVzaEludGVyYWN0aXZlVXBkYXRlc0ltcGwgPSBmbHVzaEludGVyYWN0aXZlVXBkYXRlc0ltcGw7XG59XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICBjb2xvcjogdHJ1ZSxcbiAgZGF0ZTogdHJ1ZSxcbiAgZGF0ZXRpbWU6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gIGVtYWlsOiB0cnVlLFxuICBtb250aDogdHJ1ZSxcbiAgbnVtYmVyOiB0cnVlLFxuICBwYXNzd29yZDogdHJ1ZSxcbiAgcmFuZ2U6IHRydWUsXG4gIHNlYXJjaDogdHJ1ZSxcbiAgdGVsOiB0cnVlLFxuICB0ZXh0OiB0cnVlLFxuICB0aW1lOiB0cnVlLFxuICB1cmw6IHRydWUsXG4gIHdlZWs6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL1xuXG52YXIgRUxFTUVOVF9OT0RFID0gMTtcbnZhciBURVhUX05PREUgPSAzO1xudmFyIENPTU1FTlRfTk9ERSA9IDg7XG52YXIgRE9DVU1FTlRfTk9ERSA9IDk7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICAvLyBGYWxsYmFjayB0byBuYXRpdmVFdmVudC5zcmNFbGVtZW50IGZvciBJRTlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjUwNlxuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuXG4gIC8vIE5vcm1hbGl6ZSBTVkcgPHVzZT4gZWxlbWVudCBldmVudHMgIzQ5NjNcbiAgaWYgKHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCkge1xuICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgfVxuXG4gIC8vIFNhZmFyaSBtYXkgZmlyZSBldmVudHMgb24gdGV4dCBub2RlcyAoTm9kZS5URVhUX05PREUgaXMgMykuXG4gIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkLlxuICogQGludGVybmFsXG4gKiBAbGljZW5zZSBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiAqL1xuZnVuY3Rpb24gaXNFdmVudFN1cHBvcnRlZChldmVudE5hbWVTdWZmaXgpIHtcbiAgaWYgKCFjYW5Vc2VET00pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXZlbnROYW1lID0gJ29uJyArIGV2ZW50TmFtZVN1ZmZpeDtcbiAgdmFyIGlzU3VwcG9ydGVkID0gZXZlbnROYW1lIGluIGRvY3VtZW50O1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQ2hlY2thYmxlKGVsZW0pIHtcbiAgdmFyIHR5cGUgPSBlbGVtLnR5cGU7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmICh0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFja2VyKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3ZhbHVlVHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gZGV0YWNoVHJhY2tlcihub2RlKSB7XG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgdmFsdWUgPSAnJztcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKGlzQ2hlY2thYmxlKG5vZGUpKSB7XG4gICAgdmFsdWUgPSBub2RlLmNoZWNrZWQgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJhY2tWYWx1ZU9uTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZUZpZWxkID0gaXNDaGVja2FibGUobm9kZSkgPyAnY2hlY2tlZCcgOiAndmFsdWUnO1xuICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHZhbHVlRmllbGQpO1xuXG4gIHZhciBjdXJyZW50VmFsdWUgPSAnJyArIG5vZGVbdmFsdWVGaWVsZF07XG5cbiAgLy8gaWYgc29tZW9uZSBoYXMgYWxyZWFkeSBkZWZpbmVkIGEgdmFsdWUgb3IgU2FmYXJpLCB0aGVuIGJhaWxcbiAgLy8gYW5kIGRvbid0IHRyYWNrIHZhbHVlIHdpbGwgY2F1c2Ugb3ZlciByZXBvcnRpbmcgb2YgY2hhbmdlcyxcbiAgLy8gYnV0IGl0J3MgYmV0dGVyIHRoZW4gYSBoYXJkIGZhaWx1cmVcbiAgLy8gKG5lZWRlZCBmb3IgY2VydGFpbiB0ZXN0cyB0aGF0IHNweU9uIGlucHV0IHZhbHVlcyBhbmQgU2FmYXJpKVxuICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKSB8fCB0eXBlb2YgZGVzY3JpcHRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRlc2NyaXB0b3IuZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBkZXNjcmlwdG9yLnNldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZ2V0ID0gZGVzY3JpcHRvci5nZXQsXG4gICAgICBzZXQgPSBkZXNjcmlwdG9yLnNldDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXQuY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIC8vIFdlIGNvdWxkJ3ZlIHBhc3NlZCB0aGlzIHRoZSBmaXJzdCB0aW1lXG4gIC8vIGJ1dCBpdCB0cmlnZ2VycyBhIGJ1ZyBpbiBJRTExIGFuZCBFZGdlIDE0LzE1LlxuICAvLyBDYWxsaW5nIGRlZmluZVByb3BlcnR5KCkgYWdhaW4gc2hvdWxkIGJlIGVxdWl2YWxlbnQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE3NjhcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGVcbiAgfSk7XG5cbiAgdmFyIHRyYWNrZXIgPSB7XG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfSxcbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0sXG4gICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IE9uY2UgaXQncyBqdXN0IEZpYmVyIHdlIGNhbiBtb3ZlIHRoaXMgdG8gbm9kZS5fd3JhcHBlclN0YXRlXG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IHRyYWNrVmFsdWVPbk5vZGUobm9kZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpO1xuICAvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuICAvLyB0aGF0IHRyeWluZyBhZ2FpbiB3aWxsIHN1Y2NlZWRcbiAgaWYgKCF0cmFja2VyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbGFzdFZhbHVlID0gdHJhY2tlci5nZXRWYWx1ZSgpO1xuICB2YXIgbmV4dFZhbHVlID0gZ2V0VmFsdWVGcm9tTm9kZShub2RlKTtcbiAgaWYgKG5leHRWYWx1ZSAhPT0gbGFzdFZhbHVlKSB7XG4gICAgdHJhY2tlci5zZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbnZhciBCRUZPUkVfU0xBU0hfUkUgPSAvXiguKilbXFxcXFxcL10vO1xuXG52YXIgZGVzY3JpYmVDb21wb25lbnRGcmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICB2YXIgc291cmNlSW5mbyA9ICcnO1xuICBpZiAoc291cmNlKSB7XG4gICAgdmFyIHBhdGggPSBzb3VyY2UuZmlsZU5hbWU7XG4gICAgdmFyIGZpbGVOYW1lID0gcGF0aC5yZXBsYWNlKEJFRk9SRV9TTEFTSF9SRSwgJycpO1xuICAgIHtcbiAgICAgIC8vIEluIERFViwgaW5jbHVkZSBjb2RlIGZvciBhIGNvbW1vbiBzcGVjaWFsIGNhc2U6XG4gICAgICAvLyBwcmVmZXIgXCJmb2xkZXIvaW5kZXguanNcIiBpbnN0ZWFkIG9mIGp1c3QgXCJpbmRleC5qc1wiLlxuICAgICAgaWYgKC9eaW5kZXhcXC4vLnRlc3QoZmlsZU5hbWUpKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHBhdGgubWF0Y2goQkVGT1JFX1NMQVNIX1JFKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgdmFyIHBhdGhCZWZvcmVTbGFzaCA9IG1hdGNoWzFdO1xuICAgICAgICAgIGlmIChwYXRoQmVmb3JlU2xhc2gpIHtcbiAgICAgICAgICAgIHZhciBmb2xkZXJOYW1lID0gcGF0aEJlZm9yZVNsYXNoLnJlcGxhY2UoQkVGT1JFX1NMQVNIX1JFLCAnJyk7XG4gICAgICAgICAgICBmaWxlTmFtZSA9IGZvbGRlck5hbWUgKyAnLycgKyBmaWxlTmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlSW5mbyA9ICcgKGF0ICcgKyBmaWxlTmFtZSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknO1xuICB9IGVsc2UgaWYgKG93bmVyTmFtZSkge1xuICAgIHNvdXJjZUluZm8gPSAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKSc7XG4gIH1cbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyBzb3VyY2VJbmZvO1xufTtcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7XG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1BMQUNFSE9MREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wbGFjZWhvbGRlcicpIDogMHhlYWQxO1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUGVuZGluZyA9IDA7XG52YXIgUmVzb2x2ZWQgPSAxO1xudmFyIFJlamVjdGVkID0gMjtcblxuZnVuY3Rpb24gZ2V0UmVzdWx0RnJvbVJlc29sdmVkVGhlbmFibGUodGhlbmFibGUpIHtcbiAgcmV0dXJuIHRoZW5hYmxlLl9yZWFjdFJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVmaW5lUmVzb2x2ZWRUaGVuYWJsZSh0aGVuYWJsZSkge1xuICByZXR1cm4gdGhlbmFibGUuX3JlYWN0U3RhdHVzID09PSBSZXNvbHZlZCA/IHRoZW5hYmxlLl9yZWFjdFJlc3VsdCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ0FzeW5jTW9kZSc7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuICAgIGNhc2UgUkVBQ1RfUExBQ0VIT0xERVJfVFlQRTpcbiAgICAgIHJldHVybiAnUGxhY2Vob2xkZXInO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICByZXR1cm4gJ0NvbnRleHQuQ29uc3VtZXInO1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICByZXR1cm4gJ0NvbnRleHQuUHJvdmlkZXInO1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICB2YXIgcmVuZGVyRm4gPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHJlbmRlckZuLmRpc3BsYXlOYW1lIHx8IHJlbmRlckZuLm5hbWUgfHwgJyc7XG4gICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gJ0ZvcndhcmRSZWYoJyArIGZ1bmN0aW9uTmFtZSArICcpJyA6ICdGb3J3YXJkUmVmJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdHlwZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdGhlbmFibGUgPSB0eXBlO1xuICAgICAgdmFyIHJlc29sdmVkVGhlbmFibGUgPSByZWZpbmVSZXNvbHZlZFRoZW5hYmxlKHRoZW5hYmxlKTtcbiAgICAgIGlmIChyZXNvbHZlZFRoZW5hYmxlKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHJlc29sdmVkVGhlbmFibGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBkZXNjcmliZUZpYmVyKGZpYmVyKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnRMYXp5OlxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgTW9kZTpcbiAgICAgIHZhciBvd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgICAgdmFyIHNvdXJjZSA9IGZpYmVyLl9kZWJ1Z1NvdXJjZTtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKTtcbiAgICAgIHZhciBvd25lck5hbWUgPSBudWxsO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIG93bmVyTmFtZSA9IGdldENvbXBvbmVudE5hbWUob3duZXIudHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIGluZm8gPSAnJztcbiAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgZG8ge1xuICAgIGluZm8gKz0gZGVzY3JpYmVGaWJlcihub2RlKTtcbiAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gIH0gd2hpbGUgKG5vZGUpO1xuICByZXR1cm4gaW5mbztcbn1cblxudmFyIGN1cnJlbnQgPSBudWxsO1xudmFyIHBoYXNlID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB7XG4gIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBvd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIHR5cGVvZiBvd25lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKG93bmVyLnR5cGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldigpIHtcbiAge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuICAgIC8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG4gICAgcmV0dXJuIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChjdXJyZW50KTtcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q3VycmVudEZpYmVyKCkge1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICAgIGN1cnJlbnQgPSBudWxsO1xuICAgIHBoYXNlID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50RmliZXIoZmliZXIpIHtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldjtcbiAgICBjdXJyZW50ID0gZmliZXI7XG4gICAgcGhhc2UgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRQaGFzZShsaWZlQ3ljbGVQaGFzZSkge1xuICB7XG4gICAgcGhhc2UgPSBsaWZlQ3ljbGVQaGFzZTtcbiAgfVxufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IHdhcm5pbmdXaXRob3V0U3RhY2skMTtcblxue1xuICB3YXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3dhcm5pbmctYW5kLWludmFyaWFudC1hcmdzXG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMS5hcHBseSh1bmRlZmluZWQsIFtmYWxzZSwgZm9ybWF0ICsgJyVzJ10uY29uY2F0KGFyZ3MsIFtzdGFja10pKTtcbiAgfTtcbn1cblxudmFyIHdhcm5pbmckMSA9IHdhcm5pbmc7XG5cbi8vIEEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuLy8gSXQgaXMgaGFuZGxlZCBieSBSZWFjdCBzZXBhcmF0ZWx5IGFuZCBzaG91bGRuJ3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxudmFyIFJFU0VSVkVEID0gMDtcblxuLy8gQSBzaW1wbGUgc3RyaW5nIGF0dHJpYnV0ZS5cbi8vIEF0dHJpYnV0ZXMgdGhhdCBhcmVuJ3QgaW4gdGhlIHdoaXRlbGlzdCBhcmUgcHJlc3VtZWQgdG8gaGF2ZSB0aGlzIHR5cGUuXG52YXIgU1RSSU5HID0gMTtcblxuLy8gQSBzdHJpbmcgYXR0cmlidXRlIHRoYXQgYWNjZXB0cyBib29sZWFucyBpbiBSZWFjdC4gSW4gSFRNTCwgdGhlc2UgYXJlIGNhbGxlZFxuLy8gXCJlbnVtZXJhdGVkXCIgYXR0cmlidXRlcyB3aXRoIFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIgYXMgcG9zc2libGUgdmFsdWVzLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJ0cnVlXCIgc3RyaW5nLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIHNldCB0byBhIFwiZmFsc2VcIiBzdHJpbmcuXG52YXIgQk9PTEVBTklTSF9TVFJJTkcgPSAyO1xuXG4vLyBBIHJlYWwgYm9vbGVhbiBhdHRyaWJ1dGUuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBwcmVzZW50IChzZXQgZWl0aGVyIHRvIGFuIGVtcHR5IHN0cmluZyBvciBpdHMgbmFtZSkuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgb21pdHRlZC5cbnZhciBCT09MRUFOID0gMztcblxuLy8gQW4gYXR0cmlidXRlIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgcHJlc2VudCAoc2V0IGVpdGhlciB0byBhbiBlbXB0eSBzdHJpbmcgb3IgaXRzIG5hbWUpLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIG9taXR0ZWQuXG4vLyBGb3IgYW55IG90aGVyIHZhbHVlLCBzaG91bGQgYmUgcHJlc2VudCB3aXRoIHRoYXQgdmFsdWUuXG52YXIgT1ZFUkxPQURFRF9CT09MRUFOID0gNDtcblxuLy8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxudmFyIE5VTUVSSUMgPSA1O1xuXG4vLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG52YXIgUE9TSVRJVkVfTlVNRVJJQyA9IDY7XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gJzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkQnO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfQ0hBUiA9IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDAnO1xuXG5cbnZhciBST09UX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtcmVhY3Ryb290JztcbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5cbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICB7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkSWdub3JlQXR0cmlidXRlKG5hbWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gUkVTRVJWRUQ7XG4gIH1cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gUkVTRVJWRUQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgLy8gJEZsb3dJc3N1ZSBzeW1ib2wgaXMgcGVyZmVjdGx5IHZhbGlkIGhlcmVcbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICB7XG4gICAgICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICFwcm9wZXJ0eUluZm8uYWNjZXB0c0Jvb2xlYW5zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCAhPT0gJ2RhdGEtJyAmJiBwcmVmaXggIT09ICdhcmlhLSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuICAgIHN3aXRjaCAocHJvcGVydHlJbmZvLnR5cGUpIHtcbiAgICAgIGNhc2UgQk9PTEVBTjpcbiAgICAgICAgcmV0dXJuICF2YWx1ZTtcbiAgICAgIGNhc2UgT1ZFUkxPQURFRF9CT09MRUFOOlxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IGZhbHNlO1xuICAgICAgY2FzZSBOVU1FUklDOlxuICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpO1xuICAgICAgY2FzZSBQT1NJVElWRV9OVU1FUklDOlxuICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpIHx8IHZhbHVlIDwgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eUluZm8obmFtZSkge1xuICByZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgdHlwZSwgbXVzdFVzZVByb3BlcnR5LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVOYW1lc3BhY2UpIHtcbiAgdGhpcy5hY2NlcHRzQm9vbGVhbnMgPSB0eXBlID09PSBCT09MRUFOSVNIX1NUUklORyB8fCB0eXBlID09PSBCT09MRUFOIHx8IHR5cGUgPT09IE9WRVJMT0FERURfQk9PTEVBTjtcbiAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgdGhpcy5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBhdHRyaWJ1dGVOYW1lc3BhY2U7XG4gIHRoaXMubXVzdFVzZVByb3BlcnR5ID0gbXVzdFVzZVByb3BlcnR5O1xuICB0aGlzLnByb3BlcnR5TmFtZSA9IG5hbWU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG59XG5cbi8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhpcyBsaXN0LCBiZSBzdXJlIHRvIGFsc28gYWRkIHRoZW0gdG9cbi8vIHRoZSBgcG9zc2libGVTdGFuZGFyZE5hbWVzYCBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0XG4vLyBuYW1lIHdhcm5pbmdzLlxudmFyIHByb3BlcnRpZXMgPSB7fTtcblxuLy8gVGhlc2UgcHJvcHMgYXJlIHJlc2VydmVkIGJ5IFJlYWN0LiBUaGV5IHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG5bJ2NoaWxkcmVuJywgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyxcbi8vIFRPRE86IFRoaXMgcHJldmVudHMgdGhlIGFzc2lnbm1lbnQgb2YgZGVmYXVsdFZhbHVlIHRvIHJlZ3VsYXJcbi8vIGVsZW1lbnRzIChub3QganVzdCBpbnB1dHMpLiBOb3cgdGhhdCBSZWFjdERPTUlucHV0IGFzc2lnbnMgdG8gdGhlXG4vLyBkZWZhdWx0VmFsdWUgcHJvcGVydHkgLS0gZG8gd2UgbmVlZCB0aGlzP1xuJ2RlZmF1bHRWYWx1ZScsICdkZWZhdWx0Q2hlY2tlZCcsICdpbm5lckhUTUwnLCAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJywgJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsICdzdHlsZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgUkVTRVJWRUQsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0gLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4pO1xuXG4vLyBBIGZldyBSZWFjdCBzdHJpbmcgYXR0cmlidXRlcyBoYXZlIGEgZGlmZmVyZW50IG5hbWUuXG4vLyBUaGlzIGlzIGEgbWFwcGluZyBmcm9tIFJlYWN0IHByb3AgbmFtZXMgdG8gdGhlIGF0dHJpYnV0ZSBuYW1lcy5cbltbJ2FjY2VwdENoYXJzZXQnLCAnYWNjZXB0LWNoYXJzZXQnXSwgWydjbGFzc05hbWUnLCAnY2xhc3MnXSwgWydodG1sRm9yJywgJ2ZvciddLCBbJ2h0dHBFcXVpdicsICdodHRwLWVxdWl2J11dLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIG5hbWUgPSBfcmVmWzBdLFxuICAgICAgYXR0cmlidXRlTmFtZSA9IF9yZWZbMV07XG5cbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxuLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cblsnY29udGVudEVkaXRhYmxlJywgJ2RyYWdnYWJsZScsICdzcGVsbENoZWNrJywgJ3ZhbHVlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOSVNIX1NUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxuLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIFNWRyBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuLy8gU2luY2UgdGhlc2UgYXJlIFNWRyBhdHRyaWJ1dGVzLCB0aGVpciBhdHRyaWJ1dGUgbmFtZXMgYXJlIGNhc2Utc2Vuc2l0aXZlLlxuWydhdXRvUmV2ZXJzZScsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2ZvY3VzYWJsZScsICdwcmVzZXJ2ZUFscGhhJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOSVNIX1NUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSAvLyBhdHRyaWJ1dGVOYW1lc3BhY2Vcbik7XG5cbi8vIFRoZXNlIGFyZSBIVE1MIGJvb2xlYW4gYXR0cmlidXRlcy5cblsnYWxsb3dGdWxsU2NyZWVuJywgJ2FzeW5jJyxcbi8vIE5vdGU6IHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgcHJldmVudHMgaXQgZnJvbSBiZWluZyB3cml0dGVuIHRvIHRoZSBET01cbi8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbidhdXRvRm9jdXMnLCAnYXV0b1BsYXknLCAnY29udHJvbHMnLCAnZGVmYXVsdCcsICdkZWZlcicsICdkaXNhYmxlZCcsICdmb3JtTm9WYWxpZGF0ZScsICdoaWRkZW4nLCAnbG9vcCcsICdub01vZHVsZScsICdub1ZhbGlkYXRlJywgJ29wZW4nLCAncGxheXNJbmxpbmUnLCAncmVhZE9ubHknLCAncmVxdWlyZWQnLCAncmV2ZXJzZWQnLCAnc2NvcGVkJywgJ3NlYW1sZXNzJyxcbi8vIE1pY3JvZGF0YVxuJ2l0ZW1TY29wZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxuLy8gVGhlc2UgYXJlIHRoZSBmZXcgUmVhY3QgcHJvcHMgdGhhdCB3ZSBzZXQgYXMgRE9NIHByb3BlcnRpZXNcbi8vIHJhdGhlciB0aGFuIGF0dHJpYnV0ZXMuIFRoZXNlIGFyZSBhbGwgYm9vbGVhbnMuXG5bJ2NoZWNrZWQnLFxuLy8gTm90ZTogYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbi8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuIFdlIGhhdmUgc3BlY2lhbCBsb2dpYyBmb3IgaGFuZGxpbmcgdGhpcy5cbidtdWx0aXBsZScsICdtdXRlZCcsICdzZWxlY3RlZCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgdHJ1ZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxuLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFyZSBcIm92ZXJsb2FkZWQgYm9vbGVhbnNcIjogdGhleSBiZWhhdmUgbGlrZVxuLy8gYm9vbGVhbnMsIGJ1dCBjYW4gYWxzbyBhY2NlcHQgYSBzdHJpbmcgdmFsdWUuXG5bJ2NhcHR1cmUnLCAnZG93bmxvYWQnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIE9WRVJMT0FERURfQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSAvLyBhdHRyaWJ1dGVOYW1lc3BhY2Vcbik7XG5cbi8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIHBvc2l0aXZlIG51bWJlcnMuXG5bJ2NvbHMnLCAncm93cycsICdzaXplJywgJ3NwYW4nXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFBPU0lUSVZFX05VTUVSSUMsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0gLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4pO1xuXG4vLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBudW1iZXJzLlxuWydyb3dTcGFuJywgJ3N0YXJ0J10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBOVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0gLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4pO1xuXG52YXIgQ0FNRUxJWkUgPSAvW1xcLVxcOl0oW2Etel0pL2c7XG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICByZXR1cm4gdG9rZW5bMV0udG9VcHBlckNhc2UoKTtcbn07XG5cbi8vIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcsIG5hbWVzcGFjaW5nLFxuLy8gb3IgYm9vbGVhbiB2YWx1ZSBhc3NpZ25tZW50LiBSZWd1bGFyIGF0dHJpYnV0ZXMgdGhhdCBqdXN0IGFjY2VwdCBzdHJpbmdzXG4vLyBhbmQgaGF2ZSB0aGUgc2FtZSBuYW1lcyBhcmUgb21pdHRlZCwganVzdCBsaWtlIGluIHRoZSBIVE1MIHdoaXRlbGlzdC5cbi8vIFNvbWUgb2YgdGhlc2UgYXR0cmlidXRlcyBjYW4gYmUgaGFyZCB0byBmaW5kLiBUaGlzIGxpc3Qgd2FzIGNyZWF0ZWQgYnlcbi8vIHNjcmFwcGluZyB0aGUgTUROIGRvY3VtZW50YXRpb24uXG5bJ2FjY2VudC1oZWlnaHQnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FyYWJpYy1mb3JtJywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2NhcC1oZWlnaHQnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdkb21pbmFudC1iYXNlbGluZScsICdlbmFibGUtYmFja2dyb3VuZCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2dseXBoLW5hbWUnLCAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsICdob3Jpei1hZHYteCcsICdob3Jpei1vcmlnaW4teCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnbGV0dGVyLXNwYWNpbmcnLCAnbGlnaHRpbmctY29sb3InLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdvdmVybGluZS1wb3NpdGlvbicsICdvdmVybGluZS10aGlja25lc3MnLCAncGFpbnQtb3JkZXInLCAncGFub3NlLTEnLCAncG9pbnRlci1ldmVudHMnLCAncmVuZGVyaW5nLWludGVudCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2Utd2lkdGgnLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3VuZGVybGluZS1wb3NpdGlvbicsICd1bmRlcmxpbmUtdGhpY2tuZXNzJywgJ3VuaWNvZGUtYmlkaScsICd1bmljb2RlLXJhbmdlJywgJ3VuaXRzLXBlci1lbScsICd2LWFscGhhYmV0aWMnLCAndi1oYW5naW5nJywgJ3YtaWRlb2dyYXBoaWMnLCAndi1tYXRoZW1hdGljYWwnLCAndmVjdG9yLWVmZmVjdCcsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3b3JkLXNwYWNpbmcnLCAnd3JpdGluZy1tb2RlJywgJ3htbG5zOnhsaW5rJywgJ3gtaGVpZ2h0J10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCBudWxsKTtcbn0gLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4pO1xuXG4vLyBTdHJpbmcgU1ZHIGF0dHJpYnV0ZXMgd2l0aCB0aGUgeGxpbmsgbmFtZXNwYWNlLlxuWyd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZSddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnKTtcbn0pO1xuXG4vLyBTdHJpbmcgU1ZHIGF0dHJpYnV0ZXMgd2l0aCB0aGUgeG1sIG5hbWVzcGFjZS5cblsneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJyk7XG59KTtcblxuLy8gU3BlY2lhbCBjYXNlOiB0aGlzIGF0dHJpYnV0ZSBleGlzdHMgYm90aCBpbiBIVE1MIGFuZCBTVkcuXG4vLyBJdHMgXCJ0YWJpbmRleFwiIGF0dHJpYnV0ZSBuYW1lIGlzIGNhc2Utc2Vuc2l0aXZlIGluIFNWRyBzbyB3ZSBjYW4ndCBqdXN0IHVzZVxuLy8gaXRzIFJlYWN0IGB0YWJJbmRleGAgbmFtZSwgbGlrZSB3ZSBkbyBmb3IgYXR0cmlidXRlcyB0aGF0IGV4aXN0IG9ubHkgaW4gSFRNTC5cbnByb3BlcnRpZXMudGFiSW5kZXggPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKCd0YWJJbmRleCcsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuJ3RhYmluZGV4JywgLy8gYXR0cmlidXRlTmFtZVxubnVsbCk7XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIFwiZXhwZWN0ZWRcIiBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy5cbiAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8pIHtcbiAge1xuICAgIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICB2YXIgcHJvcGVydHlOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcblxuICAgICAgcmV0dXJuIG5vZGVbcHJvcGVydHlOYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcblxuICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gbnVsbDtcblxuICAgICAgaWYgKHByb3BlcnR5SW5mby50eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU4pIHtcbiAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCBleHBlY3RlZCwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgICAgICAvLyBXZSBoYWQgYW4gYXR0cmlidXRlIGJ1dCBzaG91bGRuJ3QgaGF2ZSBoYWQgb25lLCBzbyByZWFkIGl0XG4gICAgICAgICAgLy8gZm9yIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydHlJbmZvLnR5cGUgPT09IEJPT0xFQU4pIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIHdhcyBhIGJvb2xlYW4sIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIHZhbHVlIGlzXG4gICAgICAgICAgLy8gdGhlIGZhY3QgdGhhdCB3ZSBoYXZlIGl0IGlzIHRoZSBzYW1lIGFzIHRoZSBleHBlY3RlZC5cbiAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXZlbiBpZiB0aGlzIHByb3BlcnR5IHVzZXMgYSBuYW1lc3BhY2Ugd2UgdXNlIGdldEF0dHJpYnV0ZVxuICAgICAgICAvLyBiZWNhdXNlIHdlIGFzc3VtZSBpdHMgbmFtZXNwYWNlZCBuYW1lIGlzIHRoZSBzYW1lIGFzIG91ciBjb25maWcuXG4gICAgICAgIC8vIFRvIHVzZSBnZXRBdHRyaWJ1dGVOUyB3ZSBuZWVkIHRoZSBsb2NhbCBuYW1lIHdoaWNoIHdlIGRvbid0IGhhdmVcbiAgICAgICAgLy8gaW4gb3VyIGNvbmZpZyBhdG0uXG4gICAgICAgIHN0cmluZ1ZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gbnVsbCA/IGV4cGVjdGVkIDogc3RyaW5nVmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZ1ZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIGF0dHJpYnV0ZSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIHRoaXJkIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLiBTb21lXG4gKiBhdHRyaWJ1dGVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBpZiAodmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSwgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgaWYgKHNob3VsZElnbm9yZUF0dHJpYnV0ZShuYW1lLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHZhbHVlID0gbnVsbDtcbiAgfVxuICAvLyBJZiB0aGUgcHJvcCBpc24ndCBpbiB0aGUgc3BlY2lhbCBsaXN0LCB0cmVhdCBpdCBhcyBhIHNpbXBsZSBhdHRyaWJ1dGUuXG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyB8fCBwcm9wZXJ0eUluZm8gPT09IG51bGwpIHtcbiAgICBpZiAoaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgdmFyIF9hdHRyaWJ1dGVOYW1lID0gbmFtZTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShfYXR0cmlidXRlTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShfYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbXVzdFVzZVByb3BlcnR5ID0gcHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eTtcblxuICBpZiAobXVzdFVzZVByb3BlcnR5KSB7XG4gICAgdmFyIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHZhciB0eXBlID0gcHJvcGVydHlJbmZvLnR5cGU7XG5cbiAgICAgIG5vZGVbcHJvcGVydHlOYW1lXSA9IHR5cGUgPT09IEJPT0xFQU4gPyBmYWxzZSA6ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb250cmFyeSB0byBgc2V0QXR0cmlidXRlYCwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIHByb3Blcmx5XG4gICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICBub2RlW3Byb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFRoZSByZXN0IGFyZSB0cmVhdGVkIGFzIGF0dHJpYnV0ZXMgd2l0aCBzcGVjaWFsIGNhc2VzLlxuICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lLFxuICAgICAgYXR0cmlidXRlTmFtZXNwYWNlID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZTtcblxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3R5cGUgPSBwcm9wZXJ0eUluZm8udHlwZTtcblxuICAgIHZhciBhdHRyaWJ1dGVWYWx1ZSA9IHZvaWQgMDtcbiAgICBpZiAoX3R5cGUgPT09IEJPT0xFQU4gfHwgX3R5cGUgPT09IE9WRVJMT0FERURfQk9PTEVBTiAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxuICAgICAgLy8gKCcnICsgdmFsdWUpIG1ha2VzIGl0IG91dHB1dCB0aGUgY29ycmVjdCB0b1N0cmluZygpLXZhbHVlLlxuICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlTmFtZXNwYWNlKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKGF0dHJpYnV0ZU5hbWVzcGFjZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIEZsb3cgZG9lcyBub3QgYWxsb3cgc3RyaW5nIGNvbmNhdGVuYXRpb24gb2YgbW9zdCBub24tc3RyaW5nIHR5cGVzLiBUbyB3b3JrXG4vLyBhcm91bmQgdGhpcyBsaW1pdGF0aW9uLCB3ZSB1c2UgYW4gb3BhcXVlIHR5cGUgdGhhdCBjYW4gb25seSBiZSBvYnRhaW5lZCBieVxuLy8gcGFzc2luZyB0aGUgdmFsdWUgdGhyb3VnaCBnZXRUb1N0cmluZ1ZhbHVlIGZpcnN0LlxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBmdW5jdGlvbiwgc3ltYm9sIGFyZSBhc3NpZ25lZCBhcyBlbXB0eSBzdHJpbmdzXG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IG51bGw7XG5cbnZhciBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcyA9IHtcbiAgY2hlY2tQcm9wVHlwZXM6IG51bGxcbn07XG5cbntcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuICB2YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgICBidXR0b246IHRydWUsXG4gICAgY2hlY2tib3g6IHRydWUsXG4gICAgaW1hZ2U6IHRydWUsXG4gICAgaGlkZGVuOiB0cnVlLFxuICAgIHJhZGlvOiB0cnVlLFxuICAgIHJlc2V0OiB0cnVlLFxuICAgIHN1Ym1pdDogdHJ1ZVxuICB9O1xuXG4gIHZhciBwcm9wVHlwZXMgPSB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIGlmIChoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9LFxuICAgIGNoZWNrZWQ6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIGlmIChwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gICAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gICAqL1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcykge1xuICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgcHJvcHMsICdwcm9wJywgdGFnTmFtZSwgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldFN0YWNrQWRkZW5kdW0pO1xuICB9O1xufVxuXG4vLyBFeHBvcnRzIFJlYWN0RE9NLmNyZWF0ZVJvb3RcbnZhciBlbmFibGVVc2VyVGltaW5nQVBJID0gdHJ1ZTtcblxuLy8gRXhwZXJpbWVudGFsIGVycm9yLWJvdW5kYXJ5IEFQSSB0aGF0IGNhbiByZWNvdmVyIGZyb20gZXJyb3JzIHdpdGhpbiBhIHNpbmdsZVxuLy8gcmVuZGVyIHBoYXNlXG52YXIgZW5hYmxlR2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoID0gZmFsc2U7XG4vLyBTdXNwZW5zZVxudmFyIGVuYWJsZVN1c3BlbnNlID0gZmFsc2U7XG4vLyBIZWxwcyBpZGVudGlmeSBzaWRlIGVmZmVjdHMgaW4gYmVnaW4tcGhhc2UgbGlmZWN5Y2xlIGhvb2tzIGFuZCBzZXRTdGF0ZSByZWR1Y2VyczpcbnZhciBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMgPSBmYWxzZTtcblxuLy8gSW4gc29tZSBjYXNlcywgU3RyaWN0TW9kZSBzaG91bGQgYWxzbyBkb3VibGUtcmVuZGVyIGxpZmVjeWNsZXMuXG4vLyBUaGlzIGNhbiBiZSBjb25mdXNpbmcgZm9yIHRlc3RzIHRob3VnaCxcbi8vIEFuZCBpdCBjYW4gYmUgYmFkIGZvciBwZXJmb3JtYW5jZSBpbiBwcm9kdWN0aW9uLlxuLy8gVGhpcyBmZWF0dXJlIGZsYWcgY2FuIGJlIHVzZWQgdG8gY29udHJvbCB0aGUgYmVoYXZpb3I6XG52YXIgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzRm9yU3RyaWN0TW9kZSA9IHRydWU7XG5cbi8vIFRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIGRlYnVnZ2VyLCB3ZVxuLy8gcmVwbGF5IHRoZSBiZWdpbiBwaGFzZSBvZiBhIGZhaWxlZCBjb21wb25lbnQgaW5zaWRlIGludm9rZUd1YXJkZWRDYWxsYmFjay5cbnZhciByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjayA9IHRydWU7XG5cbi8vIFdhcm4gYWJvdXQgZGVwcmVjYXRlZCwgYXN5bmMtdW5zYWZlIGxpZmVjeWNsZXM7IHJlbGF0ZXMgdG8gUkZDICM2OlxudmFyIHdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzID0gZmFsc2U7XG5cbi8vIFdhcm4gYWJvdXQgbGVnYWN5IGNvbnRleHQgQVBJXG52YXIgd2FybkFib3V0TGVnYWN5Q29udGV4dEFQSSA9IGZhbHNlO1xuXG4vLyBHYXRoZXIgYWR2YW5jZWQgdGltaW5nIG1ldHJpY3MgZm9yIFByb2ZpbGVyIHN1YnRyZWVzLlxudmFyIGVuYWJsZVByb2ZpbGVyVGltZXIgPSB0cnVlO1xuXG4vLyBUcmFjZSB3aGljaCBpbnRlcmFjdGlvbnMgdHJpZ2dlciBlYWNoIGNvbW1pdC5cbnZhciBlbmFibGVTY2hlZHVsZXJUcmFjaW5nID0gdHJ1ZTtcblxuLy8gT25seSB1c2VkIGluIHd3dyBidWlsZHMuXG5cblxuLy8gT25seSB1c2VkIGluIHd3dyBidWlsZHMuXG5cblxuLy8gUmVhY3QgRmlyZTogcHJldmVudCB0aGUgdmFsdWUgYW5kIGNoZWNrZWQgYXR0cmlidXRlcyBmcm9tIHN5bmNpbmdcbi8vIHdpdGggdGhlaXIgcmVsYXRlZCBET00gcHJvcGVydGllc1xudmFyIGRpc2FibGVJbnB1dEF0dHJpYnV0ZVN5bmNpbmcgPSBmYWxzZTtcblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUoZWxlbWVudCwgcHJvcHMpIHtcbiAge1xuICAgIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCdpbnB1dCcsIHByb3BzKTtcblxuICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggY2hlY2tlZCBhbmQgZGVmYXVsdENoZWNrZWQgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG4gICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCA/ICcnIDogcHJvcHMuZGVmYXVsdFZhbHVlO1xuXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsQ2hlY2tlZDogcHJvcHMuY2hlY2tlZCAhPSBudWxsID8gcHJvcHMuY2hlY2tlZCA6IHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgIGluaXRpYWxWYWx1ZTogZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWUpLFxuICAgIGNvbnRyb2xsZWQ6IGlzQ29udHJvbGxlZChwcm9wcylcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgJ2NoZWNrZWQnLCBjaGVja2VkLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICB2YXIgX2NvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuXG4gICAgaWYgKCFub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiBfY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYW4gdW5jb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBwcm9wcy50eXBlKTtcbiAgICAgIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgIV9jb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSB1bmNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgcHJvcHMudHlwZSk7XG4gICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVDaGVja2VkKGVsZW1lbnQsIHByb3BzKTtcblxuICB2YXIgdmFsdWUgPSBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLnZhbHVlKTtcbiAgdmFyIHR5cGUgPSBwcm9wcy50eXBlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAodmFsdWUgPT09IDAgJiYgbm9kZS52YWx1ZSA9PT0gJycgfHxcbiAgICAgIC8vIFdlIGV4cGxpY2l0bHkgd2FudCB0byBjb2VyY2UgdG8gbnVtYmVyIGhlcmUgaWYgcG9zc2libGUuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIG5vZGUudmFsdWUgIT0gdmFsdWUpIHtcbiAgICAgICAgbm9kZS52YWx1ZSA9IHRvU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudmFsdWUgIT09IHRvU3RyaW5nKHZhbHVlKSkge1xuICAgICAgbm9kZS52YWx1ZSA9IHRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N1Ym1pdCcgfHwgdHlwZSA9PT0gJ3Jlc2V0Jykge1xuICAgIC8vIFN1Ym1pdC9yZXNldCBpbnB1dHMgbmVlZCB0aGUgYXR0cmlidXRlIHJlbW92ZWQgY29tcGxldGVseSB0byBhdm9pZFxuICAgIC8vIGJsYW5rLXRleHQgYnV0dG9ucy5cbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZGlzYWJsZUlucHV0QXR0cmlidXRlU3luY2luZykge1xuICAgIC8vIFdoZW4gbm90IHN5bmNpbmcgdGhlIHZhbHVlIGF0dHJpYnV0ZSwgUmVhY3Qgb25seSBhc3NpZ25zIGEgbmV3IHZhbHVlXG4gICAgLy8gd2hlbmV2ZXIgdGhlIGRlZmF1bHRWYWx1ZSBSZWFjdCBwcm9wIGhhcyBjaGFuZ2VkLiBXaGVuIG5vdCBwcmVzZW50LFxuICAgIC8vIFJlYWN0IGRvZXMgbm90aGluZ1xuICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdFZhbHVlJykpIHtcbiAgICAgIHNldERlZmF1bHRWYWx1ZShub2RlLCBwcm9wcy50eXBlLCBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLmRlZmF1bHRWYWx1ZSkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXaGVuIHN5bmNpbmcgdGhlIHZhbHVlIGF0dHJpYnV0ZSwgdGhlIHZhbHVlIGNvbWVzIGZyb20gYSBjYXNjYWRlIG9mXG4gICAgLy8gcHJvcGVydGllczpcbiAgICAvLyAgMS4gVGhlIHZhbHVlIFJlYWN0IHByb3BlcnR5XG4gICAgLy8gIDIuIFRoZSBkZWZhdWx0VmFsdWUgUmVhY3QgcHJvcGVydHlcbiAgICAvLyAgMy4gT3RoZXJ3aXNlIHRoZXJlIHNob3VsZCBiZSBubyBjaGFuZ2VcbiAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIHtcbiAgICAgIHNldERlZmF1bHRWYWx1ZShub2RlLCBwcm9wcy50eXBlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdFZhbHVlJykpIHtcbiAgICAgIHNldERlZmF1bHRWYWx1ZShub2RlLCBwcm9wcy50eXBlLCBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLmRlZmF1bHRWYWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXNhYmxlSW5wdXRBdHRyaWJ1dGVTeW5jaW5nKSB7XG4gICAgLy8gV2hlbiBub3Qgc3luY2luZyB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUsIHRoZSBhdHRyaWJ1dGUgaXMgZGlyZWN0bHlcbiAgICAvLyBjb250cm9sbGFibGUgZnJvbSB0aGUgZGVmYXVsdFZhbHVlIFJlYWN0IHByb3BlcnR5LiBJdCBuZWVkcyB0byBiZVxuICAgIC8vIHVwZGF0ZWQgYXMgbmV3IHByb3BzIGNvbWUgaW4uXG4gICAgaWYgKHByb3BzLmRlZmF1bHRDaGVja2VkID09IG51bGwpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCdjaGVja2VkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIXByb3BzLmRlZmF1bHRDaGVja2VkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXaGVuIHN5bmNpbmcgdGhlIGNoZWNrZWQgYXR0cmlidXRlLCBpdCBvbmx5IGNoYW5nZXMgd2hlbiBpdCBuZWVkc1xuICAgIC8vIHRvIGJlIHJlbW92ZWQsIHN1Y2ggYXMgdHJhbnNpdGlvbmluZyBmcm9tIGEgY2hlY2tib3ggaW50byBhIHRleHQgaW5wdXRcbiAgICBpZiAocHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIXByb3BzLmRlZmF1bHRDaGVja2VkO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyKGVsZW1lbnQsIHByb3BzLCBpc0h5ZHJhdGluZykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAgLy8gRG8gbm90IGFzc2lnbiB2YWx1ZSBpZiBpdCBpcyBhbHJlYWR5IHNldC4gVGhpcyBwcmV2ZW50cyB1c2VyIHRleHQgaW5wdXRcbiAgLy8gZnJvbSBiZWluZyBsb3N0IGR1cmluZyBTU1IgaHlkcmF0aW9uLlxuICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykgfHwgcHJvcHMuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgdmFyIHR5cGUgPSBwcm9wcy50eXBlO1xuICAgIHZhciBpc0J1dHRvbiA9IHR5cGUgPT09ICdzdWJtaXQnIHx8IHR5cGUgPT09ICdyZXNldCc7XG5cbiAgICAvLyBBdm9pZCBzZXR0aW5nIHZhbHVlIGF0dHJpYnV0ZSBvbiBzdWJtaXQvcmVzZXQgaW5wdXRzIGFzIGl0IG92ZXJyaWRlcyB0aGVcbiAgICAvLyBkZWZhdWx0IHZhbHVlIHByb3ZpZGVkIGJ5IHRoZSBicm93c2VyLiBTZWU6ICMxMjg3MlxuICAgIGlmIChpc0J1dHRvbiAmJiAocHJvcHMudmFsdWUgPT09IHVuZGVmaW5lZCB8fCBwcm9wcy52YWx1ZSA9PT0gbnVsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX2luaXRpYWxWYWx1ZSA9IHRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpO1xuXG4gICAgLy8gRG8gbm90IGFzc2lnbiB2YWx1ZSBpZiBpdCBpcyBhbHJlYWR5IHNldC4gVGhpcyBwcmV2ZW50cyB1c2VyIHRleHQgaW5wdXRcbiAgICAvLyBmcm9tIGJlaW5nIGxvc3QgZHVyaW5nIFNTUiBoeWRyYXRpb24uXG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgaWYgKGRpc2FibGVJbnB1dEF0dHJpYnV0ZVN5bmNpbmcpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSk7XG5cbiAgICAgICAgLy8gV2hlbiBub3Qgc3luY2luZyB0aGUgdmFsdWUgYXR0cmlidXRlLCB0aGUgdmFsdWUgcHJvcGVydHkgcG9pbnRzXG4gICAgICAgIC8vIGRpcmVjdGx5IHRvIHRoZSBSZWFjdCBwcm9wLiBPbmx5IGFzc2lnbiBpdCBpZiBpdCBleGlzdHMuXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQWx3YXlzIGFzc2lnbiBvbiBidXR0b25zIHNvIHRoYXQgaXQgaXMgcG9zc2libGUgdG8gYXNzaWduIGFuXG4gICAgICAgICAgLy8gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIGJ1dHRvbiB0ZXh0LlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCBkbyBub3QgcmUtYXNzaWduIHRoZSB2YWx1ZSBwcm9wZXJ0eSBpZiBpcyBlbXB0eS4gVGhpc1xuICAgICAgICAgIC8vIHBvdGVudGlhbGx5IGF2b2lkcyBhIERPTSB3cml0ZSBhbmQgcHJldmVudHMgRmlyZWZveCAofjYwLjAuMSkgZnJvbVxuICAgICAgICAgIC8vIHByZW1hdHVyZWx5IG1hcmtpbmcgcmVxdWlyZWQgaW5wdXRzIGFzIGludmFsaWQuIEVxdWFsaXR5IGlzIGNvbXBhcmVkXG4gICAgICAgICAgLy8gdG8gdGhlIGN1cnJlbnQgdmFsdWUgaW4gY2FzZSB0aGUgYnJvd3NlciBwcm92aWRlZCB2YWx1ZSBpcyBub3QgYW5cbiAgICAgICAgICAvLyBlbXB0eSBzdHJpbmcuXG4gICAgICAgICAgaWYgKGlzQnV0dG9uIHx8IHZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gdG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2hlbiBzeW5jaW5nIHRoZSB2YWx1ZSBhdHRyaWJ1dGUsIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzaG91bGQgdXNlXG4gICAgICAgIC8vIHRoZSB0aGUgd3JhcHBlclN0YXRlLl9pbml0aWFsVmFsdWUgcHJvcGVydHkuIFRoaXMgdXNlczpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAxLiBUaGUgdmFsdWUgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4gICAgICAgIC8vICAgMi4gVGhlIGRlZmF1bHRWYWx1ZSBSZWFjdCBwcm9wZXJ0eSB3aGVuIHByZXNlbnRcbiAgICAgICAgLy8gICAzLiBBbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgaWYgKF9pbml0aWFsVmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgICAgICBub2RlLnZhbHVlID0gX2luaXRpYWxWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaXNhYmxlSW5wdXRBdHRyaWJ1dGVTeW5jaW5nKSB7XG4gICAgICAvLyBXaGVuIG5vdCBzeW5jaW5nIHRoZSB2YWx1ZSBhdHRyaWJ1dGUsIGFzc2lnbiB0aGUgdmFsdWUgYXR0cmlidXRlXG4gICAgICAvLyBkaXJlY3RseSBmcm9tIHRoZSBkZWZhdWx0VmFsdWUgUmVhY3QgcHJvcGVydHkgKHdoZW4gcHJlc2VudClcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSB0b1N0cmluZyhkZWZhdWx0VmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgaXMgc3luY2hyb25pemVkIHRvIHRoZSBwcm9wZXJ0eSxcbiAgICAgIC8vIHNvIHdlIGFzc2lnbiBkZWZhdWx0VmFsdWUgdG8gdGhlIHNhbWUgdGhpbmcgYXMgdGhlIHZhbHVlIHByb3BlcnR5XG4gICAgICAvLyBhc3NpZ25tZW50IHN0ZXAgYWJvdmUuXG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IF9pbml0aWFsVmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcbiAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIHdoZXJlIHNldHRpbmcgZGVmYXVsdENoZWNrZWRcbiAgLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxuICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxuICAvLyBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHVuc2V0IG5hbWUgdG8gYXZvaWQgZGlzcnVwdGluZyByYWRpbyBidXR0b24gZ3JvdXBzLlxuICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgbm9kZS5uYW1lID0gJyc7XG4gIH1cblxuICBpZiAoZGlzYWJsZUlucHV0QXR0cmlidXRlU3luY2luZykge1xuICAgIC8vIFdoZW4gbm90IHN5bmNpbmcgdGhlIGNoZWNrZWQgYXR0cmlidXRlLCB0aGUgY2hlY2tlZCBwcm9wZXJ0eVxuICAgIC8vIG5ldmVyIGdldHMgYXNzaWduZWQuIEl0IG11c3QgYmUgbWFudWFsbHkgc2V0LiBXZSBkb24ndCB3YW50XG4gICAgLy8gdG8gZG8gdGhpcyB3aGVuIGh5ZHJhdGluZyBzbyB0aGF0IGV4aXN0aW5nIHVzZXIgaW5wdXQgaXNuJ3RcbiAgICAvLyBtb2RpZmllZFxuICAgIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAgIHVwZGF0ZUNoZWNrZWQoZWxlbWVudCwgcHJvcHMpO1xuICAgIH1cblxuICAgIC8vIE9ubHkgYXNzaWduIHRoZSBjaGVja2VkIGF0dHJpYnV0ZSBpZiBpdCBpcyBkZWZpbmVkLiBUaGlzIHNhdmVzXG4gICAgLy8gYSBET00gd3JpdGUgd2hlbiBjb250cm9sbGluZyB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUgaXNuJ3QgbmVlZGVkXG4gICAgLy8gKHRleHQgaW5wdXRzLCBzdWJtaXQvcmVzZXQpXG4gICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCdkZWZhdWx0Q2hlY2tlZCcpKSB7XG4gICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiBzeW5jaW5nIHRoZSBjaGVja2VkIGF0dHJpYnV0ZSwgYm90aCB0aGUgdGhlIGNoZWNrZWQgcHJvcGVydHkgYW5kXG4gICAgLy8gYXR0cmlidXRlIGFyZSBhc3NpZ25lZCBhdCB0aGUgc2FtZSB0aW1lIHVzaW5nIGRlZmF1bHRDaGVja2VkLiBUaGlzIHVzZXM6XG4gICAgLy9cbiAgICAvLyAgIDEuIFRoZSBjaGVja2VkIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuICAgIC8vICAgMi4gVGhlIGRlZmF1bHRDaGVja2VkIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuICAgIC8vICAgMy4gT3RoZXJ3aXNlLCBmYWxzZVxuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQ7XG4gIH1cblxuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB1cGRhdGVXcmFwcGVyKG5vZGUsIHByb3BzKTtcbiAgdXBkYXRlTmFtZWRDb3VzaW5zKG5vZGUsIHByb3BzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTmFtZWRDb3VzaW5zKHJvb3ROb2RlLCBwcm9wcykge1xuICB2YXIgbmFtZSA9IHByb3BzLm5hbWU7XG4gIGlmIChwcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5hbWUgIT0gbnVsbCkge1xuICAgIHZhciBxdWVyeVJvb3QgPSByb290Tm9kZTtcblxuICAgIHdoaWxlIChxdWVyeVJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgcXVlcnlSb290ID0gcXVlcnlSb290LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gSWYgYHJvb3ROb2RlLmZvcm1gIHdhcyBub24tbnVsbCwgdGhlbiB3ZSBjb3VsZCB0cnkgYGZvcm0uZWxlbWVudHNgLFxuICAgIC8vIGJ1dCB0aGF0IHNvbWV0aW1lcyBiZWhhdmVzIHN0cmFuZ2VseSBpbiBJRTguIFdlIGNvdWxkIGFsc28gdHJ5IHVzaW5nXG4gICAgLy8gYGZvcm0uZ2V0RWxlbWVudHNCeU5hbWVgLCBidXQgdGhhdCB3aWxsIG9ubHkgcmV0dXJuIGRpcmVjdCBjaGlsZHJlblxuICAgIC8vIGFuZCB3b24ndCBpbmNsdWRlIGlucHV0cyB0aGF0IHVzZSB0aGUgSFRNTDUgYGZvcm09YCBhdHRyaWJ1dGUuIFNpbmNlXG4gICAgLy8gdGhlIGlucHV0IG1pZ2h0IG5vdCBldmVuIGJlIGluIGEgZm9ybS4gSXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gdGhlXG4gICAgLy8gZG9jdW1lbnQuIExldCdzIGp1c3QgdXNlIHRoZSBsb2NhbCBgcXVlcnlTZWxlY3RvckFsbGAgdG8gZW5zdXJlIHdlIGRvbid0XG4gICAgLy8gbWlzcyBhbnl0aGluZy5cbiAgICB2YXIgZ3JvdXAgPSBxdWVyeVJvb3QucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT0nICsgSlNPTi5zdHJpbmdpZnkoJycgKyBuYW1lKSArICddW3R5cGU9XCJyYWRpb1wiXScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG90aGVyTm9kZSA9IGdyb3VwW2ldO1xuICAgICAgaWYgKG90aGVyTm9kZSA9PT0gcm9vdE5vZGUgfHwgb3RoZXJOb2RlLmZvcm0gIT09IHJvb3ROb2RlLmZvcm0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgcmFkaW8gYnV0dG9ucyByZW5kZXJlZCBieSBkaWZmZXJlbnQgY29waWVzIG9mIFJlYWN0XG4gICAgICAvLyBhbmQgdGhlIHNhbWUgbmFtZSBhcmUgcmVuZGVyZWQgaW50byB0aGUgc2FtZSBmb3JtIChzYW1lIGFzICMxOTM5KS5cbiAgICAgIC8vIFRoYXQncyBwcm9iYWJseSBva2F5OyB3ZSBkb24ndCBzdXBwb3J0IGl0IGp1c3QgYXMgd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gbWl4aW5nIFJlYWN0IHJhZGlvIGJ1dHRvbnMgd2l0aCBub24tUmVhY3Qgb25lcy5cbiAgICAgIHZhciBvdGhlclByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxKG90aGVyTm9kZSk7XG4gICAgICAhb3RoZXJQcm9wcyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NSW5wdXQ6IE1peGluZyBSZWFjdCBhbmQgbm9uLVJlYWN0IHJhZGlvIGlucHV0cyB3aXRoIHRoZSBzYW1lIGBuYW1lYCBpcyBub3Qgc3VwcG9ydGVkLicpIDogdm9pZCAwO1xuXG4gICAgICAvLyBXZSBuZWVkIHVwZGF0ZSB0aGUgdHJhY2tlZCB2YWx1ZSBvbiB0aGUgbmFtZWQgY291c2luIHNpbmNlIHRoZSB2YWx1ZVxuICAgICAgLy8gd2FzIGNoYW5nZWQgYnV0IHRoZSBpbnB1dCBzYXcgbm8gZXZlbnQgb3IgdmFsdWUgc2V0XG4gICAgICB1cGRhdGVWYWx1ZUlmQ2hhbmdlZChvdGhlck5vZGUpO1xuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgY29udHJvbGxlZCByYWRpbyBidXR0b24gZ3JvdXAsIGZvcmNpbmcgdGhlIGlucHV0IHRoYXRcbiAgICAgIC8vIHdhcyBwcmV2aW91c2x5IGNoZWNrZWQgdG8gdXBkYXRlIHdpbGwgY2F1c2UgaXQgdG8gYmUgY29tZSByZS1jaGVja2VkXG4gICAgICAvLyBhcyBhcHByb3ByaWF0ZS5cbiAgICAgIHVwZGF0ZVdyYXBwZXIob3RoZXJOb2RlLCBvdGhlclByb3BzKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cbi8vIEZvciBudW1iZXIgaW5wdXRzLCB0aGUgZGlzcGxheSB2YWx1ZSBsb3NlcyB0cmFpbGluZyBkZWNpbWFsIHBvaW50cy4gRm9yIGVtYWlsIGlucHV0cyxcbi8vIENocm9tZSByYWlzZXMgXCJUaGUgc3BlY2lmaWVkIHZhbHVlIDx4PiBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIuXG4vL1xuLy8gSGVyZSB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGRlZmF1bHRWYWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZCwgYXZvaWRpbmcgdGhlc2UgcHJvYmxlbXNcbi8vIHdoZW4gdGhlIHVzZXIgaXMgaW5wdXR0aW5nIHRleHRcbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTNcbmZ1bmN0aW9uIHNldERlZmF1bHRWYWx1ZShub2RlLCB0eXBlLCB2YWx1ZSkge1xuICBpZiAoXG4gIC8vIEZvY3VzZWQgbnVtYmVyIGlucHV0cyBzeW5jaHJvbml6ZSBvbiBibHVyLiBTZWUgQ2hhbmdlRXZlbnRQbHVnaW4uanNcbiAgdHlwZSAhPT0gJ251bWJlcicgfHwgbm9kZS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IG5vZGUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSB0b1N0cmluZyhub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuZGVmYXVsdFZhbHVlICE9PSB0b1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gdG9TdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZXZlbnRUeXBlcyQxID0ge1xuICBjaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ2hhbmdlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25DaGFuZ2VDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX0JMVVIsIFRPUF9DSEFOR0UsIFRPUF9DTElDSywgVE9QX0ZPQ1VTLCBUT1BfSU5QVVQsIFRPUF9LRVlfRE9XTiwgVE9QX0tFWV9VUCwgVE9QX1NFTEVDVElPTl9DSEFOR0VdXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChpbnN0LCBuYXRpdmVFdmVudCwgdGFyZ2V0KSB7XG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzJDEuY2hhbmdlLCBpbnN0LCBuYXRpdmVFdmVudCwgdGFyZ2V0KTtcbiAgZXZlbnQudHlwZSA9ICdjaGFuZ2UnO1xuICAvLyBGbGFnIHRoaXMgZXZlbnQgbG9vcCBhcyBuZWVkaW5nIHN0YXRlIHJlc3RvcmUuXG4gIGVucXVldWVTdGF0ZVJlc3RvcmUodGFyZ2V0KTtcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cbi8qKlxuICogRm9yIElFIHNoaW1zXG4gKi9cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjaGFuZ2VgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNoYW5nZUV2ZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAnZmlsZSc7XG59XG5cbmZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGFjdGl2ZUVsZW1lbnRJbnN0LCBuYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpKTtcblxuICAvLyBJZiBjaGFuZ2UgYW5kIHByb3BlcnR5Y2hhbmdlIGJ1YmJsZWQsIHdlJ2QganVzdCBiaW5kIHRvIGl0IGxpa2UgYWxsIHRoZVxuICAvLyBvdGhlciBldmVudHMgYW5kIGhhdmUgaXQgZ28gdGhyb3VnaCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuIFNpbmNlIGl0XG4gIC8vIGRvZXNuJ3QsIHdlIG1hbnVhbGx5IGxpc3RlbiBmb3IgdGhlIGV2ZW50cyBhbmQgc28gd2UgaGF2ZSB0byBlbnF1ZXVlIGFuZFxuICAvLyBwcm9jZXNzIHRoZSBhYnN0cmFjdCBldmVudCBtYW51YWxseS5cbiAgLy9cbiAgLy8gQmF0Y2hpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgYWxsIGV2ZW50IGhhbmRsZXJzIHJ1blxuICAvLyBiZWZvcmUgdGhlIG5leHQgcmVyZW5kZXIgKGluY2x1ZGluZyBldmVudCBoYW5kbGVycyBhdHRhY2hlZCB0byBhbmNlc3RvclxuICAvLyBlbGVtZW50cyBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBpbnB1dCkuIFdpdGhvdXQgdGhpcywgY29udHJvbGxlZFxuICAvLyBjb21wb25lbnRzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gY29uanVuY3Rpb24gd2l0aCBldmVudCBidWJibGluZyBiZWNhdXNlXG4gIC8vIHRoZSBjb21wb25lbnQgaXMgcmVyZW5kZXJlZCBhbmQgdGhlIHZhbHVlIHJldmVydGVkIGJlZm9yZSBhbGwgdGhlIGV2ZW50XG4gIC8vIGhhbmRsZXJzIGNhbiBydW4uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcwOC5cbiAgYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50SW5CYXRjaChldmVudCkge1xuICBydW5FdmVudHNJbkJhdGNoKGV2ZW50LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KSB7XG4gIHZhciB0YXJnZXROb2RlID0gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpO1xuICBpZiAodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IFRPUF9DSEFOR0UpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XG4gKi9cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmIChjYW5Vc2VET00pIHtcbiAgLy8gSUU5IGNsYWltcyB0byBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBidXQgZmFpbHMgdG8gdHJpZ2dlciBpdCB3aGVuXG4gIC8vIGRlbGV0aW5nIHRleHQsIHNvIHdlIGlnbm9yZSBpdHMgaW5wdXQgZXZlbnRzLlxuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBpc0V2ZW50U3VwcG9ydGVkKCdpbnB1dCcpICYmICghZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDkpO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpKSB7XG4gICAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsKHRvcExldmVsVHlwZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IFRPUF9GT0NVUykge1xuICAgIC8vIEluIElFOSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09IFRPUF9CTFVSKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfU0VMRUNUSU9OX0NIQU5HRSB8fCB0b3BMZXZlbFR5cGUgPT09IFRPUF9LRVlfVVAgfHwgdG9wTGV2ZWxUeXBlID09PSBUT1BfS0VZX0RPV04pIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX0NMSUNLKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfSU5QVVQgfHwgdG9wTGV2ZWxUeXBlID09PSBUT1BfQ0hBTkdFKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKG5vZGUpIHtcbiAgdmFyIHN0YXRlID0gbm9kZS5fd3JhcHBlclN0YXRlO1xuXG4gIGlmICghc3RhdGUgfHwgIXN0YXRlLmNvbnRyb2xsZWQgfHwgbm9kZS50eXBlICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghZGlzYWJsZUlucHV0QXR0cmlidXRlU3luY2luZykge1xuICAgIC8vIElmIGNvbnRyb2xsZWQsIGFzc2lnbiB0aGUgdmFsdWUgYXR0cmlidXRlIHRvIHRoZSBjdXJyZW50IHZhbHVlIG9uIGJsdXJcbiAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgJ251bWJlcicsIG5vZGUudmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9cbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQxLFxuXG4gIF9pc0lucHV0RXZlbnRTdXBwb3J0ZWQ6IGlzSW5wdXRFdmVudFN1cHBvcnRlZCxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlJDEodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICB2YXIgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSB2b2lkIDAsXG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IHZvaWQgMDtcbiAgICBpZiAoc2hvdWxkVXNlQ2hhbmdlRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50O1xuICAgIH0gZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2hvdWxkVXNlQ2xpY2tFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudDtcbiAgICB9XG5cbiAgICBpZiAoZ2V0VGFyZ2V0SW5zdEZ1bmMpIHtcbiAgICAgIHZhciBpbnN0ID0gZ2V0VGFyZ2V0SW5zdEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KTtcbiAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgIHZhciBldmVudCA9IGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChpbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgICAgaGFuZGxlRXZlbnRGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0Tm9kZSwgdGFyZ2V0SW5zdCk7XG4gICAgfVxuXG4gICAgLy8gV2hlbiBibHVycmluZywgc2V0IHRoZSB2YWx1ZSBhdHRyaWJ1dGUgZm9yIG51bWJlciBpbnB1dHNcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfQkxVUikge1xuICAgICAgaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cih0YXJnZXROb2RlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cbnZhciBET01FdmVudFBsdWdpbk9yZGVyID0gWydSZXNwb25kZXJFdmVudFBsdWdpbicsICdTaW1wbGVFdmVudFBsdWdpbicsICdFbnRlckxlYXZlRXZlbnRQbHVnaW4nLCAnQ2hhbmdlRXZlbnRQbHVnaW4nLCAnU2VsZWN0RXZlbnRQbHVnaW4nLCAnQmVmb3JlSW5wdXRFdmVudFBsdWdpbiddO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmV4dGVuZCh7XG4gIHZpZXc6IG51bGwsXG4gIGRldGFpbDogbnVsbFxufSk7XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxudmFyIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICBBbHQ6ICdhbHRLZXknLFxuICBDb250cm9sOiAnY3RybEtleScsXG4gIE1ldGE6ICdtZXRhS2V5JyxcbiAgU2hpZnQ6ICdzaGlmdEtleSdcbn07XG5cbi8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgZ2V0TW9kaWZpZXJTdGF0ZSBzbyB3ZSBzaW1wbHkgbWFwIGl0IHRvIHRoZSBvbmx5XG4vLyBtb2RpZmllciBrZXlzIGV4cG9zZWQgYnkgdGhlIGV2ZW50IGl0c2VsZiwgZG9lcyBub3Qgc3VwcG9ydCBMb2NrLWtleXMuXG4vLyBDdXJyZW50bHksIGFsbCBtYWpvciBicm93c2VycyBleGNlcHQgQ2hyb21lIHNlZW1zIHRvIHN1cHBvcnQgTG9jay1rZXlzLlxuZnVuY3Rpb24gbW9kaWZpZXJTdGF0ZUdldHRlcihrZXlBcmcpIHtcbiAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gdGhpcztcbiAgdmFyIG5hdGl2ZUV2ZW50ID0gc3ludGhldGljRXZlbnQubmF0aXZlRXZlbnQ7XG4gIGlmIChuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKTtcbiAgfVxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG5cbnZhciBwcmV2aW91c1NjcmVlblggPSAwO1xudmFyIHByZXZpb3VzU2NyZWVuWSA9IDA7XG4vLyBVc2UgZmxhZ3MgdG8gc2lnbmFsIG1vdmVtZW50WC9ZIGhhcyBhbHJlYWR5IGJlZW4gc2V0XG52YXIgaXNNb3ZlbWVudFhTZXQgPSBmYWxzZTtcbnZhciBpc01vdmVtZW50WVNldCA9IGZhbHNlO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gU3ludGhldGljVUlFdmVudC5leHRlbmQoe1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBwYWdlWDogbnVsbCxcbiAgcGFnZVk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiBudWxsLFxuICBidXR0b25zOiBudWxsLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCAoZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudCk7XG4gIH0sXG4gIG1vdmVtZW50WDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCdtb3ZlbWVudFgnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQubW92ZW1lbnRYO1xuICAgIH1cblxuICAgIHZhciBzY3JlZW5YID0gcHJldmlvdXNTY3JlZW5YO1xuICAgIHByZXZpb3VzU2NyZWVuWCA9IGV2ZW50LnNjcmVlblg7XG5cbiAgICBpZiAoIWlzTW92ZW1lbnRYU2V0KSB7XG4gICAgICBpc01vdmVtZW50WFNldCA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ21vdXNlbW92ZScgPyBldmVudC5zY3JlZW5YIC0gc2NyZWVuWCA6IDA7XG4gIH0sXG4gIG1vdmVtZW50WTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCdtb3ZlbWVudFknIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQubW92ZW1lbnRZO1xuICAgIH1cblxuICAgIHZhciBzY3JlZW5ZID0gcHJldmlvdXNTY3JlZW5ZO1xuICAgIHByZXZpb3VzU2NyZWVuWSA9IGV2ZW50LnNjcmVlblk7XG5cbiAgICBpZiAoIWlzTW92ZW1lbnRZU2V0KSB7XG4gICAgICBpc01vdmVtZW50WVNldCA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ21vdXNlbW92ZScgPyBldmVudC5zY3JlZW5ZIC0gc2NyZWVuWSA6IDA7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgUG9pbnRlckV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNQb2ludGVyRXZlbnQgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmV4dGVuZCh7XG4gIHBvaW50ZXJJZDogbnVsbCxcbiAgd2lkdGg6IG51bGwsXG4gIGhlaWdodDogbnVsbCxcbiAgcHJlc3N1cmU6IG51bGwsXG4gIHRhbmdlbnRpYWxQcmVzc3VyZTogbnVsbCxcbiAgdGlsdFg6IG51bGwsXG4gIHRpbHRZOiBudWxsLFxuICB0d2lzdDogbnVsbCxcbiAgcG9pbnRlclR5cGU6IG51bGwsXG4gIGlzUHJpbWFyeTogbnVsbFxufSk7XG5cbnZhciBldmVudFR5cGVzJDIgPSB7XG4gIG1vdXNlRW50ZXI6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Nb3VzZUVudGVyJyxcbiAgICBkZXBlbmRlbmNpZXM6IFtUT1BfTU9VU0VfT1VULCBUT1BfTU9VU0VfT1ZFUl1cbiAgfSxcbiAgbW91c2VMZWF2ZToge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlTGVhdmUnLFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9NT1VTRV9PVVQsIFRPUF9NT1VTRV9PVkVSXVxuICB9LFxuICBwb2ludGVyRW50ZXI6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Qb2ludGVyRW50ZXInLFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9QT0lOVEVSX09VVCwgVE9QX1BPSU5URVJfT1ZFUl1cbiAgfSxcbiAgcG9pbnRlckxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uUG9pbnRlckxlYXZlJyxcbiAgICBkZXBlbmRlbmNpZXM6IFtUT1BfUE9JTlRFUl9PVVQsIFRPUF9QT0lOVEVSX09WRVJdXG4gIH1cbn07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMixcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGlzT3ZlckV2ZW50ID0gdG9wTGV2ZWxUeXBlID09PSBUT1BfTU9VU0VfT1ZFUiB8fCB0b3BMZXZlbFR5cGUgPT09IFRPUF9QT0lOVEVSX09WRVI7XG4gICAgdmFyIGlzT3V0RXZlbnQgPSB0b3BMZXZlbFR5cGUgPT09IFRPUF9NT1VTRV9PVVQgfHwgdG9wTGV2ZWxUeXBlID09PSBUT1BfUE9JTlRFUl9PVVQ7XG5cbiAgICBpZiAoaXNPdmVyRXZlbnQgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIWlzT3V0RXZlbnQgJiYgIWlzT3ZlckV2ZW50KSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIG9yIHBvaW50ZXIgaW4gb3Igb3V0IC0gaWdub3JpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2luID0gdm9pZCAwO1xuICAgIGlmIChuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICAgIHdpbiA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb20gPSB2b2lkIDA7XG4gICAgdmFyIHRvID0gdm9pZCAwO1xuICAgIGlmIChpc091dEV2ZW50KSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQ7XG4gICAgICB0byA9IHJlbGF0ZWQgPyBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgICBmcm9tID0gbnVsbDtcbiAgICAgIHRvID0gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBldmVudEludGVyZmFjZSA9IHZvaWQgMCxcbiAgICAgICAgbGVhdmVFdmVudFR5cGUgPSB2b2lkIDAsXG4gICAgICAgIGVudGVyRXZlbnRUeXBlID0gdm9pZCAwLFxuICAgICAgICBldmVudFR5cGVQcmVmaXggPSB2b2lkIDA7XG5cbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfTU9VU0VfT1VUIHx8IHRvcExldmVsVHlwZSA9PT0gVE9QX01PVVNFX09WRVIpIHtcbiAgICAgIGV2ZW50SW50ZXJmYWNlID0gU3ludGhldGljTW91c2VFdmVudDtcbiAgICAgIGxlYXZlRXZlbnRUeXBlID0gZXZlbnRUeXBlcyQyLm1vdXNlTGVhdmU7XG4gICAgICBlbnRlckV2ZW50VHlwZSA9IGV2ZW50VHlwZXMkMi5tb3VzZUVudGVyO1xuICAgICAgZXZlbnRUeXBlUHJlZml4ID0gJ21vdXNlJztcbiAgICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX1BPSU5URVJfT1VUIHx8IHRvcExldmVsVHlwZSA9PT0gVE9QX1BPSU5URVJfT1ZFUikge1xuICAgICAgZXZlbnRJbnRlcmZhY2UgPSBTeW50aGV0aWNQb2ludGVyRXZlbnQ7XG4gICAgICBsZWF2ZUV2ZW50VHlwZSA9IGV2ZW50VHlwZXMkMi5wb2ludGVyTGVhdmU7XG4gICAgICBlbnRlckV2ZW50VHlwZSA9IGV2ZW50VHlwZXMkMi5wb2ludGVyRW50ZXI7XG4gICAgICBldmVudFR5cGVQcmVmaXggPSAncG9pbnRlcic7XG4gICAgfVxuXG4gICAgdmFyIGZyb21Ob2RlID0gZnJvbSA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKGZyb20pO1xuICAgIHZhciB0b05vZGUgPSB0byA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRvKTtcblxuICAgIHZhciBsZWF2ZSA9IGV2ZW50SW50ZXJmYWNlLmdldFBvb2xlZChsZWF2ZUV2ZW50VHlwZSwgZnJvbSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gZXZlbnRUeXBlUHJlZml4ICsgJ2xlYXZlJztcbiAgICBsZWF2ZS50YXJnZXQgPSBmcm9tTm9kZTtcbiAgICBsZWF2ZS5yZWxhdGVkVGFyZ2V0ID0gdG9Ob2RlO1xuXG4gICAgdmFyIGVudGVyID0gZXZlbnRJbnRlcmZhY2UuZ2V0UG9vbGVkKGVudGVyRXZlbnRUeXBlLCB0bywgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBlbnRlci50eXBlID0gZXZlbnRUeXBlUHJlZml4ICsgJ2VudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0b05vZGU7XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuXG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pO1xuXG4gICAgcmV0dXJuIFtsZWF2ZSwgZW50ZXJdO1xuICB9XG59O1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuXG52YXIgaGFzT3duUHJvcGVydHkkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgLy8gQWRkZWQgdGhlIG5vbnplcm8geSBjaGVjayB0byBtYWtlIEZsb3cgaGFwcHksIGJ1dCBpdCBpcyByZWR1bmRhbnRcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSQxLmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuXG4vKipcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBjYWxsZWQgYGRlbGV0ZWAgYnV0IHdlJ2QgaGF2ZSB0byBtYWtlIHN1cmUgdG8gYWx3YXlzXG4gKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICogc3VwcG9ydGVkIHdlIGNhbiByZW5hbWUgaXQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxGaWJlcjtcbn1cblxuZnVuY3Rpb24gaGFzKGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXIgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAga2V5Ll9yZWFjdEludGVybmFsRmliZXIgPSB2YWx1ZTtcbn1cblxuLy8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXMuIFRoZXkncmUgdXNlZCBieSBSZWFjdCBEZXYgVG9vbHMuXG52YXIgTm9FZmZlY3QgPSAvKiAgICAgICAgICAgICAgKi8wO1xudmFyIFBlcmZvcm1lZFdvcmsgPSAvKiAgICAgICAgICovMTtcblxuLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG52YXIgUGxhY2VtZW50ID0gLyogICAgICAgICAgICAgKi8yO1xudmFyIFVwZGF0ZSA9IC8qICAgICAgICAgICAgICAgICovNDtcbnZhciBQbGFjZW1lbnRBbmRVcGRhdGUgPSAvKiAgICAqLzY7XG52YXIgRGVsZXRpb24gPSAvKiAgICAgICAgICAgICAgKi84O1xudmFyIENvbnRlbnRSZXNldCA9IC8qICAgICAgICAgICovMTY7XG52YXIgQ2FsbGJhY2sgPSAvKiAgICAgICAgICAgICAgKi8zMjtcbnZhciBEaWRDYXB0dXJlID0gLyogICAgICAgICAgICAqLzY0O1xudmFyIFJlZiA9IC8qICAgICAgICAgICAgICAgICAgICovMTI4O1xudmFyIFNuYXBzaG90ID0gLyogICAgICAgICAgICAgICovMjU2O1xuXG4vLyBVcGRhdGUgJiBDYWxsYmFjayAmIFJlZiAmIFNuYXBzaG90XG52YXIgTGlmZWN5Y2xlRWZmZWN0TWFzayA9IC8qICAgKi80MjA7XG5cbi8vIFVuaW9uIG9mIGFsbCBob3N0IGVmZmVjdHNcbnZhciBIb3N0RWZmZWN0TWFzayA9IC8qICAgICAgICAqLzUxMTtcblxudmFyIEluY29tcGxldGUgPSAvKiAgICAgICAgICAgICovNTEyO1xudmFyIFNob3VsZENhcHR1cmUgPSAvKiAgICAgICAgICovMTAyNDtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcblxudmFyIE1PVU5USU5HID0gMTtcbnZhciBNT1VOVEVEID0gMjtcbnZhciBVTk1PVU5URUQgPSAzO1xuXG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgfVxuICAgIHdoaWxlIChub2RlLnJldHVybikge1xuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICAgIHJldHVybiBNT1VOVElORztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGUucmV0dXJuKSB7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBNT1VOVEVEO1xuICB9XG4gIC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cbiAgcmV0dXJuIFVOTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWQoZmliZXIpIHtcbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGlzTW91bnRlZChjb21wb25lbnQpIHtcbiAge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudDtcbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgKG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgfHwgb3duZXIudGFnID09PSBDbGFzc0NvbXBvbmVudExhenkpKSB7XG4gICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgdmFyIGluc3RhbmNlID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAhaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lckZpYmVyLnR5cGUpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQoY29tcG9uZW50KTtcbiAgaWYgKCFmaWJlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKSB7XG4gICEoaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gIGlmICghYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGVuIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiBpdCBpcyBtb3VudGVkLlxuICAgIHZhciBzdGF0ZSA9IGlzRmliZXJNb3VudGVkSW1wbChmaWJlcik7XG4gICAgIShzdGF0ZSAhPT0gVU5NT1VOVEVEKSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgICBpZiAoc3RhdGUgPT09IE1PVU5USU5HKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZpYmVyO1xuICB9XG4gIC8vIElmIHdlIGhhdmUgdHdvIHBvc3NpYmxlIGJyYW5jaGVzLCB3ZSdsbCB3YWxrIGJhY2t3YXJkcyB1cCB0byB0aGUgcm9vdFxuICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgLy8gc3BlY2lhbCBjYXNlcyBhbmQgd2UnbGwgZGVhbCB3aXRoIHRoZW0uXG4gIHZhciBhID0gZmliZXI7XG4gIHZhciBiID0gYWx0ZXJuYXRlO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBwYXJlbnRBID0gYS5yZXR1cm47XG4gICAgdmFyIHBhcmVudEIgPSBwYXJlbnRBID8gcGFyZW50QS5hbHRlcm5hdGUgOiBudWxsO1xuICAgIGlmICghcGFyZW50QSB8fCAhcGFyZW50Qikge1xuICAgICAgLy8gV2UncmUgYXQgdGhlIHJvb3QuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBJZiBib3RoIGNvcGllcyBvZiB0aGUgcGFyZW50IGZpYmVyIHBvaW50IHRvIHRoZSBzYW1lIGNoaWxkLCB3ZSBjYW5cbiAgICAvLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbiAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG4gICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBhKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkID09PSBiKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEIgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gYWx0ZXJuYXRlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG4gICAgICAvLyB3YXkgdGhpcyBjb3VsZCBwb3NzaWJseSBoYXBwZW4gaXMgaWYgdGhpcyB3YXMgdW5tb3VudGVkLCBpZiBhdCBhbGwuXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKGEucmV0dXJuICE9PSBiLnJldHVybikge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVyIG9mIEEgYW5kIHRoZSByZXR1cm4gcG9pbnRlciBvZiBCIHBvaW50IHRvIGRpZmZlcmVudFxuICAgICAgLy8gZmliZXJzLiBXZSBhc3N1bWUgdGhhdCByZXR1cm4gcG9pbnRlcnMgbmV2ZXIgY3Jpc3MtY3Jvc3MsIHNvIEEgbXVzdFxuICAgICAgLy8gYmVsb25nIHRvIHRoZSBjaGlsZCBzZXQgb2YgQS5yZXR1cm4sIGFuZCBCIG11c3QgYmVsb25nIHRvIHRoZSBjaGlsZFxuICAgICAgLy8gc2V0IG9mIEIucmV0dXJuLlxuICAgICAgYSA9IHBhcmVudEE7XG4gICAgICBiID0gcGFyZW50QjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVycyBwb2ludCB0byB0aGUgc2FtZSBmaWJlci4gV2UnbGwgaGF2ZSB0byB1c2UgdGhlXG4gICAgICAvLyBkZWZhdWx0LCBzbG93IHBhdGg6IHNjYW4gdGhlIGNoaWxkIHNldHMgb2YgZWFjaCBwYXJlbnQgYWx0ZXJuYXRlIHRvIHNlZVxuICAgICAgLy8gd2hpY2ggY2hpbGQgYmVsb25ncyB0byB3aGljaCBzZXQuXG4gICAgICAvL1xuICAgICAgLy8gU2VhcmNoIHBhcmVudCBBJ3MgY2hpbGQgc2V0XG4gICAgICB2YXIgZGlkRmluZENoaWxkID0gZmFsc2U7XG4gICAgICB2YXIgX2NoaWxkID0gcGFyZW50QS5jaGlsZDtcbiAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcbiAgICAgICAgX2NoaWxkID0gcGFyZW50Qi5jaGlsZDtcbiAgICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgICFkaWRGaW5kQ2hpbGQgPyBpbnZhcmlhbnQoZmFsc2UsICdDaGlsZCB3YXMgbm90IGZvdW5kIGluIGVpdGhlciBwYXJlbnQgc2V0LiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdCByZWxhdGVkIHRvIHRoZSByZXR1cm4gcG9pbnRlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShhLmFsdGVybmF0ZSA9PT0gYikgPyBpbnZhcmlhbnQoZmFsc2UsICdSZXR1cm4gZmliZXJzIHNob3VsZCBhbHdheXMgYmUgZWFjaCBvdGhlcnNcXCcgYWx0ZXJuYXRlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgfVxuICAvLyBJZiB0aGUgcm9vdCBpcyBub3QgYSBob3N0IGNvbnRhaW5lciwgd2UncmUgaW4gYSBkaXNjb25uZWN0ZWQgdHJlZS4gSS5lLlxuICAvLyB1bm1vdW50ZWQuXG4gICEoYS50YWcgPT09IEhvc3RSb290KSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgaWYgKGEuc3RhdGVOb2RlLmN1cnJlbnQgPT09IGEpIHtcbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9XG4gIC8vIE90aGVyd2lzZSBCIGhhcyB0byBiZSBjdXJyZW50IGJyYW5jaC5cbiAgcmV0dXJuIGFsdGVybmF0ZTtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXIocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICYmIG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudEJ1YmJsZUxpc3RlbmVyKGVsZW1lbnQsIGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXIoZWxlbWVudCwgZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG59XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWFuaW1hdGlvbnMvI0FuaW1hdGlvbkV2ZW50LWludGVyZmFjZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uRXZlbnRcbiAqL1xudmFyIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50ID0gU3ludGhldGljRXZlbnQuZXh0ZW5kKHtcbiAgYW5pbWF0aW9uTmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY2xpcGJvYXJkLWFwaXMvXG4gKi9cbnZhciBTeW50aGV0aWNDbGlwYm9hcmRFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmV4dGVuZCh7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gU3ludGhldGljVUlFdmVudC5leHRlbmQoe1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59KTtcblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGUgPSB2b2lkIDA7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7XG5cbiAgICAvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfVxuXG4gIC8vIElFIGFuZCBFZGdlIChvbiBXaW5kb3dzKSBhbmQgQ2hyb21lIC8gU2FmYXJpIChvbiBXaW5kb3dzIGFuZCBMaW51eClcbiAgLy8gcmVwb3J0IEVudGVyIGFzIGNoYXJDb2RlIDEwIHdoZW4gY3RybCBpcyBwcmVzc2VkLlxuICBpZiAoY2hhckNvZGUgPT09IDEwKSB7XG4gICAgY2hhckNvZGUgPSAxMztcbiAgfVxuXG4gIC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuICBpZiAoY2hhckNvZGUgPj0gMzIgfHwgY2hhckNvZGUgPT09IDEzKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIG5vcm1hbGl6ZUtleSA9IHtcbiAgRXNjOiAnRXNjYXBlJyxcbiAgU3BhY2ViYXI6ICcgJyxcbiAgTGVmdDogJ0Fycm93TGVmdCcsXG4gIFVwOiAnQXJyb3dVcCcsXG4gIFJpZ2h0OiAnQXJyb3dSaWdodCcsXG4gIERvd246ICdBcnJvd0Rvd24nLFxuICBEZWw6ICdEZWxldGUnLFxuICBXaW46ICdPUycsXG4gIE1lbnU6ICdDb250ZXh0TWVudScsXG4gIEFwcHM6ICdDb250ZXh0TWVudScsXG4gIFNjcm9sbDogJ1Njcm9sbExvY2snLFxuICBNb3pQcmludGFibGVLZXk6ICdVbmlkZW50aWZpZWQnXG59O1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICAnOCc6ICdCYWNrc3BhY2UnLFxuICAnOSc6ICdUYWInLFxuICAnMTInOiAnQ2xlYXInLFxuICAnMTMnOiAnRW50ZXInLFxuICAnMTYnOiAnU2hpZnQnLFxuICAnMTcnOiAnQ29udHJvbCcsXG4gICcxOCc6ICdBbHQnLFxuICAnMTknOiAnUGF1c2UnLFxuICAnMjAnOiAnQ2Fwc0xvY2snLFxuICAnMjcnOiAnRXNjYXBlJyxcbiAgJzMyJzogJyAnLFxuICAnMzMnOiAnUGFnZVVwJyxcbiAgJzM0JzogJ1BhZ2VEb3duJyxcbiAgJzM1JzogJ0VuZCcsXG4gICczNic6ICdIb21lJyxcbiAgJzM3JzogJ0Fycm93TGVmdCcsXG4gICczOCc6ICdBcnJvd1VwJyxcbiAgJzM5JzogJ0Fycm93UmlnaHQnLFxuICAnNDAnOiAnQXJyb3dEb3duJyxcbiAgJzQ1JzogJ0luc2VydCcsXG4gICc0Nic6ICdEZWxldGUnLFxuICAnMTEyJzogJ0YxJyxcbiAgJzExMyc6ICdGMicsXG4gICcxMTQnOiAnRjMnLFxuICAnMTE1JzogJ0Y0JyxcbiAgJzExNic6ICdGNScsXG4gICcxMTcnOiAnRjYnLFxuICAnMTE4JzogJ0Y3JyxcbiAgJzExOSc6ICdGOCcsXG4gICcxMjAnOiAnRjknLFxuICAnMTIxJzogJ0YxMCcsXG4gICcxMjInOiAnRjExJyxcbiAgJzEyMyc6ICdGMTInLFxuICAnMTQ0JzogJ051bUxvY2snLFxuICAnMTQ1JzogJ1Njcm9sbExvY2snLFxuICAnMjI0JzogJ01ldGEnXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBga2V5YCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cblxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7XG5cbiAgICAvLyBUaGUgZW50ZXIta2V5IGlzIHRlY2huaWNhbGx5IGJvdGggcHJpbnRhYmxlIGFuZCBub24tcHJpbnRhYmxlIGFuZCBjYW5cbiAgICAvLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDEzID8gJ0VudGVyJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9XG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQgPSBTeW50aGV0aWNVSUV2ZW50LmV4dGVuZCh7XG4gIGtleTogZ2V0RXZlbnRLZXksXG4gIGxvY2F0aW9uOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICByZXBlYXQ6IG51bGwsXG4gIGxvY2FsZTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICAvLyBMZWdhY3kgSW50ZXJmYWNlXG4gIGNoYXJDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgYWN0dWFsIHByaW50YWJsZSBjaGFyYWN0ZXIuXG5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAga2V5Q29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cblxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYHdoaWNoYCBpcyBhbiBhbGlhcyBmb3IgZWl0aGVyIGBrZXlDb2RlYCBvciBgY2hhckNvZGVgIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLyB0eXBlIG9mIHRoZSBldmVudC5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgU3ludGhldGljRHJhZ0V2ZW50ID0gU3ludGhldGljTW91c2VFdmVudC5leHRlbmQoe1xuICBkYXRhVHJhbnNmZXI6IG51bGxcbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNUb3VjaEV2ZW50ID0gU3ludGhldGljVUlFdmVudC5leHRlbmQoe1xuICB0b3VjaGVzOiBudWxsLFxuICB0YXJnZXRUb3VjaGVzOiBudWxsLFxuICBjaGFuZ2VkVG91Y2hlczogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG59KTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL1xudmFyIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCA9IFN5bnRoZXRpY0V2ZW50LmV4dGVuZCh7XG4gIHByb3BlcnR5TmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNXaGVlbEV2ZW50ID0gU3ludGhldGljTW91c2VFdmVudC5leHRlbmQoe1xuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwO1xuICB9LFxuXG4gIGRlbHRhWjogbnVsbCxcblxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogbnVsbFxufSk7XG5cbi8qKlxuICogVHVybnNcbiAqIFsnYWJvcnQnLCAuLi5dXG4gKiBpbnRvXG4gKiBldmVudFR5cGVzID0ge1xuICogICAnYWJvcnQnOiB7XG4gKiAgICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAqICAgICAgIGJ1YmJsZWQ6ICdvbkFib3J0JyxcbiAqICAgICAgIGNhcHR1cmVkOiAnb25BYm9ydENhcHR1cmUnLFxuICogICAgIH0sXG4gKiAgICAgZGVwZW5kZW5jaWVzOiBbVE9QX0FCT1JUXSxcbiAqICAgfSxcbiAqICAgLi4uXG4gKiB9O1xuICogdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0gbmV3IE1hcChbXG4gKiAgIFtUT1BfQUJPUlQsIHsgc2FtZUNvbmZpZyB9XSxcbiAqIF0pO1xuICovXG5cbnZhciBpbnRlcmFjdGl2ZUV2ZW50VHlwZU5hbWVzID0gW1tUT1BfQkxVUiwgJ2JsdXInXSwgW1RPUF9DQU5DRUwsICdjYW5jZWwnXSwgW1RPUF9DTElDSywgJ2NsaWNrJ10sIFtUT1BfQ0xPU0UsICdjbG9zZSddLCBbVE9QX0NPTlRFWFRfTUVOVSwgJ2NvbnRleHRNZW51J10sIFtUT1BfQ09QWSwgJ2NvcHknXSwgW1RPUF9DVVQsICdjdXQnXSwgW1RPUF9BVVhfQ0xJQ0ssICdhdXhDbGljayddLCBbVE9QX0RPVUJMRV9DTElDSywgJ2RvdWJsZUNsaWNrJ10sIFtUT1BfRFJBR19FTkQsICdkcmFnRW5kJ10sIFtUT1BfRFJBR19TVEFSVCwgJ2RyYWdTdGFydCddLCBbVE9QX0RST1AsICdkcm9wJ10sIFtUT1BfRk9DVVMsICdmb2N1cyddLCBbVE9QX0lOUFVULCAnaW5wdXQnXSwgW1RPUF9JTlZBTElELCAnaW52YWxpZCddLCBbVE9QX0tFWV9ET1dOLCAna2V5RG93biddLCBbVE9QX0tFWV9QUkVTUywgJ2tleVByZXNzJ10sIFtUT1BfS0VZX1VQLCAna2V5VXAnXSwgW1RPUF9NT1VTRV9ET1dOLCAnbW91c2VEb3duJ10sIFtUT1BfTU9VU0VfVVAsICdtb3VzZVVwJ10sIFtUT1BfUEFTVEUsICdwYXN0ZSddLCBbVE9QX1BBVVNFLCAncGF1c2UnXSwgW1RPUF9QTEFZLCAncGxheSddLCBbVE9QX1BPSU5URVJfQ0FOQ0VMLCAncG9pbnRlckNhbmNlbCddLCBbVE9QX1BPSU5URVJfRE9XTiwgJ3BvaW50ZXJEb3duJ10sIFtUT1BfUE9JTlRFUl9VUCwgJ3BvaW50ZXJVcCddLCBbVE9QX1JBVEVfQ0hBTkdFLCAncmF0ZUNoYW5nZSddLCBbVE9QX1JFU0VULCAncmVzZXQnXSwgW1RPUF9TRUVLRUQsICdzZWVrZWQnXSwgW1RPUF9TVUJNSVQsICdzdWJtaXQnXSwgW1RPUF9UT1VDSF9DQU5DRUwsICd0b3VjaENhbmNlbCddLCBbVE9QX1RPVUNIX0VORCwgJ3RvdWNoRW5kJ10sIFtUT1BfVE9VQ0hfU1RBUlQsICd0b3VjaFN0YXJ0J10sIFtUT1BfVk9MVU1FX0NIQU5HRSwgJ3ZvbHVtZUNoYW5nZSddXTtcbnZhciBub25JbnRlcmFjdGl2ZUV2ZW50VHlwZU5hbWVzID0gW1tUT1BfQUJPUlQsICdhYm9ydCddLCBbVE9QX0FOSU1BVElPTl9FTkQsICdhbmltYXRpb25FbmQnXSwgW1RPUF9BTklNQVRJT05fSVRFUkFUSU9OLCAnYW5pbWF0aW9uSXRlcmF0aW9uJ10sIFtUT1BfQU5JTUFUSU9OX1NUQVJULCAnYW5pbWF0aW9uU3RhcnQnXSwgW1RPUF9DQU5fUExBWSwgJ2NhblBsYXknXSwgW1RPUF9DQU5fUExBWV9USFJPVUdILCAnY2FuUGxheVRocm91Z2gnXSwgW1RPUF9EUkFHLCAnZHJhZyddLCBbVE9QX0RSQUdfRU5URVIsICdkcmFnRW50ZXInXSwgW1RPUF9EUkFHX0VYSVQsICdkcmFnRXhpdCddLCBbVE9QX0RSQUdfTEVBVkUsICdkcmFnTGVhdmUnXSwgW1RPUF9EUkFHX09WRVIsICdkcmFnT3ZlciddLCBbVE9QX0RVUkFUSU9OX0NIQU5HRSwgJ2R1cmF0aW9uQ2hhbmdlJ10sIFtUT1BfRU1QVElFRCwgJ2VtcHRpZWQnXSwgW1RPUF9FTkNSWVBURUQsICdlbmNyeXB0ZWQnXSwgW1RPUF9FTkRFRCwgJ2VuZGVkJ10sIFtUT1BfRVJST1IsICdlcnJvciddLCBbVE9QX0dPVF9QT0lOVEVSX0NBUFRVUkUsICdnb3RQb2ludGVyQ2FwdHVyZSddLCBbVE9QX0xPQUQsICdsb2FkJ10sIFtUT1BfTE9BREVEX0RBVEEsICdsb2FkZWREYXRhJ10sIFtUT1BfTE9BREVEX01FVEFEQVRBLCAnbG9hZGVkTWV0YWRhdGEnXSwgW1RPUF9MT0FEX1NUQVJULCAnbG9hZFN0YXJ0J10sIFtUT1BfTE9TVF9QT0lOVEVSX0NBUFRVUkUsICdsb3N0UG9pbnRlckNhcHR1cmUnXSwgW1RPUF9NT1VTRV9NT1ZFLCAnbW91c2VNb3ZlJ10sIFtUT1BfTU9VU0VfT1VULCAnbW91c2VPdXQnXSwgW1RPUF9NT1VTRV9PVkVSLCAnbW91c2VPdmVyJ10sIFtUT1BfUExBWUlORywgJ3BsYXlpbmcnXSwgW1RPUF9QT0lOVEVSX01PVkUsICdwb2ludGVyTW92ZSddLCBbVE9QX1BPSU5URVJfT1VULCAncG9pbnRlck91dCddLCBbVE9QX1BPSU5URVJfT1ZFUiwgJ3BvaW50ZXJPdmVyJ10sIFtUT1BfUFJPR1JFU1MsICdwcm9ncmVzcyddLCBbVE9QX1NDUk9MTCwgJ3Njcm9sbCddLCBbVE9QX1NFRUtJTkcsICdzZWVraW5nJ10sIFtUT1BfU1RBTExFRCwgJ3N0YWxsZWQnXSwgW1RPUF9TVVNQRU5ELCAnc3VzcGVuZCddLCBbVE9QX1RJTUVfVVBEQVRFLCAndGltZVVwZGF0ZSddLCBbVE9QX1RPR0dMRSwgJ3RvZ2dsZSddLCBbVE9QX1RPVUNIX01PVkUsICd0b3VjaE1vdmUnXSwgW1RPUF9UUkFOU0lUSU9OX0VORCwgJ3RyYW5zaXRpb25FbmQnXSwgW1RPUF9XQUlUSU5HLCAnd2FpdGluZyddLCBbVE9QX1dIRUVMLCAnd2hlZWwnXV07XG5cbnZhciBldmVudFR5cGVzJDQgPSB7fTtcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcblxuZnVuY3Rpb24gYWRkRXZlbnRUeXBlTmFtZVRvQ29uZmlnKF9yZWYsIGlzSW50ZXJhY3RpdmUpIHtcbiAgdmFyIHRvcEV2ZW50ID0gX3JlZlswXSxcbiAgICAgIGV2ZW50ID0gX3JlZlsxXTtcblxuICB2YXIgY2FwaXRhbGl6ZWRFdmVudCA9IGV2ZW50WzBdLnRvVXBwZXJDYXNlKCkgKyBldmVudC5zbGljZSgxKTtcbiAgdmFyIG9uRXZlbnQgPSAnb24nICsgY2FwaXRhbGl6ZWRFdmVudDtcblxuICB2YXIgdHlwZSA9IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogb25FdmVudCxcbiAgICAgIGNhcHR1cmVkOiBvbkV2ZW50ICsgJ0NhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BFdmVudF0sXG4gICAgaXNJbnRlcmFjdGl2ZTogaXNJbnRlcmFjdGl2ZVxuICB9O1xuICBldmVudFR5cGVzJDRbZXZlbnRdID0gdHlwZTtcbiAgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcEV2ZW50XSA9IHR5cGU7XG59XG5cbmludGVyYWN0aXZlRXZlbnRUeXBlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRUdXBsZSkge1xuICBhZGRFdmVudFR5cGVOYW1lVG9Db25maWcoZXZlbnRUdXBsZSwgdHJ1ZSk7XG59KTtcbm5vbkludGVyYWN0aXZlRXZlbnRUeXBlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRUdXBsZSkge1xuICBhZGRFdmVudFR5cGVOYW1lVG9Db25maWcoZXZlbnRUdXBsZSwgZmFsc2UpO1xufSk7XG5cbi8vIE9ubHkgdXNlZCBpbiBERVYgZm9yIGV4aGF1c3RpdmVuZXNzIHZhbGlkYXRpb24uXG52YXIga25vd25IVE1MVG9wTGV2ZWxUeXBlcyA9IFtUT1BfQUJPUlQsIFRPUF9DQU5DRUwsIFRPUF9DQU5fUExBWSwgVE9QX0NBTl9QTEFZX1RIUk9VR0gsIFRPUF9DTE9TRSwgVE9QX0RVUkFUSU9OX0NIQU5HRSwgVE9QX0VNUFRJRUQsIFRPUF9FTkNSWVBURUQsIFRPUF9FTkRFRCwgVE9QX0VSUk9SLCBUT1BfSU5QVVQsIFRPUF9JTlZBTElELCBUT1BfTE9BRCwgVE9QX0xPQURFRF9EQVRBLCBUT1BfTE9BREVEX01FVEFEQVRBLCBUT1BfTE9BRF9TVEFSVCwgVE9QX1BBVVNFLCBUT1BfUExBWSwgVE9QX1BMQVlJTkcsIFRPUF9QUk9HUkVTUywgVE9QX1JBVEVfQ0hBTkdFLCBUT1BfUkVTRVQsIFRPUF9TRUVLRUQsIFRPUF9TRUVLSU5HLCBUT1BfU1RBTExFRCwgVE9QX1NVQk1JVCwgVE9QX1NVU1BFTkQsIFRPUF9USU1FX1VQREFURSwgVE9QX1RPR0dMRSwgVE9QX1ZPTFVNRV9DSEFOR0UsIFRPUF9XQUlUSU5HXTtcblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDQsXG5cbiAgaXNJbnRlcmFjdGl2ZVRvcExldmVsRXZlbnRUeXBlOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIHJldHVybiBjb25maWcgIT09IHVuZGVmaW5lZCAmJiBjb25maWcuaXNJbnRlcmFjdGl2ZSA9PT0gdHJ1ZTtcbiAgfSxcblxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSBUT1BfS0VZX1BSRVNTOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUT1BfS0VZX0RPV046XG4gICAgICBjYXNlIFRPUF9LRVlfVVA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0JMVVI6XG4gICAgICBjYXNlIFRPUF9GT0NVUzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfQ0xJQ0s6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUT1BfQVVYX0NMSUNLOlxuICAgICAgY2FzZSBUT1BfRE9VQkxFX0NMSUNLOlxuICAgICAgY2FzZSBUT1BfTU9VU0VfRE9XTjpcbiAgICAgIGNhc2UgVE9QX01PVVNFX01PVkU6XG4gICAgICBjYXNlIFRPUF9NT1VTRV9VUDpcbiAgICAgIC8vIFRPRE86IERpc2FibGVkIGVsZW1lbnRzIHNob3VsZCBub3QgcmVzcG9uZCB0byBtb3VzZSBldmVudHNcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVE9QX01PVVNFX09VVDpcbiAgICAgIGNhc2UgVE9QX01PVVNFX09WRVI6XG4gICAgICBjYXNlIFRPUF9DT05URVhUX01FTlU6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0RSQUc6XG4gICAgICBjYXNlIFRPUF9EUkFHX0VORDpcbiAgICAgIGNhc2UgVE9QX0RSQUdfRU5URVI6XG4gICAgICBjYXNlIFRPUF9EUkFHX0VYSVQ6XG4gICAgICBjYXNlIFRPUF9EUkFHX0xFQVZFOlxuICAgICAgY2FzZSBUT1BfRFJBR19PVkVSOlxuICAgICAgY2FzZSBUT1BfRFJBR19TVEFSVDpcbiAgICAgIGNhc2UgVE9QX0RST1A6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfVE9VQ0hfQ0FOQ0VMOlxuICAgICAgY2FzZSBUT1BfVE9VQ0hfRU5EOlxuICAgICAgY2FzZSBUT1BfVE9VQ0hfTU9WRTpcbiAgICAgIGNhc2UgVE9QX1RPVUNIX1NUQVJUOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVG91Y2hFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRPUF9BTklNQVRJT05fRU5EOlxuICAgICAgY2FzZSBUT1BfQU5JTUFUSU9OX0lURVJBVElPTjpcbiAgICAgIGNhc2UgVE9QX0FOSU1BVElPTl9TVEFSVDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX1RSQU5TSVRJT05fRU5EOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX1NDUk9MTDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfV0hFRUw6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0NPUFk6XG4gICAgICBjYXNlIFRPUF9DVVQ6XG4gICAgICBjYXNlIFRPUF9QQVNURTpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0dPVF9QT0lOVEVSX0NBUFRVUkU6XG4gICAgICBjYXNlIFRPUF9MT1NUX1BPSU5URVJfQ0FQVFVSRTpcbiAgICAgIGNhc2UgVE9QX1BPSU5URVJfQ0FOQ0VMOlxuICAgICAgY2FzZSBUT1BfUE9JTlRFUl9ET1dOOlxuICAgICAgY2FzZSBUT1BfUE9JTlRFUl9NT1ZFOlxuICAgICAgY2FzZSBUT1BfUE9JTlRFUl9PVVQ6XG4gICAgICBjYXNlIFRPUF9QT0lOVEVSX09WRVI6XG4gICAgICBjYXNlIFRPUF9QT0lOVEVSX1VQOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljUG9pbnRlckV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoa25vd25IVE1MVG9wTGV2ZWxUeXBlcy5pbmRleE9mKHRvcExldmVsVHlwZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuIFRoaXMgd2FybmluZyAnICsgJ2lzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsIHRvcExldmVsVHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhUTUwgRXZlbnRzXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5kZXguaHRtbCNldmVudHMtMFxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgZXZlbnQgPSBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbn07XG5cbnZhciBpc0ludGVyYWN0aXZlVG9wTGV2ZWxFdmVudFR5cGUgPSBTaW1wbGVFdmVudFBsdWdpbi5pc0ludGVyYWN0aXZlVG9wTGV2ZWxFdmVudFR5cGU7XG5cblxudmFyIENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSA9IDEwO1xudmFyIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sID0gW107XG5cbi8qKlxuICogRmluZCB0aGUgZGVlcGVzdCBSZWFjdCBjb21wb25lbnQgY29tcGxldGVseSBjb250YWluaW5nIHRoZSByb290IG9mIHRoZVxuICogcGFzc2VkLWluIGluc3RhbmNlIChmb3IgdXNlIHdoZW4gZW50aXJlIFJlYWN0IHRyZWVzIGFyZSBuZXN0ZWQgd2l0aGluIGVhY2hcbiAqIG90aGVyKS4gSWYgUmVhY3QgdHJlZXMgYXJlIG5vdCBuZXN0ZWQsIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZmluZFJvb3RDb250YWluZXJOb2RlKGluc3QpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgd2hpbGUgKGluc3QucmV0dXJuKSB7XG4gICAgaW5zdCA9IGluc3QucmV0dXJuO1xuICB9XG4gIGlmIChpbnN0LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgd2UncmUgaW4gYSBkZXRhY2hlZCB0cmVlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpbnN0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIGdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0KSB7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wb3AoKTtcbiAgICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gICAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3BMZXZlbFR5cGU6IHRvcExldmVsVHlwZSxcbiAgICBuYXRpdmVFdmVudDogbmF0aXZlRXZlbnQsXG4gICAgdGFyZ2V0SW5zdDogdGFyZ2V0SW5zdCxcbiAgICBhbmNlc3RvcnM6IFtdXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBudWxsO1xuICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gbnVsbDtcbiAgaW5zdGFuY2UuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGggPCBDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUpIHtcbiAgICBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbChib29rS2VlcGluZykge1xuICB2YXIgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLnRhcmdldEluc3Q7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRhcmdldEluc3Q7XG4gIGRvIHtcbiAgICBpZiAoIWFuY2VzdG9yKSB7XG4gICAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIHJvb3QgPSBmaW5kUm9vdENvbnRhaW5lck5vZGUoYW5jZXN0b3IpO1xuICAgIGlmICghcm9vdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICBhbmNlc3RvciA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJvb3QpO1xuICB9IHdoaWxlIChhbmNlc3Rvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29rS2VlcGluZy5hbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xuICAgIHJ1bkV4dHJhY3RlZEV2ZW50c0luQmF0Y2goYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBjYW4gd2Ugc3RvcCBleHBvcnRpbmcgdGhlc2U/XG52YXIgX2VuYWJsZWQgPSB0cnVlO1xuXG5mdW5jdGlvbiBzZXRFbmFibGVkKGVuYWJsZWQpIHtcbiAgX2VuYWJsZWQgPSAhIWVuYWJsZWQ7XG59XG5cbmZ1bmN0aW9uIGlzRW5hYmxlZCgpIHtcbiAgcmV0dXJuIF9lbmFibGVkO1xufVxuXG4vKipcbiAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRvcExldmVsVHlwZSBOdW1iZXIgZnJvbSBgVG9wTGV2ZWxFdmVudFR5cGVzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGRpc3BhdGNoID0gaXNJbnRlcmFjdGl2ZVRvcExldmVsRXZlbnRUeXBlKHRvcExldmVsVHlwZSkgPyBkaXNwYXRjaEludGVyYWN0aXZlRXZlbnQgOiBkaXNwYXRjaEV2ZW50O1xuXG4gIGFkZEV2ZW50QnViYmxlTGlzdGVuZXIoZWxlbWVudCwgZ2V0UmF3RXZlbnROYW1lKHRvcExldmVsVHlwZSksXG4gIC8vIENoZWNrIGlmIGludGVyYWN0aXZlIGFuZCB3cmFwIGluIGludGVyYWN0aXZlVXBkYXRlc1xuICBkaXNwYXRjaC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xufVxuXG4vKipcbiAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wTGV2ZWxUeXBlIE51bWJlciBmcm9tIGBUb3BMZXZlbEV2ZW50VHlwZXNgLlxuICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB0cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGRpc3BhdGNoID0gaXNJbnRlcmFjdGl2ZVRvcExldmVsRXZlbnRUeXBlKHRvcExldmVsVHlwZSkgPyBkaXNwYXRjaEludGVyYWN0aXZlRXZlbnQgOiBkaXNwYXRjaEV2ZW50O1xuXG4gIGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyKGVsZW1lbnQsIGdldFJhd0V2ZW50TmFtZSh0b3BMZXZlbFR5cGUpLFxuICAvLyBDaGVjayBpZiBpbnRlcmFjdGl2ZSBhbmQgd3JhcCBpbiBpbnRlcmFjdGl2ZVVwZGF0ZXNcbiAgZGlzcGF0Y2guYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hJbnRlcmFjdGl2ZUV2ZW50KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgaW50ZXJhY3RpdmVVcGRhdGVzKGRpc3BhdGNoRXZlbnQsIHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgaWYgKCFfZW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KTtcbiAgdmFyIHRhcmdldEluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsICYmIHR5cGVvZiB0YXJnZXRJbnN0LnRhZyA9PT0gJ251bWJlcicgJiYgIWlzRmliZXJNb3VudGVkKHRhcmdldEluc3QpKSB7XG4gICAgLy8gSWYgd2UgZ2V0IGFuIGV2ZW50IChleDogaW1nIG9ubG9hZCkgYmVmb3JlIGNvbW1pdHRpbmcgdGhhdFxuICAgIC8vIGNvbXBvbmVudCdzIG1vdW50LCBpZ25vcmUgaXQgZm9yIG5vdyAodGhhdCBpcywgdHJlYXQgaXQgYXMgaWYgaXQgd2FzIGFuXG4gICAgLy8gZXZlbnQgb24gYSBub24tUmVhY3QgdHJlZSkuIFdlIG1pZ2h0IGFsc28gY29uc2lkZXIgcXVldWVpbmcgZXZlbnRzIGFuZFxuICAgIC8vIGRpc3BhdGNoaW5nIHRoZW0gYWZ0ZXIgdGhlIG1vdW50LlxuICAgIHRhcmdldEluc3QgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJvb2tLZWVwaW5nID0gZ2V0VG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QpO1xuXG4gIHRyeSB7XG4gICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xuICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWwsIGJvb2tLZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKGJvb2tLZWVwaW5nKTtcbiAgfVxufVxuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RET01FdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0XG4gKiAgICBwbHVnZ2FibGUgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluXG4gKiAgICB0aHJlYWQuXG4gKlxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXG4gKiAgICBtYXkgYmUgZG9uZSBpbiB0aGUgd29ya2VyIHRocmVhZC5cbiAqXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xuICogICAgdHJhcCBpdCkgdG8gYEV2ZW50UGx1Z2luSHViYCwgd2hpY2ggaW4gdHVybiB3aWxsIGFzayBwbHVnaW5zIGlmIHRoZXkgd2FudFxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB3aWxsIHRoZW4gcHJvY2VzcyBlYWNoIGV2ZW50IGJ5IGFubm90YXRpbmcgdGhlbSB3aXRoXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB0aGVuIGRpc3BhdGNoZXMgdGhlIGV2ZW50cy5cbiAqXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcbiAqXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiAgICAgICB8ICAgICAgICAgICAuXG4gKiAgICAgICB2ICAgICAgICAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgdiAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCBQcm9wYWdhdG9yc3xcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCAgdXRpbGl0aWVzIHxcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICBeICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxuICogKy0tLS0tLS0tLS0tLS0rICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXG4gKiAgICAgICAgICAgICAgICAgICAuXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxuICovXG5cbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vKipcbiAqIFRvIGVuc3VyZSBubyBjb25mbGljdHMgd2l0aCBvdGhlciBwb3RlbnRpYWwgUmVhY3QgaW5zdGFuY2VzIG9uIHRoZSBwYWdlXG4gKi9cbnZhciB0b3BMaXN0ZW5lcnNJREtleSA9ICdfcmVhY3RMaXN0ZW5lcnNJRCcgKyAoJycgKyBNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICpcbiAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XG4gKiBlbGVtZW50LiBUaGUgc3ltcHRvbXMgd2VyZSB0aGF0IGlmIHlvdXIgbW91c2UgaXMgbm90IG1vdmluZyBvdmVyIHNvbWV0aGluZ1xuICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XG4gKiByZWdpc3RlciB0aGUgYG1vdXNlbW92ZWAgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgdGhlbiBpdCB3aWxsIG9mIGNvdXJzZVxuICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxuICogbW92ZW1lbnQgdHlwZXMgb2YgZXZlbnRzIGFuZCBwb3NzaWJseSBhbGwgZXZlbnRzLlxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAqXG4gKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcGFyYW0ge29iamVjdH0gbW91bnRBdCBDb250YWluZXIgd2hlcmUgdG8gbW91bnQgdGhlIGxpc3RlbmVyXG4gKi9cbmZ1bmN0aW9uIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIG1vdW50QXQpIHtcbiAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICBzd2l0Y2ggKGRlcGVuZGVuY3kpIHtcbiAgICAgICAgY2FzZSBUT1BfU0NST0xMOlxuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KFRPUF9TQ1JPTEwsIG1vdW50QXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRPUF9GT0NVUzpcbiAgICAgICAgY2FzZSBUT1BfQkxVUjpcbiAgICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudChUT1BfRk9DVVMsIG1vdW50QXQpO1xuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KFRPUF9CTFVSLCBtb3VudEF0KTtcbiAgICAgICAgICAvLyBXZSBzZXQgdGhlIGZsYWcgZm9yIGEgc2luZ2xlIGRlcGVuZGVuY3kgbGF0ZXIgaW4gdGhpcyBmdW5jdGlvbixcbiAgICAgICAgICAvLyBidXQgdGhpcyBlbnN1cmVzIHdlIG1hcmsgYm90aCBhcyBhdHRhY2hlZCByYXRoZXIgdGhhbiBqdXN0IG9uZS5cbiAgICAgICAgICBpc0xpc3RlbmluZ1tUT1BfQkxVUl0gPSB0cnVlO1xuICAgICAgICAgIGlzTGlzdGVuaW5nW1RPUF9GT0NVU10gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRPUF9DQU5DRUw6XG4gICAgICAgIGNhc2UgVE9QX0NMT1NFOlxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKGdldFJhd0V2ZW50TmFtZShkZXBlbmRlbmN5KSkpIHtcbiAgICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KGRlcGVuZGVuY3ksIG1vdW50QXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBUT1BfSU5WQUxJRDpcbiAgICAgICAgY2FzZSBUT1BfU1VCTUlUOlxuICAgICAgICBjYXNlIFRPUF9SRVNFVDpcbiAgICAgICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhlbSBvbiB0aGUgdGFyZ2V0IERPTSBlbGVtZW50cy5cbiAgICAgICAgICAvLyBTb21lIG9mIHRoZW0gYnViYmxlIHNvIHdlIGRvbid0IHdhbnQgdGhlbSB0byBmaXJlIHR3aWNlLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIGxpc3RlbiBvbiB0aGUgdG9wIGxldmVsIHRvIGFsbCBub24tbWVkaWEgZXZlbnRzLlxuICAgICAgICAgIC8vIE1lZGlhIGV2ZW50cyBkb24ndCBidWJibGUgc28gYWRkaW5nIHRoZSBsaXN0ZW5lciB3b3VsZG4ndCBkbyBhbnl0aGluZy5cbiAgICAgICAgICB2YXIgaXNNZWRpYUV2ZW50ID0gbWVkaWFFdmVudFR5cGVzLmluZGV4T2YoZGVwZW5kZW5jeSkgIT09IC0xO1xuICAgICAgICAgIGlmICghaXNNZWRpYUV2ZW50KSB7XG4gICAgICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIG1vdW50QXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcyhyZWdpc3RyYXRpb25OYW1lLCBtb3VudEF0KSB7XG4gIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQoZG9jKSB7XG4gIGRvYyA9IGRvYyB8fCAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogdW5kZWZpbmVkKTtcbiAgaWYgKHR5cGVvZiBkb2MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnQgfHwgZG9jLmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jLmJvZHk7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXG4gKiBET00gaWYgYSBub2RlJ3Mgc2libGluZ3MgaGF2ZSBiZWVuIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb3V0ZXJOb2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRzKG91dGVyTm9kZSkge1xuICB2YXIgb3duZXJEb2N1bWVudCA9IG91dGVyTm9kZS5vd25lckRvY3VtZW50O1xuXG4gIHZhciB3aW4gPSBvd25lckRvY3VtZW50ICYmIG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICB2YXIgc2VsZWN0aW9uID0gd2luLmdldFNlbGVjdGlvbiAmJiB3aW4uZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIC8vIEluIEZpcmVmb3gsIGFuY2hvck5vZGUgYW5kIGZvY3VzTm9kZSBjYW4gYmUgXCJhbm9ueW1vdXMgZGl2c1wiLCBlLmcuIHRoZVxuICAvLyB1cC9kb3duIGJ1dHRvbnMgb24gYW4gPGlucHV0IHR5cGU9XCJudW1iZXJcIj4uIEFub255bW91cyBkaXZzIGRvIG5vdCBzZWVtIHRvXG4gIC8vIGV4cG9zZSBwcm9wZXJ0aWVzLCB0cmlnZ2VyaW5nIGEgXCJQZXJtaXNzaW9uIGRlbmllZCBlcnJvclwiIGlmIGFueSBvZiBpdHNcbiAgLy8gcHJvcGVydGllcyBhcmUgYWNjZXNzZWQuIFRoZSBvbmx5IHNlZW1pbmdseSBwb3NzaWJsZSB3YXkgdG8gYXZvaWQgZXJyb3JpbmdcbiAgLy8gaXMgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhdCB0eXBpY2FsbHkgd29ya3MgZm9yIG5vbi1hbm9ueW1vdXMgZGl2cyBhbmRcbiAgLy8gY2F0Y2ggYW55IGVycm9yIHRoYXQgbWF5IG90aGVyd2lzZSBhcmlzZS4gU2VlXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTIwODQyN1xuXG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgYW5jaG9yTm9kZS5ub2RlVHlwZTtcbiAgICBmb2N1c05vZGUubm9kZVR5cGU7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzKG91dGVyTm9kZSwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHtzdGFydCwgZW5kfSB3aGVyZSBgc3RhcnRgIGlzIHRoZSBjaGFyYWN0ZXIvY29kZXBvaW50IGluZGV4IG9mXG4gKiAoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSB3aXRoaW4gdGhlIHRleHRDb250ZW50IG9mIGBvdXRlck5vZGVgLCBhbmRcbiAqIGBlbmRgIGlzIHRoZSBpbmRleCBvZiAoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkuXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHlvdSBwYXNzIGluIGdhcmJhZ2UgaW5wdXQgYnV0IHdlIHNob3VsZCBwcm9iYWJseSBqdXN0IGNyYXNoLlxuICpcbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzKG91dGVyTm9kZSwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gIHZhciBsZW5ndGggPSAwO1xuICB2YXIgc3RhcnQgPSAtMTtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgaW5kZXhXaXRoaW5BbmNob3IgPSAwO1xuICB2YXIgaW5kZXhXaXRoaW5Gb2N1cyA9IDA7XG4gIHZhciBub2RlID0gb3V0ZXJOb2RlO1xuICB2YXIgcGFyZW50Tm9kZSA9IG51bGw7XG5cbiAgb3V0ZXI6IHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIG5leHQgPSBudWxsO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBhbmNob3JOb2RlICYmIChhbmNob3JPZmZzZXQgPT09IDAgfHwgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSkge1xuICAgICAgICBzdGFydCA9IGxlbmd0aCArIGFuY2hvck9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBmb2N1c05vZGUgJiYgKGZvY3VzT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoICsgZm9jdXNPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgICAgbGVuZ3RoICs9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKChuZXh0ID0gbm9kZS5maXJzdENoaWxkKSA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIE1vdmluZyBmcm9tIGBub2RlYCB0byBpdHMgZmlyc3QgY2hpbGQgYG5leHRgLlxuICAgICAgcGFyZW50Tm9kZSA9IG5vZGU7XG4gICAgICBub2RlID0gbmV4dDtcbiAgICB9XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IG91dGVyTm9kZSkge1xuICAgICAgICAvLyBJZiBgb3V0ZXJOb2RlYCBoYXMgY2hpbGRyZW4sIHRoaXMgaXMgYWx3YXlzIHRoZSBzZWNvbmQgdGltZSB2aXNpdGluZ1xuICAgICAgICAvLyBpdC4gSWYgaXQgaGFzIG5vIGNoaWxkcmVuLCB0aGlzIGlzIHN0aWxsIHRoZSBmaXJzdCBsb29wLCBhbmQgdGhlIG9ubHlcbiAgICAgICAgLy8gdmFsaWQgc2VsZWN0aW9uIGlzIGFuY2hvck5vZGUgYW5kIGZvY3VzTm9kZSBib3RoIGVxdWFsIHRvIHRoaXMgbm9kZVxuICAgICAgICAvLyBhbmQgYm90aCBvZmZzZXRzIDAsIGluIHdoaWNoIGNhc2Ugd2Ugd2lsbCBoYXZlIGhhbmRsZWQgYWJvdmUuXG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudE5vZGUgPT09IGFuY2hvck5vZGUgJiYgKytpbmRleFdpdGhpbkFuY2hvciA9PT0gYW5jaG9yT2Zmc2V0KSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudE5vZGUgPT09IGZvY3VzTm9kZSAmJiArK2luZGV4V2l0aGluRm9jdXMgPT09IGZvY3VzT2Zmc2V0KSB7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmICgobmV4dCA9IG5vZGUubmV4dFNpYmxpbmcpICE9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIE1vdmluZyBmcm9tIGBub2RlYCB0byBpdHMgbmV4dCBzaWJsaW5nIGBuZXh0YC5cbiAgICBub2RlID0gbmV4dDtcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kID09PSAtMSkge1xuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4gKFdvdWxkIGhhcHBlbiBpZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFyZW4ndFxuICAgIC8vIGFjdHVhbGx5IGluc2lkZSB0aGUgcGFzc2VkLWluIG5vZGUuKVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBlbmRcbiAgfTtcbn1cblxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldE9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuICB2YXIgd2luID0gZG9jICYmIGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIHZhciBzZWxlY3Rpb24gPSB3aW4uZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQgPyBzdGFydCA6IE1hdGgubWluKG9mZnNldHMuZW5kLCBsZW5ndGgpO1xuXG4gIC8vIElFIDExIHVzZXMgbW9kZXJuIHNlbGVjdGlvbiwgYnV0IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZXh0ZW5kIG1ldGhvZC5cbiAgLy8gRmxpcCBiYWNrd2FyZCBzZWxlY3Rpb25zLCBzbyB3ZSBjYW4gc2V0IHdpdGggYSBzaW5nbGUgcmFuZ2UuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHZhciB0ZW1wID0gZW5kO1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gdGVtcDtcbiAgfVxuXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDEgJiYgc2VsZWN0aW9uLmFuY2hvck5vZGUgPT09IHN0YXJ0TWFya2VyLm5vZGUgJiYgc2VsZWN0aW9uLmFuY2hvck9mZnNldCA9PT0gc3RhcnRNYXJrZXIub2Zmc2V0ICYmIHNlbGVjdGlvbi5mb2N1c05vZGUgPT09IGVuZE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5mb2N1c09mZnNldCA9PT0gZW5kTWFya2VyLm9mZnNldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmFuZ2UgPSBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUub3duZXJEb2N1bWVudCAmJiBjb250YWluc05vZGUobm9kZS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnREZWVwKCkge1xuICB2YXIgd2luID0gd2luZG93O1xuICB2YXIgZWxlbWVudCA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgd2hpbGUgKGVsZW1lbnQgaW5zdGFuY2VvZiB3aW4uSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAvLyBBY2Nlc3NpbmcgdGhlIGNvbnRlbnREb2N1bWVudCBvZiBhIEhUTUxJZnJhbWVFbGVtZW50IGNhbiBjYXVzZSB0aGUgYnJvd3NlclxuICAgIC8vIHRvIHRocm93LCBlLmcuIGlmIGl0IGhhcyBhIGNyb3NzLW9yaWdpbiBzcmMgYXR0cmlidXRlXG4gICAgdHJ5IHtcbiAgICAgIHdpbiA9IGVsZW1lbnQuY29udGVudERvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICBlbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudCh3aW4uZG9jdW1lbnQpO1xuICB9XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xuXG4vKipcbiAqIEBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXM6IHdlIGdldCB0aGUgZWxlbWVudCB0eXBlcyB0aGF0IHN1cHBvcnQgc2VsZWN0aW9uXG4gKiBmcm9tIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2RvLW5vdC1hcHBseSwgbG9va2luZyBhdCBgc2VsZWN0aW9uU3RhcnRgXG4gKiBhbmQgYHNlbGVjdGlvbkVuZGAgcm93cy5cbiAqL1xuZnVuY3Rpb24gaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAndGV4dCcgfHwgZWxlbS50eXBlID09PSAnc2VhcmNoJyB8fCBlbGVtLnR5cGUgPT09ICd0ZWwnIHx8IGVsZW0udHlwZSA9PT0gJ3VybCcgfHwgZWxlbS50eXBlID09PSAncGFzc3dvcmQnKSB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24oKSB7XG4gIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnREZWVwKCk7XG4gIHJldHVybiB7XG4gICAgZm9jdXNlZEVsZW06IGZvY3VzZWRFbGVtLFxuICAgIHNlbGVjdGlvblJhbmdlOiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZm9jdXNlZEVsZW0pID8gZ2V0U2VsZWN0aW9uJDEoZm9jdXNlZEVsZW0pIDogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXG4gKiBub2RlcyBhbmQgcGxhY2UgdGhlbSBiYWNrIGluLCByZXN1bHRpbmcgaW4gZm9jdXMgYmVpbmcgbG9zdC5cbiAqL1xuZnVuY3Rpb24gcmVzdG9yZVNlbGVjdGlvbihwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSB7XG4gIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnREZWVwKCk7XG4gIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiYgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgaWYgKHByaW9yU2VsZWN0aW9uUmFuZ2UgIT09IG51bGwgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICBzZXRTZWxlY3Rpb24ocHJpb3JGb2N1c2VkRWxlbSwgcHJpb3JTZWxlY3Rpb25SYW5nZSk7XG4gICAgfVxuXG4gICAgLy8gRm9jdXNpbmcgYSBub2RlIGNhbiBjaGFuZ2UgdGhlIHNjcm9sbCBwb3NpdGlvbiwgd2hpY2ggaXMgdW5kZXNpcmFibGVcbiAgICB2YXIgYW5jZXN0b3JzID0gW107XG4gICAgdmFyIGFuY2VzdG9yID0gcHJpb3JGb2N1c2VkRWxlbTtcbiAgICB3aGlsZSAoYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAoYW5jZXN0b3Iubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICBhbmNlc3RvcnMucHVzaCh7XG4gICAgICAgICAgZWxlbWVudDogYW5jZXN0b3IsXG4gICAgICAgICAgbGVmdDogYW5jZXN0b3Iuc2Nyb2xsTGVmdCxcbiAgICAgICAgICB0b3A6IGFuY2VzdG9yLnNjcm9sbFRvcFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByaW9yRm9jdXNlZEVsZW0uZm9jdXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByaW9yRm9jdXNlZEVsZW0uZm9jdXMoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluZm8gPSBhbmNlc3RvcnNbaV07XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsTGVmdCA9IGluZm8ubGVmdDtcbiAgICAgIGluZm8uZWxlbWVudC5zY3JvbGxUb3AgPSBpbmZvLnRvcDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2V0U2VsZWN0aW9uOiBHZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgZm9jdXNlZCB0ZXh0YXJlYSwgaW5wdXQgb3JcbiAqIGNvbnRlbnRFZGl0YWJsZSBub2RlLlxuICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAqIC1AcmV0dXJuIHtzdGFydDogc2VsZWN0aW9uU3RhcnQsIGVuZDogc2VsZWN0aW9uRW5kfVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24kMShpbnB1dCkge1xuICB2YXIgc2VsZWN0aW9uID0gdm9pZCAwO1xuXG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbiAgICBzZWxlY3Rpb24gPSB7XG4gICAgICBzdGFydDogaW5wdXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0gZ2V0T2Zmc2V0cyhpbnB1dCk7XG4gIH1cblxuICByZXR1cm4gc2VsZWN0aW9uIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xufVxuXG4vKipcbiAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICogdGhlIGlucHV0LlxuICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICovXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb24oaW5wdXQsIG9mZnNldHMpIHtcbiAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydCxcbiAgICAgIGVuZCA9IG9mZnNldHMuZW5kO1xuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgfVxufVxuXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcblxudmFyIGV2ZW50VHlwZXMkMyA9IHtcbiAgc2VsZWN0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvblNlbGVjdCcsXG4gICAgICBjYXB0dXJlZDogJ29uU2VsZWN0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9CTFVSLCBUT1BfQ09OVEVYVF9NRU5VLCBUT1BfRFJBR19FTkQsIFRPUF9GT0NVUywgVE9QX0tFWV9ET1dOLCBUT1BfS0VZX1VQLCBUT1BfTU9VU0VfRE9XTiwgVE9QX01PVVNFX1VQLCBUT1BfU0VMRUNUSU9OX0NIQU5HRV1cbiAgfVxufTtcblxudmFyIGFjdGl2ZUVsZW1lbnQkMSA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QkMSA9IG51bGw7XG52YXIgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG52YXIgbW91c2VEb3duID0gZmFsc2U7XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aGljaCBpcyBhIHVuaXF1ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XG4gKiB0d28gaWRlbnRpY2FsIHNlbGVjdGlvbnMgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHJldHVybiBpZGVudGljYWwgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKG5vZGUpIHtcbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gbm9kZSAmJiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMobm9kZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IG5vZGUuc2VsZWN0aW9uU3RhcnQsXG4gICAgICBlbmQ6IG5vZGUuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgd2luID0gbm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbi5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yTm9kZTogc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQ6IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGU6IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldDogc2VsZWN0aW9uLmZvY3VzT2Zmc2V0XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBkb2N1bWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50IHRhcmdldC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRUYXJnZXRcbiAqIEByZXR1cm4ge0RvY3VtZW50fVxuICovXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldERvY3VtZW50KGV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBldmVudFRhcmdldC53aW5kb3cgPT09IGV2ZW50VGFyZ2V0ID8gZXZlbnRUYXJnZXQuZG9jdW1lbnQgOiBldmVudFRhcmdldC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IGV2ZW50VGFyZ2V0IDogZXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRUYXJnZXRcbiAqIEByZXR1cm4gez9TeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIHZhciBkb2MgPSBnZXRFdmVudFRhcmdldERvY3VtZW50KG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQkMSA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQkMSAhPT0gZ2V0QWN0aXZlRWxlbWVudChkb2MpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQkMSk7XG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcyQzLnNlbGVjdCwgYWN0aXZlRWxlbWVudEluc3QkMSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50JDE7XG5cbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkb2MgPSBnZXRFdmVudFRhcmdldERvY3VtZW50KG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAvLyBUcmFjayB3aGV0aGVyIGFsbCBsaXN0ZW5lcnMgZXhpc3RzIGZvciB0aGlzIHBsdWdpbi4gSWYgbm9uZSBleGlzdCwgd2UgZG9cbiAgICAvLyBub3QgZXh0cmFjdCBldmVudHMuIFNlZSAjMzYzOS5cbiAgICBpZiAoIWRvYyB8fCAhaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcygnb25TZWxlY3QnLCBkb2MpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlJDEodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgICBjYXNlIFRPUF9GT0NVUzpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSB8fCB0YXJnZXROb2RlLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0JMVVI6XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IG51bGw7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xuICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxuICAgICAgLy8gc2VtYW50aWNzIG9mIHRoZSBuYXRpdmUgc2VsZWN0IGV2ZW50LlxuICAgICAgY2FzZSBUT1BfTU9VU0VfRE9XTjpcbiAgICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRPUF9DT05URVhUX01FTlU6XG4gICAgICBjYXNlIFRPUF9NT1VTRV9VUDpcbiAgICAgIGNhc2UgVE9QX0RSQUdfRU5EOlxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlIFRPUF9TRUxFQ1RJT05fQ0hBTkdFOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgVE9QX0tFWV9ET1dOOlxuICAgICAgY2FzZSBUT1BfS0VZX1VQOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJbmplY3QgbW9kdWxlcyBmb3IgcmVzb2x2aW5nIERPTSBoaWVyYXJjaHkgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqL1xuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoRE9NRXZlbnRQbHVnaW5PcmRlcik7XG5zZXRDb21wb25lbnRUcmVlKGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMSwgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxLCBnZXROb2RlRnJvbUluc3RhbmNlJDEpO1xuXG4vKipcbiAqIFNvbWUgaW1wb3J0YW50IGV2ZW50IHBsdWdpbnMgaW5jbHVkZWQgYnkgZGVmYXVsdCAod2l0aG91dCBoYXZpbmcgdG8gcmVxdWlyZVxuICogdGhlbSkuXG4gKi9cbmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoe1xuICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXG4gIEVudGVyTGVhdmVFdmVudFBsdWdpbjogRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLFxuICBDaGFuZ2VFdmVudFBsdWdpbjogQ2hhbmdlRXZlbnRQbHVnaW4sXG4gIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcbiAgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogQmVmb3JlSW5wdXRFdmVudFBsdWdpblxufSk7XG5cbnZhciBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5JbnZhbGlkQ2hpbGQgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgLy8gRmxhdHRlbiBjaGlsZHJlbi4gV2UnbGwgd2FybiBpZiB0aGV5IGFyZSBpbnZhbGlkXG4gIC8vIGR1cmluZyB2YWxpZGF0ZVByb3BzKCkgd2hpY2ggcnVucyBmb3IgaHlkcmF0aW9uIHRvby5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgd291bGQgdGhyb3cgb24gbm9uLWVsZW1lbnQgb2JqZWN0cy5cbiAgLy8gRWxlbWVudHMgYXJlIHN0cmluZ2lmaWVkICh3aGljaCBpcyBub3JtYWxseSBpcnJlbGV2YW50XG4gIC8vIGJ1dCBtYXR0ZXJzIGZvciA8ZmJ0PikuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgLy8gTm90ZTogd2UgZG9uJ3Qgd2FybiBhYm91dCBpbnZhbGlkIGNoaWxkcmVuIGhlcmUuXG4gICAgLy8gSW5zdGVhZCwgdGhpcyBpcyBkb25lIHNlcGFyYXRlbHkgYmVsb3cgc28gdGhhdFxuICAgIC8vIGl0IGhhcHBlbnMgZHVyaW5nIHRoZSBoeWRyYXRpb24gY29kZXBhdGggdG9vLlxuICB9KTtcblxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IGhvc3QgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHtcbiAgICAvLyBUaGlzIG1pcnJvcnMgdGhlIGNvZGVwYXRoIGFib3ZlLCBidXQgcnVucyBmb3IgaHlkcmF0aW9uIHRvby5cbiAgICAvLyBXYXJuIGFib3V0IGludmFsaWQgY2hpbGRyZW4gaGVyZSBzbyB0aGF0IGNsaWVudCBhbmQgaHlkcmF0aW9uIGFyZSBjb25zaXN0ZW50LlxuICAgIC8vIFRPRE86IHRoaXMgc2VlbXMgbGlrZSBpdCBjb3VsZCBjYXVzZSBhIERFVi1vbmx5IHRocm93IGZvciBoeWRyYXRpb25cbiAgICAvLyBpZiBjaGlsZHJlbiBjb250YWlucyBhIG5vbi1lbGVtZW50IG9iamVjdC4gV2Ugc2hvdWxkIHRyeSB0byBhdm9pZCB0aGF0LlxuICAgIGlmICh0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdvYmplY3QnICYmIHByb3BzLmNoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKHByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGlkV2FybkludmFsaWRDaGlsZCkge1xuICAgICAgICAgIGRpZFdhcm5JbnZhbGlkQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAgICBpZiAocHJvcHMuc2VsZWN0ZWQgIT0gbnVsbCAmJiAhZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24pIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpO1xuICAgICAgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgLy8gdmFsdWU9XCJcIiBzaG91bGQgbWFrZSBhIHZhbHVlIGF0dHJpYnV0ZSAoIzYyMTkpXG4gIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdG9TdHJpbmcoZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSkpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7IGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuICB2YXIgY29udGVudCA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBob3N0UHJvcHMuY2hpbGRyZW4gPSBjb250ZW50O1xuICB9XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gdm9pZCAwO1xuXG57XG4gIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgdmFyIG93bmVyTmFtZSA9IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCk7XG4gIGlmIChvd25lck5hbWUpIHtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG5cbi8qKlxuICogVmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKSB7XG4gIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCdzZWxlY3QnLCBwcm9wcyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKTtcbiAgICB9IGVsc2UgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiBpc0FycmF5KSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhub2RlLCBtdWx0aXBsZSwgcHJvcFZhbHVlLCBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgdmFyIG9wdGlvbnMgPSBub2RlLm9wdGlvbnM7XG5cbiAgaWYgKG11bHRpcGxlKSB7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWVzID0gcHJvcFZhbHVlO1xuICAgIHZhciBzZWxlY3RlZFZhbHVlID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gUHJlZml4IHRvIGF2b2lkIGNoYW9zIHdpdGggc3BlY2lhbCBrZXlzLlxuICAgICAgc2VsZWN0ZWRWYWx1ZVsnJCcgKyBzZWxlY3RlZFZhbHVlc1tpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgb3B0aW9ucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkoJyQnICsgb3B0aW9uc1tfaV0udmFsdWUpO1xuICAgICAgaWYgKG9wdGlvbnNbX2ldLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW19pXS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGVkICYmIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW19pXS5kZWZhdWx0U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgc2V0IGBzZWxlY3QudmFsdWVgIGFzIGV4YWN0IGJlaGF2aW9yIGlzbid0IGNvbnNpc3RlbnQgYWNyb3NzIGFsbFxuICAgIC8vIGJyb3dzZXJzIGZvciBhbGwgY2FzZXMuXG4gICAgdmFyIF9zZWxlY3RlZFZhbHVlID0gdG9TdHJpbmcoZ2V0VG9TdHJpbmdWYWx1ZShwcm9wVmFsdWUpKTtcbiAgICB2YXIgZGVmYXVsdFNlbGVjdGVkID0gbnVsbDtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBvcHRpb25zLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIGlmIChvcHRpb25zW19pMl0udmFsdWUgPT09IF9zZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbX2kyXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGlmIChzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgICBvcHRpb25zW19pMl0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFNlbGVjdGVkID09PSBudWxsICYmICFvcHRpb25zW19pMl0uZGlzYWJsZWQpIHtcbiAgICAgICAgZGVmYXVsdFNlbGVjdGVkID0gb3B0aW9uc1tfaTJdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdFNlbGVjdGVkICE9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0U2VsZWN0ZWQuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMihlbGVtZW50LCBwcm9wcykge1xuICByZXR1cm4gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpO1xuICB9XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIHdhc011bHRpcGxlOiAhIXByb3BzLm11bHRpcGxlXG4gIH07XG5cbiAge1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnU2VsZWN0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBzZWxlY3QgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgbm9kZS5tdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0VXBkYXRlV3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB3YXNNdWx0aXBsZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09ICEhcHJvcHMubXVsdGlwbGUpIHtcbiAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnLCBmYWxzZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9XG59XG5cbnZhciBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IGZhbHNlO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gICEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IHZvaWQgMDtcblxuICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbiAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK1NvcGhpZSBzZWVtZWQgdG8gbGlrZSB0aGlzXG4gIC8vIHNvbHV0aW9uLiBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZFxuICAvLyB0byBiZSBhIHN0cmluZy5cbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGlsZHJlbjogdG9TdHJpbmcobm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSlcbiAgfSk7XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZSQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCd0ZXh0YXJlYScsIHByb3BzKTtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbERlZmF1bHRWYWwpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJyVzIGNvbnRhaW5zIGEgdGV4dGFyZWEgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluaXRpYWxWYWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIC8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XG4gIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKTtcbiAgICAgIH1cbiAgICAgICEoZGVmYXVsdFZhbHVlID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpIDogdm9pZCAwO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICEoY2hpbGRyZW4ubGVuZ3RoIDw9IDEpID8gaW52YXJpYW50KGZhbHNlLCAnPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLicpIDogdm9pZCAwO1xuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0VmFsdWUgPSBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG4gICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxWYWx1ZTogZ2V0VG9TdHJpbmdWYWx1ZShpbml0aWFsVmFsdWUpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUpO1xuICB2YXIgZGVmYXVsdFZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy5kZWZhdWx0VmFsdWUpO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgIHZhciBuZXdWYWx1ZSA9IHRvU3RyaW5nKHZhbHVlKTtcbiAgICAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuICAgIGlmIChuZXdWYWx1ZSAhPT0gbm9kZS52YWx1ZSkge1xuICAgICAgbm9kZS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwgJiYgbm9kZS5kZWZhdWx0VmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfVxuICBpZiAoZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHRvU3RyaW5nKGRlZmF1bHRWYWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcblxuICAvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxuICAvLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cbiAgaWYgKHRleHRDb250ZW50ID09PSBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSB7XG4gICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpO1xufVxuXG52YXIgSFRNTF9OQU1FU1BBQ0UkMSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFJDEsXG4gIG1hdGhtbDogTUFUSF9OQU1FU1BBQ0UsXG4gIHN2ZzogU1ZHX05BTUVTUEFDRVxufTtcblxuLy8gQXNzdW1lcyB0aGVyZSBpcyBubyBwYXJlbnQgbmFtZXNwYWNlLlxuZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBTVkdfTkFNRVNQQUNFO1xuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0UkMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PSBudWxsIHx8IHBhcmVudE5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgIC8vIE5vIChvciBkZWZhdWx0KSBwYXJlbnQgbmFtZXNwYWNlOiBwb3RlbnRpYWwgZW50cnkgcG9pbnQuXG4gICAgcmV0dXJuIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRSQxO1xuICB9XG4gIC8vIEJ5IGRlZmF1bHQsIHBhc3MgbmFtZXNwYWNlIGJlbG93LlxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG4vLyBTVkcgdGVtcCBjb250YWluZXIgZm9yIElFIGxhY2tpbmcgaW5uZXJIVE1MXG52YXIgcmV1c2FibGVTVkdDb250YWluZXIgPSB2b2lkIDA7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4gIC8vIHRoZSB0YXJnZXQgbm9kZVxuXG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gTmFtZXNwYWNlcy5zdmcgJiYgISgnaW5uZXJIVE1MJyBpbiBub2RlKSkge1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN2Z05vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufSk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUuIEZvciB0ZXh0IHVwZGF0ZXMsIGl0J3MgZmFzdGVyXG4gKiB0byBzZXQgdGhlIGBub2RlVmFsdWVgIG9mIHRoZSBUZXh0IG5vZGUgZGlyZWN0bHkgaW5zdGVhZCBvZiB1c2luZ1xuICogYC50ZXh0Q29udGVudGAgd2hpY2ggd2lsbCByZW1vdmUgdGhlIGV4aXN0aW5nIG5vZGUgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gIGlmICh0ZXh0KSB7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cbiAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkID09PSBub2RlLmxhc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZEFyZWE6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICghaXNDdXN0b21Qcm9wZXJ0eSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwICYmICEoaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gIH1cblxuICByZXR1cm4gKCcnICsgdmFsdWUpLnRyaW0oKTtcbn1cblxudmFyIHVwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShuYW1lKSB7XG4gIHJldHVybiBuYW1lLnJlcGxhY2UodXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcbiAgdmFyIG1zUGF0dGVybiQxID0gL14tbXMtLztcbiAgdmFyIGh5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuXG4gIC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuICB2YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XG5cbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG4gIHZhciB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IGZhbHNlO1xuXG4gIHZhciBjYW1lbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSxcbiAgICAvLyBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gICAgLy8gKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICAgIC8vIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAgICBjYW1lbGl6ZShuYW1lLnJlcGxhY2UobXNQYXR0ZXJuJDEsICdtcy0nKSkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nJDEoZmFsc2UsIFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJykpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzTmFOID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdgSW5maW5pdHlgIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfTtcblxuICB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSQxID0gd2FyblZhbGlkU3R5bGU7XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogVGhpcyBjcmVhdGVzIGEgc3RyaW5nIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgZXF1aXZhbGVudCB0byB0aGUgc3R5bGVcbiAqIGF0dHJpYnV0ZSBnZW5lcmF0ZWQgYnkgc2VydmVyLXNpZGUgcmVuZGVyaW5nLiBJdCBieS1wYXNzZXMgd2FybmluZ3MgYW5kXG4gKiBzZWN1cml0eSBjaGVja3Mgc28gaXQncyBub3Qgc2FmZSB0byB1c2UgdGhpcyB2YWx1ZSBmb3IgYW55dGhpbmcgb3RoZXIgdGhhblxuICogY29tcGFyaXNvbi4gSXQgaXMgb25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhzdHlsZXMpIHtcbiAge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgdmFyIGRlbGltaXRlciA9ICcnO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRlbGltaXRlciArIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KTtcblxuICAgICAgICBkZWxpbWl0ZXIgPSAnOyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZXMobm9kZSwgc3R5bGVzKSB7XG4gIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICB7XG4gICAgICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUkMShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgIHN0eWxlTmFtZSA9ICdjc3NGbG9hdCc7XG4gICAgfVxuICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gIGFyZWE6IHRydWUsXG4gIGJhc2U6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlXG4gIC8vIE5PVEU6IG1lbnVpdGVtJ3MgY2xvc2UgdGFnIHNob3VsZCBiZSBvbWl0dGVkLCBidXQgdGhhdCBjYXVzZXMgcHJvYmxlbXMuXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgbWVudWl0ZW06IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG4vLyBUT0RPOiBXZSBjYW4gcmVtb3ZlIHRoaXMgaWYgd2UgYWRkIGludmFyaWFudFdpdGhTdGFjaygpXG4vLyBvciBhZGQgc3RhY2sgYnkgZGVmYXVsdCB0byBpbnZhcmlhbnRzIHdoZXJlIHBvc3NpYmxlLlxudmFyIEhUTUwkMSA9ICdfX2h0bWwnO1xuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQyID0gbnVsbDtcbntcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKHZvaWRFbGVtZW50VGFnc1t0YWddKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnJXMgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4lcycsIHRhZywgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQyLmdldFN0YWNrQWRkZW5kdW0oKSkgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIEhUTUwkMSBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkgPyBpbnZhcmlhbnQoZmFsc2UsICdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhcmlhbnQtZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB2b2lkIDA7XG4gIH1cbiAge1xuICAgICEocHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHx8ICFwcm9wcy5jb250ZW50RWRpdGFibGUgfHwgcHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyB3YXJuaW5nJDEoZmFsc2UsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJykgOiB2b2lkIDA7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuIHVzaW5nIEpTWC4lcycsIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMi5nZXRTdGFja0FkZGVuZHVtKCkpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuICAgIC8vIFdlIGRvbid0IG1pbmQgdGhpcyB3aGl0ZWxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhlIEhUTUwgb3IgU1ZHIHdoaXRlbGlzdCwgYmUgc3VyZSB0b1xuLy8gYWxzbyBhZGQgdGhlbSB0byB0aGlzIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3QgbmFtZVxuLy8gd2FybmluZ3MuXG52YXIgcG9zc2libGVTdGFuZGFyZE5hbWVzID0ge1xuICAvLyBIVE1MXG4gIGFjY2VwdDogJ2FjY2VwdCcsXG4gIGFjY2VwdGNoYXJzZXQ6ICdhY2NlcHRDaGFyc2V0JyxcbiAgJ2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuICBhY2Nlc3NrZXk6ICdhY2Nlc3NLZXknLFxuICBhY3Rpb246ICdhY3Rpb24nLFxuICBhbGxvd2Z1bGxzY3JlZW46ICdhbGxvd0Z1bGxTY3JlZW4nLFxuICBhbHQ6ICdhbHQnLFxuICBhczogJ2FzJyxcbiAgYXN5bmM6ICdhc3luYycsXG4gIGF1dG9jYXBpdGFsaXplOiAnYXV0b0NhcGl0YWxpemUnLFxuICBhdXRvY29tcGxldGU6ICdhdXRvQ29tcGxldGUnLFxuICBhdXRvY29ycmVjdDogJ2F1dG9Db3JyZWN0JyxcbiAgYXV0b2ZvY3VzOiAnYXV0b0ZvY3VzJyxcbiAgYXV0b3BsYXk6ICdhdXRvUGxheScsXG4gIGF1dG9zYXZlOiAnYXV0b1NhdmUnLFxuICBjYXB0dXJlOiAnY2FwdHVyZScsXG4gIGNlbGxwYWRkaW5nOiAnY2VsbFBhZGRpbmcnLFxuICBjZWxsc3BhY2luZzogJ2NlbGxTcGFjaW5nJyxcbiAgY2hhbGxlbmdlOiAnY2hhbGxlbmdlJyxcbiAgY2hhcnNldDogJ2NoYXJTZXQnLFxuICBjaGVja2VkOiAnY2hlY2tlZCcsXG4gIGNoaWxkcmVuOiAnY2hpbGRyZW4nLFxuICBjaXRlOiAnY2l0ZScsXG4gIGNsYXNzOiAnY2xhc3NOYW1lJyxcbiAgY2xhc3NpZDogJ2NsYXNzSUQnLFxuICBjbGFzc25hbWU6ICdjbGFzc05hbWUnLFxuICBjb2xzOiAnY29scycsXG4gIGNvbHNwYW46ICdjb2xTcGFuJyxcbiAgY29udGVudDogJ2NvbnRlbnQnLFxuICBjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuICBjb250ZXh0bWVudTogJ2NvbnRleHRNZW51JyxcbiAgY29udHJvbHM6ICdjb250cm9scycsXG4gIGNvbnRyb2xzbGlzdDogJ2NvbnRyb2xzTGlzdCcsXG4gIGNvb3JkczogJ2Nvb3JkcycsXG4gIGNyb3Nzb3JpZ2luOiAnY3Jvc3NPcmlnaW4nLFxuICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyxcbiAgZGF0YTogJ2RhdGEnLFxuICBkYXRldGltZTogJ2RhdGVUaW1lJyxcbiAgZGVmYXVsdDogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICBmb3I6ICdodG1sRm9yJyxcbiAgZm9ybTogJ2Zvcm0nLFxuICBmb3JtbWV0aG9kOiAnZm9ybU1ldGhvZCcsXG4gIGZvcm1hY3Rpb246ICdmb3JtQWN0aW9uJyxcbiAgZm9ybWVuY3R5cGU6ICdmb3JtRW5jVHlwZScsXG4gIGZvcm1ub3ZhbGlkYXRlOiAnZm9ybU5vVmFsaWRhdGUnLFxuICBmb3JtdGFyZ2V0OiAnZm9ybVRhcmdldCcsXG4gIGZyYW1lYm9yZGVyOiAnZnJhbWVCb3JkZXInLFxuICBoZWFkZXJzOiAnaGVhZGVycycsXG4gIGhlaWdodDogJ2hlaWdodCcsXG4gIGhpZGRlbjogJ2hpZGRlbicsXG4gIGhpZ2g6ICdoaWdoJyxcbiAgaHJlZjogJ2hyZWYnLFxuICBocmVmbGFuZzogJ2hyZWZMYW5nJyxcbiAgaHRtbGZvcjogJ2h0bWxGb3InLFxuICBodHRwZXF1aXY6ICdodHRwRXF1aXYnLFxuICAnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnLFxuICBpY29uOiAnaWNvbicsXG4gIGlkOiAnaWQnLFxuICBpbm5lcmh0bWw6ICdpbm5lckhUTUwnLFxuICBpbnB1dG1vZGU6ICdpbnB1dE1vZGUnLFxuICBpbnRlZ3JpdHk6ICdpbnRlZ3JpdHknLFxuICBpczogJ2lzJyxcbiAgaXRlbWlkOiAnaXRlbUlEJyxcbiAgaXRlbXByb3A6ICdpdGVtUHJvcCcsXG4gIGl0ZW1yZWY6ICdpdGVtUmVmJyxcbiAgaXRlbXNjb3BlOiAnaXRlbVNjb3BlJyxcbiAgaXRlbXR5cGU6ICdpdGVtVHlwZScsXG4gIGtleXBhcmFtczogJ2tleVBhcmFtcycsXG4gIGtleXR5cGU6ICdrZXlUeXBlJyxcbiAga2luZDogJ2tpbmQnLFxuICBsYWJlbDogJ2xhYmVsJyxcbiAgbGFuZzogJ2xhbmcnLFxuICBsaXN0OiAnbGlzdCcsXG4gIGxvb3A6ICdsb29wJyxcbiAgbG93OiAnbG93JyxcbiAgbWFuaWZlc3Q6ICdtYW5pZmVzdCcsXG4gIG1hcmdpbndpZHRoOiAnbWFyZ2luV2lkdGgnLFxuICBtYXJnaW5oZWlnaHQ6ICdtYXJnaW5IZWlnaHQnLFxuICBtYXg6ICdtYXgnLFxuICBtYXhsZW5ndGg6ICdtYXhMZW5ndGgnLFxuICBtZWRpYTogJ21lZGlhJyxcbiAgbWVkaWFncm91cDogJ21lZGlhR3JvdXAnLFxuICBtZXRob2Q6ICdtZXRob2QnLFxuICBtaW46ICdtaW4nLFxuICBtaW5sZW5ndGg6ICdtaW5MZW5ndGgnLFxuICBtdWx0aXBsZTogJ211bHRpcGxlJyxcbiAgbXV0ZWQ6ICdtdXRlZCcsXG4gIG5hbWU6ICduYW1lJyxcbiAgbm9tb2R1bGU6ICdub01vZHVsZScsXG4gIG5vbmNlOiAnbm9uY2UnLFxuICBub3ZhbGlkYXRlOiAnbm9WYWxpZGF0ZScsXG4gIG9wZW46ICdvcGVuJyxcbiAgb3B0aW11bTogJ29wdGltdW0nLFxuICBwYXR0ZXJuOiAncGF0dGVybicsXG4gIHBsYWNlaG9sZGVyOiAncGxhY2Vob2xkZXInLFxuICBwbGF5c2lubGluZTogJ3BsYXlzSW5saW5lJyxcbiAgcG9zdGVyOiAncG9zdGVyJyxcbiAgcHJlbG9hZDogJ3ByZWxvYWQnLFxuICBwcm9maWxlOiAncHJvZmlsZScsXG4gIHJhZGlvZ3JvdXA6ICdyYWRpb0dyb3VwJyxcbiAgcmVhZG9ubHk6ICdyZWFkT25seScsXG4gIHJlZmVycmVycG9saWN5OiAncmVmZXJyZXJQb2xpY3knLFxuICByZWw6ICdyZWwnLFxuICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgcmV2ZXJzZWQ6ICdyZXZlcnNlZCcsXG4gIHJvbGU6ICdyb2xlJyxcbiAgcm93czogJ3Jvd3MnLFxuICByb3dzcGFuOiAncm93U3BhbicsXG4gIHNhbmRib3g6ICdzYW5kYm94JyxcbiAgc2NvcGU6ICdzY29wZScsXG4gIHNjb3BlZDogJ3Njb3BlZCcsXG4gIHNjcm9sbGluZzogJ3Njcm9sbGluZycsXG4gIHNlYW1sZXNzOiAnc2VhbWxlc3MnLFxuICBzZWxlY3RlZDogJ3NlbGVjdGVkJyxcbiAgc2hhcGU6ICdzaGFwZScsXG4gIHNpemU6ICdzaXplJyxcbiAgc2l6ZXM6ICdzaXplcycsXG4gIHNwYW46ICdzcGFuJyxcbiAgc3BlbGxjaGVjazogJ3NwZWxsQ2hlY2snLFxuICBzcmM6ICdzcmMnLFxuICBzcmNkb2M6ICdzcmNEb2MnLFxuICBzcmNsYW5nOiAnc3JjTGFuZycsXG4gIHNyY3NldDogJ3NyY1NldCcsXG4gIHN0YXJ0OiAnc3RhcnQnLFxuICBzdGVwOiAnc3RlcCcsXG4gIHN0eWxlOiAnc3R5bGUnLFxuICBzdW1tYXJ5OiAnc3VtbWFyeScsXG4gIHRhYmluZGV4OiAndGFiSW5kZXgnLFxuICB0YXJnZXQ6ICd0YXJnZXQnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHlwZTogJ3R5cGUnLFxuICB1c2VtYXA6ICd1c2VNYXAnLFxuICB2YWx1ZTogJ3ZhbHVlJyxcbiAgd2lkdGg6ICd3aWR0aCcsXG4gIHdtb2RlOiAnd21vZGUnLFxuICB3cmFwOiAnd3JhcCcsXG5cbiAgLy8gU1ZHXG4gIGFib3V0OiAnYWJvdXQnLFxuICBhY2NlbnRoZWlnaHQ6ICdhY2NlbnRIZWlnaHQnLFxuICAnYWNjZW50LWhlaWdodCc6ICdhY2NlbnRIZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAnYWNjdW11bGF0ZScsXG4gIGFkZGl0aXZlOiAnYWRkaXRpdmUnLFxuICBhbGlnbm1lbnRiYXNlbGluZTogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gIGFsbG93cmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6ICdhbHBoYWJldGljJyxcbiAgYW1wbGl0dWRlOiAnYW1wbGl0dWRlJyxcbiAgYXJhYmljZm9ybTogJ2FyYWJpY0Zvcm0nLFxuICAnYXJhYmljLWZvcm0nOiAnYXJhYmljRm9ybScsXG4gIGFzY2VudDogJ2FzY2VudCcsXG4gIGF0dHJpYnV0ZW5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRldHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvcmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogJ2F6aW11dGgnLFxuICBiYXNlZnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VsaW5lc2hpZnQ6ICdiYXNlbGluZVNoaWZ0JyxcbiAgJ2Jhc2VsaW5lLXNoaWZ0JzogJ2Jhc2VsaW5lU2hpZnQnLFxuICBiYXNlcHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmJveDogJ2Jib3gnLFxuICBiZWdpbjogJ2JlZ2luJyxcbiAgYmlhczogJ2JpYXMnLFxuICBieTogJ2J5JyxcbiAgY2FsY21vZGU6ICdjYWxjTW9kZScsXG4gIGNhcGhlaWdodDogJ2NhcEhlaWdodCcsXG4gICdjYXAtaGVpZ2h0JzogJ2NhcEhlaWdodCcsXG4gIGNsaXA6ICdjbGlwJyxcbiAgY2xpcHBhdGg6ICdjbGlwUGF0aCcsXG4gICdjbGlwLXBhdGgnOiAnY2xpcFBhdGgnLFxuICBjbGlwcGF0aHVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNsaXBydWxlOiAnY2xpcFJ1bGUnLFxuICAnY2xpcC1ydWxlJzogJ2NsaXBSdWxlJyxcbiAgY29sb3I6ICdjb2xvcicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbjogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uJzogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnM6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyc6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgY29sb3Jwcm9maWxlOiAnY29sb3JQcm9maWxlJyxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAnY29sb3JQcm9maWxlJyxcbiAgY29sb3JyZW5kZXJpbmc6ICdjb2xvclJlbmRlcmluZycsXG4gICdjb2xvci1yZW5kZXJpbmcnOiAnY29sb3JSZW5kZXJpbmcnLFxuICBjb250ZW50c2NyaXB0dHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudHN0eWxldHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6ICdjdXJzb3InLFxuICBjeDogJ2N4JyxcbiAgY3k6ICdjeScsXG4gIGQ6ICdkJyxcbiAgZGF0YXR5cGU6ICdkYXRhdHlwZScsXG4gIGRlY2VsZXJhdGU6ICdkZWNlbGVyYXRlJyxcbiAgZGVzY2VudDogJ2Rlc2NlbnQnLFxuICBkaWZmdXNlY29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246ICdkaXJlY3Rpb24nLFxuICBkaXNwbGF5OiAnZGlzcGxheScsXG4gIGRpdmlzb3I6ICdkaXZpc29yJyxcbiAgZG9taW5hbnRiYXNlbGluZTogJ2RvbWluYW50QmFzZWxpbmUnLFxuICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnZG9taW5hbnRCYXNlbGluZScsXG4gIGR1cjogJ2R1cicsXG4gIGR4OiAnZHgnLFxuICBkeTogJ2R5JyxcbiAgZWRnZW1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogJ2VsZXZhdGlvbicsXG4gIGVuYWJsZWJhY2tncm91bmQ6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogJ2VuYWJsZUJhY2tncm91bmQnLFxuICBlbmQ6ICdlbmQnLFxuICBleHBvbmVudDogJ2V4cG9uZW50JyxcbiAgZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAnZmlsbCcsXG4gIGZpbGxvcGFjaXR5OiAnZmlsbE9wYWNpdHknLFxuICAnZmlsbC1vcGFjaXR5JzogJ2ZpbGxPcGFjaXR5JyxcbiAgZmlsbHJ1bGU6ICdmaWxsUnVsZScsXG4gICdmaWxsLXJ1bGUnOiAnZmlsbFJ1bGUnLFxuICBmaWx0ZXI6ICdmaWx0ZXInLFxuICBmaWx0ZXJyZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJ1bml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RvcGFjaXR5OiAnZmxvb2RPcGFjaXR5JyxcbiAgJ2Zsb29kLW9wYWNpdHknOiAnZmxvb2RPcGFjaXR5JyxcbiAgZmxvb2Rjb2xvcjogJ2Zsb29kQ29sb3InLFxuICAnZmxvb2QtY29sb3InOiAnZmxvb2RDb2xvcicsXG4gIGZvY3VzYWJsZTogJ2ZvY3VzYWJsZScsXG4gIGZvbnRmYW1pbHk6ICdmb250RmFtaWx5JyxcbiAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICBmb250c2l6ZTogJ2ZvbnRTaXplJyxcbiAgJ2ZvbnQtc2l6ZSc6ICdmb250U2l6ZScsXG4gIGZvbnRzaXplYWRqdXN0OiAnZm9udFNpemVBZGp1c3QnLFxuICAnZm9udC1zaXplLWFkanVzdCc6ICdmb250U2l6ZUFkanVzdCcsXG4gIGZvbnRzdHJldGNoOiAnZm9udFN0cmV0Y2gnLFxuICAnZm9udC1zdHJldGNoJzogJ2ZvbnRTdHJldGNoJyxcbiAgZm9udHN0eWxlOiAnZm9udFN0eWxlJyxcbiAgJ2ZvbnQtc3R5bGUnOiAnZm9udFN0eWxlJyxcbiAgZm9udHZhcmlhbnQ6ICdmb250VmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQnOiAnZm9udFZhcmlhbnQnLFxuICBmb250d2VpZ2h0OiAnZm9udFdlaWdodCcsXG4gICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgZm9ybWF0OiAnZm9ybWF0JyxcbiAgZnJvbTogJ2Zyb20nLFxuICBmeDogJ2Z4JyxcbiAgZnk6ICdmeScsXG4gIGcxOiAnZzEnLFxuICBnMjogJ2cyJyxcbiAgZ2x5cGhuYW1lOiAnZ2x5cGhOYW1lJyxcbiAgJ2dseXBoLW5hbWUnOiAnZ2x5cGhOYW1lJyxcbiAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJzogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gIGdseXBocmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudHRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnR1bml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAnaGFuZ2luZycsXG4gIGhvcml6YWR2eDogJ2hvcml6QWR2WCcsXG4gICdob3Jpei1hZHYteCc6ICdob3JpekFkdlgnLFxuICBob3Jpem9yaWdpbng6ICdob3Jpek9yaWdpblgnLFxuICAnaG9yaXotb3JpZ2luLXgnOiAnaG9yaXpPcmlnaW5YJyxcbiAgaWRlb2dyYXBoaWM6ICdpZGVvZ3JhcGhpYycsXG4gIGltYWdlcmVuZGVyaW5nOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgaW4yOiAnaW4yJyxcbiAgaW46ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gIHR5cGVvZjogJ3R5cGVvZicsXG4gIHUxOiAndTEnLFxuICB1MjogJ3UyJyxcbiAgdW5kZXJsaW5lcG9zaXRpb246ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gICd1bmRlcmxpbmUtcG9zaXRpb24nOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICB1bmRlcmxpbmV0aGlja25lc3M6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICAndW5kZXJsaW5lLXRoaWNrbmVzcyc6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICB1bmljb2RlOiAndW5pY29kZScsXG4gIHVuaWNvZGViaWRpOiAndW5pY29kZUJpZGknLFxuICAndW5pY29kZS1iaWRpJzogJ3VuaWNvZGVCaWRpJyxcbiAgdW5pY29kZXJhbmdlOiAndW5pY29kZVJhbmdlJyxcbiAgJ3VuaWNvZGUtcmFuZ2UnOiAndW5pY29kZVJhbmdlJyxcbiAgdW5pdHNwZXJlbTogJ3VuaXRzUGVyRW0nLFxuICAndW5pdHMtcGVyLWVtJzogJ3VuaXRzUGVyRW0nLFxuICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnLFxuICB2YWxwaGFiZXRpYzogJ3ZBbHBoYWJldGljJyxcbiAgJ3YtYWxwaGFiZXRpYyc6ICd2QWxwaGFiZXRpYycsXG4gIHZhbHVlczogJ3ZhbHVlcycsXG4gIHZlY3RvcmVmZmVjdDogJ3ZlY3RvckVmZmVjdCcsXG4gICd2ZWN0b3ItZWZmZWN0JzogJ3ZlY3RvckVmZmVjdCcsXG4gIHZlcnNpb246ICd2ZXJzaW9uJyxcbiAgdmVydGFkdnk6ICd2ZXJ0QWR2WScsXG4gICd2ZXJ0LWFkdi15JzogJ3ZlcnRBZHZZJyxcbiAgdmVydG9yaWdpbng6ICd2ZXJ0T3JpZ2luWCcsXG4gICd2ZXJ0LW9yaWdpbi14JzogJ3ZlcnRPcmlnaW5YJyxcbiAgdmVydG9yaWdpbnk6ICd2ZXJ0T3JpZ2luWScsXG4gICd2ZXJ0LW9yaWdpbi15JzogJ3ZlcnRPcmlnaW5ZJyxcbiAgdmhhbmdpbmc6ICd2SGFuZ2luZycsXG4gICd2LWhhbmdpbmcnOiAndkhhbmdpbmcnLFxuICB2aWRlb2dyYXBoaWM6ICd2SWRlb2dyYXBoaWMnLFxuICAndi1pZGVvZ3JhcGhpYyc6ICd2SWRlb2dyYXBoaWMnLFxuICB2aWV3Ym94OiAndmlld0JveCcsXG4gIHZpZXd0YXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogJ3Zpc2liaWxpdHknLFxuICB2bWF0aGVtYXRpY2FsOiAndk1hdGhlbWF0aWNhbCcsXG4gICd2LW1hdGhlbWF0aWNhbCc6ICd2TWF0aGVtYXRpY2FsJyxcbiAgdm9jYWI6ICd2b2NhYicsXG4gIHdpZHRoczogJ3dpZHRocycsXG4gIHdvcmRzcGFjaW5nOiAnd29yZFNwYWNpbmcnLFxuICAnd29yZC1zcGFjaW5nJzogJ3dvcmRTcGFjaW5nJyxcbiAgd3JpdGluZ21vZGU6ICd3cml0aW5nTW9kZScsXG4gICd3cml0aW5nLW1vZGUnOiAnd3JpdGluZ01vZGUnLFxuICB4MTogJ3gxJyxcbiAgeDI6ICd4MicsXG4gIHg6ICd4JyxcbiAgeGNoYW5uZWxzZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4aGVpZ2h0OiAneEhlaWdodCcsXG4gICd4LWhlaWdodCc6ICd4SGVpZ2h0JyxcbiAgeGxpbmthY3R1YXRlOiAneGxpbmtBY3R1YXRlJyxcbiAgJ3hsaW5rOmFjdHVhdGUnOiAneGxpbmtBY3R1YXRlJyxcbiAgeGxpbmthcmNyb2xlOiAneGxpbmtBcmNyb2xlJyxcbiAgJ3hsaW5rOmFyY3JvbGUnOiAneGxpbmtBcmNyb2xlJyxcbiAgeGxpbmtocmVmOiAneGxpbmtIcmVmJyxcbiAgJ3hsaW5rOmhyZWYnOiAneGxpbmtIcmVmJyxcbiAgeGxpbmtyb2xlOiAneGxpbmtSb2xlJyxcbiAgJ3hsaW5rOnJvbGUnOiAneGxpbmtSb2xlJyxcbiAgeGxpbmtzaG93OiAneGxpbmtTaG93JyxcbiAgJ3hsaW5rOnNob3cnOiAneGxpbmtTaG93JyxcbiAgeGxpbmt0aXRsZTogJ3hsaW5rVGl0bGUnLFxuICAneGxpbms6dGl0bGUnOiAneGxpbmtUaXRsZScsXG4gIHhsaW5rdHlwZTogJ3hsaW5rVHlwZScsXG4gICd4bGluazp0eXBlJzogJ3hsaW5rVHlwZScsXG4gIHhtbGJhc2U6ICd4bWxCYXNlJyxcbiAgJ3htbDpiYXNlJzogJ3htbEJhc2UnLFxuICB4bWxsYW5nOiAneG1sTGFuZycsXG4gICd4bWw6bGFuZyc6ICd4bWxMYW5nJyxcbiAgeG1sbnM6ICd4bWxucycsXG4gICd4bWw6c3BhY2UnOiAneG1sU3BhY2UnLFxuICB4bWxuc3hsaW5rOiAneG1sbnNYbGluaycsXG4gICd4bWxuczp4bGluayc6ICd4bWxuc1hsaW5rJyxcbiAgeG1sc3BhY2U6ICd4bWxTcGFjZScsXG4gIHkxOiAneTEnLFxuICB5MjogJ3kyJyxcbiAgeTogJ3knLFxuICB5Y2hhbm5lbHNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6ICd6JyxcbiAgem9vbWFuZHBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgYXJpYVByb3BlcnRpZXMgPSB7XG4gICdhcmlhLWN1cnJlbnQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1kZXRhaWxzJzogMCxcbiAgJ2FyaWEtZGlzYWJsZWQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1oaWRkZW4nOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1pbnZhbGlkJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgJ2FyaWEtbGFiZWwnOiAwLFxuICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiAwLFxuICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAnYXJpYS1hdXRvY29tcGxldGUnOiAwLFxuICAnYXJpYS1jaGVja2VkJzogMCxcbiAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAnYXJpYS1oYXNwb3B1cCc6IDAsXG4gICdhcmlhLWxldmVsJzogMCxcbiAgJ2FyaWEtbW9kYWwnOiAwLFxuICAnYXJpYS1tdWx0aWxpbmUnOiAwLFxuICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiAwLFxuICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICdhcmlhLXBsYWNlaG9sZGVyJzogMCxcbiAgJ2FyaWEtcHJlc3NlZCc6IDAsXG4gICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgJ2FyaWEtcmVxdWlyZWQnOiAwLFxuICAnYXJpYS1zZWxlY3RlZCc6IDAsXG4gICdhcmlhLXNvcnQnOiAwLFxuICAnYXJpYS12YWx1ZW1heCc6IDAsXG4gICdhcmlhLXZhbHVlbWluJzogMCxcbiAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAnYXJpYS12YWx1ZXRleHQnOiAwLFxuICAvLyBMaXZlIFJlZ2lvbiBBdHRyaWJ1dGVzXG4gICdhcmlhLWF0b21pYyc6IDAsXG4gICdhcmlhLWJ1c3knOiAwLFxuICAnYXJpYS1saXZlJzogMCxcbiAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtZHJvcGVmZmVjdCc6IDAsXG4gICdhcmlhLWdyYWJiZWQnOiAwLFxuICAvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogMCxcbiAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAnYXJpYS1jb2xpbmRleCc6IDAsXG4gICdhcmlhLWNvbHNwYW4nOiAwLFxuICAnYXJpYS1jb250cm9scyc6IDAsXG4gICdhcmlhLWRlc2NyaWJlZGJ5JzogMCxcbiAgJ2FyaWEtZXJyb3JtZXNzYWdlJzogMCxcbiAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgJ2FyaWEtbGFiZWxsZWRieSc6IDAsXG4gICdhcmlhLW93bnMnOiAwLFxuICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICdhcmlhLXJvd2NvdW50JzogMCxcbiAgJ2FyaWEtcm93aW5kZXgnOiAwLFxuICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgJ2FyaWEtc2V0c2l6ZSc6IDBcbn07XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciByQVJJQUNhbWVsID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG52YXIgaGFzT3duUHJvcGVydHkkMiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkkMi5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChyQVJJQUNhbWVsLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgYXJpYU5hbWUgPSAnYXJpYS0nICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbiAgICBpZiAoY29ycmVjdE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBBUklBIGF0dHJpYnV0ZXMgZm9sbG93IHRoZSBwYXR0ZXJuIGFyaWEtKiBhbmQgbXVzdCBiZSBsb3dlcmNhc2UuJywgbmFtZSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gY29ycmVjdE5hbWUpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgY29ycmVjdE5hbWUpO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAockFSSUEudGVzdChuYW1lKSkge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgc3RhbmRhcmROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBudWxsO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuICAgIGlmIChzdGFuZGFyZE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkodHlwZSwga2V5KTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gaW52YWxpZFByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuXG4gIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnSW52YWxpZCBhcmlhIHByb3AgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL2ludmFsaWQtYXJpYS1wcm9wJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcyk7XG59XG5cbnZhciBkaWRXYXJuVmFsdWVOdWxsID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKSB7XG4gIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgIGRpZFdhcm5WYWx1ZU51bGwgPSB0cnVlO1xuICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHZhbGlkYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzJDEgPSB7fTtcbiAgdmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBFVkVOVF9OQU1FX1JFR0VYID0gL15vbi4vO1xuICB2YXIgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYID0gL15vblteQS1aXS87XG4gIHZhciByQVJJQSQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG4gIHZhciByQVJJQUNhbWVsJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbiAgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuICcgKyAnQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCAnICsgJ2FyZSBub3QgbmVlZGVkL3N1cHBvcnRlZCBieSBSZWFjdC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBXZSBjYW4ndCByZWx5IG9uIHRoZSBldmVudCBzeXN0ZW0gYmVpbmcgaW5qZWN0ZWQgb24gdGhlIHNlcnZlci5cbiAgICBpZiAoY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJywgbmFtZSk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiAnICsgJ1JlYWN0IGV2ZW50cyB1c2UgdGhlIGNhbWVsQ2FzZSBuYW1pbmcgY29udmVudGlvbiwgZm9yIGV4YW1wbGUgYG9uQ2xpY2tgLicsIG5hbWUpO1xuICAgICAgfVxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIExldCB0aGUgQVJJQSBhdHRyaWJ1dGUgaG9vayB2YWxpZGF0ZSBBUklBIGF0dHJpYnV0ZXNcbiAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpbm5lcmh0bWwnKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnICsgJ1Bhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLicsIHR5cGVvZiB2YWx1ZSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCBuYW1lKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIHZhciBpc1Jlc2VydmVkID0gcHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDtcblxuICAgIC8vIEtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIG1hdGNoIHRoZSBjYXNpbmcgc3BlY2lmaWVkIGluIHRoZSBwcm9wZXJ0eSBjb25maWcuXG4gICAgaWYgKHBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbmFtZSkge1xuICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSAnICsgJ2ludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSAnICsgJ2F0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gJyArICdJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlICcgKyAnaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyAmJiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgbmFtZSwgbmFtZSk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcbiAgICBpZiAoaXNSZXNlcnZlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcbiAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFdhcm4gd2hlbiBwYXNzaW5nIHRoZSBzdHJpbmdzICdmYWxzZScgb3IgJ3RydWUnIGludG8gYSBib29sZWFuIHByb3BcbiAgICBpZiAoKHZhbHVlID09PSAnZmFsc2UnIHx8IHZhbHVlID09PSAndHJ1ZScpICYmIHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gQk9PTEVBTikge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnUmVjZWl2ZWQgdGhlIHN0cmluZyBgJXNgIGZvciB0aGUgYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC4gJyArICclcyAnICsgJ0RpZCB5b3UgbWVhbiAlcz17JXN9PycsIHZhbHVlLCBuYW1lLCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdUaGUgYnJvd3NlciB3aWxsIGludGVycHJldCBpdCBhcyBhIHRydXRoeSB2YWx1ZS4nIDogJ0FsdGhvdWdoIHRoaXMgd29ya3MsIGl0IHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQgaWYgeW91IHBhc3MgdGhlIHN0cmluZyBcImZhbHNlXCIuJywgbmFtZSwgdmFsdWUpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICB2YXIgdW5rbm93blByb3BzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgY2FuVXNlRXZlbnRTeXN0ZW0pO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG4gIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnSW52YWxpZCB2YWx1ZSBmb3IgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSBpdCBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgaXQgaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtYXR0cmlidXRlLWJlaGF2aW9yJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIHRoZW0gaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtYXR0cmlidXRlLWJlaGF2aW9yJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGNhblVzZUV2ZW50U3lzdGVtKTtcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gZmFsc2U7XG52YXIgZGlkV2FyblNoYWR5RE9NID0gZmFsc2U7XG5cbnZhciBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCA9ICdkYW5nZXJvdXNseVNldElubmVySFRNTCc7XG52YXIgU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HID0gJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc7XG52YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSA9ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnO1xudmFyIEFVVE9GT0NVUyA9ICdhdXRvRm9jdXMnO1xudmFyIENISUxEUkVOID0gJ2NoaWxkcmVuJztcbnZhciBTVFlMRSA9ICdzdHlsZSc7XG52YXIgSFRNTCA9ICdfX2h0bWwnO1xuXG52YXIgSFRNTF9OQU1FU1BBQ0UgPSBOYW1lc3BhY2VzLmh0bWw7XG5cblxudmFyIHdhcm5lZFVua25vd25UYWdzID0gdm9pZCAwO1xudmFyIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyA9IHZvaWQgMDtcblxudmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSB2b2lkIDA7XG52YXIgd2FybkZvclRleHREaWZmZXJlbmNlID0gdm9pZCAwO1xudmFyIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZSA9IHZvaWQgMDtcbnZhciB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gdm9pZCAwO1xudmFyIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IHZvaWQgMDtcbnZhciBjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nID0gdm9pZCAwO1xuXG52YXIgbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlID0gdm9pZCAwO1xudmFyIG5vcm1hbGl6ZUhUTUwgPSB2b2lkIDA7XG5cbntcbiAgd2FybmVkVW5rbm93blRhZ3MgPSB7XG4gICAgLy8gQ2hyb21lIGlzIHRoZSBvbmx5IG1ham9yIGJyb3dzZXIgbm90IHNoaXBwaW5nIDx0aW1lPi4gQnV0IGFzIG9mIEp1bHlcbiAgICAvLyAyMDE3IGl0IGludGVuZHMgdG8gc2hpcCBpdCBkdWUgdG8gd2lkZXNwcmVhZCB1c2FnZS4gV2UgaW50ZW50aW9uYWxseVxuICAgIC8vICpkb24ndCogd2FybiBmb3IgPHRpbWU+IGV2ZW4gaWYgaXQncyB1bnJlY29nbml6ZWQgYnkgQ2hyb21lIGJlY2F1c2VcbiAgICAvLyBpdCBzb29uIHdpbGwgYmUsIGFuZCBtYW55IGFwcHMgaGF2ZSBiZWVuIHVzaW5nIGl0IGFueXdheS5cbiAgICB0aW1lOiB0cnVlLFxuICAgIC8vIFRoZXJlIGFyZSB3b3JraW5nIHBvbHlmaWxscyBmb3IgPGRpYWxvZz4uIExldCBwZW9wbGUgdXNlIGl0LlxuICAgIGRpYWxvZzogdHJ1ZSxcbiAgICAvLyBFbGVjdHJvbiBzaGlwcyBhIGN1c3RvbSA8d2Vidmlldz4gdGFnIHRvIGRpc3BsYXkgZXh0ZXJuYWwgd2ViIGNvbnRlbnQgaW5cbiAgICAvLyBhbiBpc29sYXRlZCBmcmFtZSBhbmQgcHJvY2Vzcy5cbiAgICAvLyBUaGlzIHRhZyBpcyBub3QgcHJlc2VudCBpbiBub24gRWxlY3Ryb24gZW52aXJvbm1lbnRzIHN1Y2ggYXMgSlNEb20gd2hpY2hcbiAgICAvLyBpcyBvZnRlbiB1c2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICAgIC8vIEBzZWUgaHR0cHM6Ly9lbGVjdHJvbmpzLm9yZy9kb2NzL2FwaS93ZWJ2aWV3LXRhZ1xuICAgIHdlYnZpZXc6IHRydWVcbiAgfTtcblxuICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIC8qIGNhblVzZUV2ZW50U3lzdGVtICovdHJ1ZSk7XG4gIH07XG5cbiAgLy8gSUUgMTEgcGFyc2VzICYgbm9ybWFsaXplcyB0aGUgc3R5bGUgYXR0cmlidXRlIGFzIG9wcG9zZWQgdG8gb3RoZXJcbiAgLy8gYnJvd3NlcnMuIEl0IGFkZHMgc3BhY2VzIGFuZCBzb3J0cyB0aGUgcHJvcGVydGllcyBpbiBzb21lXG4gIC8vIG5vbi1hbHBoYWJldGljYWwgb3JkZXIuIEhhbmRsaW5nIHRoYXQgd291bGQgcmVxdWlyZSBzb3J0aW5nIENTU1xuICAvLyBwcm9wZXJ0aWVzIGluIHRoZSBjbGllbnQgJiBzZXJ2ZXIgdmVyc2lvbnMgb3IgYXBwbHlpbmdcbiAgLy8gYGV4cGVjdGVkU3R5bGVgIHRvIGEgdGVtcG9yYXJ5IERPTSBub2RlIHRvIHJlYWQgaXRzIGBzdHlsZWAgYXR0cmlidXRlXG4gIC8vIG5vcm1hbGl6ZWQuIFNpbmNlIGl0IG9ubHkgYWZmZWN0cyBJRSwgd2UncmUgc2tpcHBpbmcgc3R5bGUgd2FybmluZ3NcbiAgLy8gaW4gdGhhdCBicm93c2VyIGNvbXBsZXRlbHkgaW4gZmF2b3Igb2YgZG9pbmcgYWxsIHRoYXQgd29yay5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE4MDdcbiAgY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZyA9IGNhblVzZURPTSAmJiAhZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xuXG4gIC8vIEhUTUwgcGFyc2luZyBub3JtYWxpemVzIENSIGFuZCBDUkxGIHRvIExGLlxuICAvLyBJdCBhbHNvIGNhbiB0dXJuIFxcdTAwMDAgaW50byBcXHVGRkZEIGluc2lkZSBhdHRyaWJ1dGVzLlxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc2luZ2xlLXBhZ2UuaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgLy8gSWYgd2UgaGF2ZSBhIG1pc21hdGNoLCBpdCBtaWdodCBiZSBjYXVzZWQgYnkgdGhhdC5cbiAgLy8gV2Ugd2lsbCBzdGlsbCBwYXRjaCB1cCBpbiB0aGlzIGNhc2UgYnV0IG5vdCBmaXJlIHRoZSB3YXJuaW5nLlxuICB2YXIgTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYID0gL1xcclxcbj8vZztcbiAgdmFyIE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHUwMDAwfFxcdUZGRkQvZztcblxuICBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgdmFyIG1hcmt1cFN0cmluZyA9IHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnID8gbWFya3VwIDogJycgKyBtYXJrdXA7XG4gICAgcmV0dXJuIG1hcmt1cFN0cmluZy5yZXBsYWNlKE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCwgJ1xcbicpLnJlcGxhY2UoTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYLCAnJyk7XG4gIH07XG5cbiAgd2FybkZvclRleHREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHNlcnZlclRleHQsIGNsaWVudFRleHQpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFRleHQpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJUZXh0KTtcbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclRleHQgPT09IG5vcm1hbGl6ZWRDbGllbnRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCInLCBub3JtYWxpemVkU2VydmVyVGV4dCwgbm9ybWFsaXplZENsaWVudFRleHQpO1xuICB9O1xuXG4gIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgc2VydmVyVmFsdWUsIGNsaWVudFZhbHVlKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub3JtYWxpemVkQ2xpZW50VmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VmFsdWUpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVmFsdWUpO1xuICAgIGlmIChub3JtYWxpemVkU2VydmVyVmFsdWUgPT09IG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnUHJvcCBgJXNgIGRpZCBub3QgbWF0Y2guIFNlcnZlcjogJXMgQ2xpZW50OiAlcycsIHByb3BOYW1lLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VydmVyVmFsdWUpLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQ2xpZW50VmFsdWUpKTtcbiAgfTtcblxuICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBhdHRyaWJ1dGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBuYW1lcy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0V4dHJhIGF0dHJpYnV0ZXMgZnJvbSB0aGUgc2VydmVyOiAlcycsIG5hbWVzKTtcbiAgfTtcblxuICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAocmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIgPT09IGZhbHNlKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGBmYWxzZWAuXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS4nLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcblxuICAvLyBQYXJzZSB0aGUgSFRNTCBhbmQgcmVhZCBpdCBiYWNrIHRvIG5vcm1hbGl6ZSB0aGUgSFRNTCBzdHJpbmcgc28gdGhhdCBpdFxuICAvLyBjYW4gYmUgdXNlZCBmb3IgY29tcGFyaXNvbi5cbiAgbm9ybWFsaXplSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQsIGh0bWwpIHtcbiAgICAvLyBXZSBjb3VsZCBoYXZlIGNyZWF0ZWQgYSBzZXBhcmF0ZSBkb2N1bWVudCBoZXJlIHRvIGF2b2lkXG4gICAgLy8gcmUtaW5pdGlhbGl6aW5nIGN1c3RvbSBlbGVtZW50cyBpZiB0aGV5IGV4aXN0LiBCdXQgdGhpcyBicmVha3NcbiAgICAvLyBob3cgPG5vc2NyaXB0PiBpcyBiZWluZyBoYW5kbGVkLiBTbyB3ZSB1c2UgdGhlIHNhbWUgZG9jdW1lbnQuXG4gICAgLy8gU2VlIHRoZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExMTU3LlxuICAgIHZhciB0ZXN0RWxlbWVudCA9IHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFID8gcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChwYXJlbnQudGFnTmFtZSkgOiBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocGFyZW50Lm5hbWVzcGFjZVVSSSwgcGFyZW50LnRhZ05hbWUpO1xuICAgIHRlc3RFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIHRlc3RFbGVtZW50LmlubmVySFRNTDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGlzRG9jdW1lbnRPckZyYWdtZW50ID0gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG4gIHZhciBkb2MgPSBpc0RvY3VtZW50T3JGcmFnbWVudCA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHJldHVybiByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KG5vZGUpIHtcbiAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IG5vb3A7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIG5leHRIdG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBdm9pZCBzZXR0aW5nIGluaXRpYWwgdGV4dENvbnRlbnQgd2hlbiB0aGUgdGV4dCBpcyBlbXB0eS4gSW4gSUUxMSBzZXR0aW5nXG4gICAgICAgIC8vIHRleHRDb250ZW50IG9uIGEgPHRleHRhcmVhPiB3aWxsIGNhdXNlIHRoZSBwbGFjZWhvbGRlciB0byBub3RcbiAgICAgICAgLy8gc2hvdyB3aXRoaW4gdGhlIDx0ZXh0YXJlYT4gdW50aWwgaXQgaGFzIGJlZW4gZm9jdXNlZCBhbmQgYmx1cnJlZCBhZ2Fpbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy82NzMxI2lzc3VlY29tbWVudC0yNTQ4NzQ1NTNcbiAgICAgICAgdmFyIGNhblNldFRleHRDb250ZW50ID0gdGFnICE9PSAndGV4dGFyZWEnIHx8IG5leHRQcm9wICE9PSAnJztcbiAgICAgICAgaWYgKGNhblNldFRleHRDb250ZW50KSB7XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQVVUT0ZPQ1VTKSB7XG4gICAgICAvLyBXZSBwb2x5ZmlsbCBpdCBzZXBhcmF0ZWx5IG9uIHRoZSBjbGllbnQgZHVyaW5nIGNvbW1pdC5cbiAgICAgIC8vIFdlIGNvdWxkIGhhdmUgZXhjbHVkZWQgaXQgaW4gdGhlIHByb3BlcnR5IGxpc3QgaW5zdGVhZCBvZlxuICAgICAgLy8gYWRkaW5nIGEgc3BlY2lhbCBjYXNlIGhlcmUsIGJ1dCB0aGVuIGl0IHdvdWxkbid0IGJlIGVtaXR0ZWRcbiAgICAgIC8vIG9uIHNlcnZlciByZW5kZXJpbmcgKGJ1dCB3ZSAqZG8qIHdhbnQgdG8gZW1pdCBpdCBpbiBTU1IpLlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCwgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgLy8gVE9ETzogSGFuZGxlIHdhc0N1c3RvbUNvbXBvbmVudFRhZ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZVBheWxvYWQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgcHJvcEtleSA9IHVwZGF0ZVBheWxvYWRbaV07XG4gICAgdmFyIHByb3BWYWx1ZSA9IHVwZGF0ZVBheWxvYWRbaSArIDFdO1xuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIHByb3BWYWx1ZSwgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCByb290Q29udGFpbmVyRWxlbWVudCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IHZvaWQgMDtcblxuICAvLyBXZSBjcmVhdGUgdGFncyBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoZWlyIHBhcmVudCBjb250YWluZXIsIGV4Y2VwdCBIVE1MXG4gIC8vIHRhZ3MgZ2V0IG5vIG5hbWVzcGFjZS5cbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICB2YXIgZG9tRWxlbWVudCA9IHZvaWQgMDtcbiAgdmFyIG5hbWVzcGFjZVVSSSA9IHBhcmVudE5hbWVzcGFjZTtcbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICBuYW1lc3BhY2VVUkkgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICB7XG4gICAgICBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKTtcbiAgICAgIC8vIFNob3VsZCB0aGlzIGNoZWNrIGJlIGdhdGVkIGJ5IHBhcmVudCBuYW1lc3BhY2U/IE5vdCBzdXJlIHdlIHdhbnQgdG9cbiAgICAgIC8vIGFsbG93IDxTVkc+IG9yIDxtQVRIPi5cbiAgICAgICEoaXNDdXN0b21Db21wb25lbnRUYWcgfHwgdHlwZSA9PT0gdHlwZS50b0xvd2VyQ2FzZSgpKSA/IHdhcm5pbmckMShmYWxzZSwgJzwlcyAvPiBpcyB1c2luZyBpbmNvcnJlY3QgY2FzaW5nLiAnICsgJ1VzZSBQYXNjYWxDYXNlIGZvciBSZWFjdCBjb21wb25lbnRzLCAnICsgJ29yIGxvd2VyY2FzZSBmb3IgSFRNTCBlbGVtZW50cy4nLCB0eXBlKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgIC8vIENyZWF0ZSB0aGUgc2NyaXB0IHZpYSAuaW5uZXJIVE1MIHNvIGl0cyBcInBhcnNlci1pbnNlcnRlZFwiIGZsYWcgaXNcbiAgICAgIC8vIHNldCB0byB0cnVlIGFuZCBpdCBkb2VzIG5vdCBleGVjdXRlXG4gICAgICB2YXIgZGl2ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpdi5pbm5lckhUTUwgPSAnPHNjcmlwdD48JyArICcvc2NyaXB0Pic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8vIFRoaXMgaXMgZ3VhcmFudGVlZCB0byB5aWVsZCBhIHNjcmlwdCBlbGVtZW50LlxuICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBkaXYuZmlyc3RDaGlsZDtcbiAgICAgIGRvbUVsZW1lbnQgPSBkaXYucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyAkRmxvd0lzc3VlIGBjcmVhdGVFbGVtZW50YCBzaG91bGQgYmUgdXBkYXRlZCBmb3IgV2ViIENvbXBvbmVudHNcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSwgeyBpczogcHJvcHMuaXMgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjYXVzZSBvZiBhIEZpcmVmb3ggYnVnLlxuICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNjg5NlxuICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICAgIC8vIE5vcm1hbGx5IGF0dHJpYnV0ZXMgYXJlIGFzc2lnbmVkIGluIGBzZXRJbml0aWFsRE9NUHJvcGVydGllc2AsIGhvd2V2ZXIgdGhlIGBtdWx0aXBsZWBcbiAgICAgIC8vIGF0dHJpYnV0ZSBvbiBgc2VsZWN0YHMgbmVlZHMgdG8gYmUgYWRkZWQgYmVmb3JlIGBvcHRpb25gcyBhcmUgaW5zZXJ0ZWQuIFRoaXMgcHJldmVudHNcbiAgICAgIC8vIGEgYnVnIHdoZXJlIHRoZSBgc2VsZWN0YCBkb2VzIG5vdCBzY3JvbGwgdG8gdGhlIGNvcnJlY3Qgb3B0aW9uIGJlY2F1c2Ugc2luZ3VsYXJcbiAgICAgIC8vIGBzZWxlY3RgIGVsZW1lbnRzIGF1dG9tYXRpY2FsbHkgcGljayB0aGUgZmlyc3QgaXRlbS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMjIyXG4gICAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMubXVsdGlwbGUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBkb21FbGVtZW50O1xuICAgICAgICBub2RlLm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdHlwZSk7XG4gIH1cblxuICB7XG4gICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIGlmICghaXNDdXN0b21Db21wb25lbnRUYWcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvbUVsZW1lbnQpID09PSAnW29iamVjdCBIVE1MVW5rbm93bkVsZW1lbnRdJyAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFVua25vd25UYWdzLCB0eXBlKSkge1xuICAgICAgICB3YXJuZWRVbmtub3duVGFnc1t0eXBlXSA9IHRydWU7XG4gICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1RoZSB0YWcgPCVzPiBpcyB1bnJlY29nbml6ZWQgaW4gdGhpcyBicm93c2VyLiAnICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBSZWFjdCBjb21wb25lbnQsIHN0YXJ0IGl0cyBuYW1lIHdpdGggJyArICdhbiB1cHBlcmNhc2UgbGV0dGVyLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkb21FbGVtZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSh0ZXh0LCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KS5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbn1cblxuZnVuY3Rpb24gc2V0SW5pdGlhbFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICclcyBpcyB1c2luZyBzaGFkeSBET00uIFVzaW5nIHNoYWR5IERPTSB3aXRoIFJlYWN0IGNhbiAnICsgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgdmFyIHByb3BzID0gdm9pZCAwO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0xPQUQsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWFFdmVudFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyYXBCdWJibGVkRXZlbnQobWVkaWFFdmVudFR5cGVzW2ldLCBkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfRVJST1IsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfRVJST1IsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfTE9BRCwgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9SRVNFVCwgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9TVUJNSVQsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfVE9HR0xFLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0lOVkFMSUQsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0lOVkFMSUQsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0lOVkFMSUQsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzKTtcblxuICBzZXRJbml0aWFsRE9NUHJvcGVydGllcyh0YWcsIGRvbUVsZW1lbnQsIHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcywgZmFsc2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuLy8gQ2FsY3VsYXRlIHRoZSBkaWZmIGJldHdlZW4gdGhlIHR3byBvYmplY3RzLlxuZnVuY3Rpb24gZGlmZlByb3BlcnRpZXMoZG9tRWxlbWVudCwgdGFnLCBsYXN0UmF3UHJvcHMsIG5leHRSYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCBuZXh0UmF3UHJvcHMpO1xuICB9XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuXG4gIHZhciBsYXN0UHJvcHMgPSB2b2lkIDA7XG4gIHZhciBuZXh0UHJvcHMgPSB2b2lkIDA7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGxhc3RQcm9wcyA9IGxhc3RSYXdQcm9wcztcbiAgICAgIG5leHRQcm9wcyA9IG5leHRSYXdQcm9wcztcbiAgICAgIGlmICh0eXBlb2YgbGFzdFByb3BzLm9uQ2xpY2sgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG5leHRQcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cblxuICBhc3NlcnRWYWxpZFByb3BzKHRhZywgbmV4dFByb3BzKTtcblxuICB2YXIgcHJvcEtleSA9IHZvaWQgMDtcbiAgdmFyIHN0eWxlTmFtZSA9IHZvaWQgMDtcbiAgdmFyIHN0eWxlVXBkYXRlcyA9IG51bGw7XG4gIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbGFzdFByb3BzW3Byb3BLZXldID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHZhciBsYXN0U3R5bGUgPSBsYXN0UHJvcHNbcHJvcEtleV07XG4gICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCB8fCBwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gTm9vcC4gVGhpcyBpcyBoYW5kbGVkIGJ5IHRoZSBjbGVhciB0ZXh0IG1lY2hhbmlzbS5cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBBVVRPRk9DVVMpIHtcbiAgICAgIC8vIE5vb3AuIEl0IGRvZXNuJ3Qgd29yayBvbiB1cGRhdGVzIGFueXdheS5cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgZmliZXIgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbGwgb3RoZXIgZGVsZXRlZCBwcm9wZXJ0aWVzIHdlIGFkZCBpdCB0byB0aGUgcXVldWUuIFdlIHVzZVxuICAgICAgLy8gdGhlIHdoaXRlbGlzdCBpbiB0aGUgY29tbWl0IHBoYXNlIGluc3RlYWQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbnVsbCk7XG4gICAgfVxuICB9XG4gIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgdmFyIGxhc3RQcm9wID0gbGFzdFByb3BzICE9IG51bGwgPyBsYXN0UHJvcHNbcHJvcEtleV0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkLnB1c2gocHJvcEtleSwgc3R5bGVVcGRhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3AgPyBsYXN0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0SHRtbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IEl0IG1pZ2h0IGJlIHRvbyBsYXRlIHRvIGNsZWFyIHRoaXMgaWYgd2UgaGF2ZSBjaGlsZHJlblxuICAgICAgICAvLyBpbnNlcnRlZCBhbHJlYWR5LlxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmIChsYXN0UHJvcCAhPT0gbmV4dFByb3AgJiYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBlYWdlcmx5IGxpc3RlbiB0byB0aGlzIGV2ZW4gdGhvdWdoIHdlIGhhdmVuJ3QgY29tbWl0dGVkIHlldC5cbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgICBpZiAoIXVwZGF0ZVBheWxvYWQgJiYgbGFzdFByb3AgIT09IG5leHRQcm9wKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAgIC8vIHRoYXQgdGhlIFwiY3VycmVudFwiIHByb3BzIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbiAgICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYW55IG90aGVyIHByb3BlcnR5IHdlIGFsd2F5cyBhZGQgaXQgdG8gdGhlIHF1ZXVlIGFuZCB0aGVuIHdlXG4gICAgICAvLyBmaWx0ZXIgaXQgb3V0IHVzaW5nIHRoZSB3aGl0ZWxpc3QgZHVyaW5nIHRoZSBjb21taXQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH1cbiAgfVxuICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKFNUWUxFLCBzdHlsZVVwZGF0ZXMpO1xuICB9XG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufVxuXG4vLyBBcHBseSB0aGUgZGlmZi5cbmZ1bmN0aW9uIHVwZGF0ZVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdGFnLCBsYXN0UmF3UHJvcHMsIG5leHRSYXdQcm9wcykge1xuICAvLyBVcGRhdGUgY2hlY2tlZCAqYmVmb3JlKiBuYW1lLlxuICAvLyBJbiB0aGUgbWlkZGxlIG9mIGFuIHVwZGF0ZSwgaXQgaXMgcG9zc2libGUgdG8gaGF2ZSBtdWx0aXBsZSBjaGVja2VkLlxuICAvLyBXaGVuIGEgY2hlY2tlZCByYWRpbyB0cmllcyB0byBjaGFuZ2UgbmFtZSwgYnJvd3NlciBtYWtlcyBhbm90aGVyIHJhZGlvJ3MgY2hlY2tlZCBmYWxzZS5cbiAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiBuZXh0UmF3UHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuZXh0UmF3UHJvcHMubmFtZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlQ2hlY2tlZChkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICB9XG5cbiAgdmFyIHdhc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgbGFzdFJhd1Byb3BzKTtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCBuZXh0UmF3UHJvcHMpO1xuICAvLyBBcHBseSB0aGUgZGlmZi5cbiAgdXBkYXRlRE9NUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB3YXNDdXN0b21Db21wb25lbnRUYWcsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcblxuICAvLyBUT0RPOiBFbnN1cmUgdGhhdCBhbiB1cGRhdGUgZ2V0cyBzY2hlZHVsZWQgaWYgYW55IG9mIHRoZSBzcGVjaWFsIHByb3BzXG4gIC8vIGNoYW5nZWQuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVyIGFyb3VuZCBpbnB1dHMgKmFmdGVyKiB1cGRhdGluZyBwcm9wcy4gVGhpcyBoYXMgdG9cbiAgICAgIC8vIGhhcHBlbiBhZnRlciBgdXBkYXRlRE9NUHJvcGVydGllc2AuIE90aGVyd2lzZSBIVE1MNSBpbnB1dCB2YWxpZGF0aW9uc1xuICAgICAgLy8gcmFpc2Ugd2FybmluZ3MgYW5kIHByZXZlbnQgdGhlIG5ldyB2YWx1ZSBmcm9tIGJlaW5nIGFzc2lnbmVkLlxuICAgICAgdXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgdXBkYXRlV3JhcHBlciQxKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgLy8gPHNlbGVjdD4gdmFsdWUgdXBkYXRlIG5lZWRzIHRvIG9jY3VyIGFmdGVyIDxvcHRpb24+IGNoaWxkcmVuXG4gICAgICAvLyByZWNvbmNpbGlhdGlvblxuICAgICAgcG9zdFVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBvc3NpYmxlU3RhbmRhcmROYW1lKHByb3BOYW1lKSB7XG4gIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghcG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdIHx8IG51bGw7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcGFyZW50TmFtZXNwYWNlLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSB2b2lkIDA7XG4gIHZhciBleHRyYUF0dHJpYnV0ZU5hbWVzID0gdm9pZCAwO1xuXG4gIHtcbiAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgPSByYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSA9PT0gdHJ1ZTtcbiAgICBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJyVzIGlzIHVzaW5nIHNoYWR5IERPTS4gVXNpbmcgc2hhZHkgRE9NIHdpdGggUmVhY3QgY2FuICcgKyAnY2F1c2UgdGhpbmdzIHRvIGJyZWFrIHN1YnRseS4nLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgZGlkV2FyblNoYWR5RE9NID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBNYWtlIHN1cmUgdGhhdCB3ZSBjaGVjayBpc01vdW50ZWQgYmVmb3JlIGZpcmluZyBhbnkgb2YgdGhlc2UgZXZlbnRzLlxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0xPQUQsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIC8vIENyZWF0ZSBsaXN0ZW5lciBmb3IgZWFjaCBtZWRpYSBldmVudFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWRpYUV2ZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChtZWRpYUV2ZW50VHlwZXNbaV0sIGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0VSUk9SLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfRVJST1IsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfTE9BRCwgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmb3JtJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX1JFU0VULCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX1NVQk1JVCwgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX1RPR0dMRSwgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0lOVkFMSUQsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfSU5WQUxJRCwgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0lOVkFMSUQsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHJhd1Byb3BzKTtcblxuICB7XG4gICAgZXh0cmFBdHRyaWJ1dGVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXR0cmlidXRlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlc1tfaV0ubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIC8vIEJ1aWx0LWluIFNTUiBhdHRyaWJ1dGUgaXMgd2hpdGVsaXN0ZWRcbiAgICAgICAgY2FzZSAnZGF0YS1yZWFjdHJvb3QnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgICAgLy8gVE9ETzogT25seSBpZ25vcmUgdGhlbSBvbiBjb250cm9sbGVkIHRhZ3MuXG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlbGVjdGVkJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBJbnRlbnRpb25hbGx5IHVzZSB0aGUgb3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAvLyBTZWUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMDY3Ni5cbiAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmFkZChhdHRyaWJ1dGVzW19pXS5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlUGF5bG9hZCA9IG51bGw7XG4gIGZvciAodmFyIHByb3BLZXkgaW4gcmF3UHJvcHMpIHtcbiAgICBpZiAoIXJhd1Byb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wID0gcmF3UHJvcHNbcHJvcEtleV07XG4gICAgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAvLyBGb3IgdGV4dCBjb250ZW50IGNoaWxkcmVuIHdlIGNvbXBhcmUgYWdhaW5zdCB0ZXh0Q29udGVudC4gVGhpc1xuICAgICAgLy8gbWlnaHQgbWF0Y2ggYWRkaXRpb25hbCBIVE1MIHRoYXQgaXMgaGlkZGVuIHdoZW4gd2UgcmVhZCBpdCB1c2luZ1xuICAgICAgLy8gdGV4dENvbnRlbnQuIEUuZy4gXCJmb29cIiB3aWxsIG1hdGNoIFwiZjxzcGFuPm9vPC9zcGFuPlwiIGJ1dCB0aGF0IHN0aWxsXG4gICAgICAvLyBzYXRpc2ZpZXMgb3VyIHJlcXVpcmVtZW50LiBPdXIgcmVxdWlyZW1lbnQgaXMgbm90IHRvIHByb2R1Y2UgcGVyZmVjdFxuICAgICAgLy8gSFRNTCBhbmQgYXR0cmlidXRlcy4gSWRlYWxseSB3ZSBzaG91bGQgcHJlc2VydmUgc3RydWN0dXJlIGJ1dCBpdCdzXG4gICAgICAvLyBvayBub3QgdG8gaWYgdGhlIHZpc2libGUgY29udGVudCBpcyBzdGlsbCBlbm91Z2ggdG8gaW5kaWNhdGUgd2hhdFxuICAgICAgLy8gZXZlbiBsaXN0ZW5lcnMgdGhlc2Ugbm9kZXMgbWlnaHQgYmUgd2lyZWQgdXAgdG8uXG4gICAgICAvLyBUT0RPOiBXYXJuIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBhIHNpbmdsZSB0ZXh0Tm9kZSBhcyBhIGNoaWxkLlxuICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIHVzZSBkb21FbGVtZW50LmZpcnN0Q2hpbGQubm9kZVZhbHVlIHRvIGNvbXBhcmU/XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAodHJ1ZSAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gJycgKyBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICh0cnVlICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZShkb21FbGVtZW50LnRleHRDb250ZW50LCBuZXh0UHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbQ0hJTERSRU4sICcnICsgbmV4dFByb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0cnVlICYmXG4gICAgLy8gQ29udmluY2UgRmxvdyB3ZSd2ZSBjYWxjdWxhdGVkIGl0IChpdCdzIERFVi1vbmx5IGluIHRoaXMgbWV0aG9kLilcbiAgICB0eXBlb2YgaXNDdXN0b21Db21wb25lbnRUYWcgPT09ICdib29sZWFuJykge1xuICAgICAgLy8gVmFsaWRhdGUgdGhhdCB0aGUgcHJvcGVydGllcyBjb3JyZXNwb25kIHRvIHRoZWlyIGV4cGVjdGVkIHZhbHVlcy5cbiAgICAgIHZhciBzZXJ2ZXJWYWx1ZSA9IHZvaWQgMDtcbiAgICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8ocHJvcEtleSk7XG4gICAgICBpZiAoc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcuIFdlJ3JlIGlnbm9yaW5nIGFsbCB0aGVzZSB3YXJuaW5ncy5cbiAgICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEgfHxcbiAgICAgIC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgLy8gVE9ETzogT25seSBpZ25vcmUgdGhlbSBvbiBjb250cm9sbGVkIHRhZ3MuXG4gICAgICBwcm9wS2V5ID09PSAndmFsdWUnIHx8IHByb3BLZXkgPT09ICdjaGVja2VkJyB8fCBwcm9wS2V5ID09PSAnc2VsZWN0ZWQnKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgICAgdmFyIHNlcnZlckhUTUwgPSBkb21FbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGV4cGVjdGVkSFRNTCA9IG5vcm1hbGl6ZUhUTUwoZG9tRWxlbWVudCwgbmV4dEh0bWwgIT0gbnVsbCA/IG5leHRIdG1sIDogJycpO1xuICAgICAgICBpZiAoZXhwZWN0ZWRIVE1MICE9PSBzZXJ2ZXJIVE1MKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlckhUTUwsIGV4cGVjdGVkSFRNTCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wS2V5KTtcblxuICAgICAgICBpZiAoY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgIHZhciBleHBlY3RlZFN0eWxlID0gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKG5leHRQcm9wKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgIGlmIChleHBlY3RlZFN0eWxlICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBleHBlY3RlZFN0eWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXNob3VsZElnbm9yZUF0dHJpYnV0ZShwcm9wS2V5LCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSAmJiAhc2hvdWxkUmVtb3ZlQXR0cmlidXRlKHByb3BLZXksIG5leHRQcm9wLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgICAgICB2YXIgaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCwgcHJvcGVydHlJbmZvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3duTmFtZXNwYWNlID0gcGFyZW50TmFtZXNwYWNlO1xuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICBvd25OYW1lc3BhY2UgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodGFnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZShwcm9wS2V5KTtcbiAgICAgICAgICAgIGlmIChzdGFuZGFyZE5hbWUgIT09IG51bGwgJiYgc3RhbmRhcmROYW1lICE9PSBwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIC8vIElmIGFuIFNWRyBwcm9wIGlzIHN1cHBsaWVkIHdpdGggYmFkIGNhc2luZywgaXQgd2lsbFxuICAgICAgICAgICAgICAvLyBiZSBzdWNjZXNzZnVsbHkgcGFyc2VkIGZyb20gSFRNTCwgYnV0IHdpbGwgcHJvZHVjZSBhIG1pc21hdGNoXG4gICAgICAgICAgICAgIC8vIChhbmQgd291bGQgYmUgaW5jb3JyZWN0bHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCkuXG4gICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHdlIGFscmVhZHkgd2FybiBhYm91dCBiYWQgY2FzaW5nIGVsc2V3aGVyZS5cbiAgICAgICAgICAgICAgLy8gU28gd2UnbGwgc2tpcCB0aGUgbWlzbGVhZGluZyBleHRyYSBtaXNtYXRjaCB3YXJuaW5nIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgICAgaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShzdGFuZGFyZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSAmJiAhaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgIGlmIChleHRyYUF0dHJpYnV0ZU5hbWVzLnNpemUgPiAwICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMoZXh0cmFBdHRyaWJ1dGVOYW1lcyk7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzLCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAvLyBGb3IgaW5wdXQgYW5kIHRleHRhcmVhIHdlIGN1cnJlbnQgYWx3YXlzIHNldCB0aGUgdmFsdWUgcHJvcGVydHkgYXRcbiAgICAgIC8vIHBvc3QgbW91bnQgdG8gZm9yY2UgaXQgdG8gZGl2ZXJnZSBmcm9tIGF0dHJpYnV0ZXMuIEhvd2V2ZXIsIGZvclxuICAgICAgLy8gb3B0aW9uIGFuZCBzZWxlY3Qgd2UgZG9uJ3QgcXVpdGUgZG8gdGhlIHNhbWUgdGhpbmcgYW5kIHNlbGVjdFxuICAgICAgLy8gaXMgbm90IHJlc2lsaWVudCB0byB0aGUgRE9NIHN0YXRlIGNoYW5naW5nIHNvIHdlIGRvbid0IGRvIHRoYXQgaGVyZS5cbiAgICAgIC8vIFRPRE86IENvbnNpZGVyIG5vdCBkb2luZyB0aGlzIGZvciBpbnB1dCBhbmQgdGV4dGFyZWEuXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiByYXdQcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlUGF5bG9hZDtcbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkVGV4dCh0ZXh0Tm9kZSwgdGV4dCkge1xuICB2YXIgaXNEaWZmZXJlbnQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWUgIT09IHRleHQ7XG4gIHJldHVybiBpc0RpZmZlcmVudDtcbn1cblxuZnVuY3Rpb24gd2FybkZvclVubWF0Y2hlZFRleHQodGV4dE5vZGUsIHRleHQpIHtcbiAge1xuICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZSh0ZXh0Tm9kZS5ub2RlVmFsdWUsIHRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnRGlkIG5vdCBleHBlY3Qgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIDwlcz4gaW4gPCVzPi4nLCBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnRGlkIG5vdCBleHBlY3Qgc2VydmVyIEhUTUwgdG8gY29udGFpbiB0aGUgdGV4dCBub2RlIFwiJXNcIiBpbiA8JXM+LicsIGNoaWxkLm5vZGVWYWx1ZSwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Tm9kZSwgdGFnLCBwcm9wcykge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdFeHBlY3RlZCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgbWF0Y2hpbmcgPCVzPiBpbiA8JXM+LicsIHRhZywgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAvLyBXZSBleHBlY3QgdG8gaW5zZXJ0IGVtcHR5IHRleHQgbm9kZXMgc2luY2UgdGhleSdyZSBub3QgcmVwcmVzZW50ZWQgaW5cbiAgICAgIC8vIHRoZSBIVE1MLlxuICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGlmIHdlIGNhbiBqdXN0IGF2b2lkIGluc2VydGluZyBlbXB0eVxuICAgICAgLy8gdGV4dCBub2Rlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdFeHBlY3RlZCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgbWF0Y2hpbmcgdGV4dCBub2RlIGZvciBcIiVzXCIgaW4gPCVzPi4nLCB0ZXh0LCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMShkb21FbGVtZW50LCB0YWcsIHByb3BzKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQyKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgfVxufVxuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKCkge307XG52YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJyxcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNodG1sLWludGVncmF0aW9uLXBvaW50XG4gIC8vIFRPRE86IERpc3Rpbmd1aXNoIGJ5IG5hbWVzcGFjZSBoZXJlIC0tIGZvciA8dGl0bGU+LCBpbmNsdWRpbmcgaXQgaGVyZVxuICAvLyBlcnJzIG9uIHRoZSBzaWRlIG9mIGZld2VyIHdhcm5pbmdzXG4gICdmb3JlaWduT2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1idXR0b24tc2NvcGVcbiAgdmFyIGJ1dHRvblNjb3BlVGFncyA9IGluU2NvcGVUYWdzLmNvbmNhdChbJ2J1dHRvbiddKTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG4gIHZhciBpbXBsaWVkRW5kVGFncyA9IFsnZGQnLCAnZHQnLCAnbGknLCAnb3B0aW9uJywgJ29wdGdyb3VwJywgJ3AnLCAncnAnLCAncnQnXTtcblxuICB2YXIgZW1wdHlBbmNlc3RvckluZm8gPSB7XG4gICAgY3VycmVudDogbnVsbCxcblxuICAgIGZvcm1UYWc6IG51bGwsXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICBub2JyVGFnSW5TY29wZTogbnVsbCxcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcblxuICAgIGxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGwsXG4gICAgZGxJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGxcbiAgfTtcblxuICB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZykge1xuICAgIHZhciBhbmNlc3RvckluZm8gPSBfYXNzaWduKHt9LCBvbGRJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW5mbyA9IHsgdGFnOiB0YWcgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknO1xuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH1cblxuICAgIC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgY2FzZSAnaHInOlxuICAgICAgY2FzZSAneG1wJzpcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2xpJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdkZCc6XG4gICAgICBjYXNlICdkdCc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoaXMgY2hlY2suXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ25vYnInOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZFRleHQsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgaWYgKGNoaWxkVGV4dCAhPSBudWxsKSB7XG4gICAgICAhKGNoaWxkVGFnID09IG51bGwpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nOiB3aGVuIGNoaWxkVGV4dCBpcyBwYXNzZWQsIGNoaWxkVGFnIHNob3VsZCBiZSBudWxsJykgOiB2b2lkIDA7XG4gICAgICBjaGlsZFRhZyA9ICcjdGV4dCc7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGludmFsaWRQYXJlbnRPckFuY2VzdG9yID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG4gICAgaWYgKCFpbnZhbGlkUGFyZW50T3JBbmNlc3Rvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhbmNlc3RvclRhZyA9IGludmFsaWRQYXJlbnRPckFuY2VzdG9yLnRhZztcbiAgICB2YXIgYWRkZW5kdW0gPSBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCk7XG5cbiAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBhZGRlbmR1bTtcbiAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuICAgIGlmIChjaGlsZFRhZyA9PT0gJyN0ZXh0Jykge1xuICAgICAgaWYgKC9cXFMvLnRlc3QoY2hpbGRUZXh0KSkge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdUZXh0IG5vZGVzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1doaXRlc3BhY2UgdGV4dCBub2Rlcyc7XG4gICAgICAgIHdoaXRlc3BhY2VJbmZvID0gXCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIiArICdlYWNoIGxpbmUgb2YgeW91ciBzb3VyY2UgY29kZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgIH1cblxuICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgIH1cbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgY2hpbGQgb2YgPCVzPi4lcyVzJXMnLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIHdoaXRlc3BhY2VJbmZvLCBpbmZvLCBhZGRlbmR1bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgZGVzY2VuZGFudCBvZiAnICsgJzwlcz4uJXMnLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIGFkZGVuZHVtKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIFJlbmRlcmVycyB0aGF0IGRvbid0IHN1cHBvcnQgcGVyc2lzdGVuY2Vcbi8vIGNhbiByZS1leHBvcnQgZXZlcnl0aGluZyBmcm9tIHRoaXMgbW9kdWxlLlxuXG5mdW5jdGlvbiBzaGltKCkge1xuICBpbnZhcmlhbnQoZmFsc2UsICdUaGUgY3VycmVudCByZW5kZXJlciBkb2VzIG5vdCBzdXBwb3J0IHBlcnNpc3RlbmNlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xufVxuXG4vLyBQZXJzaXN0ZW5jZSAod2hlbiB1bnN1cHBvcnRlZClcbnZhciBzdXBwb3J0c1BlcnNpc3RlbmNlID0gZmFsc2U7XG52YXIgY2xvbmVJbnN0YW5jZSA9IHNoaW07XG52YXIgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQgPSBzaGltO1xudmFyIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCA9IHNoaW07XG52YXIgZmluYWxpemVDb250YWluZXJDaGlsZHJlbiA9IHNoaW07XG52YXIgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuID0gc2hpbTtcblxudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HID0gdm9pZCAwO1xue1xuICBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyA9ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnO1xufVxuXG52YXIgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG52YXIgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuXG5mdW5jdGlvbiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgcmV0dXJuICEhcHJvcHMuYXV0b0ZvY3VzO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250ZXh0KHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICB2YXIgdHlwZSA9IHZvaWQgMDtcbiAgdmFyIG5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgdmFyIG5vZGVUeXBlID0gcm9vdENvbnRhaW5lckluc3RhbmNlLm5vZGVUeXBlO1xuICBzd2l0Y2ggKG5vZGVUeXBlKSB7XG4gICAgY2FzZSBET0NVTUVOVF9OT0RFOlxuICAgIGNhc2UgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcbiAgICAgIHtcbiAgICAgICAgdHlwZSA9IG5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gJyNkb2N1bWVudCcgOiAnI2ZyYWdtZW50JztcbiAgICAgICAgdmFyIHJvb3QgPSByb290Q29udGFpbmVySW5zdGFuY2UuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBuYW1lc3BhY2UgPSByb290ID8gcm9vdC5uYW1lc3BhY2VVUkkgOiBnZXRDaGlsZE5hbWVzcGFjZShudWxsLCAnJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckluc3RhbmNlLnBhcmVudE5vZGUgOiByb290Q29udGFpbmVySW5zdGFuY2U7XG4gICAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBjb250YWluZXIubmFtZXNwYWNlVVJJIHx8IG51bGw7XG4gICAgICAgIHR5cGUgPSBjb250YWluZXIudGFnTmFtZTtcbiAgICAgICAgbmFtZXNwYWNlID0gZ2V0Q2hpbGROYW1lc3BhY2Uob3duTmFtZXNwYWNlLCB0eXBlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbiAge1xuICAgIHZhciB2YWxpZGF0ZWRUYWcgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIF9hbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIHZhbGlkYXRlZFRhZyk7XG4gICAgcmV0dXJuIHsgbmFtZXNwYWNlOiBuYW1lc3BhY2UsIGFuY2VzdG9ySW5mbzogX2FuY2VzdG9ySW5mbyB9O1xuICB9XG4gIHJldHVybiBuYW1lc3BhY2U7XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkSG9zdENvbnRleHQocGFyZW50SG9zdENvbnRleHQsIHR5cGUsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICB7XG4gICAgdmFyIHBhcmVudEhvc3RDb250ZXh0RGV2ID0gcGFyZW50SG9zdENvbnRleHQ7XG4gICAgdmFyIF9uYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnRIb3N0Q29udGV4dERldi5uYW1lc3BhY2UsIHR5cGUpO1xuICAgIHZhciBfYW5jZXN0b3JJbmZvMiA9IHVwZGF0ZWRBbmNlc3RvckluZm8ocGFyZW50SG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlKTtcbiAgICByZXR1cm4geyBuYW1lc3BhY2U6IF9uYW1lc3BhY2UsIGFuY2VzdG9ySW5mbzogX2FuY2VzdG9ySW5mbzIgfTtcbiAgfVxuICB2YXIgcGFyZW50TmFtZXNwYWNlID0gcGFyZW50SG9zdENvbnRleHQ7XG4gIHJldHVybiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpO1xufVxuXG5mdW5jdGlvbiBnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVGb3JDb21taXQoY29udGFpbmVySW5mbykge1xuICBldmVudHNFbmFibGVkID0gaXNFbmFibGVkKCk7XG4gIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24oKTtcbiAgc2V0RW5hYmxlZChmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0QWZ0ZXJDb21taXQoY29udGFpbmVySW5mbykge1xuICByZXN0b3JlU2VsZWN0aW9uKHNlbGVjdGlvbkluZm9ybWF0aW9uKTtcbiAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuICBzZXRFbmFibGVkKGV2ZW50c0VuYWJsZWQpO1xuICBldmVudHNFbmFibGVkID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgdmFyIHBhcmVudE5hbWVzcGFjZSA9IHZvaWQgMDtcbiAge1xuICAgIC8vIFRPRE86IHRha2UgbmFtZXNwYWNlIGludG8gYWNjb3VudCB3aGVuIHZhbGlkYXRpbmcuXG4gICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgdmFsaWRhdGVET01OZXN0aW5nKHR5cGUsIG51bGwsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG4gICAgaWYgKHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHN0cmluZyA9ICcnICsgcHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUpO1xuICAgICAgdmFsaWRhdGVET01OZXN0aW5nKG51bGwsIHN0cmluZywgb3duQW5jZXN0b3JJbmZvKTtcbiAgICB9XG4gICAgcGFyZW50TmFtZXNwYWNlID0gaG9zdENvbnRleHREZXYubmFtZXNwYWNlO1xuICB9XG4gIHZhciBkb21FbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBwYXJlbnROYW1lc3BhY2UpO1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBkb21FbGVtZW50KTtcbiAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBwcm9wcyk7XG4gIHJldHVybiBkb21FbGVtZW50O1xufVxuXG5mdW5jdGlvbiBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAgc2V0SW5pdGlhbFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIHJldHVybiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVVwZGF0ZShkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAge1xuICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgIGlmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gIT09IHR5cGVvZiBvbGRQcm9wcy5jaGlsZHJlbiAmJiAodHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSkge1xuICAgICAgdmFyIHN0cmluZyA9ICcnICsgbmV3UHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUpO1xuICAgICAgdmFsaWRhdGVET01OZXN0aW5nKG51bGwsIHN0cmluZywgb3duQW5jZXN0b3JJbmZvKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmZQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJvcHMpIHtcbiAgcmV0dXJuIHR5cGUgPT09ICd0ZXh0YXJlYScgfHwgdHlwZSA9PT0gJ29wdGlvbicgfHwgdHlwZSA9PT0gJ25vc2NyaXB0JyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSh0eXBlLCBwcm9wcykge1xuICByZXR1cm4gISFwcm9wcy5oaWRkZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRJbnN0YW5jZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHtcbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgdGV4dCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgfVxuICB2YXIgdGV4dE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCB0ZXh0Tm9kZSk7XG4gIHJldHVybiB0ZXh0Tm9kZTtcbn1cblxudmFyIGlzUHJpbWFyeVJlbmRlcmVyID0gdHJ1ZTtcbnZhciBzY2hlZHVsZVRpbWVvdXQgPSBzZXRUaW1lb3V0O1xudmFyIGNhbmNlbFRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG52YXIgbm9UaW1lb3V0ID0gLTE7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAgICBNdXRhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgc3VwcG9ydHNNdXRhdGlvbiA9IHRydWU7XG5cbmZ1bmN0aW9uIGNvbW1pdE1vdW50KGRvbUVsZW1lbnQsIHR5cGUsIG5ld1Byb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIC8vIERlc3BpdGUgdGhlIG5hbWluZyB0aGF0IG1pZ2h0IGltcGx5IG90aGVyd2lzZSwgdGhpcyBtZXRob2Qgb25seVxuICAvLyBmaXJlcyBpZiB0aGVyZSBpcyBhbiBgVXBkYXRlYCBlZmZlY3Qgc2NoZWR1bGVkIGR1cmluZyBtb3VudGluZy5cbiAgLy8gVGhpcyBoYXBwZW5zIGlmIGBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbmAgcmV0dXJucyBgdHJ1ZWAgKHdoaWNoIGl0XG4gIC8vIGRvZXMgdG8gaW1wbGVtZW50IHRoZSBgYXV0b0ZvY3VzYCBhdHRyaWJ1dGUgb24gdGhlIGNsaWVudCkuIEJ1dFxuICAvLyB0aGVyZSBhcmUgYWxzbyBvdGhlciBjYXNlcyB3aGVuIHRoaXMgbWlnaHQgaGFwcGVuIChzdWNoIGFzIHBhdGNoaW5nXG4gIC8vIHVwIHRleHQgY29udGVudCBkdXJpbmcgaHlkcmF0aW9uIG1pc21hdGNoKS4gU28gd2UnbGwgY2hlY2sgdGhpcyBhZ2Fpbi5cbiAgaWYgKHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgbmV3UHJvcHMpKSB7XG4gICAgZG9tRWxlbWVudC5mb2N1cygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFVwZGF0ZShkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgLy8gVXBkYXRlIHRoZSBwcm9wcyBoYW5kbGUgc28gdGhhdCB3ZSBrbm93IHdoaWNoIHByb3BzIGFyZSB0aGUgb25lcyB3aXRoXG4gIC8vIHdpdGggY3VycmVudCBldmVudCBoYW5kbGVycy5cbiAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBuZXdQcm9wcyk7XG4gIC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBET00gbm9kZS5cbiAgdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xufVxuXG5mdW5jdGlvbiByZXNldFRleHRDb250ZW50KGRvbUVsZW1lbnQpIHtcbiAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycpO1xufVxuXG5mdW5jdGlvbiBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCkge1xuICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gbmV3VGV4dDtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihjb250YWluZXIsIGNoaWxkKSB7XG4gIHZhciBwYXJlbnROb2RlID0gdm9pZCAwO1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICBwYXJlbnROb2RlID0gY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGNvbnRhaW5lcik7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50Tm9kZSA9IGNvbnRhaW5lcjtcbiAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfVxuICAvLyBUaGlzIGNvbnRhaW5lciBtaWdodCBiZSB1c2VkIGZvciBhIHBvcnRhbC5cbiAgLy8gSWYgc29tZXRoaW5nIGluc2lkZSBhIHBvcnRhbCBpcyBjbGlja2VkLCB0aGF0IGNsaWNrIHNob3VsZCBidWJibGVcbiAgLy8gdGhyb3VnaCB0aGUgUmVhY3QgdHJlZS4gSG93ZXZlciwgb24gTW9iaWxlIFNhZmFyaSB0aGUgY2xpY2sgd291bGRcbiAgLy8gbmV2ZXIgYnViYmxlIHRocm91Z2ggdGhlICpET00qIHRyZWUgdW5sZXNzIGFuIGFuY2VzdG9yIHdpdGggb25jbGlja1xuICAvLyBldmVudCBleGlzdHMuIFNvIHdlIHdvdWxkbid0IHNlZSBpdCBhbmQgZGlzcGF0Y2ggaXQuXG4gIC8vIFRoaXMgaXMgd2h5IHdlIGVuc3VyZSB0aGF0IGNvbnRhaW5lcnMgaGF2ZSBpbmxpbmUgb25jbGljayBkZWZpbmVkLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExOTE4XG4gIGlmIChwYXJlbnROb2RlLm9uY2xpY2sgPT09IG51bGwpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KHBhcmVudE5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShjb250YWluZXIsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gICAgIEh5ZHJhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgc3VwcG9ydHNIeWRyYXRpb24gPSB0cnVlO1xuXG5mdW5jdGlvbiBjYW5IeWRyYXRlSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gIGlmIChpbnN0YW5jZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFIHx8IHR5cGUudG9Mb3dlckNhc2UoKSAhPT0gaW5zdGFuY2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYW4gZWxlbWVudCBub2RlLlxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoaW5zdGFuY2UsIHRleHQpIHtcbiAgaWYgKHRleHQgPT09ICcnIHx8IGluc3RhbmNlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAvLyBFbXB0eSBzdHJpbmdzIGFyZSBub3QgcGFyc2VkIGJ5IEhUTUwgc28gdGhlcmUgd29uJ3QgYmUgYSBjb3JyZWN0IG1hdGNoIGhlcmUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhIHRleHQgbm9kZS5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoaW5zdGFuY2UpIHtcbiAgdmFyIG5vZGUgPSBpbnN0YW5jZS5uZXh0U2libGluZztcbiAgLy8gU2tpcCBub24taHlkcmF0YWJsZSBub2Rlcy5cbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFICYmIG5vZGUubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChwYXJlbnRJbnN0YW5jZSkge1xuICB2YXIgbmV4dCA9IHBhcmVudEluc3RhbmNlLmZpcnN0Q2hpbGQ7XG4gIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gIHdoaWxlIChuZXh0ICYmIG5leHQubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSAmJiBuZXh0Lm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgfVxuICByZXR1cm4gbmV4dDtcbn1cblxuZnVuY3Rpb24gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBpbnN0YW5jZSk7XG4gIC8vIFRPRE86IFBvc3NpYmx5IGRlZmVyIHRoaXMgdW50aWwgdGhlIGNvbW1pdCBwaGFzZSB3aGVyZSBhbGwgdGhlIGV2ZW50c1xuICAvLyBnZXQgYXR0YWNoZWQuXG4gIHVwZGF0ZUZpYmVyUHJvcHMoaW5zdGFuY2UsIHByb3BzKTtcbiAgdmFyIHBhcmVudE5hbWVzcGFjZSA9IHZvaWQgMDtcbiAge1xuICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgfVxuICByZXR1cm4gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gaHlkcmF0ZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dEluc3RhbmNlKTtcbiAgcmV0dXJuIGRpZmZIeWRyYXRlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbn1cblxuZnVuY3Rpb24gZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dEluc3RhbmNlLCB0ZXh0KSB7XG4gIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpIHtcbiAge1xuICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkaWROb3RIeWRyYXRlSW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSkge1xuICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcykge1xuICB7XG4gICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudENvbnRhaW5lciwgdHlwZSwgcHJvcHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudENvbnRhaW5lciwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dCkge1xuICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50SW5zdGFuY2UsIHRleHQpO1xuICB9XG59XG5cbi8vIFByZWZpeCBtZWFzdXJlbWVudHMgc28gdGhhdCBpdCdzIHBvc3NpYmxlIHRvIGZpbHRlciB0aGVtLlxuLy8gTG9uZ2VyIHByZWZpeGVzIGFyZSBoYXJkIHRvIHJlYWQgaW4gRGV2VG9vbHMuXG52YXIgcmVhY3RFbW9qaSA9ICdcXHUyNjlCJztcbnZhciB3YXJuaW5nRW1vamkgPSAnXFx1MjZENCc7XG52YXIgc3VwcG9ydHNVc2VyVGltaW5nID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyA9PT0gJ2Z1bmN0aW9uJztcblxuLy8gS2VlcCB0cmFjayBvZiBjdXJyZW50IGZpYmVyIHNvIHRoYXQgd2Uga25vdyB0aGUgcGF0aCB0byB1bndpbmQgb24gcGF1c2UuXG4vLyBUT0RPOiB0aGlzIGxvb2tzIHRoZSBzYW1lIGFzIG5leHRVbml0T2ZXb3JrIGluIHNjaGVkdWxlci4gQ2FuIHdlIHVuaWZ5IHRoZW0/XG52YXIgY3VycmVudEZpYmVyID0gbnVsbDtcbi8vIElmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgdXNlciBjb2RlLCB3aGljaCBmaWJlciBhbmQgbWV0aG9kIGlzIGl0P1xuLy8gUmV1c2luZyBgY3VycmVudEZpYmVyYCB3b3VsZCBiZSBjb25mdXNpbmcgZm9yIHRoaXMgYmVjYXVzZSB1c2VyIGNvZGUgZmliZXJcbi8vIGNhbiBjaGFuZ2UgZHVyaW5nIGNvbW1pdCBwaGFzZSB0b28sIGJ1dCB3ZSBkb24ndCBuZWVkIHRvIHVud2luZCBpdCAoc2luY2Vcbi8vIGxpZmVjeWNsZXMgaW4gdGhlIGNvbW1pdCBwaGFzZSBkb24ndCByZXNlbWJsZSBhIHRyZWUpLlxudmFyIGN1cnJlbnRQaGFzZSA9IG51bGw7XG52YXIgY3VycmVudFBoYXNlRmliZXIgPSBudWxsO1xuLy8gRGlkIGxpZmVjeWNsZSBob29rIHNjaGVkdWxlIGFuIHVwZGF0ZT8gVGhpcyBpcyBvZnRlbiBhIHBlcmZvcm1hbmNlIHByb2JsZW0sXG4vLyBzbyB3ZSB3aWxsIGtlZXAgdHJhY2sgb2YgaXQsIGFuZCBpbmNsdWRlIGl0IGluIHRoZSByZXBvcnQuXG4vLyBUcmFjayBjb21taXRzIGNhdXNlZCBieSBjYXNjYWRpbmcgdXBkYXRlcy5cbnZhciBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbnZhciBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbnZhciBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IGZhbHNlO1xudmFyIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPSAwO1xudmFyIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbnZhciBpc1dhaXRpbmdGb3JDYWxsYmFjayA9IGZhbHNlO1xuLy8gRHVyaW5nIGNvbW1pdHMsIHdlIG9ubHkgc2hvdyBhIG1lYXN1cmVtZW50IG9uY2UgcGVyIG1ldGhvZCBuYW1lXG4vLyB0byBhdm9pZCBzdHJldGNoIHRoZSBjb21taXQgcGhhc2Ugd2l0aCBtZWFzdXJlbWVudCBvdmVyaGVhZC5cbnZhciBsYWJlbHNJbkN1cnJlbnRDb21taXQgPSBuZXcgU2V0KCk7XG5cbnZhciBmb3JtYXRNYXJrTmFtZSA9IGZ1bmN0aW9uIChtYXJrTmFtZSkge1xuICByZXR1cm4gcmVhY3RFbW9qaSArICcgJyArIG1hcmtOYW1lO1xufTtcblxudmFyIGZvcm1hdExhYmVsID0gZnVuY3Rpb24gKGxhYmVsLCB3YXJuaW5nKSB7XG4gIHZhciBwcmVmaXggPSB3YXJuaW5nID8gd2FybmluZ0Vtb2ppICsgJyAnIDogcmVhY3RFbW9qaSArICcgJztcbiAgdmFyIHN1ZmZpeCA9IHdhcm5pbmcgPyAnIFdhcm5pbmc6ICcgKyB3YXJuaW5nIDogJyc7XG4gIHJldHVybiAnJyArIHByZWZpeCArIGxhYmVsICsgc3VmZml4O1xufTtcblxudmFyIGJlZ2luTWFyayA9IGZ1bmN0aW9uIChtYXJrTmFtZSkge1xuICBwZXJmb3JtYW5jZS5tYXJrKGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKSk7XG59O1xuXG52YXIgY2xlYXJNYXJrID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZm9ybWF0TWFya05hbWUobWFya05hbWUpKTtcbn07XG5cbnZhciBlbmRNYXJrID0gZnVuY3Rpb24gKGxhYmVsLCBtYXJrTmFtZSwgd2FybmluZykge1xuICB2YXIgZm9ybWF0dGVkTWFya05hbWUgPSBmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSk7XG4gIHZhciBmb3JtYXR0ZWRMYWJlbCA9IGZvcm1hdExhYmVsKGxhYmVsLCB3YXJuaW5nKTtcbiAgdHJ5IHtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKGZvcm1hdHRlZExhYmVsLCBmb3JtYXR0ZWRNYXJrTmFtZSk7XG4gIH0gY2F0Y2ggKGVycikge31cbiAgLy8gSWYgcHJldmlvdXMgbWFyayB3YXMgbWlzc2luZyBmb3Igc29tZSByZWFzb24sIHRoaXMgd2lsbCB0aHJvdy5cbiAgLy8gVGhpcyBjb3VsZCBvbmx5IGhhcHBlbiBpZiBSZWFjdCBjcmFzaGVkIGluIGFuIHVuZXhwZWN0ZWQgcGxhY2UgZWFybGllci5cbiAgLy8gRG9uJ3QgcGlsZSBvbiB3aXRoIG1vcmUgZXJyb3JzLlxuXG4gIC8vIENsZWFyIG1hcmtzIGltbWVkaWF0ZWx5IHRvIGF2b2lkIGdyb3dpbmcgYnVmZmVyLlxuICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKGZvcm1hdHRlZE1hcmtOYW1lKTtcbiAgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhmb3JtYXR0ZWRMYWJlbCk7XG59O1xuXG52YXIgZ2V0RmliZXJNYXJrTmFtZSA9IGZ1bmN0aW9uIChsYWJlbCwgZGVidWdJRCkge1xuICByZXR1cm4gbGFiZWwgKyAnICgjJyArIGRlYnVnSUQgKyAnKSc7XG59O1xuXG52YXIgZ2V0RmliZXJMYWJlbCA9IGZ1bmN0aW9uIChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKSB7XG4gIGlmIChwaGFzZSA9PT0gbnVsbCkge1xuICAgIC8vIFRoZXNlIGFyZSBjb21wb3NpdGUgY29tcG9uZW50IHRvdGFsIHRpbWUgbWVhc3VyZW1lbnRzLlxuICAgIHJldHVybiBjb21wb25lbnROYW1lICsgJyBbJyArIChpc01vdW50ZWQgPyAndXBkYXRlJyA6ICdtb3VudCcpICsgJ10nO1xuICB9IGVsc2Uge1xuICAgIC8vIENvbXBvc2l0ZSBjb21wb25lbnQgbWV0aG9kcy5cbiAgICByZXR1cm4gY29tcG9uZW50TmFtZSArICcuJyArIHBoYXNlO1xuICB9XG59O1xuXG52YXIgYmVnaW5GaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG5cbiAgaWYgKGlzQ29tbWl0dGluZyAmJiBsYWJlbHNJbkN1cnJlbnRDb21taXQuaGFzKGxhYmVsKSkge1xuICAgIC8vIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCB3ZSBkb24ndCBzaG93IGR1cGxpY2F0ZSBsYWJlbHMgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIGEgZml4ZWQgb3ZlcmhlYWQgZm9yIGV2ZXJ5IG1lYXN1cmVtZW50LCBhbmQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRvIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSBiZXlvbmQgbmVjZXNzYXJ5LlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsYWJlbHNJbkN1cnJlbnRDb21taXQuYWRkKGxhYmVsKTtcblxuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgYmVnaW5NYXJrKG1hcmtOYW1lKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgY2xlYXJGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBjbGVhck1hcmsobWFya05hbWUpO1xufTtcblxudmFyIGVuZEZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UsIHdhcm5pbmcpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdVbmtub3duJztcbiAgdmFyIGRlYnVnSUQgPSBmaWJlci5fZGVidWdJRDtcbiAgdmFyIGlzTW91bnRlZCA9IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbDtcbiAgdmFyIGxhYmVsID0gZ2V0RmliZXJMYWJlbChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKTtcbiAgdmFyIG1hcmtOYW1lID0gZ2V0RmliZXJNYXJrTmFtZShsYWJlbCwgZGVidWdJRCk7XG4gIGVuZE1hcmsobGFiZWwsIG1hcmtOYW1lLCB3YXJuaW5nKTtcbn07XG5cbnZhciBzaG91bGRJZ25vcmVGaWJlciA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAvLyBIb3N0IGNvbXBvbmVudHMgc2hvdWxkIGJlIHNraXBwZWQgaW4gdGhlIHRpbWVsaW5lLlxuICAvLyBXZSBjb3VsZCBjaGVjayB0eXBlb2YgZmliZXIudHlwZSwgYnV0IGRvZXMgdGhpcyB3b3JrIHdpdGggUk4/XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICBjYXNlIE1vZGU6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgIGNsZWFyRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UpO1xuICB9XG4gIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbiAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbn07XG5cbnZhciBwYXVzZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gU3RvcHMgYWxsIGN1cnJlbnRseSBhY3RpdmUgbWVhc3VyZW1lbnRzIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVzdW1lZFxuICAvLyBpZiB3ZSBjb250aW51ZSBpbiBhIGxhdGVyIGRlZmVycmVkIGxvb3AgZnJvbSB0aGUgc2FtZSB1bml0IG9mIHdvcmsuXG4gIHZhciBmaWJlciA9IGN1cnJlbnRGaWJlcjtcbiAgd2hpbGUgKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIGlmIChmaWJlci5yZXR1cm4gIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShmaWJlci5yZXR1cm4pO1xuICB9XG4gIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgIGJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVzdW1lcyBhbGwgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBhY3RpdmUgZHVyaW5nIHRoZSBsYXN0IGRlZmVycmVkIGxvb3AuXG4gIGlmIChjdXJyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShjdXJyZW50RmliZXIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWNvcmRFZmZlY3QoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQrKztcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxNb3VudCcgJiYgY3VycmVudFBoYXNlICE9PSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpIHtcbiAgICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRSZXF1ZXN0Q2FsbGJhY2tUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nICYmICFpc1dhaXRpbmdGb3JDYWxsYmFjaykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgYmVnaW5NYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BSZXF1ZXN0Q2FsbGJhY2tUaW1lcihkaWRFeHBpcmUsIGV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgIHZhciB3YXJuaW5nID0gZGlkRXhwaXJlID8gJ1JlYWN0IHdhcyBibG9ja2VkIGJ5IG1haW4gdGhyZWFkJyA6IG51bGw7XG4gICAgICBlbmRNYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4gd2lsbCBmb3JjZSBmbHVzaCBpbiAnICsgZXhwaXJhdGlvblRpbWUgKyAnIG1zKScsICcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJywgd2FybmluZyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCB0aGlzIGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlcjtcbiAgICBpZiAoIWJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FuY2VsV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlbWVtYmVyIHdlIHNob3VsZG4ndCBjb21wbGV0ZSBtZWFzdXJlbWVudCBmb3IgdGhpcyBmaWJlci5cbiAgICAvLyBPdGhlcndpc2UgZmxhbWVjaGFydCB3aWxsIGJlIGRlZXAgZXZlbiBmb3Igc21hbGwgdXBkYXRlcy5cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGNsZWFyRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCBpdHMgcGFyZW50IGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgaWYgKCFmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcEZhaWxlZFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgaXRzIHBhcmVudCBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgIGlmICghZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICB2YXIgd2FybmluZyA9ICdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSB0aGlzIGVycm9yIGJvdW5kYXJ5JztcbiAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIHdhcm5pbmcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgcGhhc2UpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclBlbmRpbmdQaGFzZU1lYXN1cmVtZW50KCk7XG4gICAgaWYgKCFiZWdpbkZpYmVyTWFyayhmaWJlciwgcGhhc2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZUZpYmVyID0gZmliZXI7XG4gICAgY3VycmVudFBoYXNlID0gcGhhc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFBoYXNlVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIHdhcm5pbmcgPSBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA/ICdTY2hlZHVsZWQgYSBjYXNjYWRpbmcgdXBkYXRlJyA6IG51bGw7XG4gICAgICBlbmRGaWJlck1hcmsoY3VycmVudFBoYXNlRmliZXIsIGN1cnJlbnRQaGFzZSwgd2FybmluZyk7XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gICAgY3VycmVudFBoYXNlRmliZXIgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya0xvb3BUaW1lcihuZXh0VW5pdE9mV29yaykge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGN1cnJlbnRGaWJlciA9IG5leHRVbml0T2ZXb3JrO1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPSAwO1xuICAgIC8vIFRoaXMgaXMgdG9wIGxldmVsIGNhbGwuXG4gICAgLy8gQW55IG90aGVyIG1lYXN1cmVtZW50cyBhcmUgcGVyZm9ybWVkIHdpdGhpbi5cbiAgICBiZWdpbk1hcmsoJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScpO1xuICAgIC8vIFJlc3VtZSBhbnkgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBpbiBwcm9ncmVzcyBkdXJpbmcgdGhlIGxhc3QgbG9vcC5cbiAgICByZXN1bWVUaW1lcnMoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5LCBkaWRDb21wbGV0ZVJvb3QpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgd2FybmluZyA9IG51bGw7XG4gICAgaWYgKGludGVycnVwdGVkQnkgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbnRlcnJ1cHRlZEJ5LnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgd2FybmluZyA9ICdBIHRvcC1sZXZlbCB1cGRhdGUgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoaW50ZXJydXB0ZWRCeS50eXBlKSB8fCAnVW5rbm93bic7XG4gICAgICAgIHdhcm5pbmcgPSAnQW4gdXBkYXRlIHRvICcgKyBjb21wb25lbnROYW1lICsgJyBpbnRlcnJ1cHRlZCB0aGUgcHJldmlvdXMgcmVuZGVyJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPiAxKSB7XG4gICAgICB3YXJuaW5nID0gJ1RoZXJlIHdlcmUgY2FzY2FkaW5nIHVwZGF0ZXMnO1xuICAgIH1cbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbiAgICB2YXIgbGFiZWwgPSBkaWRDb21wbGV0ZVJvb3QgPyAnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb246IENvbXBsZXRlZCBSb290KScgOiAnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb246IFlpZWxkZWQpJztcbiAgICAvLyBQYXVzZSBhbnkgbWVhc3VyZW1lbnRzIHVudGlsIHRoZSBuZXh0IGxvb3AuXG4gICAgcGF1c2VUaW1lcnMoKTtcbiAgICBlbmRNYXJrKGxhYmVsLCAnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJywgd2FybmluZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDb21taXRUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpc0NvbW1pdHRpbmcgPSB0cnVlO1xuICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FybmluZyA9IG51bGw7XG4gICAgaWYgKGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCkge1xuICAgICAgd2FybmluZyA9ICdMaWZlY3ljbGUgaG9vayBzY2hlZHVsZWQgYSBjYXNjYWRpbmcgdXBkYXRlJztcbiAgICB9IGVsc2UgaWYgKGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPiAwKSB7XG4gICAgICB3YXJuaW5nID0gJ0NhdXNlZCBieSBhIGNhc2NhZGluZyB1cGRhdGUgaW4gZWFybGllciBjb21taXQnO1xuICAgIH1cbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wKys7XG4gICAgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gICAgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmNsZWFyKCk7XG5cbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBDaGFuZ2VzKScsICcoQ29tbWl0dGluZyBDaGFuZ2VzKScsIHdhcm5pbmcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgU25hcHNob3QgRWZmZWN0cyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDb21taXR0aW5nIFNuYXBzaG90IEVmZmVjdHM6ICcgKyBjb3VudCArICcgVG90YWwpJywgJyhDb21taXR0aW5nIFNuYXBzaG90IEVmZmVjdHMpJywgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDb21taXRIb3N0RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0cyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY291bnQgPSBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdDtcbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgZW5kTWFyaygnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzOiAnICsgY291bnQgKyAnIFRvdGFsKScsICcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHMpJywgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDb21taXRMaWZlQ3ljbGVzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGJlZ2luTWFyaygnKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdExpZmVDeWNsZXNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY291bnQgPSBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdDtcbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgZW5kTWFyaygnKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHM6ICcgKyBjb3VudCArICcgVG90YWwpJywgJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzKScsIG51bGwpO1xuICB9XG59XG5cbnZhciB2YWx1ZVN0YWNrID0gW107XG5cbnZhciBmaWJlclN0YWNrID0gdm9pZCAwO1xuXG57XG4gIGZpYmVyU3RhY2sgPSBbXTtcbn1cblxudmFyIGluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUN1cnNvcihkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBkZWZhdWx0VmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcG9wKGN1cnNvciwgZmliZXIpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1VuZXhwZWN0ZWQgcG9wLicpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4XSkge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcblxuICB2YWx1ZVN0YWNrW2luZGV4XSA9IG51bGw7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgfVxuXG4gIGluZGV4LS07XG59XG5cbmZ1bmN0aW9uIHB1c2goY3Vyc29yLCB2YWx1ZSwgZmliZXIpIHtcbiAgaW5kZXgrKztcblxuICB2YWx1ZVN0YWNrW2luZGV4XSA9IGN1cnNvci5jdXJyZW50O1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IGZpYmVyO1xuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tUaGF0U3RhY2tJc0VtcHR5KCkge1xuICB7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnRXhwZWN0ZWQgYW4gZW1wdHkgc3RhY2suIFNvbWV0aGluZyB3YXMgbm90IHJlc2V0IHByb3Blcmx5LicpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldFN0YWNrQWZ0ZXJGYXRhbEVycm9ySW5EZXYoKSB7XG4gIHtcbiAgICBpbmRleCA9IC0xO1xuICAgIHZhbHVlU3RhY2subGVuZ3RoID0gMDtcbiAgICBmaWJlclN0YWNrLmxlbmd0aCA9IDA7XG4gIH1cbn1cblxudmFyIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCA9IHZvaWQgMDtcblxue1xuICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcbn1cblxudmFyIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9O1xue1xuICBPYmplY3QuZnJlZXplKGVtcHR5Q29udGV4dE9iamVjdCk7XG59XG5cbi8vIEEgY3Vyc29yIHRvIHRoZSBjdXJyZW50IG1lcmdlZCBjb250ZXh0IG9iamVjdCBvbiB0aGUgc3RhY2suXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGVtcHR5Q29udGV4dE9iamVjdCk7XG4vLyBBIGN1cnNvciB0byBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb250ZXh0IGhhcyBjaGFuZ2VkLlxudmFyIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZmFsc2UpO1xuLy8gS2VlcCB0cmFjayBvZiB0aGUgcHJldmlvdXMgY29udGV4dCBvYmplY3QgdGhhdCB3YXMgb24gdGhlIHN0YWNrLlxuLy8gV2UgdXNlIHRoaXMgdG8gZ2V0IGFjY2VzcyB0byB0aGUgcGFyZW50IGNvbnRleHQgYWZ0ZXIgd2UgaGF2ZSBhbHJlYWR5XG4vLyBwdXNoZWQgdGhlIG5leHQgY29udGV4dCBwcm92aWRlciwgYW5kIG5vdyBuZWVkIHRvIG1lcmdlIHRoZWlyIGNvbnRleHRzLlxudmFyIHByZXZpb3VzQ29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcblxuZnVuY3Rpb24gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGRpZFB1c2hPd25Db250ZXh0SWZQcm92aWRlcikge1xuICBpZiAoZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyICYmIGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAvLyBJZiB0aGUgZmliZXIgaXMgYSBjb250ZXh0IHByb3ZpZGVyIGl0c2VsZiwgd2hlbiB3ZSByZWFkIGl0cyBjb250ZXh0XG4gICAgLy8gd2UgbWF5IGhhdmUgYWxyZWFkeSBwdXNoZWQgaXRzIG93biBjaGlsZCBjb250ZXh0IG9uIHRoZSBzdGFjay4gQSBjb250ZXh0XG4gICAgLy8gcHJvdmlkZXIgc2hvdWxkIG5vdCBcInNlZVwiIGl0cyBvd24gY2hpbGQgY29udGV4dC4gVGhlcmVmb3JlIHdlIHJlYWQgdGhlXG4gICAgLy8gcHJldmlvdXMgKHBhcmVudCkgY29udGV4dCBpbnN0ZWFkIGZvciBhIGNvbnRleHQgcHJvdmlkZXIuXG4gICAgcmV0dXJuIHByZXZpb3VzQ29udGV4dDtcbiAgfVxuICByZXR1cm4gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBtYXNrZWRDb250ZXh0KSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9IHVubWFza2VkQ29udGV4dDtcbiAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQgPSBtYXNrZWRDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG4gIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgfVxuXG4gIC8vIEF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIHVubWFza2VkIGNvbnRleHQgaGFzIGNoYW5nZWQuXG4gIC8vIEZhaWxpbmcgdG8gZG8gdGhpcyB3aWxsIHJlc3VsdCBpbiB1bm5lY2Vzc2FyeSBjYWxscyB0byBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLlxuICAvLyBUaGlzIG1heSB0cmlnZ2VyIGluZmluaXRlIGxvb3BzIGlmIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgY2FsbHMgc2V0U3RhdGUuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPT09IHVubWFza2VkQ29udGV4dCkge1xuICAgIHJldHVybiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge307XG4gIGZvciAodmFyIGtleSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICBjb250ZXh0W2tleV0gPSB1bm1hc2tlZENvbnRleHRba2V5XTtcbiAgfVxuXG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ1Vua25vd24nO1xuICAgIGNoZWNrUHJvcFR5cGVzKGNvbnRleHRUeXBlcywgY29udGV4dCwgJ2NvbnRleHQnLCBuYW1lLCBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KTtcbiAgfVxuXG4gIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgLy8gQ29udGV4dCBpcyBjcmVhdGVkIGJlZm9yZSB0aGUgY2xhc3MgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCBzbyBjaGVjayBmb3IgaW5zdGFuY2UuXG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAgcmV0dXJuIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIodHlwZSkge1xuICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSB0eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuICByZXR1cm4gY2hpbGRDb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcG9wQ29udGV4dChmaWJlcikge1xuICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChmaWJlcikge1xuICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIsIGNvbnRleHQsIGRpZENoYW5nZSkge1xuICAhKGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50ID09PSBlbXB0eUNvbnRleHRPYmplY3QpID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBjb250ZXh0LCBmaWJlcik7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHR5cGUsIHBhcmVudENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSB0eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gIC8vIFRPRE8gKGJ2YXVnaG4pIFJlcGxhY2UgdGhpcyBiZWhhdmlvciB3aXRoIGFuIGludmFyaWFudCgpIGluIHRoZSBmdXR1cmUuXG4gIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIXdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcy5jaGlsZENvbnRleHRUeXBlcyBpcyBzcGVjaWZpZWQgYnV0IHRoZXJlIGlzIG5vIGdldENoaWxkQ29udGV4dCgpIG1ldGhvZCAnICsgJ29uIHRoZSBpbnN0YW5jZS4gWW91IGNhbiBlaXRoZXIgZGVmaW5lIGdldENoaWxkQ29udGV4dCgpIG9uICVzIG9yIHJlbW92ZSAnICsgJ2NoaWxkQ29udGV4dFR5cGVzIGZyb20gaXQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRDb250ZXh0O1xuICB9XG5cbiAgdmFyIGNoaWxkQ29udGV4dCA9IHZvaWQgMDtcbiAge1xuICAgIHNldEN1cnJlbnRQaGFzZSgnZ2V0Q2hpbGRDb250ZXh0Jyk7XG4gIH1cbiAgc3RhcnRQaGFzZVRpbWVyKGZpYmVyLCAnZ2V0Q2hpbGRDb250ZXh0Jyk7XG4gIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuICBzdG9wUGhhc2VUaW1lcigpO1xuICB7XG4gICAgc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG4gIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgIShjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dFR5cGVzKSA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ1Vua25vd24nLCBjb250ZXh0S2V5KSA6IHZvaWQgMDtcbiAgfVxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdVbmtub3duJztcbiAgICBjaGVja1Byb3BUeXBlcyhjaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGQgY29udGV4dCcsIG5hbWUsXG4gICAgLy8gSW4gcHJhY3RpY2UsIHRoZXJlIGlzIG9uZSBjYXNlIGluIHdoaWNoIHdlIHdvbid0IGdldCBhIHN0YWNrLiBJdCdzIHdoZW5cbiAgICAvLyBzb21lYm9keSBjYWxscyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcigpIGFuZCB3ZSBwcm9jZXNzXG4gICAgLy8gY29udGV4dCBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50IGluc3RhbmNlLiBUaGUgc3RhY2sgd2lsbCBiZSBtaXNzaW5nXG4gICAgLy8gYmVjYXVzZSBpdCdzIG91dHNpZGUgb2YgdGhlIHJlY29uY2lsaWF0aW9uLCBhbmQgc28gdGhlIHBvaW50ZXIgaGFzIG5vdFxuICAgIC8vIGJlZW4gc2V0LiBUaGlzIGlzIHJhcmUgYW5kIGRvZXNuJ3QgbWF0dGVyLiBXZSdsbCBhbHNvIHJlbW92ZSB0aGF0IEFQSS5cbiAgICBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KTtcbiAgfVxuXG4gIHJldHVybiBfYXNzaWduKHt9LCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gV2UgcHVzaCB0aGUgY29udGV4dCBhcyBlYXJseSBhcyBwb3NzaWJsZSB0byBlbnN1cmUgc3RhY2sgaW50ZWdyaXR5LlxuICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgLy8gYW5kIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGxhdGVyIHdoZW4gaW52YWxpZGF0aW5nIHRoZSBjb250ZXh0LlxuICB2YXIgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCB8fCBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbiAgLy8gUmVtZW1iZXIgdGhlIHBhcmVudCBjb250ZXh0IHNvIHdlIGNhbiBtZXJnZSB3aXRoIGl0IGxhdGVyLlxuICAvLyBJbmhlcml0IHRoZSBwYXJlbnQncyBkaWQtcGVyZm9ybS13b3JrIHZhbHVlIHRvIGF2b2lkIGluYWR2ZXJ0ZW50bHkgYmxvY2tpbmcgdXBkYXRlcy5cbiAgcHJldmlvdXNDb250ZXh0ID0gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCB0eXBlLCBkaWRDaGFuZ2UpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAhaW5zdGFuY2UgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBoYXZlIGFuIGluc3RhbmNlIGJ5IHRoaXMgcG9pbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgaWYgKGRpZENoYW5nZSkge1xuICAgIC8vIE1lcmdlIHBhcmVudCBhbmQgb3duIGNvbnRleHQuXG4gICAgLy8gU2tpcCB0aGlzIGlmIHdlJ3JlIG5vdCB1cGRhdGluZyBkdWUgdG8gc0NVLlxuICAgIC8vIFRoaXMgYXZvaWRzIHVubmVjZXNzYXJpbHkgcmVjb21wdXRpbmcgbWVtb2l6ZWQgdmFsdWVzLlxuICAgIHZhciBtZXJnZWRDb250ZXh0ID0gcHJvY2Vzc0NoaWxkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdHlwZSwgcHJldmlvdXNDb250ZXh0KTtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IG1lcmdlZENvbnRleHQ7XG5cbiAgICAvLyBSZXBsYWNlIHRoZSBvbGQgKG9yIGVtcHR5KSBjb250ZXh0IHdpdGggdGhlIG5ldyBvbmUuXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIHVud2luZCB0aGUgY29udGV4dCBpbiB0aGUgcmV2ZXJzZSBvcmRlci5cbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICAvLyBOb3cgcHVzaCB0aGUgbmV3IGNvbnRleHQgYW5kIG1hcmsgdGhhdCBpdCBoYXMgY2hhbmdlZC5cbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVyZ2VkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKSB7XG4gIC8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuICAvLyBtYWtlcyBzZW5zZSBlbHNld2hlcmVcbiAgIShpc0ZpYmVyTW91bnRlZChmaWJlcikgJiYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgfHwgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudExhenkpKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHN1YnRyZWUgcGFyZW50IHRvIGJlIGEgbW91bnRlZCBjbGFzcyBjb21wb25lbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgZG8ge1xuICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5jb250ZXh0O1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBDb21wb25lbnQgPSBub2RlLnR5cGU7XG4gICAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnRMYXp5OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9Db21wb25lbnQgPSBnZXRSZXN1bHRGcm9tUmVzb2x2ZWRUaGVuYWJsZShub2RlLnR5cGUpO1xuICAgICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihfQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gIH0gd2hpbGUgKG5vZGUgIT09IG51bGwpO1xuICBpbnZhcmlhbnQoZmFsc2UsICdGb3VuZCB1bmV4cGVjdGVkIGRldGFjaGVkIHN1YnRyZWUgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xufVxuXG52YXIgb25Db21taXRGaWJlclJvb3QgPSBudWxsO1xudmFyIG9uQ29tbWl0RmliZXJVbm1vdW50ID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjYXRjaEVycm9ycyhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYXJnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0cnVlICYmICFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1JlYWN0IERldlRvb2xzIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsIGVycik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgaXNEZXZUb29sc1ByZXNlbnQgPSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJztcblxuZnVuY3Rpb24gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscykge1xuICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBObyBEZXZUb29sc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaG9vayA9IF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFob29rLnN1cHBvcnRzRmliZXIpIHtcbiAgICB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayAnICsgJ3dpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBSZWFjdC4gUGxlYXNlIHVwZGF0ZSBSZWFjdCBEZXZUb29scy4gJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyk7XG4gICAgfVxuICAgIC8vIERldlRvb2xzIGV4aXN0cywgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBzdXBwb3J0IEZpYmVyLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIHJlbmRlcmVySUQgPSBob29rLmluamVjdChpbnRlcm5hbHMpO1xuICAgIC8vIFdlIGhhdmUgc3VjY2Vzc2Z1bGx5IGluamVjdGVkLCBzbyBub3cgaXQgaXMgc2FmZSB0byBzZXQgdXAgaG9va3MuXG4gICAgb25Db21taXRGaWJlclJvb3QgPSBjYXRjaEVycm9ycyhmdW5jdGlvbiAocm9vdCkge1xuICAgICAgcmV0dXJuIGhvb2sub25Db21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCk7XG4gICAgfSk7XG4gICAgb25Db21taXRGaWJlclVubW91bnQgPSBjYXRjaEVycm9ycyhmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHJldHVybiBob29rLm9uQ29tbWl0RmliZXJVbm1vdW50KHJlbmRlcmVySUQsIGZpYmVyKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gQ2F0Y2ggYWxsIGVycm9ycyBiZWNhdXNlIGl0IGlzIHVuc2FmZSB0byB0aHJvdyBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG4gICAge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLicsIGVycik7XG4gICAgfVxuICB9XG4gIC8vIERldlRvb2xzIGV4aXN0c1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QpIHtcbiAgaWYgKHR5cGVvZiBvbkNvbW1pdEZpYmVyUm9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9uQ29tbWl0RmliZXJSb290KHJvb3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uQ29tbWl0VW5tb3VudChmaWJlcikge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclVubW91bnQoZmliZXIpO1xuICB9XG59XG5cbi8vIE1heCAzMSBiaXQgaW50ZWdlci4gVGhlIG1heCBpbnRlZ2VyIHNpemUgaW4gVjggZm9yIDMyLWJpdCBzeXN0ZW1zLlxuLy8gTWF0aC5wb3coMiwgMzApIC0gMVxuLy8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcbnZhciBtYXhTaWduZWQzMUJpdEludCA9IDEwNzM3NDE4MjM7XG5cbnZhciBOb1dvcmsgPSAwO1xudmFyIFN5bmMgPSAxO1xudmFyIE5ldmVyID0gbWF4U2lnbmVkMzFCaXRJbnQ7XG5cbnZhciBVTklUX1NJWkUgPSAxMDtcbnZhciBNQUdJQ19OVU1CRVJfT0ZGU0VUID0gMjtcblxuLy8gMSB1bml0IG9mIGV4cGlyYXRpb24gdGltZSByZXByZXNlbnRzIDEwbXMuXG5mdW5jdGlvbiBtc1RvRXhwaXJhdGlvblRpbWUobXMpIHtcbiAgLy8gQWx3YXlzIGFkZCBhbiBvZmZzZXQgc28gdGhhdCB3ZSBkb24ndCBjbGFzaCB3aXRoIHRoZSBtYWdpYyBudW1iZXIgZm9yIE5vV29yay5cbiAgcmV0dXJuIChtcyAvIFVOSVRfU0laRSB8IDApICsgTUFHSUNfTlVNQkVSX09GRlNFVDtcbn1cblxuZnVuY3Rpb24gZXhwaXJhdGlvblRpbWVUb01zKGV4cGlyYXRpb25UaW1lKSB7XG4gIHJldHVybiAoZXhwaXJhdGlvblRpbWUgLSBNQUdJQ19OVU1CRVJfT0ZGU0VUKSAqIFVOSVRfU0laRTtcbn1cblxuZnVuY3Rpb24gY2VpbGluZyhudW0sIHByZWNpc2lvbikge1xuICByZXR1cm4gKChudW0gLyBwcmVjaXNpb24gfCAwKSArIDEpICogcHJlY2lzaW9uO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgZXhwaXJhdGlvbkluTXMsIGJ1Y2tldFNpemVNcykge1xuICByZXR1cm4gTUFHSUNfTlVNQkVSX09GRlNFVCArIGNlaWxpbmcoY3VycmVudFRpbWUgLSBNQUdJQ19OVU1CRVJfT0ZGU0VUICsgZXhwaXJhdGlvbkluTXMgLyBVTklUX1NJWkUsIGJ1Y2tldFNpemVNcyAvIFVOSVRfU0laRSk7XG59XG5cbnZhciBMT1dfUFJJT1JJVFlfRVhQSVJBVElPTiA9IDUwMDA7XG52YXIgTE9XX1BSSU9SSVRZX0JBVENIX1NJWkUgPSAyNTA7XG5cbmZ1bmN0aW9uIGNvbXB1dGVBc3luY0V4cGlyYXRpb24oY3VycmVudFRpbWUpIHtcbiAgcmV0dXJuIGNvbXB1dGVFeHBpcmF0aW9uQnVja2V0KGN1cnJlbnRUaW1lLCBMT1dfUFJJT1JJVFlfRVhQSVJBVElPTiwgTE9XX1BSSU9SSVRZX0JBVENIX1NJWkUpO1xufVxuXG4vLyBXZSBpbnRlbnRpb25hbGx5IHNldCBhIGhpZ2hlciBleHBpcmF0aW9uIHRpbWUgZm9yIGludGVyYWN0aXZlIHVwZGF0ZXMgaW5cbi8vIGRldiB0aGFuIGluIHByb2R1Y3Rpb24uXG4vL1xuLy8gSWYgdGhlIG1haW4gdGhyZWFkIGlzIGJlaW5nIGJsb2NrZWQgc28gbG9uZyB0aGF0IHlvdSBoaXQgdGhlIGV4cGlyYXRpb24sXG4vLyBpdCdzIGEgcHJvYmxlbSB0aGF0IGNvdWxkIGJlIHNvbHZlZCB3aXRoIGJldHRlciBzY2hlZHVsaW5nLlxuLy9cbi8vIFBlb3BsZSB3aWxsIGJlIG1vcmUgbGlrZWx5IHRvIG5vdGljZSB0aGlzIGFuZCBmaXggaXQgd2l0aCB0aGUgbG9uZ1xuLy8gZXhwaXJhdGlvbiB0aW1lIGluIGRldmVsb3BtZW50LlxuLy9cbi8vIEluIHByb2R1Y3Rpb24gd2Ugb3B0IGZvciBiZXR0ZXIgVVggYXQgdGhlIHJpc2sgb2YgbWFza2luZyBzY2hlZHVsaW5nXG4vLyBwcm9ibGVtcywgYnkgZXhwaXJpbmcgZmFzdC5cbnZhciBISUdIX1BSSU9SSVRZX0VYUElSQVRJT04gPSA1MDA7XG52YXIgSElHSF9QUklPUklUWV9CQVRDSF9TSVpFID0gMTAwO1xuXG5mdW5jdGlvbiBjb21wdXRlSW50ZXJhY3RpdmVFeHBpcmF0aW9uKGN1cnJlbnRUaW1lKSB7XG4gIHJldHVybiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgSElHSF9QUklPUklUWV9FWFBJUkFUSU9OLCBISUdIX1BSSU9SSVRZX0JBVENIX1NJWkUpO1xufVxuXG52YXIgTm9Db250ZXh0ID0gMDtcbnZhciBBc3luY01vZGUgPSAxO1xudmFyIFN0cmljdE1vZGUgPSAyO1xudmFyIFByb2ZpbGVNb2RlID0gNDtcblxudmFyIGhhc0JhZE1hcFBvbHlmaWxsID0gdm9pZCAwO1xuXG57XG4gIGhhc0JhZE1hcFBvbHlmaWxsID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgIHZhciB0ZXN0TWFwID0gbmV3IE1hcChbW25vbkV4dGVuc2libGVPYmplY3QsIG51bGxdXSk7XG4gICAgdmFyIHRlc3RTZXQgPSBuZXcgU2V0KFtub25FeHRlbnNpYmxlT2JqZWN0XSk7XG4gICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIFJvbGx1cCB0byBub3QgY29uc2lkZXIgdGhlc2UgdW51c2VkLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwL2lzc3Vlcy8xNzcxXG4gICAgLy8gVE9ETzogd2UgY2FuIHJlbW92ZSB0aGVzZSBpZiBSb2xsdXAgZml4ZXMgdGhlIGJ1Zy5cbiAgICB0ZXN0TWFwLnNldCgwLCAwKTtcbiAgICB0ZXN0U2V0LmFkZCgwKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBBIEZpYmVyIGlzIHdvcmsgb24gYSBDb21wb25lbnQgdGhhdCBuZWVkcyB0byBiZSBkb25lIG9yIHdhcyBkb25lLiBUaGVyZSBjYW5cbi8vIGJlIG1vcmUgdGhhbiBvbmUgcGVyIGNvbXBvbmVudC5cblxuXG52YXIgZGVidWdDb3VudGVyID0gdm9pZCAwO1xuXG57XG4gIGRlYnVnQ291bnRlciA9IDE7XG59XG5cbmZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vIEluc3RhbmNlXG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy50eXBlID0gbnVsbDtcbiAgdGhpcy5zdGF0ZU5vZGUgPSBudWxsO1xuXG4gIC8vIEZpYmVyXG4gIHRoaXMucmV0dXJuID0gbnVsbDtcbiAgdGhpcy5jaGlsZCA9IG51bGw7XG4gIHRoaXMuc2libGluZyA9IG51bGw7XG4gIHRoaXMuaW5kZXggPSAwO1xuXG4gIHRoaXMucmVmID0gbnVsbDtcblxuICB0aGlzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcbiAgdGhpcy5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgdGhpcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHRoaXMubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHRoaXMuZmlyc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG5cbiAgdGhpcy5tb2RlID0gbW9kZTtcblxuICAvLyBFZmZlY3RzXG4gIHRoaXMuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG4gIHRoaXMubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gIHRoaXMubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgdGhpcy5jaGlsZEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcblxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIHRoaXMuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgIHRoaXMuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgdGhpcy5zZWxmQmFzZUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnRyZWVCYXNlRHVyYXRpb24gPSAwO1xuICB9XG5cbiAge1xuICAgIHRoaXMuX2RlYnVnSUQgPSBkZWJ1Z0NvdW50ZXIrKztcbiAgICB0aGlzLl9kZWJ1Z1NvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdPd25lciA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGlmICghaGFzQmFkTWFwUG9seWZpbGwgJiYgdHlwZW9mIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIGlzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIHJhdGhlciB0aGFuIGEgUE9KTyBjb25zdHJ1Y3Rvciwgc3RpbGxcbi8vIHBsZWFzZSBlbnN1cmUgd2UgZG8gdGhlIGZvbGxvd2luZzpcbi8vIDEpIE5vYm9keSBzaG91bGQgYWRkIGFueSBpbnN0YW5jZSBtZXRob2RzIG9uIHRoaXMuIEluc3RhbmNlIG1ldGhvZHMgY2FuIGJlXG4vLyAgICBtb3JlIGRpZmZpY3VsdCB0byBwcmVkaWN0IHdoZW4gdGhleSBnZXQgb3B0aW1pemVkIGFuZCB0aGV5IGFyZSBhbG1vc3Rcbi8vICAgIG5ldmVyIGlubGluZWQgcHJvcGVybHkgaW4gc3RhdGljIGNvbXBpbGVycy5cbi8vIDIpIE5vYm9keSBzaG91bGQgcmVseSBvbiBgaW5zdGFuY2VvZiBGaWJlcmAgZm9yIHR5cGUgdGVzdGluZy4gV2Ugc2hvdWxkXG4vLyAgICBhbHdheXMga25vdyB3aGVuIGl0IGlzIGEgZmliZXIuXG4vLyAzKSBXZSBtaWdodCB3YW50IHRvIGV4cGVyaW1lbnQgd2l0aCB1c2luZyBudW1lcmljIGtleXMgc2luY2UgdGhleSBhcmUgZWFzaWVyXG4vLyAgICB0byBvcHRpbWl6ZSBpbiBhIG5vbi1KSVQgZW52aXJvbm1lbnQuXG4vLyA0KSBXZSBjYW4gZWFzaWx5IGdvIGZyb20gYSBjb25zdHJ1Y3RvciB0byBhIGNyZWF0ZUZpYmVyIG9iamVjdCBsaXRlcmFsIGlmIHRoYXRcbi8vICAgIGlzIGZhc3Rlci5cbi8vIDUpIEl0IHNob3VsZCBiZSBlYXN5IHRvIHBvcnQgdGhpcyB0byBhIEMgc3RydWN0IGFuZCBrZWVwIGEgQyBpbXBsZW1lbnRhdGlvblxuLy8gICAgY29tcGF0aWJsZS5cbnZhciBjcmVhdGVGaWJlciA9IGZ1bmN0aW9uICh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTGF6eUNvbXBvbmVudFRhZyhmaWJlciwgQ29tcG9uZW50KSB7XG4gIGlmICh0eXBlb2YgQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpID8gQ2xhc3NDb21wb25lbnRMYXp5IDogRnVuY3Rpb25hbENvbXBvbmVudExhenk7XG4gIH0gZWxzZSBpZiAoQ29tcG9uZW50ICE9PSB1bmRlZmluZWQgJiYgQ29tcG9uZW50ICE9PSBudWxsICYmIENvbXBvbmVudC4kJHR5cGVvZikge1xuICAgIHJldHVybiBGb3J3YXJkUmVmTGF6eTtcbiAgfVxuICByZXR1cm4gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDtcbn1cblxuLy8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBhbiBhbHRlcm5hdGUgZmliZXIgdG8gZG8gd29yayBvbi5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHVzZSBhIGRvdWJsZSBidWZmZXJpbmcgcG9vbGluZyB0ZWNobmlxdWUgYmVjYXVzZSB3ZSBrbm93IHRoYXQgd2UnbGxcbiAgICAvLyBvbmx5IGV2ZXIgbmVlZCBhdCBtb3N0IHR3byB2ZXJzaW9ucyBvZiBhIHRyZWUuIFdlIHBvb2wgdGhlIFwib3RoZXJcIiB1bnVzZWRcbiAgICAvLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG4gICAgLy8gZXh0cmEgb2JqZWN0cyBmb3IgdGhpbmdzIHRoYXQgYXJlIG5ldmVyIHVwZGF0ZWQuIEl0IGFsc28gYWxsb3cgdXMgdG9cbiAgICAvLyByZWNsYWltIHRoZSBleHRyYSBtZW1vcnkgaWYgbmVlZGVkLlxuICAgIHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoY3VycmVudC50YWcsIHBlbmRpbmdQcm9wcywgY3VycmVudC5rZXksIGN1cnJlbnQubW9kZSk7XG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgIHtcbiAgICAgIC8vIERFVi1vbmx5IGZpZWxkc1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgPSBjdXJyZW50Ll9kZWJ1Z0lEO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlID0gY3VycmVudC5fZGVidWdTb3VyY2U7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gY3VycmVudDtcbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcblxuICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBhbHRlcm5hdGUuXG4gICAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG5cbiAgICAvLyBUaGUgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgIHdvcmtJblByb2dyZXNzLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICAvLyBXZSBpbnRlbnRpb25hbGx5IHJlc2V0LCByYXRoZXIgdGhhbiBjb3B5LCBhY3R1YWxEdXJhdGlvbiAmIGFjdHVhbFN0YXJ0VGltZS5cbiAgICAgIC8vIFRoaXMgcHJldmVudHMgdGltZSBmcm9tIGVuZGxlc3NseSBhY2N1bXVsYXRpbmcgaW4gbmV3IGNvbW1pdHMuXG4gICAgICAvLyBUaGlzIGhhcyB0aGUgZG93bnNpZGUgb2YgcmVzZXR0aW5nIHZhbHVlcyBmb3IgZGlmZmVyZW50IHByaW9yaXR5IHJlbmRlcnMsXG4gICAgICAvLyBCdXQgd29ya3MgZm9yIHlpZWxkaW5nICh0aGUgY29tbW9uIGNhc2UpIGFuZCBzaG91bGQgc3VwcG9ydCByZXN1bWluZy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmFjdHVhbER1cmF0aW9uID0gMDtcbiAgICAgIHdvcmtJblByb2dyZXNzLmFjdHVhbFN0YXJ0VGltZSA9IC0xO1xuICAgIH1cbiAgfVxuXG4gIC8vIERvbid0IHRvdWNoaW5nIHRoZSBzdWJ0cmVlJ3MgZXhwaXJhdGlvbiB0aW1lLCB3aGljaCBoYXMgbm90IGNoYW5nZWQuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkRXhwaXJhdGlvblRpbWUgPSBjdXJyZW50LmNoaWxkRXhwaXJhdGlvblRpbWU7XG4gIGlmIChwZW5kaW5nUHJvcHMgIT09IGN1cnJlbnQucGVuZGluZ1Byb3BzKSB7XG4gICAgLy8gVGhpcyBmaWJlciBoYXMgbmV3IHByb3BzLlxuICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBmaWJlcidzIHByb3BzIGhhdmUgbm90IGNoYW5nZWQuXG4gICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBjdXJyZW50LmV4cGlyYXRpb25UaW1lO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gIHdvcmtJblByb2dyZXNzLmZpcnN0Q29udGV4dERlcGVuZGVuY3kgPSBjdXJyZW50LmZpcnN0Q29udGV4dERlcGVuZGVuY3k7XG5cbiAgLy8gVGhlc2Ugd2lsbCBiZSBvdmVycmlkZGVuIGR1cmluZyB0aGUgcGFyZW50J3MgcmVjb25jaWxpYXRpb25cbiAgd29ya0luUHJvZ3Jlc3Muc2libGluZyA9IGN1cnJlbnQuc2libGluZztcbiAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSBjdXJyZW50LnJlZjtcblxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcihpc0FzeW5jKSB7XG4gIHZhciBtb2RlID0gaXNBc3luYyA/IEFzeW5jTW9kZSB8IFN0cmljdE1vZGUgOiBOb0NvbnRleHQ7XG5cbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIgJiYgaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAvLyBBbHdheXMgY29sbGVjdCBwcm9maWxlIHRpbWluZ3Mgd2hlbiBEZXZUb29scyBhcmUgcHJlc2VudC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgRGV2VG9vbHMgdG8gc3RhcnQgY2FwdHVyaW5nIHRpbWluZyBhdCBhbnkgcG9pbnTigJNcbiAgICAvLyBXaXRob3V0IHNvbWUgbm9kZXMgaW4gdGhlIHRyZWUgaGF2aW5nIGVtcHR5IGJhc2UgdGltZXMuXG4gICAgbW9kZSB8PSBQcm9maWxlTW9kZTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgbnVsbCwgbW9kZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgbW9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIG93bmVyID0gbnVsbDtcbiAge1xuICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICB2YXIgZmliZXIgPSB2b2lkIDA7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciBwZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuXG4gIHZhciBmaWJlclRhZyA9IHZvaWQgMDtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZmliZXJUYWcgPSBzaG91bGRDb25zdHJ1Y3QodHlwZSkgPyBDbGFzc0NvbXBvbmVudCA6IEluZGV0ZXJtaW5hdGVDb21wb25lbnQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgZmliZXJUYWcgPSBIb3N0Q29tcG9uZW50O1xuICB9IGVsc2Uge1xuICAgIGdldFRhZzogc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChwZW5kaW5nUHJvcHMuY2hpbGRyZW4sIG1vZGUsIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgIGZpYmVyVGFnID0gTW9kZTtcbiAgICAgICAgbW9kZSB8PSBBc3luY01vZGUgfCBTdHJpY3RNb2RlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgZmliZXJUYWcgPSBNb2RlO1xuICAgICAgICBtb2RlIHw9IFN0cmljdE1vZGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLCBtb2RlLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgIGNhc2UgUkVBQ1RfUExBQ0VIT0xERVJfVFlQRTpcbiAgICAgICAgZmliZXJUYWcgPSBQbGFjZWhvbGRlckNvbXBvbmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gQ29udGV4dFByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGNvbnN1bWVyXG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBDb250ZXh0Q29uc3VtZXI7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBGb3J3YXJkUmVmO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBmaWJlclRhZyA9IEluZGV0ZXJtaW5hdGVDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgXCIgKyAnbmFtZWQgaW1wb3J0cy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lci50eXBlKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbyk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmaWJlciA9IGNyZWF0ZUZpYmVyKGZpYmVyVGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLnR5cGUgPSB0eXBlO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIG1vZGUsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRnJhZ21lbnQsIGVsZW1lbnRzLCBrZXksIG1vZGUpO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBwZW5kaW5nUHJvcHMuaWQgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwZW5kaW5nUHJvcHMub25SZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1Byb2ZpbGVyIG11c3Qgc3BlY2lmeSBhbiBcImlkXCIgc3RyaW5nIGFuZCBcIm9uUmVuZGVyXCIgZnVuY3Rpb24gYXMgcHJvcHMnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihQcm9maWxlciwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUgfCBQcm9maWxlTW9kZSk7XG4gIGZpYmVyLnR5cGUgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBtb2RlLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0VGV4dCwgY29udGVudCwgbnVsbCwgbW9kZSk7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RDb21wb25lbnQsIG51bGwsIG51bGwsIE5vQ29udGV4dCk7XG4gIGZpYmVyLnR5cGUgPSAnREVMRVRFRCc7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgbW9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHBlbmRpbmdQcm9wcyA9IHBvcnRhbC5jaGlsZHJlbiAhPT0gbnVsbCA/IHBvcnRhbC5jaGlsZHJlbiA6IFtdO1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0UG9ydGFsLCBwZW5kaW5nUHJvcHMsIHBvcnRhbC5rZXksIG1vZGUpO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICBmaWJlci5zdGF0ZU5vZGUgPSB7XG4gICAgY29udGFpbmVySW5mbzogcG9ydGFsLmNvbnRhaW5lckluZm8sXG4gICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLCAvLyBVc2VkIGJ5IHBlcnNpc3RlbnQgdXBkYXRlc1xuICAgIGltcGxlbWVudGF0aW9uOiBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgfTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG4vLyBVc2VkIGZvciBzdGFzaGluZyBXSVAgcHJvcGVydGllcyB0byByZXBsYXkgZmFpbGVkIHdvcmsgaW4gREVWLlxuZnVuY3Rpb24gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgRmliZXIncyBpbml0aWFsIHByb3BlcnRpZXMgd2lsbCBhbHdheXMgYmUgb3ZlcndyaXR0ZW4uXG4gICAgLy8gV2Ugb25seSB1c2UgYSBGaWJlciB0byBlbnN1cmUgdGhlIHNhbWUgaGlkZGVuIGNsYXNzIHNvIERFViBpc24ndCBzbG93LlxuICAgIHRhcmdldCA9IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIG51bGwsIG51bGwsIE5vQ29udGV4dCk7XG4gIH1cblxuICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgd3JpdHRlbiBhcyBhIGxpc3Qgb2YgYWxsIHByb3BlcnRpZXMuXG4gIC8vIFdlIHRyaWVkIHRvIHVzZSBPYmplY3QuYXNzaWduKCkgaW5zdGVhZCBidXQgdGhpcyBpcyBjYWxsZWQgaW5cbiAgLy8gdGhlIGhvdHRlc3QgcGF0aCwgYW5kIE9iamVjdC5hc3NpZ24oKSB3YXMgdG9vIHNsb3c6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI1MDJcbiAgLy8gVGhpcyBjb2RlIGlzIERFVi1vbmx5IHNvIHNpemUgaXMgbm90IGEgY29uY2Vybi5cblxuICB0YXJnZXQudGFnID0gc291cmNlLnRhZztcbiAgdGFyZ2V0LmtleSA9IHNvdXJjZS5rZXk7XG4gIHRhcmdldC50eXBlID0gc291cmNlLnR5cGU7XG4gIHRhcmdldC5zdGF0ZU5vZGUgPSBzb3VyY2Uuc3RhdGVOb2RlO1xuICB0YXJnZXQucmV0dXJuID0gc291cmNlLnJldHVybjtcbiAgdGFyZ2V0LmNoaWxkID0gc291cmNlLmNoaWxkO1xuICB0YXJnZXQuc2libGluZyA9IHNvdXJjZS5zaWJsaW5nO1xuICB0YXJnZXQuaW5kZXggPSBzb3VyY2UuaW5kZXg7XG4gIHRhcmdldC5yZWYgPSBzb3VyY2UucmVmO1xuICB0YXJnZXQucGVuZGluZ1Byb3BzID0gc291cmNlLnBlbmRpbmdQcm9wcztcbiAgdGFyZ2V0Lm1lbW9pemVkUHJvcHMgPSBzb3VyY2UubWVtb2l6ZWRQcm9wcztcbiAgdGFyZ2V0LnVwZGF0ZVF1ZXVlID0gc291cmNlLnVwZGF0ZVF1ZXVlO1xuICB0YXJnZXQubWVtb2l6ZWRTdGF0ZSA9IHNvdXJjZS5tZW1vaXplZFN0YXRlO1xuICB0YXJnZXQuZmlyc3RDb250ZXh0RGVwZW5kZW5jeSA9IHNvdXJjZS5maXJzdENvbnRleHREZXBlbmRlbmN5O1xuICB0YXJnZXQubW9kZSA9IHNvdXJjZS5tb2RlO1xuICB0YXJnZXQuZWZmZWN0VGFnID0gc291cmNlLmVmZmVjdFRhZztcbiAgdGFyZ2V0Lm5leHRFZmZlY3QgPSBzb3VyY2UubmV4dEVmZmVjdDtcbiAgdGFyZ2V0LmZpcnN0RWZmZWN0ID0gc291cmNlLmZpcnN0RWZmZWN0O1xuICB0YXJnZXQubGFzdEVmZmVjdCA9IHNvdXJjZS5sYXN0RWZmZWN0O1xuICB0YXJnZXQuZXhwaXJhdGlvblRpbWUgPSBzb3VyY2UuZXhwaXJhdGlvblRpbWU7XG4gIHRhcmdldC5jaGlsZEV4cGlyYXRpb25UaW1lID0gc291cmNlLmNoaWxkRXhwaXJhdGlvblRpbWU7XG4gIHRhcmdldC5hbHRlcm5hdGUgPSBzb3VyY2UuYWx0ZXJuYXRlO1xuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIHRhcmdldC5hY3R1YWxEdXJhdGlvbiA9IHNvdXJjZS5hY3R1YWxEdXJhdGlvbjtcbiAgICB0YXJnZXQuYWN0dWFsU3RhcnRUaW1lID0gc291cmNlLmFjdHVhbFN0YXJ0VGltZTtcbiAgICB0YXJnZXQuc2VsZkJhc2VEdXJhdGlvbiA9IHNvdXJjZS5zZWxmQmFzZUR1cmF0aW9uO1xuICAgIHRhcmdldC50cmVlQmFzZUR1cmF0aW9uID0gc291cmNlLnRyZWVCYXNlRHVyYXRpb247XG4gIH1cbiAgdGFyZ2V0Ll9kZWJ1Z0lEID0gc291cmNlLl9kZWJ1Z0lEO1xuICB0YXJnZXQuX2RlYnVnU291cmNlID0gc291cmNlLl9kZWJ1Z1NvdXJjZTtcbiAgdGFyZ2V0Ll9kZWJ1Z093bmVyID0gc291cmNlLl9kZWJ1Z093bmVyO1xuICB0YXJnZXQuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBzb3VyY2UuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmc7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lICovXG4vLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBsaWZ0ZWQgaW50byB0aGUgcmVuZGVyZXIuXG5cblxuLy8gVGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzIGFyZSBvbmx5IHVzZWQgYnkgaW50ZXJhY3Rpb24gdHJhY2luZyBidWlsZHMuXG4vLyBUaGV5IGVuYWJsZSBpbnRlcmFjdGlvbnMgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHRoZWlyIGFzeW5jIHdvcmssXG4vLyBBbmQgZXhwb3NlIGludGVyYWN0aW9uIG1ldGFkYXRhIHRvIHRoZSBSZWFjdCBEZXZUb29scyBQcm9maWxlciBwbHVnaW4uXG4vLyBOb3RlIHRoYXQgdGhlc2UgYXR0cmlidXRlcyBhcmUgb25seSBkZWZpbmVkIHdoZW4gdGhlIGVuYWJsZVNjaGVkdWxlclRyYWNpbmcgZmxhZyBpcyBlbmFibGVkLlxuXG5cbi8vIEV4cG9ydGVkIEZpYmVyUm9vdCB0eXBlIGluY2x1ZGVzIGFsbCBwcm9wZXJ0aWVzLFxuLy8gVG8gYXZvaWQgcmVxdWlyaW5nIHBvdGVudGlhbGx5IGVycm9yLXByb25lIDphbnkgY2FzdHMgdGhyb3VnaG91dCB0aGUgcHJvamVjdC5cbi8vIFByb2ZpbGluZyBwcm9wZXJ0aWVzIGFyZSBvbmx5IHNhZmUgdG8gYWNjZXNzIGluIHByb2ZpbGluZyBidWlsZHMgKHdoZW4gZW5hYmxlU2NoZWR1bGVyVHJhY2luZyBpcyB0cnVlKS5cbi8vIFRoZSB0eXBlcyBhcmUgZGVmaW5lZCBzZXBhcmF0ZWx5IHdpdGhpbiB0aGlzIGZpbGUgdG8gZW5zdXJlIHRoZXkgc3RheSBpbiBzeW5jLlxuLy8gKFdlIGRvbid0IGhhdmUgdG8gdXNlIGFuIGlubGluZSA6YW55IGNhc3Qgd2hlbiBlbmFibGVTY2hlZHVsZXJUcmFjaW5nIGlzIGRpc2FibGVkLilcblxuLyogZXNsaW50LWVuYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgaXNBc3luYywgaHlkcmF0ZSkge1xuICAvLyBDeWNsaWMgY29uc3RydWN0aW9uLiBUaGlzIGNoZWF0cyB0aGUgdHlwZSBzeXN0ZW0gcmlnaHQgbm93IGJlY2F1c2VcbiAgLy8gc3RhdGVOb2RlIGlzIGFueS5cbiAgdmFyIHVuaW5pdGlhbGl6ZWRGaWJlciA9IGNyZWF0ZUhvc3RSb290RmliZXIoaXNBc3luYyk7XG5cbiAgdmFyIHJvb3QgPSB2b2lkIDA7XG4gIGlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgcm9vdCA9IHtcbiAgICAgIGN1cnJlbnQ6IHVuaW5pdGlhbGl6ZWRGaWJlcixcbiAgICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG5cbiAgICAgIGVhcmxpZXN0UGVuZGluZ1RpbWU6IE5vV29yayxcbiAgICAgIGxhdGVzdFBlbmRpbmdUaW1lOiBOb1dvcmssXG4gICAgICBlYXJsaWVzdFN1c3BlbmRlZFRpbWU6IE5vV29yayxcbiAgICAgIGxhdGVzdFN1c3BlbmRlZFRpbWU6IE5vV29yayxcbiAgICAgIGxhdGVzdFBpbmdlZFRpbWU6IE5vV29yayxcblxuICAgICAgZGlkRXJyb3I6IGZhbHNlLFxuXG4gICAgICBwZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWU6IE5vV29yayxcbiAgICAgIGZpbmlzaGVkV29yazogbnVsbCxcbiAgICAgIHRpbWVvdXRIYW5kbGU6IG5vVGltZW91dCxcbiAgICAgIGNvbnRleHQ6IG51bGwsXG4gICAgICBwZW5kaW5nQ29udGV4dDogbnVsbCxcbiAgICAgIGh5ZHJhdGU6IGh5ZHJhdGUsXG4gICAgICBuZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbjogTm9Xb3JrLFxuICAgICAgZXhwaXJhdGlvblRpbWU6IE5vV29yayxcbiAgICAgIGZpcnN0QmF0Y2g6IG51bGwsXG4gICAgICBuZXh0U2NoZWR1bGVkUm9vdDogbnVsbCxcblxuICAgICAgaW50ZXJhY3Rpb25UaHJlYWRJRDogdHJhY2luZy51bnN0YWJsZV9nZXRUaHJlYWRJRCgpLFxuICAgICAgbWVtb2l6ZWRJbnRlcmFjdGlvbnM6IG5ldyBTZXQoKSxcbiAgICAgIHBlbmRpbmdJbnRlcmFjdGlvbk1hcDogbmV3IE1hcCgpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByb290ID0ge1xuICAgICAgY3VycmVudDogdW5pbml0aWFsaXplZEZpYmVyLFxuICAgICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCxcblxuICAgICAgZWFybGllc3RQZW5kaW5nVGltZTogTm9Xb3JrLFxuICAgICAgbGF0ZXN0UGVuZGluZ1RpbWU6IE5vV29yayxcbiAgICAgIGVhcmxpZXN0U3VzcGVuZGVkVGltZTogTm9Xb3JrLFxuICAgICAgbGF0ZXN0U3VzcGVuZGVkVGltZTogTm9Xb3JrLFxuICAgICAgbGF0ZXN0UGluZ2VkVGltZTogTm9Xb3JrLFxuXG4gICAgICBkaWRFcnJvcjogZmFsc2UsXG5cbiAgICAgIHBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgICAgZmluaXNoZWRXb3JrOiBudWxsLFxuICAgICAgdGltZW91dEhhbmRsZTogbm9UaW1lb3V0LFxuICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgIHBlbmRpbmdDb250ZXh0OiBudWxsLFxuICAgICAgaHlkcmF0ZTogaHlkcmF0ZSxcbiAgICAgIG5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uOiBOb1dvcmssXG4gICAgICBleHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgICAgZmlyc3RCYXRjaDogbnVsbCxcbiAgICAgIG5leHRTY2hlZHVsZWRSb290OiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuXG4gIC8vIFRoZSByZWFzb24gZm9yIHRoZSB3YXkgdGhlIEZsb3cgdHlwZXMgYXJlIHN0cnVjdHVyZWQgaW4gdGhpcyBmaWxlLFxuICAvLyBJcyB0byBhdm9pZCBuZWVkaW5nIDphbnkgY2FzdHMgZXZlcnl3aGVyZSBpbnRlcmFjdGlvbiB0cmFjaW5nIGZpZWxkcyBhcmUgdXNlZC5cbiAgLy8gVW5mb3J0dW5hdGVseSB0aGF0IHJlcXVpcmVzIGFuIDphbnkgY2FzdCBmb3Igbm9uLWludGVyYWN0aW9uIHRyYWNpbmcgY2FwYWJsZSBidWlsZHMuXG4gIC8vICRGbG93Rml4TWUgUmVtb3ZlIHRoaXMgOmFueSBjYXN0IGFuZCByZXBsYWNlIGl0IHdpdGggc29tZXRoaW5nIGJldHRlci5cbiAgcmV0dXJuIHJvb3Q7XG59XG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYGxvd1ByaW9yaXR5V2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxudmFyIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzID0ge1xuICBkaXNjYXJkUGVuZGluZ1dhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgZmx1c2hQZW5kaW5nRGVwcmVjYXRpb25XYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG4gIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgcmVjb3JkRGVwcmVjYXRpb25XYXJuaW5nczogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIHJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7fSxcbiAgcmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHt9LFxuICBmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fVxufTtcblxue1xuICB2YXIgTElGRUNZQ0xFX1NVR0dFU1RJT05TID0ge1xuICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ6ICdjb21wb25lbnREaWRNb3VudCcsXG4gICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6ICdzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJyxcbiAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZTogJ2NvbXBvbmVudERpZFVwZGF0ZSdcbiAgfTtcblxuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBuZXcgTWFwKCk7XG4gIHZhciBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCk7XG5cbiAgLy8gVHJhY2tzIGNvbXBvbmVudHMgd2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dC5cbiAgdmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzID0gbmV3IFNldCgpO1xuICB2YXIgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyA9IG5ldyBTZXQoKTtcbiAgdmFyIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQgPSBuZXcgU2V0KCk7XG5cbiAgdmFyIHNldFRvU29ydGVkU3RyaW5nID0gZnVuY3Rpb24gKHNldCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgYXJyYXkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFycmF5LnNvcnQoKS5qb2luKCcsICcpO1xuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmRpc2NhcmRQZW5kaW5nV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBuZXcgTWFwKCk7XG4gICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpO1xuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIHBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChsaWZlY3ljbGVXYXJuaW5nc01hcCwgc3RyaWN0Um9vdCkge1xuICAgICAgdmFyIGxpZmVjeWNsZXNXYXJuaW5nTWVzYWdlcyA9IFtdO1xuXG4gICAgICBPYmplY3Qua2V5cyhsaWZlY3ljbGVXYXJuaW5nc01hcCkuZm9yRWFjaChmdW5jdGlvbiAobGlmZWN5Y2xlKSB7XG4gICAgICAgIHZhciBsaWZlY3ljbGVXYXJuaW5ncyA9IGxpZmVjeWNsZVdhcm5pbmdzTWFwW2xpZmVjeWNsZV07XG4gICAgICAgIGlmIChsaWZlY3ljbGVXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgIGxpZmVjeWNsZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgICBjb21wb25lbnROYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBmb3JtYXR0ZWQgPSBsaWZlY3ljbGUucmVwbGFjZSgnVU5TQUZFXycsICcnKTtcbiAgICAgICAgICB2YXIgc3VnZ2VzdGlvbiA9IExJRkVDWUNMRV9TVUdHRVNUSU9OU1tsaWZlY3ljbGVdO1xuICAgICAgICAgIHZhciBzb3J0ZWRDb21wb25lbnROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudE5hbWVzKTtcblxuICAgICAgICAgIGxpZmVjeWNsZXNXYXJuaW5nTWVzYWdlcy5wdXNoKGZvcm1hdHRlZCArICc6IFBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzIHRvIHVzZSAnICsgKHN1Z2dlc3Rpb24gKyAnIGluc3RlYWQ6ICcgKyBzb3J0ZWRDb21wb25lbnROYW1lcykpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGxpZmVjeWNsZXNXYXJuaW5nTWVzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBzdHJpY3RSb290Q29tcG9uZW50U3RhY2sgPSBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc3RyaWN0Um9vdCk7XG5cbiAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnVW5zYWZlIGxpZmVjeWNsZSBtZXRob2RzIHdlcmUgZm91bmQgd2l0aGluIGEgc3RyaWN0LW1vZGUgdHJlZTolcycgKyAnXFxuXFxuJXMnICsgJ1xcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6JyArICdcXG5odHRwczovL2ZiLm1lL3JlYWN0LXN0cmljdC1tb2RlLXdhcm5pbmdzJywgc3RyaWN0Um9vdENvbXBvbmVudFN0YWNrLCBsaWZlY3ljbGVzV2FybmluZ01lc2FnZXMuam9pbignXFxuXFxuJykpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gbmV3IE1hcCgpO1xuICB9O1xuXG4gIHZhciBmaW5kU3RyaWN0Um9vdCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgIHZhciBtYXliZVN0cmljdFJvb3QgPSBudWxsO1xuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgbWF5YmVTdHJpY3RSb290ID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF5YmVTdHJpY3RSb290O1xuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgdW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcodW5pcXVlTmFtZXMpO1xuXG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ2NvbXBvbmVudFdpbGxNb3VudCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi4gJyArICdVc2UgY29tcG9uZW50RGlkTW91bnQgaW5zdGVhZC4gQXMgYSB0ZW1wb3Jhcnkgd29ya2Fyb3VuZCwgJyArICd5b3UgY2FuIHJlbmFtZSB0byBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50LicgKyAnXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1hc3luYy1jb21wb25lbnQtbGlmZWN5Y2xlLWhvb2tzJywgc29ydGVkTmFtZXMpO1xuXG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgX3VuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBfdW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIF9zb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKF91bmlxdWVOYW1lcyk7XG5cbiAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi4gJyArICdVc2Ugc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyBpbnN0ZWFkLicgKyAnXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1hc3luYy1jb21wb25lbnQtbGlmZWN5Y2xlLWhvb2tzJywgX3NvcnRlZE5hbWVzKTtcblxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBfdW5pcXVlTmFtZXMyID0gbmV3IFNldCgpO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBfdW5pcXVlTmFtZXMyLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBfc29ydGVkTmFtZXMyID0gc2V0VG9Tb3J0ZWRTdHJpbmcoX3VuaXF1ZU5hbWVzMik7XG5cbiAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnY29tcG9uZW50V2lsbFVwZGF0ZSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi4gJyArICdVc2UgY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuIEFzIGEgdGVtcG9yYXJ5IHdvcmthcm91bmQsICcgKyAneW91IGNhbiByZW5hbWUgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUuJyArICdcXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnICsgJ1xcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6JyArICdcXG5odHRwczovL2ZiLm1lL3JlYWN0LWFzeW5jLWNvbXBvbmVudC1saWZlY3ljbGUtaG9va3MnLCBfc29ydGVkTmFtZXMyKTtcblxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmREZXByZWNhdGlvbldhcm5pbmdzID0gZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge1xuICAgIC8vIERlZHVwIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cbiAgICBpZiAoZGlkV2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMuaGFzKGZpYmVyLnR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRG9uJ3Qgd2FybiBhYm91dCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgdmFyIHN0cmljdFJvb3QgPSBmaW5kU3RyaWN0Um9vdChmaWJlcik7XG4gICAgaWYgKHN0cmljdFJvb3QgPT09IG51bGwpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0V4cGVjdGVkIHRvIGZpbmQgYSBTdHJpY3RNb2RlIGNvbXBvbmVudCBpbiBhIHN0cmljdCBtb2RlIHRyZWUuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG4gICAgLy8gVGhpcyBpcyBkaWZmaWN1bHQgdG8gdHJhY2sgYW55IG90aGVyIHdheSBzaW5jZSBjb21wb25lbnQgbmFtZXNcbiAgICAvLyBhcmUgb2Z0ZW4gdmFndWUgYW5kIGFyZSBsaWtlbHkgdG8gY29sbGlkZSBiZXR3ZWVuIDNyZCBwYXJ0eSBsaWJyYXJpZXMuXG4gICAgLy8gQW4gZXhwYW5kIHByb3BlcnR5IGlzIHByb2JhYmx5IG9rYXkgdG8gdXNlIGhlcmUgc2luY2UgaXQncyBERVYtb25seSxcbiAgICAvLyBhbmQgd2lsbCBvbmx5IGJlIHNldCBpbiB0aGUgZXZlbnQgb2Ygc2VyaW91cyB3YXJuaW5ncy5cbiAgICBpZiAoZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5oYXMoZmliZXIudHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FybmluZ3NGb3JSb290ID0gdm9pZCAwO1xuICAgIGlmICghcGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzLmhhcyhzdHJpY3RSb290KSkge1xuICAgICAgd2FybmluZ3NGb3JSb290ID0ge1xuICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50OiBbXSxcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IFtdLFxuICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZTogW11cbiAgICAgIH07XG5cbiAgICAgIHBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncy5zZXQoc3RyaWN0Um9vdCwgd2FybmluZ3NGb3JSb290KTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZ3NGb3JSb290ID0gcGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzLmdldChzdHJpY3RSb290KTtcbiAgICB9XG5cbiAgICB2YXIgdW5zYWZlTGlmZWN5Y2xlcyA9IFtdO1xuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlIHx8IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB1bnNhZmVMaWZlY3ljbGVzLnB1c2goJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSB8fCB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHVuc2FmZUxpZmVjeWNsZXMucHVzaCgnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSB8fCB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHVuc2FmZUxpZmVjeWNsZXMucHVzaCgnVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICB9XG5cbiAgICBpZiAodW5zYWZlTGlmZWN5Y2xlcy5sZW5ndGggPiAwKSB7XG4gICAgICB1bnNhZmVMaWZlY3ljbGVzLmZvckVhY2goZnVuY3Rpb24gKGxpZmVjeWNsZSkge1xuICAgICAgICB3YXJuaW5nc0ZvclJvb3RbbGlmZWN5Y2xlXS5wdXNoKGZpYmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcbiAgICB2YXIgc3RyaWN0Um9vdCA9IGZpbmRTdHJpY3RSb290KGZpYmVyKTtcbiAgICBpZiAoc3RyaWN0Um9vdCA9PT0gbnVsbCkge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnRXhwZWN0ZWQgdG8gZmluZCBhIFN0cmljdE1vZGUgY29tcG9uZW50IGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERlZHVwIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cbiAgICBpZiAoZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dC5oYXMoZmliZXIudHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FybmluZ3NGb3JSb290ID0gcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmdldChzdHJpY3RSb290KTtcblxuICAgIGlmIChmaWJlci50eXBlLmNvbnRleHRUeXBlcyAhPSBudWxsIHx8IGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbCB8fCBpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAod2FybmluZ3NGb3JSb290ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FybmluZ3NGb3JSb290ID0gW107XG4gICAgICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5zZXQoc3RyaWN0Um9vdCwgd2FybmluZ3NGb3JSb290KTtcbiAgICAgIH1cbiAgICAgIHdhcm5pbmdzRm9yUm9vdC5wdXNoKGZpYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZm9yRWFjaChmdW5jdGlvbiAoZmliZXJBcnJheSwgc3RyaWN0Um9vdCkge1xuICAgICAgdmFyIHVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgZmliZXJBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKHVuaXF1ZU5hbWVzKTtcbiAgICAgIHZhciBzdHJpY3RSb290Q29tcG9uZW50U3RhY2sgPSBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc3RyaWN0Um9vdCk7XG5cbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0xlZ2FjeSBjb250ZXh0IEFQSSBoYXMgYmVlbiBkZXRlY3RlZCB3aXRoaW4gYSBzdHJpY3QtbW9kZSB0cmVlOiAlcycgKyAnXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1zdHJpY3QtbW9kZS13YXJuaW5ncycsIHN0cmljdFJvb3RDb21wb25lbnRTdGFjaywgc29ydGVkTmFtZXMpO1xuICAgIH0pO1xuICB9O1xufVxuXG4vLyBUaGlzIGxldHMgdXMgaG9vayBpbnRvIEZpYmVyIHRvIGRlYnVnIHdoYXQgaXQncyBkb2luZy5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC84MDMzLlxuLy8gVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgcHVibGljIEFQSSwgbm90IGV2ZW4gZm9yIFJlYWN0IERldlRvb2xzLlxuLy8gWW91IG1heSBvbmx5IGluamVjdCBhIGRlYnVnVG9vbCBpZiB5b3Ugd29yayBvbiBSZWFjdCBGaWJlciBpdHNlbGYuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiA9IHtcbiAgZGVidWdUb29sOiBudWxsXG59O1xuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xID0gUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbjtcblxuLy8gVE9ETzogT2Zmc2NyZWVuIHVwZGF0ZXMgc2hvdWxkIG5ldmVyIHN1c3BlbmQuIEhvd2V2ZXIsIGEgcHJvbWlzZSB0aGF0XG4vLyBzdXNwZW5kZWQgaW5zaWRlIGFuIG9mZnNjcmVlbiBzdWJ0cmVlIHNob3VsZCBiZSBhYmxlIHRvIHBpbmcgYXQgdGhlIHByaW9yaXR5XG4vLyBvZiB0aGUgb3V0ZXIgcmVuZGVyLlxuXG5mdW5jdGlvbiBtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgLy8gSWYgdGhlcmUncyBhIGdhcCBiZXR3ZWVuIGNvbXBsZXRpbmcgYSBmYWlsZWQgcm9vdCBhbmQgcmV0cnlpbmcgaXQsXG4gIC8vIGFkZGl0aW9uYWwgdXBkYXRlcyBtYXkgYmUgc2NoZWR1bGVkLiBDbGVhciBgZGlkRXJyb3JgLCBpbiBjYXNlIHRoZSB1cGRhdGVcbiAgLy8gaXMgc3VmZmljaWVudCB0byBmaXggdGhlIGVycm9yLlxuICByb290LmRpZEVycm9yID0gZmFsc2U7XG5cbiAgLy8gVXBkYXRlIHRoZSBsYXRlc3QgYW5kIGVhcmxpZXN0IHBlbmRpbmcgdGltZXNcbiAgdmFyIGVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gIGlmIChlYXJsaWVzdFBlbmRpbmdUaW1lID09PSBOb1dvcmspIHtcbiAgICAvLyBObyBvdGhlciBwZW5kaW5nIHVwZGF0ZXMuXG4gICAgcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lID0gcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICB9IGVsc2Uge1xuICAgIGlmIChlYXJsaWVzdFBlbmRpbmdUaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGVhcmxpZXN0IHBlbmRpbmcgdXBkYXRlLlxuICAgICAgcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsYXRlc3RQZW5kaW5nVGltZSA9IHJvb3QubGF0ZXN0UGVuZGluZ1RpbWU7XG4gICAgICBpZiAobGF0ZXN0UGVuZGluZ1RpbWUgPCBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBsYXRlc3QgcGVuZGluZyB1cGRhdGVcbiAgICAgICAgcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaW5kTmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24oZXhwaXJhdGlvblRpbWUsIHJvb3QpO1xufVxuXG5mdW5jdGlvbiBtYXJrQ29tbWl0dGVkUHJpb3JpdHlMZXZlbHMocm9vdCwgZWFybGllc3RSZW1haW5pbmdUaW1lKSB7XG4gIHJvb3QuZGlkRXJyb3IgPSBmYWxzZTtcblxuICBpZiAoZWFybGllc3RSZW1haW5pbmdUaW1lID09PSBOb1dvcmspIHtcbiAgICAvLyBGYXN0IHBhdGguIFRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmsuIENsZWFyIGV2ZXJ5dGhpbmcuXG4gICAgcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lID0gTm9Xb3JrO1xuICAgIHJvb3QubGF0ZXN0UGVuZGluZ1RpbWUgPSBOb1dvcms7XG4gICAgcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWUgPSBOb1dvcms7XG4gICAgcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lID0gTm9Xb3JrO1xuICAgIHJvb3QubGF0ZXN0UGluZ2VkVGltZSA9IE5vV29yaztcbiAgICBmaW5kTmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24oTm9Xb3JrLCByb290KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBMZXQncyBzZWUgaWYgdGhlIHByZXZpb3VzIGxhdGVzdCBrbm93biBwZW5kaW5nIGxldmVsIHdhcyBqdXN0IGZsdXNoZWQuXG4gIHZhciBsYXRlc3RQZW5kaW5nVGltZSA9IHJvb3QubGF0ZXN0UGVuZGluZ1RpbWU7XG4gIGlmIChsYXRlc3RQZW5kaW5nVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgaWYgKGxhdGVzdFBlbmRpbmdUaW1lIDwgZWFybGllc3RSZW1haW5pbmdUaW1lKSB7XG4gICAgICAvLyBXZSd2ZSBmbHVzaGVkIGFsbCB0aGUga25vd24gcGVuZGluZyBsZXZlbHMuXG4gICAgICByb290LmVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lID0gTm9Xb3JrO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZWFybGllc3RQZW5kaW5nVGltZSA9IHJvb3QuZWFybGllc3RQZW5kaW5nVGltZTtcbiAgICAgIGlmIChlYXJsaWVzdFBlbmRpbmdUaW1lIDwgZWFybGllc3RSZW1haW5pbmdUaW1lKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGZsdXNoZWQgdGhlIGVhcmxpZXN0IGtub3duIHBlbmRpbmcgbGV2ZWwuIFNldCB0aGlzIHRvIHRoZVxuICAgICAgICAvLyBsYXRlc3QgcGVuZGluZyB0aW1lLlxuICAgICAgICByb290LmVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE5vdyBsZXQncyBoYW5kbGUgdGhlIGVhcmxpZXN0IHJlbWFpbmluZyBsZXZlbCBpbiB0aGUgd2hvbGUgdHJlZS4gV2UgbmVlZCB0b1xuICAvLyBkZWNpZGUgd2hldGhlciB0byB0cmVhdCBpdCBhcyBhIHBlbmRpbmcgbGV2ZWwgb3IgYXMgc3VzcGVuZGVkLiBDaGVja1xuICAvLyBpdCBmYWxscyB3aXRoaW4gdGhlIHJhbmdlIG9mIGtub3duIHN1c3BlbmRlZCBsZXZlbHMuXG5cbiAgdmFyIGVhcmxpZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lO1xuICBpZiAoZWFybGllc3RTdXNwZW5kZWRUaW1lID09PSBOb1dvcmspIHtcbiAgICAvLyBUaGVyZSdzIG5vIHN1c3BlbmRlZCB3b3JrLiBUcmVhdCB0aGUgZWFybGllc3QgcmVtYWluaW5nIGxldmVsIGFzIGFcbiAgICAvLyBwZW5kaW5nIGxldmVsLlxuICAgIG1hcmtQZW5kaW5nUHJpb3JpdHlMZXZlbChyb290LCBlYXJsaWVzdFJlbWFpbmluZ1RpbWUpO1xuICAgIGZpbmROZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbihOb1dvcmssIHJvb3QpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsYXRlc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lO1xuICBpZiAoZWFybGllc3RSZW1haW5pbmdUaW1lID4gbGF0ZXN0U3VzcGVuZGVkVGltZSkge1xuICAgIC8vIFRoZSBlYXJsaWVzdCByZW1haW5pbmcgbGV2ZWwgaXMgbGF0ZXIgdGhhbiBhbGwgdGhlIHN1c3BlbmRlZCB3b3JrLiBUaGF0XG4gICAgLy8gbWVhbnMgd2UndmUgZmx1c2hlZCBhbGwgdGhlIHN1c3BlbmRlZCB3b3JrLlxuICAgIHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lID0gTm9Xb3JrO1xuICAgIHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZSA9IE5vV29yaztcbiAgICByb290LmxhdGVzdFBpbmdlZFRpbWUgPSBOb1dvcms7XG5cbiAgICAvLyBUaGVyZSdzIG5vIHN1c3BlbmRlZCB3b3JrLiBUcmVhdCB0aGUgZWFybGllc3QgcmVtYWluaW5nIGxldmVsIGFzIGFcbiAgICAvLyBwZW5kaW5nIGxldmVsLlxuICAgIG1hcmtQZW5kaW5nUHJpb3JpdHlMZXZlbChyb290LCBlYXJsaWVzdFJlbWFpbmluZ1RpbWUpO1xuICAgIGZpbmROZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbihOb1dvcmssIHJvb3QpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlYXJsaWVzdFJlbWFpbmluZ1RpbWUgPCBlYXJsaWVzdFN1c3BlbmRlZFRpbWUpIHtcbiAgICAvLyBUaGUgZWFybGllc3QgcmVtYWluaW5nIHRpbWUgaXMgZWFybGllciB0aGFuIGFsbCB0aGUgc3VzcGVuZGVkIHdvcmsuXG4gICAgLy8gVHJlYXQgaXQgYXMgYSBwZW5kaW5nIHVwZGF0ZS5cbiAgICBtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgZWFybGllc3RSZW1haW5pbmdUaW1lKTtcbiAgICBmaW5kTmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24oTm9Xb3JrLCByb290KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUaGUgZWFybGllc3QgcmVtYWluaW5nIHRpbWUgZmFsbHMgd2l0aGluIHRoZSByYW5nZSBvZiBrbm93biBzdXNwZW5kZWRcbiAgLy8gbGV2ZWxzLiBXZSBzaG91bGQgdHJlYXQgdGhpcyBhcyBzdXNwZW5kZWQgd29yay5cbiAgZmluZE5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uKE5vV29yaywgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIGhhc0xvd2VyUHJpb3JpdHlXb3JrKHJvb3QsIGVycm9yZWRFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgbGF0ZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lO1xuICB2YXIgbGF0ZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZTtcbiAgdmFyIGxhdGVzdFBpbmdlZFRpbWUgPSByb290LmxhdGVzdFBpbmdlZFRpbWU7XG4gIHJldHVybiBsYXRlc3RQZW5kaW5nVGltZSAhPT0gTm9Xb3JrICYmIGxhdGVzdFBlbmRpbmdUaW1lID4gZXJyb3JlZEV4cGlyYXRpb25UaW1lIHx8IGxhdGVzdFN1c3BlbmRlZFRpbWUgIT09IE5vV29yayAmJiBsYXRlc3RTdXNwZW5kZWRUaW1lID4gZXJyb3JlZEV4cGlyYXRpb25UaW1lIHx8IGxhdGVzdFBpbmdlZFRpbWUgIT09IE5vV29yayAmJiBsYXRlc3RQaW5nZWRUaW1lID4gZXJyb3JlZEV4cGlyYXRpb25UaW1lO1xufVxuXG5mdW5jdGlvbiBpc1ByaW9yaXR5TGV2ZWxTdXNwZW5kZWQocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGVhcmxpZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lO1xuICB2YXIgbGF0ZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZTtcbiAgcmV0dXJuIGVhcmxpZXN0U3VzcGVuZGVkVGltZSAhPT0gTm9Xb3JrICYmIGV4cGlyYXRpb25UaW1lID49IGVhcmxpZXN0U3VzcGVuZGVkVGltZSAmJiBleHBpcmF0aW9uVGltZSA8PSBsYXRlc3RTdXNwZW5kZWRUaW1lO1xufVxuXG5mdW5jdGlvbiBtYXJrU3VzcGVuZGVkUHJpb3JpdHlMZXZlbChyb290LCBzdXNwZW5kZWRUaW1lKSB7XG4gIHJvb3QuZGlkRXJyb3IgPSBmYWxzZTtcbiAgY2xlYXJQaW5nKHJvb3QsIHN1c3BlbmRlZFRpbWUpO1xuXG4gIC8vIEZpcnN0LCBjaGVjayB0aGUga25vd24gcGVuZGluZyBsZXZlbHMgYW5kIHVwZGF0ZSB0aGVtIGlmIG5lZWRlZC5cbiAgdmFyIGVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gIHZhciBsYXRlc3RQZW5kaW5nVGltZSA9IHJvb3QubGF0ZXN0UGVuZGluZ1RpbWU7XG4gIGlmIChlYXJsaWVzdFBlbmRpbmdUaW1lID09PSBzdXNwZW5kZWRUaW1lKSB7XG4gICAgaWYgKGxhdGVzdFBlbmRpbmdUaW1lID09PSBzdXNwZW5kZWRUaW1lKSB7XG4gICAgICAvLyBCb3RoIGtub3duIHBlbmRpbmcgbGV2ZWxzIHdlcmUgc3VzcGVuZGVkLiBDbGVhciB0aGVtLlxuICAgICAgcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lID0gcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IE5vV29yaztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIGVhcmxpZXN0IHBlbmRpbmcgbGV2ZWwgd2FzIHN1c3BlbmRlZC4gQ2xlYXIgYnkgc2V0dGluZyBpdCB0byB0aGVcbiAgICAgIC8vIGxhdGVzdCBwZW5kaW5nIGxldmVsLlxuICAgICAgcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lID0gbGF0ZXN0UGVuZGluZ1RpbWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGxhdGVzdFBlbmRpbmdUaW1lID09PSBzdXNwZW5kZWRUaW1lKSB7XG4gICAgLy8gVGhlIGxhdGVzdCBwZW5kaW5nIGxldmVsIHdhcyBzdXNwZW5kZWQuIENsZWFyIGJ5IHNldHRpbmcgaXQgdG8gdGhlXG4gICAgLy8gbGF0ZXN0IHBlbmRpbmcgbGV2ZWwuXG4gICAgcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IGVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gIH1cblxuICAvLyBGaW5hbGx5LCB1cGRhdGUgdGhlIGtub3duIHN1c3BlbmRlZCBsZXZlbHMuXG4gIHZhciBlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPSByb290LmVhcmxpZXN0U3VzcGVuZGVkVGltZTtcbiAgdmFyIGxhdGVzdFN1c3BlbmRlZFRpbWUgPSByb290LmxhdGVzdFN1c3BlbmRlZFRpbWU7XG4gIGlmIChlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPT09IE5vV29yaykge1xuICAgIC8vIE5vIG90aGVyIHN1c3BlbmRlZCBsZXZlbHMuXG4gICAgcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWUgPSByb290LmxhdGVzdFN1c3BlbmRlZFRpbWUgPSBzdXNwZW5kZWRUaW1lO1xuICB9IGVsc2Uge1xuICAgIGlmIChlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPiBzdXNwZW5kZWRUaW1lKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBlYXJsaWVzdCBzdXNwZW5kZWQgbGV2ZWwuXG4gICAgICByb290LmVhcmxpZXN0U3VzcGVuZGVkVGltZSA9IHN1c3BlbmRlZFRpbWU7XG4gICAgfSBlbHNlIGlmIChsYXRlc3RTdXNwZW5kZWRUaW1lIDwgc3VzcGVuZGVkVGltZSkge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgbGF0ZXN0IHN1c3BlbmRlZCBsZXZlbFxuICAgICAgcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lID0gc3VzcGVuZGVkVGltZTtcbiAgICB9XG4gIH1cblxuICBmaW5kTmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24oc3VzcGVuZGVkVGltZSwgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIG1hcmtQaW5nZWRQcmlvcml0eUxldmVsKHJvb3QsIHBpbmdlZFRpbWUpIHtcbiAgcm9vdC5kaWRFcnJvciA9IGZhbHNlO1xuXG4gIC8vIFRPRE86IFdoZW4gd2UgYWRkIGJhY2sgcmVzdW1pbmcsIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBwcm9ncmVzc2VkIHdvcmtcbiAgLy8gaXMgdGhyb3duIG91dCBhbmQgbm90IHJldXNlZCBkdXJpbmcgdGhlIHJlc3RhcnRlZCByZW5kZXIuIE9uZSB3YXkgdG9cbiAgLy8gaW52YWxpZGF0ZSB0aGUgcHJvZ3Jlc3NlZCB3b3JrIGlzIHRvIHJlc3RhcnQgYXQgZXhwaXJhdGlvblRpbWUgKyAxLlxuICB2YXIgbGF0ZXN0UGluZ2VkVGltZSA9IHJvb3QubGF0ZXN0UGluZ2VkVGltZTtcbiAgaWYgKGxhdGVzdFBpbmdlZFRpbWUgPT09IE5vV29yayB8fCBsYXRlc3RQaW5nZWRUaW1lIDwgcGluZ2VkVGltZSkge1xuICAgIHJvb3QubGF0ZXN0UGluZ2VkVGltZSA9IHBpbmdlZFRpbWU7XG4gIH1cbiAgZmluZE5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uKHBpbmdlZFRpbWUsIHJvb3QpO1xufVxuXG5mdW5jdGlvbiBjbGVhclBpbmcocm9vdCwgY29tcGxldGVkVGltZSkge1xuICAvLyBUT0RPOiBUcmFjayB3aGV0aGVyIHRoZSByb290IHdhcyBwaW5nZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIElmIHNvLFxuICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBsb3NlIHRyYWNrIG9mIGl0LlxuICB2YXIgbGF0ZXN0UGluZ2VkVGltZSA9IHJvb3QubGF0ZXN0UGluZ2VkVGltZTtcbiAgaWYgKGxhdGVzdFBpbmdlZFRpbWUgIT09IE5vV29yayAmJiBsYXRlc3RQaW5nZWRUaW1lIDw9IGNvbXBsZXRlZFRpbWUpIHtcbiAgICByb290LmxhdGVzdFBpbmdlZFRpbWUgPSBOb1dvcms7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEVhcmxpZXN0T3V0c3RhbmRpbmdQcmlvcml0eUxldmVsKHJvb3QsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBlYXJsaWVzdEV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG5cbiAgdmFyIGVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gIHZhciBlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPSByb290LmVhcmxpZXN0U3VzcGVuZGVkVGltZTtcbiAgaWYgKGVhcmxpZXN0RXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBlYXJsaWVzdFBlbmRpbmdUaW1lICE9PSBOb1dvcmsgJiYgZWFybGllc3RQZW5kaW5nVGltZSA8IGVhcmxpZXN0RXhwaXJhdGlvblRpbWUpIHtcbiAgICBlYXJsaWVzdEV4cGlyYXRpb25UaW1lID0gZWFybGllc3RQZW5kaW5nVGltZTtcbiAgfVxuICBpZiAoZWFybGllc3RFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IGVhcmxpZXN0U3VzcGVuZGVkVGltZSAhPT0gTm9Xb3JrICYmIGVhcmxpZXN0U3VzcGVuZGVkVGltZSA8IGVhcmxpZXN0RXhwaXJhdGlvblRpbWUpIHtcbiAgICBlYXJsaWVzdEV4cGlyYXRpb25UaW1lID0gZWFybGllc3RTdXNwZW5kZWRUaW1lO1xuICB9XG4gIHJldHVybiBlYXJsaWVzdEV4cGlyYXRpb25UaW1lO1xufVxuXG5mdW5jdGlvbiBkaWRFeHBpcmVBdEV4cGlyYXRpb25UaW1lKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHJvb3QuZXhwaXJhdGlvblRpbWU7XG4gIGlmIChleHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIGN1cnJlbnRUaW1lID49IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhlIHJvb3QgaGFzIGV4cGlyZWQuIEZsdXNoIGFsbCB3b3JrIHVwIHRvIHRoZSBjdXJyZW50IHRpbWUuXG4gICAgcm9vdC5uZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbiA9IGN1cnJlbnRUaW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmROZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbihjb21wbGV0ZWRFeHBpcmF0aW9uVGltZSwgcm9vdCkge1xuICB2YXIgZWFybGllc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWU7XG4gIHZhciBsYXRlc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lO1xuICB2YXIgZWFybGllc3RQZW5kaW5nVGltZSA9IHJvb3QuZWFybGllc3RQZW5kaW5nVGltZTtcbiAgdmFyIGxhdGVzdFBpbmdlZFRpbWUgPSByb290LmxhdGVzdFBpbmdlZFRpbWU7XG5cbiAgLy8gV29yayBvbiB0aGUgZWFybGllc3QgcGVuZGluZyB0aW1lLiBGYWlsaW5nIHRoYXQsIHdvcmsgb24gdGhlIGxhdGVzdFxuICAvLyBwaW5nZWQgdGltZS5cbiAgdmFyIG5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uID0gZWFybGllc3RQZW5kaW5nVGltZSAhPT0gTm9Xb3JrID8gZWFybGllc3RQZW5kaW5nVGltZSA6IGxhdGVzdFBpbmdlZFRpbWU7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gcGVuZGluZyBvciBwaW5nZWQgd29yaywgY2hlY2sgaWYgdGhlcmUncyBzdXNwZW5kZWQgd29ya1xuICAvLyB0aGF0J3MgbG93ZXIgcHJpb3JpdHkgdGhhbiB3aGF0IHdlIGp1c3QgY29tcGxldGVkLlxuICBpZiAobmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24gPT09IE5vV29yayAmJiAoY29tcGxldGVkRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBsYXRlc3RTdXNwZW5kZWRUaW1lID4gY29tcGxldGVkRXhwaXJhdGlvblRpbWUpKSB7XG4gICAgLy8gVGhlIGxvd2VzdCBwcmlvcml0eSBzdXNwZW5kZWQgd29yayBpcyB0aGUgd29yayBtb3N0IGxpa2VseSB0byBiZVxuICAgIC8vIGNvbW1pdHRlZCBuZXh0LiBMZXQncyBzdGFydCByZW5kZXJpbmcgaXQgYWdhaW4sIHNvIHRoYXQgaWYgaXQgdGltZXMgb3V0LFxuICAgIC8vIGl0J3MgcmVhZHkgdG8gY29tbWl0LlxuICAgIG5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uID0gbGF0ZXN0U3VzcGVuZGVkVGltZTtcbiAgfVxuXG4gIHZhciBleHBpcmF0aW9uVGltZSA9IG5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uO1xuICBpZiAoZXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJiBlYXJsaWVzdFN1c3BlbmRlZFRpbWUgIT09IE5vV29yayAmJiBlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIEV4cGlyZSB1c2luZyB0aGUgZWFybGllc3Qga25vd24gZXhwaXJhdGlvbiB0aW1lLlxuICAgIGV4cGlyYXRpb25UaW1lID0gZWFybGllc3RTdXNwZW5kZWRUaW1lO1xuICB9XG5cbiAgcm9vdC5uZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbiA9IG5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uO1xuICByb290LmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG59XG5cbi8vIFVwZGF0ZVF1ZXVlIGlzIGEgbGlua2VkIGxpc3Qgb2YgcHJpb3JpdGl6ZWQgdXBkYXRlcy5cbi8vXG4vLyBMaWtlIGZpYmVycywgdXBkYXRlIHF1ZXVlcyBjb21lIGluIHBhaXJzOiBhIGN1cnJlbnQgcXVldWUsIHdoaWNoIHJlcHJlc2VudHNcbi8vIHRoZSB2aXNpYmxlIHN0YXRlIG9mIHRoZSBzY3JlZW4sIGFuZCBhIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIHdoaWNoIGlzXG4vLyBjYW4gYmUgbXV0YXRlZCBhbmQgcHJvY2Vzc2VkIGFzeW5jaHJvbm91c2x5IGJlZm9yZSBpdCBpcyBjb21taXR0ZWQg4oCUIGEgZm9ybVxuLy8gb2YgZG91YmxlIGJ1ZmZlcmluZy4gSWYgYSB3b3JrLWluLXByb2dyZXNzIHJlbmRlciBpcyBkaXNjYXJkZWQgYmVmb3JlXG4vLyBmaW5pc2hpbmcsIHdlIGNyZWF0ZSBhIG5ldyB3b3JrLWluLXByb2dyZXNzIGJ5IGNsb25pbmcgdGhlIGN1cnJlbnQgcXVldWUuXG4vL1xuLy8gQm90aCBxdWV1ZXMgc2hhcmUgYSBwZXJzaXN0ZW50LCBzaW5nbHktbGlua2VkIGxpc3Qgc3RydWN0dXJlLiBUbyBzY2hlZHVsZSBhblxuLy8gdXBkYXRlLCB3ZSBhcHBlbmQgaXQgdG8gdGhlIGVuZCBvZiBib3RoIHF1ZXVlcy4gRWFjaCBxdWV1ZSBtYWludGFpbnMgYVxuLy8gcG9pbnRlciB0byBmaXJzdCB1cGRhdGUgaW4gdGhlIHBlcnNpc3RlbnQgbGlzdCB0aGF0IGhhc24ndCBiZWVuIHByb2Nlc3NlZC5cbi8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHBvaW50ZXIgYWx3YXlzIGhhcyBhIHBvc2l0aW9uIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhblxuLy8gdGhlIGN1cnJlbnQgcXVldWUsIHNpbmNlIHdlIGFsd2F5cyB3b3JrIG9uIHRoYXQgb25lLiBUaGUgY3VycmVudCBxdWV1ZSdzXG4vLyBwb2ludGVyIGlzIG9ubHkgdXBkYXRlZCBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSwgd2hlbiB3ZSBzd2FwIGluIHRoZVxuLy8gd29yay1pbi1wcm9ncmVzcy5cbi8vXG4vLyBGb3IgZXhhbXBsZTpcbi8vXG4vLyAgIEN1cnJlbnQgcG9pbnRlcjogICAgICAgICAgIEEgLSBCIC0gQyAtIEQgLSBFIC0gRlxuLy8gICBXb3JrLWluLXByb2dyZXNzIHBvaW50ZXI6ICAgICAgICAgICAgICBEIC0gRSAtIEZcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBoYXNcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkIG1vcmUgdXBkYXRlcyB0aGFuIGN1cnJlbnQuXG4vL1xuLy8gVGhlIHJlYXNvbiB3ZSBhcHBlbmQgdG8gYm90aCBxdWV1ZXMgaXMgYmVjYXVzZSBvdGhlcndpc2Ugd2UgbWlnaHQgZHJvcFxuLy8gdXBkYXRlcyB3aXRob3V0IGV2ZXIgcHJvY2Vzc2luZyB0aGVtLiBGb3IgZXhhbXBsZSwgaWYgd2Ugb25seSBhZGQgdXBkYXRlcyB0b1xuLy8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIHNvbWUgdXBkYXRlcyBjb3VsZCBiZSBsb3N0IHdoZW5ldmVyIGEgd29yay1pblxuLy8gLXByb2dyZXNzIHJlbmRlciByZXN0YXJ0cyBieSBjbG9uaW5nIGZyb20gY3VycmVudC4gU2ltaWxhcmx5LCBpZiB3ZSBvbmx5IGFkZFxuLy8gdXBkYXRlcyB0byB0aGUgY3VycmVudCBxdWV1ZSwgdGhlIHVwZGF0ZXMgd2lsbCBiZSBsb3N0IHdoZW5ldmVyIGFuIGFscmVhZHlcbi8vIGluLXByb2dyZXNzIHF1ZXVlIGNvbW1pdHMgYW5kIHN3YXBzIHdpdGggdGhlIGN1cnJlbnQgcXVldWUuIEhvd2V2ZXIsIGJ5XG4vLyBhZGRpbmcgdG8gYm90aCBxdWV1ZXMsIHdlIGd1YXJhbnRlZSB0aGF0IHRoZSB1cGRhdGUgd2lsbCBiZSBwYXJ0IG9mIHRoZSBuZXh0XG4vLyB3b3JrLWluLXByb2dyZXNzLiAoQW5kIGJlY2F1c2UgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgYmVjb21lcyB0aGVcbi8vIGN1cnJlbnQgcXVldWUgb25jZSBpdCBjb21taXRzLCB0aGVyZSdzIG5vIGRhbmdlciBvZiBhcHBseWluZyB0aGUgc2FtZVxuLy8gdXBkYXRlIHR3aWNlLilcbi8vXG4vLyBQcmlvcml0aXphdGlvblxuLy8gLS0tLS0tLS0tLS0tLS1cbi8vXG4vLyBVcGRhdGVzIGFyZSBub3Qgc29ydGVkIGJ5IHByaW9yaXR5LCBidXQgYnkgaW5zZXJ0aW9uOyBuZXcgdXBkYXRlcyBhcmUgYWx3YXlzXG4vLyBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuLy9cbi8vIFRoZSBwcmlvcml0eSBpcyBzdGlsbCBpbXBvcnRhbnQsIHRob3VnaC4gV2hlbiBwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWVcbi8vIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLCBvbmx5IHRoZSB1cGRhdGVzIHdpdGggc3VmZmljaWVudCBwcmlvcml0eSBhcmVcbi8vIGluY2x1ZGVkIGluIHRoZSByZXN1bHQuIElmIHdlIHNraXAgYW4gdXBkYXRlIGJlY2F1c2UgaXQgaGFzIGluc3VmZmljaWVudFxuLy8gcHJpb3JpdHksIGl0IHJlbWFpbnMgaW4gdGhlIHF1ZXVlIHRvIGJlIHByb2Nlc3NlZCBsYXRlciwgZHVyaW5nIGEgbG93ZXJcbi8vIHByaW9yaXR5IHJlbmRlci4gQ3J1Y2lhbGx5LCBhbGwgdXBkYXRlcyBzdWJzZXF1ZW50IHRvIGEgc2tpcHBlZCB1cGRhdGUgYWxzb1xuLy8gcmVtYWluIGluIHRoZSBxdWV1ZSAqcmVnYXJkbGVzcyBvZiB0aGVpciBwcmlvcml0eSouIFRoYXQgbWVhbnMgaGlnaCBwcmlvcml0eVxuLy8gdXBkYXRlcyBhcmUgc29tZXRpbWVzIHByb2Nlc3NlZCB0d2ljZSwgYXQgdHdvIHNlcGFyYXRlIHByaW9yaXRpZXMuIFdlIGFsc29cbi8vIGtlZXAgdHJhY2sgb2YgYSBiYXNlIHN0YXRlLCB0aGF0IHJlcHJlc2VudHMgdGhlIHN0YXRlIGJlZm9yZSB0aGUgZmlyc3Rcbi8vIHVwZGF0ZSBpbiB0aGUgcXVldWUgaXMgYXBwbGllZC5cbi8vXG4vLyBGb3IgZXhhbXBsZTpcbi8vXG4vLyAgIEdpdmVuIGEgYmFzZSBzdGF0ZSBvZiAnJywgYW5kIHRoZSBmb2xsb3dpbmcgcXVldWUgb2YgdXBkYXRlc1xuLy9cbi8vICAgICBBMSAtIEIyIC0gQzEgLSBEMlxuLy9cbi8vICAgd2hlcmUgdGhlIG51bWJlciBpbmRpY2F0ZXMgdGhlIHByaW9yaXR5LCBhbmQgdGhlIHVwZGF0ZSBpcyBhcHBsaWVkIHRvIHRoZVxuLy8gICBwcmV2aW91cyBzdGF0ZSBieSBhcHBlbmRpbmcgYSBsZXR0ZXIsIFJlYWN0IHdpbGwgcHJvY2VzcyB0aGVzZSB1cGRhdGVzIGFzXG4vLyAgIHR3byBzZXBhcmF0ZSByZW5kZXJzLCBvbmUgcGVyIGRpc3RpbmN0IHByaW9yaXR5IGxldmVsOlxuLy9cbi8vICAgRmlyc3QgcmVuZGVyLCBhdCBwcmlvcml0eSAxOlxuLy8gICAgIEJhc2Ugc3RhdGU6ICcnXG4vLyAgICAgVXBkYXRlczogW0ExLCBDMV1cbi8vICAgICBSZXN1bHQgc3RhdGU6ICdBQydcbi8vXG4vLyAgIFNlY29uZCByZW5kZXIsIGF0IHByaW9yaXR5IDI6XG4vLyAgICAgQmFzZSBzdGF0ZTogJ0EnICAgICAgICAgICAgPC0gIFRoZSBiYXNlIHN0YXRlIGRvZXMgbm90IGluY2x1ZGUgQzEsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlY2F1c2UgQjIgd2FzIHNraXBwZWQuXG4vLyAgICAgVXBkYXRlczogW0IyLCBDMSwgRDJdICAgICAgPC0gIEMxIHdhcyByZWJhc2VkIG9uIHRvcCBvZiBCMlxuLy8gICAgIFJlc3VsdCBzdGF0ZTogJ0FCQ0QnXG4vL1xuLy8gQmVjYXVzZSB3ZSBwcm9jZXNzIHVwZGF0ZXMgaW4gaW5zZXJ0aW9uIG9yZGVyLCBhbmQgcmViYXNlIGhpZ2ggcHJpb3JpdHlcbi8vIHVwZGF0ZXMgd2hlbiBwcmVjZWRpbmcgdXBkYXRlcyBhcmUgc2tpcHBlZCwgdGhlIGZpbmFsIHJlc3VsdCBpcyBkZXRlcm1pbmlzdGljXG4vLyByZWdhcmRsZXNzIG9mIHByaW9yaXR5LiBJbnRlcm1lZGlhdGUgc3RhdGUgbWF5IHZhcnkgYWNjb3JkaW5nIHRvIHN5c3RlbVxuLy8gcmVzb3VyY2VzLCBidXQgdGhlIGZpbmFsIHN0YXRlIGlzIGFsd2F5cyB0aGUgc2FtZS5cblxudmFyIFVwZGF0ZVN0YXRlID0gMDtcbnZhciBSZXBsYWNlU3RhdGUgPSAxO1xudmFyIEZvcmNlVXBkYXRlID0gMjtcbnZhciBDYXB0dXJlVXBkYXRlID0gMztcblxuLy8gR2xvYmFsIHN0YXRlIHRoYXQgaXMgcmVzZXQgYXQgdGhlIGJlZ2lubmluZyBvZiBjYWxsaW5nIGBwcm9jZXNzVXBkYXRlUXVldWVgLlxuLy8gSXQgc2hvdWxkIG9ubHkgYmUgcmVhZCByaWdodCBhZnRlciBjYWxsaW5nIGBwcm9jZXNzVXBkYXRlUXVldWVgLCB2aWFcbi8vIGBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nYC5cbnZhciBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG52YXIgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IHZvaWQgMDtcbnZhciBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSB2b2lkIDA7XG52YXIgcmVzZXRDdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSB2b2lkIDA7XG57XG4gIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcbiAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbiAgcmVzZXRDdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVXBkYXRlUXVldWUoYmFzZVN0YXRlKSB7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGJhc2VTdGF0ZSxcbiAgICBmaXJzdFVwZGF0ZTogbnVsbCxcbiAgICBsYXN0VXBkYXRlOiBudWxsLFxuICAgIGZpcnN0Q2FwdHVyZWRVcGRhdGU6IG51bGwsXG4gICAgbGFzdENhcHR1cmVkVXBkYXRlOiBudWxsLFxuICAgIGZpcnN0RWZmZWN0OiBudWxsLFxuICAgIGxhc3RFZmZlY3Q6IG51bGwsXG4gICAgZmlyc3RDYXB0dXJlZEVmZmVjdDogbnVsbCxcbiAgICBsYXN0Q2FwdHVyZWRFZmZlY3Q6IG51bGxcbiAgfTtcbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG5mdW5jdGlvbiBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnRRdWV1ZSkge1xuICB2YXIgcXVldWUgPSB7XG4gICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgIGZpcnN0VXBkYXRlOiBjdXJyZW50UXVldWUuZmlyc3RVcGRhdGUsXG4gICAgbGFzdFVwZGF0ZTogY3VycmVudFF1ZXVlLmxhc3RVcGRhdGUsXG5cbiAgICAvLyBUT0RPOiBXaXRoIHJlc3VtaW5nLCBpZiB3ZSBiYWlsIG91dCBhbmQgcmVzdXNlIHRoZSBjaGlsZCB0cmVlLCB3ZSBzaG91bGRcbiAgICAvLyBrZWVwIHRoZXNlIGVmZmVjdHMuXG4gICAgZmlyc3RDYXB0dXJlZFVwZGF0ZTogbnVsbCxcbiAgICBsYXN0Q2FwdHVyZWRVcGRhdGU6IG51bGwsXG5cbiAgICBmaXJzdEVmZmVjdDogbnVsbCxcbiAgICBsYXN0RWZmZWN0OiBudWxsLFxuXG4gICAgZmlyc3RDYXB0dXJlZEVmZmVjdDogbnVsbCxcbiAgICBsYXN0Q2FwdHVyZWRFZmZlY3Q6IG51bGxcbiAgfTtcbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVcGRhdGUoZXhwaXJhdGlvblRpbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG5cbiAgICB0YWc6IFVwZGF0ZVN0YXRlLFxuICAgIHBheWxvYWQ6IG51bGwsXG4gICAgY2FsbGJhY2s6IG51bGwsXG5cbiAgICBuZXh0OiBudWxsLFxuICAgIG5leHRFZmZlY3Q6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kVXBkYXRlVG9RdWV1ZShxdWV1ZSwgdXBkYXRlKSB7XG4gIC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gIGlmIChxdWV1ZS5sYXN0VXBkYXRlID09PSBudWxsKSB7XG4gICAgLy8gUXVldWUgaXMgZW1wdHlcbiAgICBxdWV1ZS5maXJzdFVwZGF0ZSA9IHF1ZXVlLmxhc3RVcGRhdGUgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgcXVldWUubGFzdFVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIHF1ZXVlLmxhc3RVcGRhdGUgPSB1cGRhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKSB7XG4gIC8vIFVwZGF0ZSBxdWV1ZXMgYXJlIGNyZWF0ZWQgbGF6aWx5LlxuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICB2YXIgcXVldWUxID0gdm9pZCAwO1xuICB2YXIgcXVldWUyID0gdm9pZCAwO1xuICBpZiAoYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgLy8gVGhlcmUncyBvbmx5IG9uZSBmaWJlci5cbiAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgICBxdWV1ZTIgPSBudWxsO1xuICAgIGlmIChxdWV1ZTEgPT09IG51bGwpIHtcbiAgICAgIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUoZmliZXIubWVtb2l6ZWRTdGF0ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZXJlIGFyZSB0d28gb3duZXJzLlxuICAgIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgIHF1ZXVlMiA9IGFsdGVybmF0ZS51cGRhdGVRdWV1ZTtcbiAgICBpZiAocXVldWUxID09PSBudWxsKSB7XG4gICAgICBpZiAocXVldWUyID09PSBudWxsKSB7XG4gICAgICAgIC8vIE5laXRoZXIgZmliZXIgaGFzIGFuIHVwZGF0ZSBxdWV1ZS4gQ3JlYXRlIG5ldyBvbmVzLlxuICAgICAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZSA9IGNyZWF0ZVVwZGF0ZVF1ZXVlKGZpYmVyLm1lbW9pemVkU3RhdGUpO1xuICAgICAgICBxdWV1ZTIgPSBhbHRlcm5hdGUudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShhbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbmx5IG9uZSBmaWJlciBoYXMgYW4gdXBkYXRlIHF1ZXVlLiBDbG9uZSB0byBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZSA9IGNsb25lVXBkYXRlUXVldWUocXVldWUyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHF1ZXVlMiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBPbmx5IG9uZSBmaWJlciBoYXMgYW4gdXBkYXRlIHF1ZXVlLiBDbG9uZSB0byBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAgICBxdWV1ZTIgPSBhbHRlcm5hdGUudXBkYXRlUXVldWUgPSBjbG9uZVVwZGF0ZVF1ZXVlKHF1ZXVlMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCb3RoIG93bmVycyBoYXZlIGFuIHVwZGF0ZSBxdWV1ZS5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHF1ZXVlMiA9PT0gbnVsbCB8fCBxdWV1ZTEgPT09IHF1ZXVlMikge1xuICAgIC8vIFRoZXJlJ3Mgb25seSBhIHNpbmdsZSBxdWV1ZS5cbiAgICBhcHBlbmRVcGRhdGVUb1F1ZXVlKHF1ZXVlMSwgdXBkYXRlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSBhcmUgdHdvIHF1ZXVlcy4gV2UgbmVlZCB0byBhcHBlbmQgdGhlIHVwZGF0ZSB0byBib3RoIHF1ZXVlcyxcbiAgICAvLyB3aGlsZSBhY2NvdW50aW5nIGZvciB0aGUgcGVyc2lzdGVudCBzdHJ1Y3R1cmUgb2YgdGhlIGxpc3Qg4oCUIHdlIGRvbid0XG4gICAgLy8gd2FudCB0aGUgc2FtZSB1cGRhdGUgdG8gYmUgYWRkZWQgbXVsdGlwbGUgdGltZXMuXG4gICAgaWYgKHF1ZXVlMS5sYXN0VXBkYXRlID09PSBudWxsIHx8IHF1ZXVlMi5sYXN0VXBkYXRlID09PSBudWxsKSB7XG4gICAgICAvLyBPbmUgb2YgdGhlIHF1ZXVlcyBpcyBub3QgZW1wdHkuIFdlIG11c3QgYWRkIHRoZSB1cGRhdGUgdG8gYm90aCBxdWV1ZXMuXG4gICAgICBhcHBlbmRVcGRhdGVUb1F1ZXVlKHF1ZXVlMSwgdXBkYXRlKTtcbiAgICAgIGFwcGVuZFVwZGF0ZVRvUXVldWUocXVldWUyLCB1cGRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3RoIHF1ZXVlcyBhcmUgbm9uLWVtcHR5LiBUaGUgbGFzdCB1cGRhdGUgaXMgdGhlIHNhbWUgaW4gYm90aCBsaXN0cyxcbiAgICAgIC8vIGJlY2F1c2Ugb2Ygc3RydWN0dXJhbCBzaGFyaW5nLiBTbywgb25seSBhcHBlbmQgdG8gb25lIG9mIHRoZSBsaXN0cy5cbiAgICAgIGFwcGVuZFVwZGF0ZVRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAgICAgLy8gQnV0IHdlIHN0aWxsIG5lZWQgdG8gdXBkYXRlIHRoZSBgbGFzdFVwZGF0ZWAgcG9pbnRlciBvZiBxdWV1ZTIuXG4gICAgICBxdWV1ZTIubGFzdFVwZGF0ZSA9IHVwZGF0ZTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnRMYXp5KSAmJiAoY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID09PSBxdWV1ZTEgfHwgcXVldWUyICE9PSBudWxsICYmIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9PT0gcXVldWUyKSAmJiAhZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSkge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnQW4gdXBkYXRlIChzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCBvciBmb3JjZVVwZGF0ZSkgd2FzIHNjaGVkdWxlZCAnICsgJ2Zyb20gaW5zaWRlIGFuIHVwZGF0ZSBmdW5jdGlvbi4gVXBkYXRlIGZ1bmN0aW9ucyBzaG91bGQgYmUgcHVyZSwgJyArICd3aXRoIHplcm8gc2lkZS1lZmZlY3RzLiBDb25zaWRlciB1c2luZyBjb21wb25lbnREaWRVcGRhdGUgb3IgYSAnICsgJ2NhbGxiYWNrLicpO1xuICAgICAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlKSB7XG4gIC8vIENhcHR1cmVkIHVwZGF0ZXMgZ28gaW50byBhIHNlcGFyYXRlIGxpc3QsIGFuZCBvbmx5IG9uIHRoZSB3b3JrLWluLVxuICAvLyBwcm9ncmVzcyBxdWV1ZS5cbiAgdmFyIHdvcmtJblByb2dyZXNzUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgaWYgKHdvcmtJblByb2dyZXNzUXVldWUgPT09IG51bGwpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1F1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPOiBJIHB1dCB0aGlzIGhlcmUgcmF0aGVyIHRoYW4gY3JlYXRlV29ya0luUHJvZ3Jlc3Mgc28gdGhhdCB3ZSBkb24ndFxuICAgIC8vIGNsb25lIHRoZSBxdWV1ZSB1bm5lY2Vzc2FyaWx5LiBUaGVyZSdzIHByb2JhYmx5IGEgYmV0dGVyIHdheSB0b1xuICAgIC8vIHN0cnVjdHVyZSB0aGlzLlxuICAgIHdvcmtJblByb2dyZXNzUXVldWUgPSBlbnN1cmVXb3JrSW5Qcm9ncmVzc1F1ZXVlSXNBQ2xvbmUod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzUXVldWUpO1xuICB9XG5cbiAgLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgaWYgKHdvcmtJblByb2dyZXNzUXVldWUubGFzdENhcHR1cmVkVXBkYXRlID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcmVuZGVyIHBoYXNlIHVwZGF0ZVxuICAgIHdvcmtJblByb2dyZXNzUXVldWUuZmlyc3RDYXB0dXJlZFVwZGF0ZSA9IHdvcmtJblByb2dyZXNzUXVldWUubGFzdENhcHR1cmVkVXBkYXRlID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzUXVldWUubGFzdENhcHR1cmVkVXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gICAgd29ya0luUHJvZ3Jlc3NRdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGUgPSB1cGRhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5zdXJlV29ya0luUHJvZ3Jlc3NRdWV1ZUlzQUNsb25lKHdvcmtJblByb2dyZXNzLCBxdWV1ZSkge1xuICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAvLyBJZiB0aGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyBlcXVhbCB0byB0aGUgY3VycmVudCBxdWV1ZSxcbiAgICAvLyB3ZSBuZWVkIHRvIGNsb25lIGl0IGZpcnN0LlxuICAgIGlmIChxdWV1ZSA9PT0gY3VycmVudC51cGRhdGVRdWV1ZSkge1xuICAgICAgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGNsb25lVXBkYXRlUXVldWUocXVldWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcXVldWU7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlRnJvbVVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUsIHVwZGF0ZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMsIGluc3RhbmNlKSB7XG4gIHN3aXRjaCAodXBkYXRlLnRhZykge1xuICAgIGNhc2UgUmVwbGFjZVN0YXRlOlxuICAgICAge1xuICAgICAgICB2YXIgX3BheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcbiAgICAgICAgaWYgKHR5cGVvZiBfcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFVwZGF0ZXIgZnVuY3Rpb25cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8IGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgICAgICAgX3BheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3BheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0YXRlIG9iamVjdFxuICAgICAgICByZXR1cm4gX3BheWxvYWQ7XG4gICAgICB9XG4gICAgY2FzZSBDYXB0dXJlVXBkYXRlOlxuICAgICAge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG4gICAgICB9XG4gICAgLy8gSW50ZW50aW9uYWwgZmFsbHRocm91Z2hcbiAgICBjYXNlIFVwZGF0ZVN0YXRlOlxuICAgICAge1xuICAgICAgICB2YXIgX3BheWxvYWQyID0gdXBkYXRlLnBheWxvYWQ7XG4gICAgICAgIHZhciBwYXJ0aWFsU3RhdGUgPSB2b2lkIDA7XG4gICAgICAgIGlmICh0eXBlb2YgX3BheWxvYWQyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlciBmdW5jdGlvblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMgfHwgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzRm9yU3RyaWN0TW9kZSAmJiB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICAgICAgICBfcGF5bG9hZDIuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZDIuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFBhcnRpYWwgc3RhdGUgb2JqZWN0XG4gICAgICAgICAgcGFydGlhbFN0YXRlID0gX3BheWxvYWQyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBOdWxsIGFuZCB1bmRlZmluZWQgYXJlIHRyZWF0ZWQgYXMgbm8tb3BzLlxuICAgICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgICAgICAgcmV0dXJuIF9hc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgIH1cbiAgICBjYXNlIEZvcmNlVXBkYXRlOlxuICAgICAge1xuICAgICAgICBoYXNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHByZXZTdGF0ZTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgcHJvcHMsIGluc3RhbmNlLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gIHF1ZXVlID0gZW5zdXJlV29ya0luUHJvZ3Jlc3NRdWV1ZUlzQUNsb25lKHdvcmtJblByb2dyZXNzLCBxdWV1ZSk7XG5cbiAge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHF1ZXVlO1xuICB9XG5cbiAgLy8gVGhlc2UgdmFsdWVzIG1heSBjaGFuZ2UgYXMgd2UgcHJvY2VzcyB0aGUgcXVldWUuXG4gIHZhciBuZXdCYXNlU3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGU7XG4gIHZhciBuZXdGaXJzdFVwZGF0ZSA9IG51bGw7XG4gIHZhciBuZXdFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2YgdXBkYXRlcyB0byBjb21wdXRlIHRoZSByZXN1bHQuXG4gIHZhciB1cGRhdGUgPSBxdWV1ZS5maXJzdFVwZGF0ZTtcbiAgdmFyIHJlc3VsdFN0YXRlID0gbmV3QmFzZVN0YXRlO1xuICB3aGlsZSAodXBkYXRlICE9PSBudWxsKSB7XG4gICAgdmFyIHVwZGF0ZUV4cGlyYXRpb25UaW1lID0gdXBkYXRlLmV4cGlyYXRpb25UaW1lO1xuICAgIGlmICh1cGRhdGVFeHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIG5vdCBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuIFNraXAgaXQuXG4gICAgICBpZiAobmV3Rmlyc3RVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3Qgc2tpcHBlZCB1cGRhdGUuIEl0IHdpbGwgYmUgdGhlIGZpcnN0IHVwZGF0ZSBpblxuICAgICAgICAvLyB0aGUgbmV3IGxpc3QuXG4gICAgICAgIG5ld0ZpcnN0VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUgdGhhdCB3YXMgc2tpcHBlZCwgdGhlIGN1cnJlbnQgcmVzdWx0XG4gICAgICAgIC8vIGlzIHRoZSBuZXcgYmFzZSBzdGF0ZS5cbiAgICAgICAgbmV3QmFzZVN0YXRlID0gcmVzdWx0U3RhdGU7XG4gICAgICB9XG4gICAgICAvLyBTaW5jZSB0aGlzIHVwZGF0ZSB3aWxsIHJlbWFpbiBpbiB0aGUgbGlzdCwgdXBkYXRlIHRoZSByZW1haW5pbmdcbiAgICAgIC8vIGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmIChuZXdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5ld0V4cGlyYXRpb25UaW1lID4gdXBkYXRlRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSB1cGRhdGVFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuIFByb2Nlc3MgaXQgYW5kIGNvbXB1dGVcbiAgICAgIC8vIGEgbmV3IHJlc3VsdC5cbiAgICAgIHJlc3VsdFN0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgdXBkYXRlLCByZXN1bHRTdGF0ZSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgICAgIHZhciBfY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG4gICAgICBpZiAoX2NhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgICAgICAgLy8gU2V0IHRoaXMgdG8gbnVsbCwgaW4gY2FzZSBpdCB3YXMgbXV0YXRlZCBkdXJpbmcgYW4gYWJvcnRlZCByZW5kZXIuXG4gICAgICAgIHVwZGF0ZS5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKHF1ZXVlLmxhc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICBxdWV1ZS5maXJzdEVmZmVjdCA9IHF1ZXVlLmxhc3RFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVldWUubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gdXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLmxhc3RFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ29udGludWUgdG8gdGhlIG5leHQgdXBkYXRlLlxuICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICB9XG5cbiAgLy8gU2VwYXJhdGVseSwgaXRlcmF0ZSB0aG91Z2ggdGhlIGxpc3Qgb2YgY2FwdHVyZWQgdXBkYXRlcy5cbiAgdmFyIG5ld0ZpcnN0Q2FwdHVyZWRVcGRhdGUgPSBudWxsO1xuICB1cGRhdGUgPSBxdWV1ZS5maXJzdENhcHR1cmVkVXBkYXRlO1xuICB3aGlsZSAodXBkYXRlICE9PSBudWxsKSB7XG4gICAgdmFyIF91cGRhdGVFeHBpcmF0aW9uVGltZSA9IHVwZGF0ZS5leHBpcmF0aW9uVGltZTtcbiAgICBpZiAoX3VwZGF0ZUV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgbm90IGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS4gU2tpcCBpdC5cbiAgICAgIGlmIChuZXdGaXJzdENhcHR1cmVkVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHNraXBwZWQgY2FwdHVyZWQgdXBkYXRlLiBJdCB3aWxsIGJlIHRoZSBmaXJzdFxuICAgICAgICAvLyB1cGRhdGUgaW4gdGhlIG5ldyBsaXN0LlxuICAgICAgICBuZXdGaXJzdENhcHR1cmVkVXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUgdGhhdCB3YXMgc2tpcHBlZCwgdGhlIGN1cnJlbnQgcmVzdWx0IGlzXG4gICAgICAgIC8vIHRoZSBuZXcgYmFzZSBzdGF0ZS5cbiAgICAgICAgaWYgKG5ld0ZpcnN0VXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3QmFzZVN0YXRlID0gcmVzdWx0U3RhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNpbmNlIHRoaXMgdXBkYXRlIHdpbGwgcmVtYWluIGluIHRoZSBsaXN0LCB1cGRhdGUgdGhlIHJlbWFpbmluZ1xuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgaWYgKG5ld0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV3RXhwaXJhdGlvblRpbWUgPiBfdXBkYXRlRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSBfdXBkYXRlRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LiBQcm9jZXNzIGl0IGFuZCBjb21wdXRlXG4gICAgICAvLyBhIG5ldyByZXN1bHQuXG4gICAgICByZXN1bHRTdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUsIHVwZGF0ZSwgcmVzdWx0U3RhdGUsIHByb3BzLCBpbnN0YW5jZSk7XG4gICAgICB2YXIgX2NhbGxiYWNrMiA9IHVwZGF0ZS5jYWxsYmFjaztcbiAgICAgIGlmIChfY2FsbGJhY2syICE9PSBudWxsKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgICAgICAgLy8gU2V0IHRoaXMgdG8gbnVsbCwgaW4gY2FzZSBpdCB3YXMgbXV0YXRlZCBkdXJpbmcgYW4gYWJvcnRlZCByZW5kZXIuXG4gICAgICAgIHVwZGF0ZS5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKHF1ZXVlLmxhc3RDYXB0dXJlZEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHF1ZXVlLmZpcnN0Q2FwdHVyZWRFZmZlY3QgPSBxdWV1ZS5sYXN0Q2FwdHVyZWRFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVldWUubGFzdENhcHR1cmVkRWZmZWN0Lm5leHRFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgICAgcXVldWUubGFzdENhcHR1cmVkRWZmZWN0ID0gdXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICB9XG5cbiAgaWYgKG5ld0ZpcnN0VXBkYXRlID09PSBudWxsKSB7XG4gICAgcXVldWUubGFzdFVwZGF0ZSA9IG51bGw7XG4gIH1cbiAgaWYgKG5ld0ZpcnN0Q2FwdHVyZWRVcGRhdGUgPT09IG51bGwpIHtcbiAgICBxdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGUgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgfVxuICBpZiAobmV3Rmlyc3RVcGRhdGUgPT09IG51bGwgJiYgbmV3Rmlyc3RDYXB0dXJlZFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHByb2Nlc3NlZCBldmVyeSB1cGRhdGUsIHdpdGhvdXQgc2tpcHBpbmcuIFRoYXQgbWVhbnMgdGhlIG5ldyBiYXNlXG4gICAgLy8gc3RhdGUgaXMgdGhlIHNhbWUgYXMgdGhlIHJlc3VsdCBzdGF0ZS5cbiAgICBuZXdCYXNlU3RhdGUgPSByZXN1bHRTdGF0ZTtcbiAgfVxuXG4gIHF1ZXVlLmJhc2VTdGF0ZSA9IG5ld0Jhc2VTdGF0ZTtcbiAgcXVldWUuZmlyc3RVcGRhdGUgPSBuZXdGaXJzdFVwZGF0ZTtcbiAgcXVldWUuZmlyc3RDYXB0dXJlZFVwZGF0ZSA9IG5ld0ZpcnN0Q2FwdHVyZWRVcGRhdGU7XG5cbiAgLy8gU2V0IHRoZSByZW1haW5pbmcgZXhwaXJhdGlvbiB0aW1lIHRvIGJlIHdoYXRldmVyIGlzIHJlbWFpbmluZyBpbiB0aGUgcXVldWUuXG4gIC8vIFRoaXMgc2hvdWxkIGJlIGZpbmUgYmVjYXVzZSB0aGUgb25seSB0d28gb3RoZXIgdGhpbmdzIHRoYXQgY29udHJpYnV0ZSB0b1xuICAvLyBleHBpcmF0aW9uIHRpbWUgYXJlIHByb3BzIGFuZCBjb250ZXh0LiBXZSdyZSBhbHJlYWR5IGluIHRoZSBtaWRkbGUgb2YgdGhlXG4gIC8vIGJlZ2luIHBoYXNlIGJ5IHRoZSB0aW1lIHdlIHN0YXJ0IHByb2Nlc3NpbmcgdGhlIHF1ZXVlLCBzbyB3ZSd2ZSBhbHJlYWR5XG4gIC8vIGRlYWx0IHdpdGggdGhlIHByb3BzLiBDb250ZXh0IGluIGNvbXBvbmVudHMgdGhhdCBzcGVjaWZ5XG4gIC8vIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB0cmlja3k7IGJ1dCB3ZSdsbCBoYXZlIHRvIGFjY291bnQgZm9yXG4gIC8vIHRoYXQgcmVnYXJkbGVzcy5cbiAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBuZXdFeHBpcmF0aW9uVGltZTtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHJlc3VsdFN0YXRlO1xuXG4gIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCkge1xuICAhKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjYWxsYmFjaykgOiB2b2lkIDA7XG4gIGNhbGxiYWNrLmNhbGwoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCkge1xuICBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkge1xuICByZXR1cm4gaGFzRm9yY2VVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFVwZGF0ZVF1ZXVlKGZpbmlzaGVkV29yaywgZmluaXNoZWRRdWV1ZSwgaW5zdGFuY2UsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIC8vIElmIHRoZSBmaW5pc2hlZCByZW5kZXIgaW5jbHVkZWQgY2FwdHVyZWQgdXBkYXRlcywgYW5kIHRoZXJlIGFyZSBzdGlsbFxuICAvLyBsb3dlciBwcmlvcml0eSB1cGRhdGVzIGxlZnQgb3Zlciwgd2UgbmVlZCB0byBrZWVwIHRoZSBjYXB0dXJlZCB1cGRhdGVzXG4gIC8vIGluIHRoZSBxdWV1ZSBzbyB0aGF0IHRoZXkgYXJlIHJlYmFzZWQgYW5kIG5vdCBkcm9wcGVkIG9uY2Ugd2UgcHJvY2VzcyB0aGVcbiAgLy8gcXVldWUgYWdhaW4gYXQgdGhlIGxvd2VyIHByaW9yaXR5LlxuICBpZiAoZmluaXNoZWRRdWV1ZS5maXJzdENhcHR1cmVkVXBkYXRlICE9PSBudWxsKSB7XG4gICAgLy8gSm9pbiB0aGUgY2FwdHVyZWQgdXBkYXRlIGxpc3QgdG8gdGhlIGVuZCBvZiB0aGUgbm9ybWFsIGxpc3QuXG4gICAgaWYgKGZpbmlzaGVkUXVldWUubGFzdFVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgZmluaXNoZWRRdWV1ZS5sYXN0VXBkYXRlLm5leHQgPSBmaW5pc2hlZFF1ZXVlLmZpcnN0Q2FwdHVyZWRVcGRhdGU7XG4gICAgICBmaW5pc2hlZFF1ZXVlLmxhc3RVcGRhdGUgPSBmaW5pc2hlZFF1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZTtcbiAgICB9XG4gICAgLy8gQ2xlYXIgdGhlIGxpc3Qgb2YgY2FwdHVyZWQgdXBkYXRlcy5cbiAgICBmaW5pc2hlZFF1ZXVlLmZpcnN0Q2FwdHVyZWRVcGRhdGUgPSBmaW5pc2hlZFF1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZSA9IG51bGw7XG4gIH1cblxuICAvLyBDb21taXQgdGhlIGVmZmVjdHNcbiAgY29tbWl0VXBkYXRlRWZmZWN0cyhmaW5pc2hlZFF1ZXVlLmZpcnN0RWZmZWN0LCBpbnN0YW5jZSk7XG4gIGZpbmlzaGVkUXVldWUuZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFF1ZXVlLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gIGNvbW1pdFVwZGF0ZUVmZmVjdHMoZmluaXNoZWRRdWV1ZS5maXJzdENhcHR1cmVkRWZmZWN0LCBpbnN0YW5jZSk7XG4gIGZpbmlzaGVkUXVldWUuZmlyc3RDYXB0dXJlZEVmZmVjdCA9IGZpbmlzaGVkUXVldWUubGFzdENhcHR1cmVkRWZmZWN0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tbWl0VXBkYXRlRWZmZWN0cyhlZmZlY3QsIGluc3RhbmNlKSB7XG4gIHdoaWxlIChlZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgX2NhbGxiYWNrMyA9IGVmZmVjdC5jYWxsYmFjaztcbiAgICBpZiAoX2NhbGxiYWNrMyAhPT0gbnVsbCkge1xuICAgICAgZWZmZWN0LmNhbGxiYWNrID0gbnVsbDtcbiAgICAgIGNhbGxDYWxsYmFjayhfY2FsbGJhY2szLCBpbnN0YW5jZSk7XG4gICAgfVxuICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0RWZmZWN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZSkge1xuICAvLyBJZiB0aGUgdmFsdWUgaXMgYW4gZXJyb3IsIGNhbGwgdGhpcyBmdW5jdGlvbiBpbW1lZGlhdGVseSBhZnRlciBpdCBpcyB0aHJvd25cbiAgLy8gc28gdGhlIHN0YWNrIGlzIGFjY3VyYXRlLlxuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICBzdGFjazogZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHNvdXJjZSlcbiAgfTtcbn1cblxudmFyIHZhbHVlQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xuXG52YXIgcmVuZGVyZXJTaWdpbCA9IHZvaWQgMDtcbntcbiAgLy8gVXNlIHRoaXMgdG8gZGV0ZWN0IG11bHRpcGxlIHJlbmRlcmVycyB1c2luZyB0aGUgc2FtZSBjb250ZXh0XG4gIHJlbmRlcmVyU2lnaWwgPSB7fTtcbn1cblxudmFyIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbDtcbnZhciBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xudmFyIGxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlc2V0Q29udGV4dERlcGVuZGVuY2VzKCkge1xuICAvLyBUaGlzIGlzIGNhbGxlZCByaWdodCBiZWZvcmUgUmVhY3QgeWllbGRzIGV4ZWN1dGlvbiwgdG8gZW5zdXJlIGByZWFkQ29udGV4dGBcbiAgLy8gY2Fubm90IGJlIGNhbGxlZCBvdXRzaWRlIHRoZSByZW5kZXIgcGhhc2UuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbDtcbiAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbiAgbGFzdENvbnRleHRXaXRoQWxsQml0c09ic2VydmVkID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFByb3ZpZGVyKHByb3ZpZGVyRmliZXIsIG5leHRWYWx1ZSkge1xuICB2YXIgY29udGV4dCA9IHByb3ZpZGVyRmliZXIudHlwZS5fY29udGV4dDtcblxuICBpZiAoaXNQcmltYXJ5UmVuZGVyZXIpIHtcbiAgICBwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUsIHByb3ZpZGVyRmliZXIpO1xuXG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gbmV4dFZhbHVlO1xuICAgIHtcbiAgICAgICEoY29udGV4dC5fY3VycmVudFJlbmRlcmVyID09PSB1bmRlZmluZWQgfHwgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID09PSBudWxsIHx8IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9PT0gcmVuZGVyZXJTaWdpbCkgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpIDogdm9pZCAwO1xuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlMiwgcHJvdmlkZXJGaWJlcik7XG5cbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dFZhbHVlO1xuICAgIHtcbiAgICAgICEoY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9PT0gdW5kZWZpbmVkIHx8IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPT09IG51bGwgfHwgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9PT0gcmVuZGVyZXJTaWdpbCkgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpIDogdm9pZCAwO1xuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IHJlbmRlcmVyU2lnaWw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvcFByb3ZpZGVyKHByb3ZpZGVyRmliZXIpIHtcbiAgdmFyIGN1cnJlbnRWYWx1ZSA9IHZhbHVlQ3Vyc29yLmN1cnJlbnQ7XG5cbiAgcG9wKHZhbHVlQ3Vyc29yLCBwcm92aWRlckZpYmVyKTtcblxuICB2YXIgY29udGV4dCA9IHByb3ZpZGVyRmliZXIudHlwZS5fY29udGV4dDtcbiAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBjdXJyZW50VmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlQ2hhbmdlZEJpdHMoY29udGV4dCwgbmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gIC8vIFVzZSBPYmplY3QuaXMgdG8gY29tcGFyZSB0aGUgbmV3IGNvbnRleHQgdmFsdWUgdG8gdGhlIG9sZCB2YWx1ZS4gSW5saW5lZFxuICAvLyBPYmplY3QuaXMgcG9seWZpbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICBpZiAob2xkVmFsdWUgPT09IG5ld1ZhbHVlICYmIChvbGRWYWx1ZSAhPT0gMCB8fCAxIC8gb2xkVmFsdWUgPT09IDEgLyBuZXdWYWx1ZSkgfHwgb2xkVmFsdWUgIT09IG9sZFZhbHVlICYmIG5ld1ZhbHVlICE9PSBuZXdWYWx1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICApIHtcbiAgICAgIC8vIE5vIGNoYW5nZVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICB2YXIgY2hhbmdlZEJpdHMgPSB0eXBlb2YgY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09ICdmdW5jdGlvbicgPyBjb250ZXh0Ll9jYWxjdWxhdGVDaGFuZ2VkQml0cyhvbGRWYWx1ZSwgbmV3VmFsdWUpIDogbWF4U2lnbmVkMzFCaXRJbnQ7XG5cbiAgICB7XG4gICAgICAhKChjaGFuZ2VkQml0cyAmIG1heFNpZ25lZDMxQml0SW50KSA9PT0gY2hhbmdlZEJpdHMpID8gd2FybmluZyQxKGZhbHNlLCAnY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IEV4cGVjdGVkIHRoZSByZXR1cm4gdmFsdWUgdG8gYmUgYSAnICsgJzMxLWJpdCBpbnRlZ2VyLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNoYW5nZWRCaXRzKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWRCaXRzIHwgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBjaGFuZ2VkQml0cywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGZpYmVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIGlmIChmaWJlciAhPT0gbnVsbCkge1xuICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgIGZpYmVyLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB9XG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIHZhciBuZXh0RmliZXIgPSB2b2lkIDA7XG5cbiAgICAvLyBWaXNpdCB0aGlzIGZpYmVyLlxuICAgIHZhciBkZXBlbmRlbmN5ID0gZmliZXIuZmlyc3RDb250ZXh0RGVwZW5kZW5jeTtcbiAgICBpZiAoZGVwZW5kZW5jeSAhPT0gbnVsbCkge1xuICAgICAgZG8ge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGV4dCBtYXRjaGVzLlxuICAgICAgICBpZiAoZGVwZW5kZW5jeS5jb250ZXh0ID09PSBjb250ZXh0ICYmIChkZXBlbmRlbmN5Lm9ic2VydmVkQml0cyAmIGNoYW5nZWRCaXRzKSAhPT0gMCkge1xuICAgICAgICAgIC8vIE1hdGNoISBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhpcyBmaWJlci5cblxuICAgICAgICAgIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnRMYXp5KSB7XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhIGZvcmNlIHVwZGF0ZSBvbiB0aGUgd29yay1pbi1wcm9ncmVzcy5cbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUocmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuICAgICAgICAgICAgLy8gVE9ETzogQmVjYXVzZSB3ZSBkb24ndCBoYXZlIGEgd29yay1pbi1wcm9ncmVzcywgdGhpcyB3aWxsIGFkZCB0aGVcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0byB0aGUgY3VycmVudCBmaWJlciwgdG9vLCB3aGljaCBtZWFucyBpdCB3aWxsIHBlcnNpc3QgZXZlbiBpZlxuICAgICAgICAgICAgLy8gdGhpcyByZW5kZXIgaXMgdGhyb3duIGF3YXkuIFNpbmNlIGl0J3MgYSByYWNlIGNvbmRpdGlvbiwgbm90IHN1cmUgaXQnc1xuICAgICAgICAgICAgLy8gd29ydGggZml4aW5nLlxuICAgICAgICAgICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmliZXIuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBmaWJlci5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgICBmaWJlci5leHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgKGFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IGFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSkge1xuICAgICAgICAgICAgYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY2hpbGQgZXhwaXJhdGlvbiB0aW1lIG9mIGFsbCB0aGUgYW5jZXN0b3JzLCBpbmNsdWRpbmdcbiAgICAgICAgICAvLyB0aGUgYWx0ZXJuYXRlcy5cbiAgICAgICAgICB2YXIgbm9kZSA9IGZpYmVyLnJldHVybjtcbiAgICAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYWx0ZXJuYXRlID0gbm9kZS5hbHRlcm5hdGU7XG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZEV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbm9kZS5jaGlsZEV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICAgICAgbm9kZS5jaGlsZEV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgKGFsdGVybmF0ZS5jaGlsZEV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGUuY2hpbGRFeHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiAoYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBhbHRlcm5hdGUuY2hpbGRFeHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSkge1xuICAgICAgICAgICAgICBhbHRlcm5hdGUuY2hpbGRFeHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTmVpdGhlciBhbHRlcm5hdGUgd2FzIHVwZGF0ZWQsIHdoaWNoIG1lYW5zIHRoZSByZXN0IG9mIHRoZVxuICAgICAgICAgICAgICAvLyBhbmNlc3RvciBwYXRoIGFscmVhZHkgaGFzIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgICAgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY3kubmV4dDtcbiAgICAgIH0gd2hpbGUgKGRlcGVuZGVuY3kgIT09IG51bGwpO1xuICAgIH0gZWxzZSBpZiAoZmliZXIudGFnID09PSBDb250ZXh0UHJvdmlkZXIpIHtcbiAgICAgIC8vIERvbid0IHNjYW4gZGVlcGVyIGlmIHRoaXMgaXMgYSBtYXRjaGluZyBwcm92aWRlclxuICAgICAgbmV4dEZpYmVyID0gZmliZXIudHlwZSA9PT0gd29ya0luUHJvZ3Jlc3MudHlwZSA/IG51bGwgOiBmaWJlci5jaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJhdmVyc2UgZG93bi5cbiAgICAgIG5leHRGaWJlciA9IGZpYmVyLmNoaWxkO1xuICAgIH1cblxuICAgIGlmIChuZXh0RmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgbmV4dEZpYmVyLnJldHVybiA9IGZpYmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBjaGlsZC4gVHJhdmVyc2UgdG8gbmV4dCBzaWJsaW5nLlxuICAgICAgbmV4dEZpYmVyID0gZmliZXI7XG4gICAgICB3aGlsZSAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0RmliZXIgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgLy8gV2UncmUgYmFjayB0byB0aGUgcm9vdCBvZiB0aGlzIHN1YnRyZWUuIEV4aXQuXG4gICAgICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2libGluZyA9IG5leHRGaWJlci5zaWJsaW5nO1xuICAgICAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIHNpYmxpbmcgdG8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG4gICAgICAgICAgc2libGluZy5yZXR1cm4gPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgICAgIG5leHRGaWJlciA9IHNpYmxpbmc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbW9yZSBzaWJsaW5ncy4gVHJhdmVyc2UgdXAuXG4gICAgICAgIG5leHRGaWJlciA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGZpYmVyID0gbmV4dEZpYmVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBudWxsO1xuXG4gIC8vIFJlc2V0IHRoZSB3b3JrLWluLXByb2dyZXNzIGxpc3RcbiAgd29ya0luUHJvZ3Jlc3MuZmlyc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICBpZiAobGFzdENvbnRleHRXaXRoQWxsQml0c09ic2VydmVkID09PSBjb250ZXh0KSB7XG4gICAgLy8gTm90aGluZyB0byBkby4gV2UgYWxyZWFkeSBvYnNlcnZlIGV2ZXJ5dGhpbmcgaW4gdGhpcyBjb250ZXh0LlxuICB9IGVsc2UgaWYgKG9ic2VydmVkQml0cyA9PT0gZmFsc2UgfHwgb2JzZXJ2ZWRCaXRzID09PSAwKSB7XG4gICAgLy8gRG8gbm90IG9ic2VydmUgYW55IHVwZGF0ZXMuXG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlc29sdmVkT2JzZXJ2ZWRCaXRzID0gdm9pZCAwOyAvLyBBdm9pZCBkZW9wdGluZyBvbiBvYnNlcnZhYmxlIGFyZ3VtZW50cyBvciBoZXRlcm9nZW5lb3VzIHR5cGVzLlxuICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZWRCaXRzICE9PSAnbnVtYmVyJyB8fCBvYnNlcnZlZEJpdHMgPT09IG1heFNpZ25lZDMxQml0SW50KSB7XG4gICAgICAvLyBPYnNlcnZlIGFsbCB1cGRhdGVzLlxuICAgICAgbGFzdENvbnRleHRXaXRoQWxsQml0c09ic2VydmVkID0gY29udGV4dDtcbiAgICAgIHJlc29sdmVkT2JzZXJ2ZWRCaXRzID0gbWF4U2lnbmVkMzFCaXRJbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVkT2JzZXJ2ZWRCaXRzID0gb2JzZXJ2ZWRCaXRzO1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0SXRlbSA9IHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBvYnNlcnZlZEJpdHM6IHJlc29sdmVkT2JzZXJ2ZWRCaXRzLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdENvbnRleHREZXBlbmRlbmN5ID09PSBudWxsKSB7XG4gICAgICAhKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0NvbnRleHQudW5zdGFibGVfcmVhZCgpOiBDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLCBlLmcuIGluc2lkZSB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuJykgOiB2b2lkIDA7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBkZXBlbmRlbmN5IGluIHRoZSBsaXN0XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlci5maXJzdENvbnRleHREZXBlbmRlbmN5ID0gbGFzdENvbnRleHREZXBlbmRlbmN5ID0gY29udGV4dEl0ZW07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcGVuZCBhIG5ldyBjb250ZXh0IGl0ZW0uXG4gICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBsYXN0Q29udGV4dERlcGVuZGVuY3kubmV4dCA9IGNvbnRleHRJdGVtO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXNQcmltYXJ5UmVuZGVyZXIgPyBjb250ZXh0Ll9jdXJyZW50VmFsdWUgOiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xufVxuXG52YXIgTk9fQ09OVEVYVCA9IHt9O1xuXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yJDEgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG52YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG52YXIgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVkQ29udGV4dChjKSB7XG4gICEoYyAhPT0gTk9fQ09OVEVYVCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBnZXRSb290SG9zdENvbnRhaW5lcigpIHtcbiAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgcmV0dXJuIHJvb3RJbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gcHVzaEhvc3RDb250YWluZXIoZmliZXIsIG5leHRSb290SW5zdGFuY2UpIHtcbiAgLy8gUHVzaCBjdXJyZW50IHJvb3QgaW5zdGFuY2Ugb250byB0aGUgc3RhY2s7XG4gIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHJlc2V0IHJvb3Qgd2hlbiBwb3J0YWxzIGFyZSBwb3BwZWQuXG4gIHB1c2gocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UsIGZpYmVyKTtcbiAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG5cbiAgLy8gRmluYWxseSwgd2UgbmVlZCB0byBwdXNoIHRoZSBob3N0IGNvbnRleHQgdG8gdGhlIHN0YWNrLlxuICAvLyBIb3dldmVyLCB3ZSBjYW4ndCBqdXN0IGNhbGwgZ2V0Um9vdEhvc3RDb250ZXh0KCkgYW5kIHB1c2ggaXQgYmVjYXVzZVxuICAvLyB3ZSdkIGhhdmUgYSBkaWZmZXJlbnQgbnVtYmVyIG9mIGVudHJpZXMgb24gdGhlIHN0YWNrIGRlcGVuZGluZyBvblxuICAvLyB3aGV0aGVyIGdldFJvb3RIb3N0Q29udGV4dCgpIHRocm93cyBzb21ld2hlcmUgaW4gcmVuZGVyZXIgY29kZSBvciBub3QuXG4gIC8vIFNvIHdlIHB1c2ggYW4gZW1wdHkgdmFsdWUgZmlyc3QuIFRoaXMgbGV0cyB1cyBzYWZlbHkgdW53aW5kIG9uIGVycm9ycy5cbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgTk9fQ09OVEVYVCwgZmliZXIpO1xuICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpO1xuICAvLyBOb3cgdGhhdCB3ZSBrbm93IHRoaXMgZnVuY3Rpb24gZG9lc24ndCB0aHJvdywgcmVwbGFjZSBpdC5cbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciQxLCBmaWJlcik7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIG5leHRSb290Q29udGV4dCwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RDb250ZXh0KCkge1xuICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IkMS5jdXJyZW50KTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGV4dChmaWJlcikge1xuICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IkMS5jdXJyZW50KTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlLCByb290SW5zdGFuY2UpO1xuXG4gIC8vIERvbid0IHB1c2ggdGhpcyBGaWJlcidzIGNvbnRleHQgdW5sZXNzIGl0J3MgdW5pcXVlLlxuICBpZiAoY29udGV4dCA9PT0gbmV4dENvbnRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgbmV4dENvbnRleHQsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgLy8gRG8gbm90IHBvcCB1bmxlc3MgdGhpcyBGaWJlciBwcm92aWRlZCB0aGUgY3VycmVudCBjb250ZXh0LlxuICAvLyBwdXNoSG9zdENvbnRleHQoKSBvbmx5IHB1c2hlcyBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGZpYmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciQxLCBmaWJlcik7XG4gIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG52YXIgY29tbWl0VGltZSA9IDA7XG52YXIgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcblxuZnVuY3Rpb24gZ2V0Q29tbWl0VGltZSgpIHtcbiAgcmV0dXJuIGNvbW1pdFRpbWU7XG59XG5cbmZ1bmN0aW9uIHJlY29yZENvbW1pdFRpbWUoKSB7XG4gIGlmICghZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb21taXRUaW1lID0gc2NoZWR1bGUudW5zdGFibGVfbm93KCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UHJvZmlsZXJUaW1lcihmaWJlcikge1xuICBpZiAoIWVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9maWxlclN0YXJ0VGltZSA9IHNjaGVkdWxlLnVuc3RhYmxlX25vdygpO1xuXG4gIGlmIChmaWJlci5hY3R1YWxTdGFydFRpbWUgPCAwKSB7XG4gICAgZmliZXIuYWN0dWFsU3RhcnRUaW1lID0gc2NoZWR1bGUudW5zdGFibGVfbm93KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoZmliZXIpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG59XG5cbmZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoZmliZXIsIG92ZXJyaWRlQmFzZVRpbWUpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByb2ZpbGVyU3RhcnRUaW1lID49IDApIHtcbiAgICB2YXIgZWxhcHNlZFRpbWUgPSBzY2hlZHVsZS51bnN0YWJsZV9ub3coKSAtIHByb2ZpbGVyU3RhcnRUaW1lO1xuICAgIGZpYmVyLmFjdHVhbER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgIGlmIChvdmVycmlkZUJhc2VUaW1lKSB7XG4gICAgICBmaWJlci5zZWxmQmFzZUR1cmF0aW9uID0gZWxhcHNlZFRpbWU7XG4gICAgfVxuICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG4gIH1cbn1cblxudmFyIGZha2VJbnRlcm5hbEluc3RhbmNlID0ge307XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8vIFJlYWN0LkNvbXBvbmVudCB1c2VzIGEgc2hhcmVkIGZyb3plbiBvYmplY3QgYnkgZGVmYXVsdC5cbi8vIFdlJ2xsIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSBuZWVkIHRvIGluaXRpYWxpemUgbGVnYWN5IHJlZnMuXG52YXIgZW1wdHlSZWZzT2JqZWN0ID0gbmV3IFJlYWN0LkNvbXBvbmVudCgpLnJlZnM7XG5cbnZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IHZvaWQgMDtcbnZhciB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUgPSB2b2lkIDA7XG52YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUgPSB2b2lkIDA7XG5cbntcbiAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcblxuICB2YXIgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrID0gbmV3IFNldCgpO1xuXG4gIHdhcm5PbkludmFsaWRDYWxsYmFjayQxID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgaWYgKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIga2V5ID0gY2FsbGVyTmFtZSArICdfJyArIGNhbGxiYWNrO1xuICAgIGlmICghZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmhhcyhrZXkpKSB7XG4gICAgICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSk7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUgPSBmdW5jdGlvbiAodHlwZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ0NvbXBvbmVudCc7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcbiAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gVGhpcyBpcyBzbyBncm9zcyBidXQgaXQncyBhdCBsZWFzdCBub24tY3JpdGljYWwgYW5kIGNhbiBiZSByZW1vdmVkIGlmXG4gIC8vIGl0IGNhdXNlcyBwcm9ibGVtcy4gVGhpcyBpcyBtZWFudCB0byBnaXZlIGEgbmljZXIgZXJyb3IgbWVzc2FnZSBmb3JcbiAgLy8gUmVhY3RET00xNS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihyZWFjdERPTTE2Q29tcG9uZW50LFxuICAvLyAuLi4pKSB3aGljaCBvdGhlcndpc2UgdGhyb3dzIGEgXCJfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYSBmdW5jdGlvblwiXG4gIC8vIGV4Y2VwdGlvbi5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZha2VJbnRlcm5hbEluc3RhbmNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQnLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ19wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhdmFpbGFibGUgaW4gUmVhY3QgMTYrLiBUaGlzIGxpa2VseSBtZWFucyB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgYW5kIGFyZSBhdHRlbXB0aW5nIHRvIG5lc3QgYSBSZWFjdCAxNSB0cmVlIGluc2lkZSBhIFJlYWN0IDE2IHRyZWUgdXNpbmcgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIsIHdoaWNoIGlzblxcJ3Qgc3VwcG9ydGVkLiBUcnkgdG8gbWFrZSBzdXJlIHlvdSBoYXZlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QgKGFuZCBpZGVhbGx5LCBzd2l0Y2ggdG8gUmVhY3RET00uY3JlYXRlUG9ydGFsKS4nKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZnJlZXplKGZha2VJbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV4dFByb3BzKSB7XG4gIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIHtcbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8IGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIC8vIEludm9rZSB0aGUgZnVuY3Rpb24gYW4gZXh0cmEgdGltZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG4gICAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuXG4gIHtcbiAgICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUoY3RvciwgcGFydGlhbFN0YXRlKTtcbiAgfVxuICAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuICB2YXIgbWVtb2l6ZWRTdGF0ZSA9IHBhcnRpYWxTdGF0ZSA9PT0gbnVsbCB8fCBwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCA/IHByZXZTdGF0ZSA6IF9hc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG1lbW9pemVkU3RhdGU7XG5cbiAgLy8gT25jZSB0aGUgdXBkYXRlIHF1ZXVlIGlzIGVtcHR5LCBwZXJzaXN0IHRoZSBkZXJpdmVkIHN0YXRlIG9udG8gdGhlXG4gIC8vIGJhc2Ugc3RhdGUuXG4gIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yaykge1xuICAgIHVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IG1lbW9pemVkU3RhdGU7XG4gIH1cbn1cblxudmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlciA9IHtcbiAgaXNNb3VudGVkOiBpc01vdW50ZWQsXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGluc3QpO1xuICAgIHZhciBjdXJyZW50VGltZSA9IHJlcXVlc3RDdXJyZW50VGltZSgpO1xuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudFRpbWUsIGZpYmVyKTtcblxuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXhwaXJhdGlvblRpbWUpO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2skMShjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICB9XG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICB9LFxuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoaW5zdCk7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcmVxdWVzdEN1cnJlbnRUaW1lKCk7XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50VGltZSwgZmliZXIpO1xuXG4gICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShleHBpcmF0aW9uVGltZSk7XG4gICAgdXBkYXRlLnRhZyA9IFJlcGxhY2VTdGF0ZTtcbiAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2skMShjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgfSxcbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoaW5zdCk7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcmVxdWVzdEN1cnJlbnRUaW1lKCk7XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50VGltZSwgZmliZXIpO1xuXG4gICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShleHBpcmF0aW9uVGltZSk7XG4gICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEoY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICAgICAgfVxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0TGVnYWN5Q29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmICh0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5leHRMZWdhY3lDb250ZXh0KTtcbiAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAge1xuICAgICAgIShzaG91bGRVcGRhdGUgIT09IHVuZGVmaW5lZCkgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG4gICAgdmFyIHJlbmRlclByZXNlbnQgPSBpbnN0YW5jZS5yZW5kZXI7XG5cbiAgICBpZiAoIXJlbmRlclByZXNlbnQpIHtcbiAgICAgIGlmIChjdG9yLnByb3RvdHlwZSAmJiB0eXBlb2YgY3Rvci5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbm9HZXRJbml0aWFsU3RhdGVPbkVTNiA9ICFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUgfHwgaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkIHx8IGluc3RhbmNlLnN0YXRlO1xuICAgICFub0dldEluaXRpYWxTdGF0ZU9uRVM2ID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIG5hbWUpIDogdm9pZCAwO1xuICAgIHZhciBub0dldERlZmF1bHRQcm9wc09uRVM2ID0gIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcyB8fCBpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQ7XG4gICAgIW5vR2V0RGVmYXVsdFByb3BzT25FUzYgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgbm9JbnN0YW5jZVByb3BUeXBlcyA9ICFpbnN0YW5jZS5wcm9wVHlwZXM7XG4gICAgIW5vSW5zdGFuY2VQcm9wVHlwZXMgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgbm9JbnN0YW5jZUNvbnRleHRUeXBlcyA9ICFpbnN0YW5jZS5jb250ZXh0VHlwZXM7XG4gICAgIW5vSW5zdGFuY2VDb250ZXh0VHlwZXMgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgbm9Db21wb25lbnRTaG91bGRVcGRhdGUgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlICE9PSAnZnVuY3Rpb24nO1xuICAgICFub0NvbXBvbmVudFNob3VsZFVwZGF0ZSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIG5hbWUpIDogdm9pZCAwO1xuICAgIGlmIChjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQSBwdXJlIGNvbXBvbmVudCcpO1xuICAgIH1cbiAgICB2YXIgbm9Db21wb25lbnREaWRVbm1vdW50ID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgIT09ICdmdW5jdGlvbic7XG4gICAgIW5vQ29tcG9uZW50RGlkVW5tb3VudCA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAhbm9Db21wb25lbnREaWRSZWNlaXZlUHJvcHMgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsICcgKyAndXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgJyArICdydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgbm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgIW5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vVW5zYWZlQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAhbm9VbnNhZmVDb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpIDogdm9pZCAwO1xuICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gbmV3UHJvcHM7XG4gICAgIShpbnN0YW5jZS5wcm9wcyA9PT0gdW5kZWZpbmVkIHx8ICFoYXNNdXRhdGVkUHJvcHMpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUsIG5hbWUpIDogdm9pZCAwO1xuICAgIHZhciBub0luc3RhbmNlRGVmYXVsdFByb3BzID0gIWluc3RhbmNlLmRlZmF1bHRQcm9wcztcbiAgICAhbm9JbnN0YW5jZURlZmF1bHRQcm9wcyA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1NldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4nICsgJyBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLicsIG5hbWUsIG5hbWUpIDogdm9pZCAwO1xuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICFkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuaGFzKGN0b3IpKSB7XG4gICAgICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKGN0b3IpO1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gJyArICdUaGlzIGNvbXBvbmVudCBkZWZpbmVzIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgb25seS4nLCBnZXRDb21wb25lbnROYW1lKGN0b3IpKTtcbiAgICB9XG5cbiAgICB2YXIgbm9JbnN0YW5jZUdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgIW5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgbm9JbnN0YW5jZUdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCA9IHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggIT09ICdmdW5jdGlvbic7XG4gICAgIW5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclczogZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgbm9TdGF0aWNHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IHR5cGVvZiBjdG9yLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nO1xuICAgICFub1N0YXRpY0dldFNuYXBzaG90QmVmb3JlVXBkYXRlID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgX3N0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaWYgKF9zdGF0ZSAmJiAodHlwZW9mIF9zdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheShfc3RhdGUpKSkge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgbmFtZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAhKHR5cGVvZiBjdG9yLmNoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0JykgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvICcgKyAndXNlIGdldENoaWxkQ29udGV4dCgpLicsIG5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnVwZGF0ZXIgPSBjbGFzc0NvbXBvbmVudFVwZGF0ZXI7XG4gIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAvLyBUaGUgaW5zdGFuY2UgbmVlZHMgYWNjZXNzIHRvIHRoZSBmaWJlciBzbyB0aGF0IGl0IGNhbiBzY2hlZHVsZSB1cGRhdGVzXG4gIHNldChpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICB7XG4gICAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgdmFyIGNvbnRleHRUeXBlcyA9IGN0b3IuY29udGV4dFR5cGVzO1xuICB2YXIgaXNDb250ZXh0Q29uc3VtZXIgPSBjb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY29udGV4dFR5cGVzICE9PSB1bmRlZmluZWQ7XG4gIHZhciBjb250ZXh0ID0gaXNDb250ZXh0Q29uc3VtZXIgPyBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIDogZW1wdHlDb250ZXh0T2JqZWN0O1xuXG4gIC8vIEluc3RhbnRpYXRlIHR3aWNlIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAge1xuICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMgfHwgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzRm9yU3RyaWN0TW9kZSAmJiB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTtcbiAgdmFyIHN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlICE9PSBudWxsICYmIGluc3RhbmNlLnN0YXRlICE9PSB1bmRlZmluZWQgPyBpbnN0YW5jZS5zdGF0ZSA6IG51bGw7XG4gIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nICYmIHN0YXRlID09PSBudWxsKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcbiAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAnICsgJyVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5ICcgKyAnYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuICcgKyAnVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLicsIGNvbXBvbmVudE5hbWUsIGluc3RhbmNlLnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5ldyBjb21wb25lbnQgQVBJcyBhcmUgZGVmaW5lZCwgXCJ1bnNhZmVcIiBsaWZlY3ljbGVzIHdvbid0IGJlIGNhbGxlZC5cbiAgICAvLyBXYXJuIGFib3V0IHRoZXNlIGxpZmVjeWNsZXMgaWYgdGhleSBhcmUgcHJlc2VudC5cbiAgICAvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgbWV0aG9kcyB0aG91Z2guXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBmb3VuZFdpbGxNb3VudE5hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ2NvbXBvbmVudFdpbGxNb3VudCc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9XG4gICAgICBpZiAoZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsIHx8IGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuICAgICAgICB2YXIgbmV3QXBpTmFtZSA9IHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/ICdnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKScgOiAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSc7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5oYXMoX2NvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5hZGQoX2NvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1Vuc2FmZSBsZWdhY3kgbGlmZWN5Y2xlcyB3aWxsIG5vdCBiZSBjYWxsZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgbmV3IGNvbXBvbmVudCBBUElzLlxcblxcbicgKyAnJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcbicgKyAnVGhlIGFib3ZlIGxpZmVjeWNsZXMgc2hvdWxkIGJlIHJlbW92ZWQuIExlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XFxuJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWFzeW5jLWNvbXBvbmVudC1saWZlY3ljbGUtaG9va3MnLCBfY29tcG9uZW50TmFtZSwgbmV3QXBpTmFtZSwgZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsID8gJ1xcbiAgJyArIGZvdW5kV2lsbE1vdW50TmFtZSA6ICcnLCBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsID8gJ1xcbiAgJyArIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgOiAnJywgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCA/ICdcXG4gICcgKyBmb3VuZFdpbGxVcGRhdGVOYW1lIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAvLyBSZWFjdEZpYmVyQ29udGV4dCB1c3VhbGx5IHVwZGF0ZXMgdGhpcyBjYWNoZSBidXQgY2FuJ3QgZm9yIG5ld2x5LWNyZWF0ZWQgaW5zdGFuY2VzLlxuICBpZiAoaXNDb250ZXh0Q29uc3VtZXIpIHtcbiAgICBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfVxuXG4gIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyAnICsgXCJkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICB9XG4gICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0TGVnYWN5Q29udGV4dCkge1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpO1xuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0TGVnYWN5Q29udGV4dCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0TGVnYWN5Q29udGV4dCk7XG4gIH1cbiAgc3RvcFBoYXNlVGltZXIoKTtcblxuICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IG9sZFN0YXRlKSB7XG4gICAge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzLnR5cGUpIHx8ICdDb21wb25lbnQnO1xuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcgKyBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn1cblxuLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuZnVuY3Rpb24gbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAge1xuICAgIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcblxuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIGluc3RhbmNlLnJlZnMgPSBlbXB0eVJlZnNPYmplY3Q7XG4gIGluc3RhbmNlLmNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gIHtcbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgPT09IG5ld1Byb3BzKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzOiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gYXNzaWduIHByb3BzIGRpcmVjdGx5IHRvIHN0YXRlICcgKyBcImJlY2F1c2UgdXBkYXRlcyB0byBwcm9wcyB3b24ndCBiZSByZWZsZWN0ZWQgaW4gc3RhdGUuIFwiICsgJ0luIG1vc3QgY2FzZXMsIGl0IGlzIGJldHRlciB0byB1c2UgcHJvcHMgZGlyZWN0bHkuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuXG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgIH1cblxuICAgIGlmICh3YXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcykge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkRGVwcmVjYXRpb25XYXJuaW5ncyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVF1ZXVlLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gICAgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgIC8vIHByb2Nlc3MgdGhlbSBub3cuXG4gICAgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUXVldWUsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICBpbnN0YW5jZS5wcm9wcyA9IG9sZFByb3BzO1xuXG4gIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgdmFyIG5leHRMZWdhY3lVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICB2YXIgbmV4dExlZ2FjeUNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0KTtcblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gIHZhciBoYXNOZXdMaWZlY3ljbGVzID0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbic7XG5cbiAgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuXG4gIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRMZWdhY3lDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0TGVnYWN5Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcblxuICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgbmV3U3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSA9IG9sZFN0YXRlO1xuICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgbmV3UHJvcHMsIGluc3RhbmNlLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG4gIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkpIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgfHwgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0TGVnYWN5Q29udGV4dCk7XG5cbiAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gICAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICB9XG4gICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuXG4gICAgLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgIC8vIG1lbW9pemVkIHN0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIGluc3RhbmNlLmNvbnRleHQgPSBuZXh0TGVnYWN5Q29udGV4dDtcblxuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufVxuXG4vLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuZnVuY3Rpb24gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICBpbnN0YW5jZS5wcm9wcyA9IG9sZFByb3BzO1xuXG4gIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgdmFyIG5leHRMZWdhY3lVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICB2YXIgbmV4dExlZ2FjeUNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0KTtcblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gIHZhciBoYXNOZXdMaWZlY3ljbGVzID0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbic7XG5cbiAgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuXG4gIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRMZWdhY3lDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0TGVnYWN5Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcblxuICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgbmV3U3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSA9IG9sZFN0YXRlO1xuICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgbmV3UHJvcHMsIGluc3RhbmNlLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG5cbiAgaWYgKG9sZFByb3BzID09PSBuZXdQcm9wcyAmJiBvbGRTdGF0ZSA9PT0gbmV3U3RhdGUgJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkgJiYgIWNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSkge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gU25hcHNob3Q7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgfHwgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0TGVnYWN5Q29udGV4dCk7XG5cbiAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gICAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5leHRMZWdhY3lDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0TGVnYWN5Q29udGV4dCk7XG4gICAgICB9XG4gICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNuYXBzaG90O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAob2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNuYXBzaG90O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAvLyBtZW1vaXplZCBwcm9wcy9zdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXdQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICBpbnN0YW5jZS5jb250ZXh0ID0gbmV4dExlZ2FjeUNvbnRleHQ7XG5cbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn1cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZJblN0cmljdE1vZGUgPSB2b2lkIDA7XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0gdm9pZCAwO1xudmFyIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyA9IHZvaWQgMDtcbnZhciB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCkge307XG5cbntcbiAgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZkluU3RyaWN0TW9kZSA9IHt9O1xuXG4gIC8qKlxuICAgKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gICAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICAgKiB1cGRhdGVzLlxuICAgKi9cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyA9IHt9O1xuXG4gIHdhcm5Gb3JNaXNzaW5nS2V5ID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09PSBudWxsIHx8IHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGlsZC5fc3RvcmUgfHwgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCB8fCBjaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAhKHR5cGVvZiBjaGlsZC5fc3RvcmUgPT09ICdvYmplY3QnKSA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICBjaGlsZC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLicgKyBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCk7XG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gICAgd2FybmluZyQxKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyk7XG4gIH07XG59XG5cbnZhciBpc0FycmF5JDEgPSBBcnJheS5pc0FycmF5O1xuXG5mdW5jdGlvbiBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQkJDEsIGVsZW1lbnQpIHtcbiAgdmFyIG1peGVkUmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChtaXhlZFJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgbWl4ZWRSZWYgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG1peGVkUmVmICE9PSAnb2JqZWN0Jykge1xuICAgIHtcbiAgICAgIGlmIChyZXR1cm5GaWJlci5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUocmV0dXJuRmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCc7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnQSBzdHJpbmcgcmVmLCBcIiVzXCIsIGhhcyBiZWVuIGZvdW5kIHdpdGhpbiBhIHN0cmljdCBtb2RlIHRyZWUuICcgKyAnU3RyaW5nIHJlZnMgYXJlIGEgc291cmNlIG9mIHBvdGVudGlhbCBidWdzIGFuZCBzaG91bGQgYmUgYXZvaWRlZC4gJyArICdXZSByZWNvbW1lbmQgdXNpbmcgY3JlYXRlUmVmKCkgaW5zdGVhZC4nICsgJ1xcbiVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6JyArICdcXG5odHRwczovL2ZiLm1lL3JlYWN0LXN0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBtaXhlZFJlZiwgZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHJldHVybkZpYmVyKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbGVtZW50Ll9vd25lcikge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgaW5zdCA9IHZvaWQgMDtcbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgICAhKG93bmVyRmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCB8fCBvd25lckZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnRMYXp5KSA/IGludmFyaWFudChmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHJlZnMuJykgOiB2b2lkIDA7XG4gICAgICAgIGluc3QgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIH1cbiAgICAgICFpbnN0ID8gaW52YXJpYW50KGZhbHNlLCAnTWlzc2luZyBvd25lciBmb3Igc3RyaW5nIHJlZiAlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBtaXhlZFJlZikgOiB2b2lkIDA7XG4gICAgICB2YXIgc3RyaW5nUmVmID0gJycgKyBtaXhlZFJlZjtcbiAgICAgIC8vIENoZWNrIGlmIHByZXZpb3VzIHN0cmluZyByZWYgbWF0Y2hlcyBuZXcgc3RyaW5nIHJlZlxuICAgICAgaWYgKGN1cnJlbnQkJDEgIT09IG51bGwgJiYgY3VycmVudCQkMS5yZWYgIT09IG51bGwgJiYgdHlwZW9mIGN1cnJlbnQkJDEucmVmID09PSAnZnVuY3Rpb24nICYmIGN1cnJlbnQkJDEucmVmLl9zdHJpbmdSZWYgPT09IHN0cmluZ1JlZikge1xuICAgICAgICByZXR1cm4gY3VycmVudCQkMS5yZWY7XG4gICAgICB9XG4gICAgICB2YXIgcmVmID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZWZzID0gaW5zdC5yZWZzO1xuICAgICAgICBpZiAocmVmcyA9PT0gZW1wdHlSZWZzT2JqZWN0KSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhIGxhenkgcG9vbGVkIGZyb3plbiBvYmplY3QsIHNvIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZS5cbiAgICAgICAgICByZWZzID0gaW5zdC5yZWZzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVsZXRlIHJlZnNbc3RyaW5nUmVmXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZzW3N0cmluZ1JlZl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlZi5fc3RyaW5nUmVmID0gc3RyaW5nUmVmO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgISh0eXBlb2YgbWl4ZWRSZWYgPT09ICdzdHJpbmcnKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHJlZiB0byBiZSBhIGZ1bmN0aW9uLCBhIHN0cmluZywgYW4gb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZVJlZigpLCBvciBudWxsLicpIDogdm9pZCAwO1xuICAgICAgIWVsZW1lbnQuX293bmVyID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCByZWYgd2FzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoJXMpIGJ1dCBubyBvd25lciB3YXMgc2V0LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWF5IGJlIGFkZGluZyBhIHJlZiB0byBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XFxuMi4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50XFwncyByZW5kZXIgbWV0aG9kXFxuMy4gWW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZFxcblNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1peGVkUmVmO1xufVxuXG5mdW5jdGlvbiB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKSB7XG4gIGlmIChyZXR1cm5GaWJlci50eXBlICE9PSAndGV4dGFyZWEnKSB7XG4gICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAge1xuICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCk7XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpICsgJ30nIDogbmV3Q2hpbGQsIGFkZGVuZHVtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUoKSB7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LicgKyBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCk7XG5cbiAgaWYgKG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIHdhcm5pbmckMShmYWxzZSwgJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LicpO1xufVxuXG4vLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZXhpc3RzIGJlY2F1c2UgSSBleHBlY3QgdG8gY2xvbmUgdGhlIGNvZGUgaW4gZWFjaCBwYXRoXG4vLyB0byBiZSBhYmxlIHRvIG9wdGltaXplIGVhY2ggcGF0aCBpbmRpdmlkdWFsbHkgYnkgYnJhbmNoaW5nIGVhcmx5LiBUaGlzIG5lZWRzXG4vLyBhIGNvbXBpbGVyIG9yIHdlIGNhbiBkbyBpdCBtYW51YWxseS4gSGVscGVycyB0aGF0IGRvbid0IG5lZWQgdGhpcyBicmFuY2hpbmdcbi8vIGxpdmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuZnVuY3Rpb24gQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIERlbGV0aW9ucyBhcmUgYWRkZWQgaW4gcmV2ZXJzZWQgb3JkZXIgc28gd2UgYWRkIGl0IHRvIHRoZSBmcm9udC5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmV0dXJuIGZpYmVyJ3MgZWZmZWN0IGxpc3QgaXMgZW1wdHkgZXhjZXB0IGZvclxuICAgIC8vIGRlbGV0aW9ucywgc28gd2UgY2FuIGp1c3QgYXBwZW5kIHRoZSBkZWxldGlvbiB0byB0aGUgbGlzdC4gVGhlIHJlbWFpbmluZ1xuICAgIC8vIGVmZmVjdHMgYXJlbid0IGFkZGVkIHVudGlsIHRoZSBjb21wbGV0ZSBwaGFzZS4gT25jZSB3ZSBpbXBsZW1lbnRcbiAgICAvLyByZXN1bWluZywgdGhpcyBtYXkgbm90IGJlIHRydWUuXG4gICAgdmFyIGxhc3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0O1xuICAgIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgICBsYXN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICAgIGNoaWxkVG9EZWxldGUubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEZvciB0aGUgc2hvdWxkQ2xvbmUgY2FzZSwgdGhpcyBjb3VsZCBiZSBtaWNyby1vcHRpbWl6ZWQgYSBiaXQgYnlcbiAgICAvLyBhc3N1bWluZyB0aGF0IGFmdGVyIHRoZSBmaXJzdCBjaGlsZCB3ZSd2ZSBhbHJlYWR5IGFkZGVkIGV2ZXJ5dGhpbmcuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGRUb0RlbGV0ZSAhPT0gbnVsbCkge1xuICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpO1xuICAgICAgY2hpbGRUb0RlbGV0ZSA9IGNoaWxkVG9EZWxldGUuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG4gICAgLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuICAgICAgZXhpc3RpbmdDaGlsZCA9IGV4aXN0aW5nQ2hpbGQuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gIH1cblxuICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICB2YXIgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY2xvbmUuaW5kZXggPSAwO1xuICAgIGNsb25lLnNpYmxpbmcgPSBudWxsO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SW5kZXgpIHtcbiAgICBuZXdGaWJlci5pbmRleCA9IG5ld0luZGV4O1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICAgIHZhciBjdXJyZW50JCQxID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuICAgIGlmIChjdXJyZW50JCQxICE9PSBudWxsKSB7XG4gICAgICB2YXIgb2xkSW5kZXggPSBjdXJyZW50JCQxLmluZGV4O1xuICAgICAgaWYgKG9sZEluZGV4IDwgbGFzdFBsYWNlZEluZGV4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBtb3ZlLlxuICAgICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlU2luZ2xlQ2hpbGQobmV3RmliZXIpIHtcbiAgICAvLyBUaGlzIGlzIHNpbXBsZXIgZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS4gV2Ugb25seSBuZWVkIHRvIGRvIGFcbiAgICAvLyBwbGFjZW1lbnQgZm9yIGluc2VydGluZyBuZXcgY2hpbGRyZW4uXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50JCQxLCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCQkMSA9PT0gbnVsbCB8fCBjdXJyZW50JCQxLnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5tb2RlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCQkMSwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQkJDEsIGVsZW1lbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQkJDEgIT09IG51bGwgJiYgY3VycmVudCQkMS50eXBlID09PSBlbGVtZW50LnR5cGUpIHtcbiAgICAgIC8vIE1vdmUgYmFzZWQgb24gaW5kZXhcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQkJDEsIGVsZW1lbnQucHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCQkMSwgZWxlbWVudCk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5tb2RlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCQkMSwgZWxlbWVudCk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50JCQxLCBwb3J0YWwsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQkJDEgPT09IG51bGwgfHwgY3VycmVudCQkMS50YWcgIT09IEhvc3RQb3J0YWwgfHwgY3VycmVudCQkMS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHwgY3VycmVudCQkMS5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gIT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50JCQxLCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50JCQxLCBmcmFnbWVudCwgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICAgIGlmIChjdXJyZW50JCQxID09PSBudWxsIHx8IGN1cnJlbnQkJDEudGFnICE9PSBGcmFnbWVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZyYWdtZW50LCByZXR1cm5GaWJlci5tb2RlLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50JCQxLCBmcmFnbWVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCgnJyArIG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgX2NyZWF0ZWQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBudWxsLCBuZXdDaGlsZCk7XG4gICAgICAgICAgICBfY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkMiA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgX2NyZWF0ZWQyLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkMjtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIHZhciBfY3JlYXRlZDMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgICBfY3JlYXRlZDMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIHJldHVybiBfY3JlYXRlZDM7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVXBkYXRlIHRoZSBmaWJlciBpZiB0aGUga2V5cyBtYXRjaCwgb3RoZXJ3aXNlIHJldHVybiBudWxsLlxuXG4gICAgdmFyIGtleSA9IG9sZEZpYmVyICE9PSBudWxsID8gb2xkRmliZXIua2V5IDogbnVsbDtcblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG9sZEZpYmVyLCAnJyArIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLCBzbyB3ZSBuZWl0aGVyIGhhdmUgdG8gY2hlY2sgdGhlIG9sZCBub3JcbiAgICAgIC8vIG5ldyBub2RlIGZvciB0aGUga2V5LiBJZiBib3RoIGFyZSB0ZXh0IG5vZGVzLCB0aGV5IG1hdGNoLlxuICAgICAgdmFyIG1hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgbWF0Y2hlZEZpYmVyLCAnJyArIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXkpIHx8IG51bGw7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBleHBpcmF0aW9uVGltZSwgbmV3Q2hpbGQua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXkpIHx8IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMiwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMyA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMywgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYXJucyBpZiB0aGVyZSBpcyBhIGR1cGxpY2F0ZSBvciBtaXNzaW5nIGtleVxuICAgKi9cbiAgZnVuY3Rpb24gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKSB7XG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcgfHwgY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGtub3duS2V5cztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkoY2hpbGQpO1xuICAgICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtub3duS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgha25vd25LZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCBgJXNgLiAnICsgJ0tleXMgc2hvdWxkIGJlIHVuaXF1ZSBzbyB0aGF0IGNvbXBvbmVudHMgbWFpbnRhaW4gdGhlaXIgaWRlbnRpdHkgJyArICdhY3Jvc3MgdXBkYXRlcy4gTm9uLXVuaXF1ZSBrZXlzIG1heSBjYXVzZSBjaGlsZHJlbiB0byBiZSAnICsgJ2R1cGxpY2F0ZWQgYW5kL29yIG9taXR0ZWQg4oCUIHRoZSBiZWhhdmlvciBpcyB1bnN1cHBvcnRlZCBhbmQgJyArICdjb3VsZCBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbi4nLCBrZXkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga25vd25LZXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgYWxnb3JpdGhtIGNhbid0IG9wdGltaXplIGJ5IHNlYXJjaGluZyBmcm9tIGJvdGhzIGVuZHMgc2luY2Ugd2VcbiAgICAvLyBkb24ndCBoYXZlIGJhY2twb2ludGVycyBvbiBmaWJlcnMuIEknbSB0cnlpbmcgdG8gc2VlIGhvdyBmYXIgd2UgY2FuIGdldFxuICAgIC8vIHdpdGggdGhhdCBtb2RlbC4gSWYgaXQgZW5kcyB1cCBub3QgYmVpbmcgd29ydGggdGhlIHRyYWRlb2Zmcywgd2UgY2FuXG4gICAgLy8gYWRkIGl0IGxhdGVyLlxuXG4gICAgLy8gRXZlbiB3aXRoIGEgdHdvIGVuZGVkIG9wdGltaXphdGlvbiwgd2UnZCB3YW50IHRvIG9wdGltaXplIGZvciB0aGUgY2FzZVxuICAgIC8vIHdoZXJlIHRoZXJlIGFyZSBmZXcgY2hhbmdlcyBhbmQgYnJ1dGUgZm9yY2UgdGhlIGNvbXBhcmlzb24gaW5zdGVhZCBvZlxuICAgIC8vIGdvaW5nIGZvciB0aGUgTWFwLiBJdCdkIGxpa2UgdG8gZXhwbG9yZSBoaXR0aW5nIHRoYXQgcGF0aCBmaXJzdCBpblxuICAgIC8vIGZvcndhcmQtb25seSBtb2RlIGFuZCBvbmx5IGdvIGZvciB0aGUgTWFwIG9uY2Ugd2Ugbm90aWNlIHRoYXQgd2UgbmVlZFxuICAgIC8vIGxvdHMgb2YgbG9vayBhaGVhZC4gVGhpcyBkb2Vzbid0IGhhbmRsZSByZXZlcnNhbCBhcyB3ZWxsIGFzIHR3byBlbmRlZFxuICAgIC8vIHNlYXJjaCBidXQgdGhhdCdzIHVudXN1YWwuIEJlc2lkZXMsIGZvciB0aGUgdHdvIGVuZGVkIG9wdGltaXphdGlvbiB0b1xuICAgIC8vIHdvcmsgb24gSXRlcmFibGVzLCB3ZSdkIG5lZWQgdG8gY29weSB0aGUgd2hvbGUgc2V0LlxuXG4gICAgLy8gSW4gdGhpcyBmaXJzdCBpdGVyYXRpb24sIHdlJ2xsIGp1c3QgbGl2ZSB3aXRoIGhpdHRpbmcgdGhlIGJhZCBjYXNlXG4gICAgLy8gKGFkZGluZyBldmVyeXRoaW5nIHRvIGEgTWFwKSBpbiBmb3IgZXZlcnkgaW5zZXJ0L21vdmUuXG5cbiAgICAvLyBJZiB5b3UgY2hhbmdlIHRoaXMgY29kZSwgYWxzbyB1cGRhdGUgcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcigpIHdoaWNoXG4gICAgLy8gdXNlcyB0aGUgc2FtZSBhbGdvcml0aG0uXG5cbiAgICB7XG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmICghX25ld0ZpYmVyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgIC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbiAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgdmFyIF9uZXdGaWJlcjIgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChfbmV3RmliZXIyKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyMi5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXIyLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMiwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbkl0ZXJhYmxlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgcmVjb25jaWxlQ2hpbGRyZW5BcnJheSgpLFxuICAgIC8vIGJ1dCB1c2luZyB0aGUgaXRlcmF0b3IgaW5zdGVhZC5cblxuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAhKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICB7XG4gICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHJlbmRlcmluZyBHZW5lcmF0b3JzIGJlY2F1c2UgaXQncyBhIG11dGF0aW9uLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI5OTVcbiAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IHRvU3RyaW5nVGFnXG4gICAgICBuZXdDaGlsZHJlbkl0ZXJhYmxlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdHZW5lcmF0b3InKSB7XG4gICAgICAgICFkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID8gd2FybmluZyQxKGZhbHNlLCAnVXNpbmcgR2VuZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMgYmVjYXVzZSBlbnVtZXJhdGluZyBhIGdlbmVyYXRvciBtdXRhdGVzIGl0LiAnICsgJ1lvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSAnICsgJ2BbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gS2VlcCBpbiBtaW5kICcgKyAneW91IG1pZ2h0IG5lZWQgdG8gcG9seWZpbGwgdGhlc2UgZmVhdHVyZXMgZm9yIG9sZGVyIGJyb3dzZXJzLicpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICBpZiAobmV3Q2hpbGRyZW5JdGVyYWJsZS5lbnRyaWVzID09PSBpdGVyYXRvckZuKSB7XG4gICAgICAgICFkaWRXYXJuQWJvdXRNYXBzID8gd2FybmluZyQxKGZhbHNlLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgLy8gV2UnbGwgZ2V0IGEgZGlmZmVyZW50IGl0ZXJhdG9yIGxhdGVyIGZvciB0aGUgbWFpbiBwYXNzLlxuICAgICAgdmFyIF9uZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAgIGlmIChfbmV3Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG4gICAgICAgIHZhciBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgICAgIGZvciAoOyAhX3N0ZXAuZG9uZTsgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAhKG5ld0NoaWxkcmVuICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQW4gaXRlcmFibGUgb2JqZWN0IHByb3ZpZGVkIG5vIGl0ZXJhdG9yLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuXG4gICAgdmFyIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAoIW9sZEZpYmVyKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIzID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKF9uZXdGaWJlcjMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjMsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyMztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgIC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbiAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIHZhciBfbmV3RmliZXI0ID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoX25ld0ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXI0LmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjQua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyNC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjQsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI0O1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB0ZXh0IG5vZGVzIHNpbmNlIHdlIGRvbid0IGhhdmUgYVxuICAgIC8vIHdheSB0byBkZWZpbmUgdGhlbS5cbiAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQgIT09IG51bGwgJiYgY3VycmVudEZpcnN0Q2hpbGQudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgc28gbGV0J3MganVzdCB1cGRhdGUgaXQgYW5kIGRlbGV0ZVxuICAgICAgLy8gdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgICAvLyBUaGUgZXhpc3RpbmcgZmlyc3QgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlIHNvIHdlIG5lZWQgdG8gY3JlYXRlIG9uZVxuICAgIC8vIGFuZCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZXMuXG4gICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEZyYWdtZW50ID8gZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIDogY2hpbGQudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgPyBlbGVtZW50LnByb3BzLmNoaWxkcmVuIDogZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUsIGVsZW1lbnQua2V5KTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jcmVhdGVkNCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgX2NyZWF0ZWQ0LnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQpO1xuICAgICAgX2NyZWF0ZWQ0LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIF9jcmVhdGVkNDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBwb3J0YWwsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGtleSA9IHBvcnRhbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gSG9zdFBvcnRhbCAmJiBjaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA9PT0gcG9ydGFsLmNvbnRhaW5lckluZm8gJiYgY2hpbGQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uID09PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICAvLyBUaGlzIEFQSSB3aWxsIHRhZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdGhlIHJlY29uY2lsaWF0aW9uXG4gIC8vIGl0c2VsZi4gVGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaWRlLWVmZmVjdCBsaXN0IGFzIHdlIHBhc3MgdGhyb3VnaCB0aGVcbiAgLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVjdXJzaXZlLlxuICAgIC8vIElmIHRoZSB0b3AgbGV2ZWwgaXRlbSBpcyBhbiBhcnJheSwgd2UgdHJlYXQgaXQgYXMgYSBzZXQgb2YgY2hpbGRyZW4sXG4gICAgLy8gbm90IGFzIGEgZnJhZ21lbnQuIE5lc3RlZCBhcnJheXMgb24gdGhlIG90aGVyIGhhbmQgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgLy8gZnJhZ21lbnQgbm9kZXMuIFJlY3Vyc2lvbiBoYXBwZW5zIGF0IHRoZSBub3JtYWwgZmxvdy5cblxuICAgIC8vIEhhbmRsZSB0b3AgbGV2ZWwgdW5rZXllZCBmcmFnbWVudHMgYXMgaWYgdGhleSB3ZXJlIGFycmF5cy5cbiAgICAvLyBUaGlzIGxlYWRzIHRvIGFuIGFtYmlndWl0eSBiZXR3ZWVuIDw+e1suLi5dfTwvPiBhbmQgPD4uLi48Lz4uXG4gICAgLy8gV2UgdHJlYXQgdGhlIGFtYmlndW91cyBjYXNlcyBhYm92ZSB0aGUgc2FtZS5cbiAgICB2YXIgaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwgJiYgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSAmJiBuZXdDaGlsZC5rZXkgPT09IG51bGw7XG4gICAgaWYgKGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGw7XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSkge1xuICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmIChnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmIChpc09iamVjdCkge1xuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3VuZGVmaW5lZCcgJiYgIWlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIHRoZSBuZXcgY2hpbGQgaXMgdW5kZWZpbmVkLCBhbmQgdGhlIHJldHVybiBmaWJlciBpcyBhIGNvbXBvc2l0ZVxuICAgICAgLy8gY29tcG9uZW50LCB0aHJvdyBhbiBlcnJvci4gSWYgRmliZXIgcmV0dXJuIHR5cGVzIGFyZSBkaXNhYmxlZCxcbiAgICAgIC8vIHdlIGFscmVhZHkgdGhyZXcgYWJvdmUuXG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50TGF6eTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBmYWxsIHRocm91Z2ggdG8gdGhlIG5leHQgY2FzZSwgd2hpY2ggaGFuZGxlcyBib3RoXG4gICAgICAgIC8vIGZ1bmN0aW9ucyBhbmQgY2xhc3Nlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVkIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJyVzKC4uLik6IE5vdGhpbmcgd2FzIHJldHVybmVkIGZyb20gcmVuZGVyLiBUaGlzIHVzdWFsbHkgbWVhbnMgYSByZXR1cm4gc3RhdGVtZW50IGlzIG1pc3NpbmcuIE9yLCB0byByZW5kZXIgbm90aGluZywgcmV0dXJuIG51bGwuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIGNhc2VzIGFyZSBhbGwgdHJlYXRlZCBhcyBlbXB0eS5cbiAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVycztcbn1cblxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKHRydWUpO1xudmFyIG1vdW50Q2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIoZmFsc2UpO1xuXG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzKSB7XG4gICEoY3VycmVudCQkMSA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gY3VycmVudCQkMS5jaGlsZCkgPyBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMsIGN1cnJlbnRDaGlsZC5leHBpcmF0aW9uVGltZSk7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV3Q2hpbGQ7XG5cbiAgbmV3Q2hpbGQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHdoaWxlIChjdXJyZW50Q2hpbGQuc2libGluZyAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5zaWJsaW5nO1xuICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQuc2libGluZyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcywgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lKTtcbiAgICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuICBuZXdDaGlsZC5zaWJsaW5nID0gbnVsbDtcbn1cblxuLy8gVGhlIGRlZXBlc3QgRmliZXIgb24gdGhlIHN0YWNrIGludm9sdmVkIGluIGEgaHlkcmF0aW9uIGNvbnRleHQuXG4vLyBUaGlzIG1heSBoYXZlIGJlZW4gYW4gaW5zZXJ0aW9uIG9yIGEgaHlkcmF0aW9uLlxudmFyIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbnZhciBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcGFyZW50SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKTtcbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKHJldHVybkZpYmVyLCBpbnN0YW5jZSkge1xuICB7XG4gICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZShyZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbywgaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlKHJldHVybkZpYmVyLnR5cGUsIHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHMsIHJldHVybkZpYmVyLnN0YXRlTm9kZSwgaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCk7XG4gIGNoaWxkVG9EZWxldGUuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gIGNoaWxkVG9EZWxldGUucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gIGNoaWxkVG9EZWxldGUuZWZmZWN0VGFnID0gRGVsZXRpb247XG5cbiAgLy8gVGhpcyBtaWdodCBzZWVtIGxpa2UgaXQgYmVsb25ncyBvbiBwcm9ncmVzc2VkRmlyc3REZWxldGlvbi4gSG93ZXZlcixcbiAgLy8gdGhlc2UgY2hpbGRyZW4gYXJlIG5vdCBwYXJ0IG9mIHRoZSByZWNvbmNpbGlhdGlvbiBsaXN0IG9mIGNoaWxkcmVuLlxuICAvLyBFdmVuIGlmIHdlIGFib3J0IGFuZCByZXJlY29uY2lsZSB0aGUgY2hpbGRyZW4sIHRoYXQgd2lsbCB0cnkgdG8gaHlkcmF0ZVxuICAvLyBhZ2FpbiBhbmQgdGhlIG5vZGVzIGFyZSBzdGlsbCBpbiB0aGUgaG9zdCB0cmVlIHNvIHRoZXNlIHdpbGwgYmVcbiAgLy8gcmVjcmVhdGVkLlxuICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLCBmaWJlcikge1xuICBmaWJlci5lZmZlY3RUYWcgfD0gUGxhY2VtZW50O1xuICB7XG4gICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcGFyZW50Q29udGFpbmVyID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIHZhciBfdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgIHZhciBfcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdHlwZSwgX3Byb3BzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgICB2YXIgX3RleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgX3RleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgIHZhciBwcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIGluc3RhbmNlID0gY2FuSHlkcmF0ZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpO1xuICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBjYW5IeWRyYXRlVGV4dEluc3RhbmNlKG5leHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICAgIGlmICh0ZXh0SW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSB0ZXh0SW5zdGFuY2U7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgaWYgKCFuZXh0SW5zdGFuY2UpIHtcbiAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBmaXJzdEF0dGVtcHRlZEluc3RhbmNlID0gbmV4dEluc3RhbmNlO1xuICBpZiAoIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAvLyBJZiB3ZSBjYW4ndCBoeWRyYXRlIHRoaXMgaW5zdGFuY2UgbGV0J3MgdHJ5IHRoZSBuZXh0IG9uZS5cbiAgICAvLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4gICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaXJzdEF0dGVtcHRlZEluc3RhbmNlKTtcbiAgICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBXZSBtYXRjaGVkIHRoZSBuZXh0IG9uZSwgd2UnbGwgbm93IGFzc3VtZSB0aGF0IHRoZSBmaXJzdCBvbmUgd2FzXG4gICAgLy8gc3VwZXJmbHVvdXMgYW5kIHdlJ2xsIGRlbGV0ZSBpdC4gU2luY2Ugd2UgY2FuJ3QgZWFnZXJseSBkZWxldGUgaXRcbiAgICAvLyB3ZSdsbCBoYXZlIHRvIHNjaGVkdWxlIGEgZGVsZXRpb24uIFRvIGRvIHRoYXQsIHRoaXMgbm9kZSBuZWVkcyBhIGR1bW15XG4gICAgLy8gZmliZXIgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSk7XG4gIH1cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKG5leHRJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoZmliZXIsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciB1cGRhdGVQYXlsb2FkID0gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBmaWJlcik7XG4gIC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuICBmaWJlci51cGRhdGVRdWV1ZSA9IHVwZGF0ZVBheWxvYWQ7XG4gIC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS5cbiAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHZhciB0ZXh0SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciB0ZXh0Q29udGVudCA9IGZpYmVyLm1lbW9pemVkUHJvcHM7XG4gIHZhciBzaG91bGRVcGRhdGUgPSBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIGZpYmVyKTtcbiAge1xuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIGlzIGNhbGxlZCBpbiBhIGNvbnRleHQgd2hlcmUgdGhlXG4gICAgICAvLyBoeWRyYXRpb24gcGFyZW50IGlzIHRoZSBwYXJlbnQgaG9zdCBjb21wb25lbnQgb2YgdGhpcyBob3N0IHRleHQuXG4gICAgICB2YXIgcmV0dXJuRmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzaG91bGRVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpIHtcbiAgdmFyIHBhcmVudCA9IGZpYmVyLnJldHVybjtcbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290KSB7XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IHBhcmVudDtcbn1cblxuZnVuY3Rpb24gcG9wSHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZmliZXIgIT09IGh5ZHJhdGlvblBhcmVudEZpYmVyKSB7XG4gICAgLy8gV2UncmUgZGVlcGVyIHRoYW4gdGhlIGN1cnJlbnQgaHlkcmF0aW9uIGNvbnRleHQsIGluc2lkZSBhbiBpbnNlcnRlZFxuICAgIC8vIHRyZWUuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgLy8gc2libGluZ3MuXG4gICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICAvLyBJZiB3ZSBoYXZlIGFueSByZW1haW5pbmcgaHlkcmF0YWJsZSBub2Rlcywgd2UgbmVlZCB0byBkZWxldGUgdGhlbSBub3cuXG4gIC8vIFdlIG9ubHkgZG8gdGhpcyBkZWVwZXIgdGhhbiBoZWFkIGFuZCBib2R5IHNpbmNlIHRoZXkgdGVuZCB0byBoYXZlIHJhbmRvbVxuICAvLyBvdGhlciBub2RlcyBpbiB0aGVtLiBXZSBhbHNvIGlnbm9yZSBjb21wb25lbnRzIHdpdGggcHVyZSB0ZXh0IGNvbnRlbnQgaW5cbiAgLy8gc2lkZSBvZiB0aGVtLlxuICAvLyBUT0RPOiBCZXR0ZXIgaGV1cmlzdGljLlxuICBpZiAoZmliZXIudGFnICE9PSBIb3N0Q29tcG9uZW50IHx8IHR5cGUgIT09ICdoZWFkJyAmJiB0eXBlICE9PSAnYm9keScgJiYgIXNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSB7XG4gICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG4gICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA/IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaWJlci5zdGF0ZU5vZGUpIDogbnVsbDtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkTGF6eUNvbXBvbmVudFR5cGUodGhlbmFibGUpIHtcbiAgdmFyIHN0YXR1cyA9IHRoZW5hYmxlLl9yZWFjdFN0YXR1cztcbiAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICBjYXNlIFJlc29sdmVkOlxuICAgICAgdmFyIENvbXBvbmVudCA9IHRoZW5hYmxlLl9yZWFjdFJlc3VsdDtcbiAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgY2FzZSBSZWplY3RlZDpcbiAgICAgIHRocm93IHRoZW5hYmxlLl9yZWFjdFJlc3VsdDtcbiAgICBjYXNlIFBlbmRpbmc6XG4gICAgICB0aHJvdyB0aGVuYWJsZTtcbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aGVuYWJsZS5fcmVhY3RTdGF0dXMgPSBQZW5kaW5nO1xuICAgICAgICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uIChyZXNvbHZlZFZhbHVlKSB7XG4gICAgICAgICAgaWYgKHRoZW5hYmxlLl9yZWFjdFN0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICAgICAgdGhlbmFibGUuX3JlYWN0U3RhdHVzID0gUmVzb2x2ZWQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc29sdmVkVmFsdWUgPT09ICdvYmplY3QnICYmIHJlc29sdmVkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGBkZWZhdWx0YCBwcm9wZXJ0eSBpcyBub3QgZW1wdHksIGFzc3VtZSBpdCdzIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgLy8gb2YgYW4gYXN5bmMgaW1wb3J0KCkgYW5kIHVzZSB0aGF0LiBPdGhlcndpc2UsIHVzZSB0aGVcbiAgICAgICAgICAgICAgLy8gcmVzb2x2ZWQgdmFsdWUgaXRzZWxmLlxuICAgICAgICAgICAgICB2YXIgZGVmYXVsdEV4cG9ydCA9IHJlc29sdmVkVmFsdWUuZGVmYXVsdDtcbiAgICAgICAgICAgICAgcmVzb2x2ZWRWYWx1ZSA9IGRlZmF1bHRFeHBvcnQgIT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0RXhwb3J0ICE9PSBudWxsID8gZGVmYXVsdEV4cG9ydCA6IHJlc29sdmVkVmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlZFZhbHVlID0gcmVzb2x2ZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoZW5hYmxlLl9yZWFjdFJlc3VsdCA9IHJlc29sdmVkVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAodGhlbmFibGUuX3JlYWN0U3RhdHVzID09PSBQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGVuYWJsZS5fcmVhY3RTdGF0dXMgPSBSZWplY3RlZDtcbiAgICAgICAgICAgIHRoZW5hYmxlLl9yZWFjdFJlc3VsdCA9IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRocm93IHRoZW5hYmxlO1xuICAgICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQzID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG5cbnZhciBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uYWxDb21wb25lbnQgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0U3RhdGVsZXNzUmVmcyA9IHZvaWQgMDtcblxue1xuICBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uYWxDb21wb25lbnQgPSB7fTtcbiAgZGlkV2FybkFib3V0U3RhdGVsZXNzUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBpZiAoY3VycmVudCQkMSA9PT0gbnVsbCkge1xuICAgIC8vIElmIHRoaXMgaXMgYSBmcmVzaCBuZXcgY29tcG9uZW50IHRoYXQgaGFzbid0IGJlZW4gcmVuZGVyZWQgeWV0LCB3ZVxuICAgIC8vIHdvbid0IHVwZGF0ZSBpdHMgY2hpbGQgc2V0IGJ5IGFwcGx5aW5nIG1pbmltYWwgc2lkZS1lZmZlY3RzLiBJbnN0ZWFkLFxuICAgIC8vIHdlIHdpbGwgYWRkIHRoZW0gYWxsIHRvIHRoZSBjaGlsZCBiZWZvcmUgaXQgZ2V0cyByZW5kZXJlZC4gVGhhdCBtZWFuc1xuICAgIC8vIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIHJlY29uY2lsaWF0aW9uIHBhc3MgYnkgbm90IHRyYWNraW5nIHNpZGUtZWZmZWN0cy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoZSBjdXJyZW50IGNoaWxkIGlzIHRoZSBzYW1lIGFzIHRoZSB3b3JrIGluIHByb2dyZXNzLCBpdCBtZWFucyB0aGF0XG4gICAgLy8gd2UgaGF2ZW4ndCB5ZXQgc3RhcnRlZCBhbnkgd29yayBvbiB0aGVzZSBjaGlsZHJlbi4gVGhlcmVmb3JlLCB3ZSB1c2VcbiAgICAvLyB0aGUgY2xvbmUgYWxnb3JpdGhtIHRvIGNyZWF0ZSBhIGNvcHkgb2YgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuLlxuXG4gICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudCQkMS5jaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV4dFByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgcmVuZGVyID0gdHlwZS5yZW5kZXI7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQkJDEgIT09IG51bGwgPyBjdXJyZW50JCQxLnJlZiA6IG51bGw7XG4gICAgaWYgKHJlZiA9PT0gY3VycmVudFJlZikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dENoaWxkcmVuID0gdm9pZCAwO1xuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMy5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXIobmV4dFByb3BzLCByZWYpO1xuICAgIHNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgfVxuXG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNb2RlKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVQcm9maWxlcihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICB9XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgaWYgKGN1cnJlbnQkJDEgPT09IG51bGwgJiYgcmVmICE9PSBudWxsIHx8IGN1cnJlbnQkJDEgIT09IG51bGwgJiYgY3VycmVudCQkMS5yZWYgIT09IHJlZikge1xuICAgIC8vIFNjaGVkdWxlIGEgUmVmIGVmZmVjdFxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBSZWY7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSk7XG4gIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICB2YXIgbmV4dENoaWxkcmVuID0gdm9pZCAwO1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMy5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICBuZXh0Q2hpbGRyZW4gPSBDb21wb25lbnQobmV4dFByb3BzLCBjb250ZXh0KTtcbiAgICBzZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gIH1cblxuICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuICB2YXIgaGFzQ29udGV4dCA9IHZvaWQgMDtcbiAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICBoYXNDb250ZXh0ID0gdHJ1ZTtcbiAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBoYXNDb250ZXh0ID0gZmFsc2U7XG4gIH1cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICB2YXIgc2hvdWxkVXBkYXRlID0gdm9pZCAwO1xuICBpZiAoY3VycmVudCQkMSA9PT0gbnVsbCkge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPT09IG51bGwpIHtcbiAgICAgIC8vIEluIHRoZSBpbml0aWFsIHBhc3Mgd2UgbWlnaHQgbmVlZCB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlLlxuICAgICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuICAgICAgc2hvdWxkVXBkYXRlID0gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzaG91bGRVcGRhdGUgPSB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB9XG4gIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbn1cblxuZnVuY3Rpb24gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0LCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAvLyBSZWZzIHNob3VsZCB1cGRhdGUgZXZlbiBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZVxuICBtYXJrUmVmKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzKTtcblxuICB2YXIgZGlkQ2FwdHVyZUVycm9yID0gKHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIERpZENhcHR1cmUpICE9PSBOb0VmZmVjdDtcblxuICBpZiAoIXNob3VsZFVwZGF0ZSAmJiAhZGlkQ2FwdHVyZUVycm9yKSB7XG4gICAgLy8gQ29udGV4dCBwcm92aWRlcnMgc2hvdWxkIGRlZmVyIHRvIHNDVSBmb3IgcmVuZGVyaW5nXG4gICAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgLy8gUmVyZW5kZXJcbiAgUmVhY3RDdXJyZW50T3duZXIkMy5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB2b2lkIDA7XG4gIGlmIChkaWRDYXB0dXJlRXJyb3IgJiYgKCFlbmFibGVHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggfHwgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggIT09ICdmdW5jdGlvbicpKSB7XG4gICAgLy8gSWYgd2UgY2FwdHVyZWQgYW4gZXJyb3IsIGJ1dCBnZXREZXJpdmVkU3RhdGVGcm9tIGNhdGNoIGlzIG5vdCBkZWZpbmVkLFxuICAgIC8vIHVubW91bnQgYWxsIHRoZSBjaGlsZHJlbi4gY29tcG9uZW50RGlkQ2F0Y2ggd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgdG9cbiAgICAvLyByZS1yZW5kZXIgYSBmYWxsYmFjay4gVGhpcyBpcyB0ZW1wb3JhcnkgdW50aWwgd2UgbWlncmF0ZSBldmVyeW9uZSB0b1xuICAgIC8vIHRoZSBuZXcgQVBJLlxuICAgIC8vIFRPRE86IFdhcm4gaW4gYSBmdXR1cmUgcmVsZWFzZS5cbiAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuXG4gICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyB8fCBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgfVxuICAgICAgc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG4gIGlmIChjdXJyZW50JCQxICE9PSBudWxsICYmIGRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIElmIHdlJ3JlIHJlY292ZXJpbmcgZnJvbSBhbiBlcnJvciwgcmVjb25jaWxlIHR3aWNlOiBmaXJzdCB0byBkZWxldGVcbiAgICAvLyBhbGwgdGhlIGV4aXN0aW5nIGNoaWxkcmVuLlxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBudWxsLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIC8vIE5vdyB3ZSBjYW4gY29udGludWUgcmVjb25jaWxpbmcgbGlrZSBub3JtYWwuIFRoaXMgaGFzIHRoZSBlZmZlY3Qgb2ZcbiAgICAvLyByZW1vdW50aW5nIGFsbCBjaGlsZHJlbiByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlaXIgdGhlaXJcbiAgICAvLyBpZGVudGl0eSBtYXRjaGVzLlxuICB9XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgLy8gTWVtb2l6ZSBwcm9wcyBhbmQgc3RhdGUgdXNpbmcgdGhlIHZhbHVlcyB3ZSBqdXN0IHVzZWQgdG8gcmVuZGVyLlxuICAvLyBUT0RPOiBSZXN0cnVjdHVyZSBzbyB3ZSBuZXZlciByZWFkIHZhbHVlcyBmcm9tIHRoZSBpbnN0YW5jZS5cbiAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5zdGF0ZSk7XG4gIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UucHJvcHMpO1xuXG4gIC8vIFRoZSBjb250ZXh0IG1pZ2h0IGhhdmUgY2hhbmdlZCBzbyB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIGl0LlxuICBpZiAoaGFzQ29udGV4dCkge1xuICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5wZW5kaW5nQ29udGV4dCwgcm9vdC5wZW5kaW5nQ29udGV4dCAhPT0gcm9vdC5jb250ZXh0KTtcbiAgfSBlbHNlIGlmIChyb290LmNvbnRleHQpIHtcbiAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxuICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGV4dCwgZmFsc2UpO1xuICB9XG4gIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCByb290LmNvbnRhaW5lckluZm8pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0Um9vdChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAhKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0lmIHRoZSByb290IGRvZXMgbm90IGhhdmUgYW4gdXBkYXRlUXVldWUsIHdlIHNob3VsZCBoYXZlIGFscmVhZHkgYmFpbGVkIG91dC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBwcmV2Q2hpbGRyZW4gPSBwcmV2U3RhdGUgIT09IG51bGwgPyBwcmV2U3RhdGUuZWxlbWVudCA6IG51bGw7XG4gIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUXVldWUsIG5leHRQcm9wcywgbnVsbCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0U3RhdGUuZWxlbWVudDtcbiAgaWYgKG5leHRDaGlsZHJlbiA9PT0gcHJldkNoaWxkcmVuKSB7XG4gICAgLy8gSWYgdGhlIHN0YXRlIGlzIHRoZSBzYW1lIGFzIGJlZm9yZSwgdGhhdCdzIGEgYmFpbG91dCBiZWNhdXNlIHdlIGhhZFxuICAgIC8vIG5vIHdvcmsgdGhhdCBleHBpcmVzIGF0IHRoaXMgdGltZS5cbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfVxuICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaWYgKChjdXJyZW50JCQxID09PSBudWxsIHx8IGN1cnJlbnQkJDEuY2hpbGQgPT09IG51bGwpICYmIHJvb3QuaHlkcmF0ZSAmJiBlbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKSkge1xuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IGN1cnJlbnQgY2hpbGRyZW4gdGhpcyBtaWdodCBiZSB0aGUgZmlyc3QgcGFzcy5cbiAgICAvLyBXZSBhbHdheXMgdHJ5IHRvIGh5ZHJhdGUuIElmIHRoaXMgaXNuJ3QgYSBoeWRyYXRpb24gcGFzcyB0aGVyZSB3b24ndFxuICAgIC8vIGJlIGFueSBjaGlsZHJlbiB0byBoeWRyYXRlIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nIGFzXG4gICAgLy8gbm90IGh5ZHJhdGluZy5cblxuICAgIC8vIFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrLiBXZSB0cmFjayB0aGUgaG9zdCByb290IGFzIGEgcGxhY2VtZW50IHRvXG4gICAgLy8ga25vdyB0aGF0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIG1vdW50aW5nIHN0YXRlLiBUaGF0IHdheSBpc01vdW50ZWRcbiAgICAvLyB3b3JrcyBhcyBleHBlY3RlZC4gV2UgbXVzdCByZXNldCB0aGlzIGJlZm9yZSBjb21taXR0aW5nLlxuICAgIC8vIFRPRE86IERlbGV0ZSB0aGlzIHdoZW4gd2UgZGVsZXRlIGlzTW91bnRlZCBhbmQgZmluZERPTU5vZGUuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcblxuICAgIC8vIEVuc3VyZSB0aGF0IGNoaWxkcmVuIG1vdW50IGludG8gdGhpcyByb290IHdpdGhvdXQgdHJhY2tpbmdcbiAgICAvLyBzaWRlLWVmZmVjdHMuIFRoaXMgZW5zdXJlcyB0aGF0IHdlIGRvbid0IHN0b3JlIFBsYWNlbWVudCBlZmZlY3RzIG9uXG4gICAgLy8gbm9kZXMgdGhhdCB3aWxsIGJlIGh5ZHJhdGVkLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlIHJlc2V0IGh5ZHJhdGlvbiBzdGF0ZSBpbiBjYXNlIHdlIGFib3J0ZWQgYW5kIHJlc3VtZWQgYW5vdGhlclxuICAgIC8vIHJvb3QuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgfVxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgaWYgKGN1cnJlbnQkJDEgPT09IG51bGwpIHtcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50JCQxICE9PSBudWxsID8gY3VycmVudCQkMS5tZW1vaXplZFByb3BzIDogbnVsbDtcblxuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICB2YXIgaXNEaXJlY3RUZXh0Q2hpbGQgPSBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBuZXh0UHJvcHMpO1xuXG4gIGlmIChpc0RpcmVjdFRleHRDaGlsZCkge1xuICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgLy8gY2FzZS4gV2Ugd29uJ3QgaGFuZGxlIGl0IGFzIGEgcmVpZmllZCBjaGlsZC4gV2Ugd2lsbCBpbnN0ZWFkIGhhbmRsZVxuICAgIC8vIHRoaXMgaW4gdGhlIGhvc3QgZW52aXJvbm1lbnQgdGhhdCBhbHNvIGhhdmUgYWNjZXNzIHRvIHRoaXMgcHJvcC4gVGhhdFxuICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcbiAgfSBlbHNlIGlmIChwcmV2UHJvcHMgIT09IG51bGwgJiYgc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJldlByb3BzKSkge1xuICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgLy8gZW1wdHksIHdlIG5lZWQgdG8gc2NoZWR1bGUgdGhlIHRleHQgY29udGVudCB0byBiZSByZXNldC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gQ29udGVudFJlc2V0O1xuICB9XG5cbiAgbWFya1JlZihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgLy8gQ2hlY2sgdGhlIGhvc3QgY29uZmlnIHRvIHNlZSBpZiB0aGUgY2hpbGRyZW4gYXJlIG9mZnNjcmVlbi9oaWRkZW4uXG4gIGlmIChyZW5kZXJFeHBpcmF0aW9uVGltZSAhPT0gTmV2ZXIgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIEFzeW5jTW9kZSAmJiBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlKHR5cGUsIG5leHRQcm9wcykpIHtcbiAgICAvLyBTY2hlZHVsZSB0aGlzIGZpYmVyIHRvIHJlLXJlbmRlciBhdCBvZmZzY3JlZW4gcHJpb3JpdHkuIFRoZW4gYmFpbG91dC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IE5ldmVyO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0VGV4dChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoY3VycmVudCQkMSA9PT0gbnVsbCkge1xuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gIC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuICAvLyBpbW1lZGlhdGVseSBhZnRlci5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEZWZhdWx0UHJvcHMoQ29tcG9uZW50LCBiYXNlUHJvcHMpIHtcbiAgaWYgKENvbXBvbmVudCAmJiBDb21wb25lbnQuZGVmYXVsdFByb3BzKSB7XG4gICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzLiBUYWtlbiBmcm9tIFJlYWN0RWxlbWVudFxuICAgIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGJhc2VQcm9wcyk7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHM7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG4gIHJldHVybiBiYXNlUHJvcHM7XG59XG5cbmZ1bmN0aW9uIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAhKGN1cnJlbnQkJDEgPT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQW4gaW5kZXRlcm1pbmF0ZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIGhhdmUgbW91bnRlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIGlmICh0eXBlb2YgQ29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBDb21wb25lbnQgIT09IG51bGwgJiYgdHlwZW9mIENvbXBvbmVudC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgQ29tcG9uZW50ID0gcmVhZExhenlDb21wb25lbnRUeXBlKENvbXBvbmVudCk7XG4gICAgdmFyIHJlc29sdmVkVGFnID0gd29ya0luUHJvZ3Jlc3MudGFnID0gcmVzb2x2ZUxhenlDb21wb25lbnRUYWcod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCk7XG4gICAgdmFyIHJlc29sdmVkUHJvcHMgPSByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgcHJvcHMpO1xuICAgIHN3aXRjaCAocmVzb2x2ZWRUYWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudExhenk6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnRMYXp5OlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBGb3J3YXJkUmVmTGF6eTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVGb3J3YXJkUmVmKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRoaXMgbWVzc2FnZSBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgbWV0aW9uIEZvcndhcmRSZWYgYmVjYXVzZSB0aGVcbiAgICAgICAgICAvLyBmYWN0IHRoYXQgaXQncyBhIHNlcGFyYXRlIHR5cGUgb2Ygd29yayBpcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuXG4gICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQuIFJlY2VpdmVkIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvOiAlcy4gUHJvbWlzZSBlbGVtZW50cyBtdXN0IHJlc29sdmUgdG8gYSBjbGFzcyBvciBmdW5jdGlvbi4nLCBDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBmYWxzZSk7XG4gIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuXG4gIHZhciB2YWx1ZSA9IHZvaWQgMDtcblxuICB7XG4gICAgaWYgKENvbXBvbmVudC5wcm90b3R5cGUgJiYgdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCBcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFwiICsgJ1RoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIG51bGwpO1xuICAgIH1cblxuICAgIFJlYWN0Q3VycmVudE93bmVyJDMuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHZhbHVlID0gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0KTtcbiAgfVxuICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUuJCR0eXBlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgY2xhc3MgaW5zdGFuY2VcbiAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDbGFzc0NvbXBvbmVudDtcblxuICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gICAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAgIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cbiAgICB2YXIgaGFzQ29udGV4dCA9IGZhbHNlO1xuICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICBoYXNDb250ZXh0ID0gdHJ1ZTtcbiAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYXNDb250ZXh0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHZhbHVlLnN0YXRlICE9PSBudWxsICYmIHZhbHVlLnN0YXRlICE9PSB1bmRlZmluZWQgPyB2YWx1ZS5zdGF0ZSA6IG51bGw7XG5cbiAgICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUsIGhhc0NvbnRleHQsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRnVuY3Rpb25hbENvbXBvbmVudDtcbiAgICB7XG4gICAgICBpZiAoQ29tcG9uZW50KSB7XG4gICAgICAgICEhQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMoLi4uKTogY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbmFsIGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgfVxuICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICB2YXIgb3duZXJOYW1lID0gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKTtcbiAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3YXJuaW5nS2V5ID0gb3duZXJOYW1lIHx8IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEIHx8ICcnO1xuICAgICAgICB2YXIgZGVidWdTb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2U7XG4gICAgICAgIGlmIChkZWJ1Z1NvdXJjZSkge1xuICAgICAgICAgIHdhcm5pbmdLZXkgPSBkZWJ1Z1NvdXJjZS5maWxlTmFtZSArICc6JyArIGRlYnVnU291cmNlLmxpbmVOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdGF0ZWxlc3NSZWZzW3dhcm5pbmdLZXldKSB7XG4gICAgICAgICAgZGlkV2FybkFib3V0U3RhdGVsZXNzUmVmc1t3YXJuaW5nS2V5XSA9IHRydWU7XG4gICAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMuICcgKyAnQXR0ZW1wdHMgdG8gYWNjZXNzIHRoaXMgcmVmIHdpbGwgZmFpbC4lcycsIGluZm8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbmFsQ29tcG9uZW50W19jb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzOiBTdGF0ZWxlc3MgZnVuY3Rpb25hbCBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4nLCBfY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbmFsQ29tcG9uZW50W19jb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHZhbHVlLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBwcm9wcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVBsYWNlaG9sZGVyQ29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBpZiAoZW5hYmxlU3VzcGVuc2UpIHtcbiAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gcmVuZGVyIHRoZSBub3JtYWwgc3RhdGUuIElmIHdlIGRpZCxcbiAgICAvLyBhbmQgd2UgdGltZWQgb3V0LCByZW5kZXIgdGhlIHBsYWNlaG9sZGVyIHN0YXRlLlxuICAgIHZhciBhbHJlYWR5Q2FwdHVyZWQgPSAod29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICYgRGlkQ2FwdHVyZSkgPT09IE5vRWZmZWN0O1xuXG4gICAgdmFyIG5leHREaWRUaW1lb3V0ID0gdm9pZCAwO1xuICAgIGlmIChjdXJyZW50JCQxICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSBvdXRzaWRlIHN0cmljdCBtb2RlLiBTb21ldGhpbmcgaW5zaWRlIHRoaXMgUGxhY2Vob2xkZXIgYm91bmRhcnlcbiAgICAgIC8vIHN1c3BlbmRlZCBkdXJpbmcgdGhlIGxhc3QgY29tbWl0LiBTd2l0Y2ggdG8gdGhlIHBsYWNob2xkZXIuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICBuZXh0RGlkVGltZW91dCA9IHRydWU7XG4gICAgICAvLyBJZiB3ZSdyZSByZWNvdmVyaW5nIGZyb20gYW4gZXJyb3IsIHJlY29uY2lsZSB0d2ljZTogZmlyc3QgdG8gZGVsZXRlXG4gICAgICAvLyBhbGwgdGhlIGV4aXN0aW5nIGNoaWxkcmVuLlxuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG51bGwsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGN1cnJlbnQkJDEuY2hpbGQgPSBudWxsO1xuICAgICAgLy8gTm93IHdlIGNhbiBjb250aW51ZSByZWNvbmNpbGluZyBsaWtlIG5vcm1hbC4gVGhpcyBoYXMgdGhlIGVmZmVjdCBvZlxuICAgICAgLy8gcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyIHRoZWlyXG4gICAgICAvLyBpZGVudGl0eSBtYXRjaGVzLlxuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0RGlkVGltZW91dCA9ICFhbHJlYWR5Q2FwdHVyZWQ7XG4gICAgfVxuXG4gICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkgIT09IE5vRWZmZWN0KSB7XG4gICAgICBpZiAobmV4dERpZFRpbWVvdXQpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRpbWVkLW91dCB2aWV3IGNvbW1pdHMsIHNjaGVkdWxlIGFuIHVwZGF0ZSBlZmZlY3QgdG8gcmVjb3JkXG4gICAgICAgIC8vIHRoZSBjb21taXR0ZWQgdGltZS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBzdGF0ZSBub2RlIHBvaW50cyB0byB0aGUgdGltZSBhdCB3aGljaCBwbGFjZWhvbGRlciB0aW1lZCBvdXQuXG4gICAgICAgIC8vIFdlIGNhbiBjbGVhciBpdCBvbmNlIHdlIHN3aXRjaCBiYWNrIHRvIHRoZSBub3JtYWwgY2hpbGRyZW4uXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGBjaGlsZHJlbmAgcHJvcCBpcyBhIGZ1bmN0aW9uLCB0cmVhdCBpdCBsaWtlIGEgcmVuZGVyIHByb3AuXG4gICAgLy8gVE9ETzogVGhpcyBpcyB0ZW1wb3JhcnkgdW50aWwgd2UgZmluYWxpemUgYSBsb3dlciBsZXZlbCBBUEkuXG4gICAgdmFyIGNoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB2b2lkIDA7XG4gICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbmV4dENoaWxkcmVuID0gY2hpbGRyZW4obmV4dERpZFRpbWVvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBuZXh0RGlkVGltZW91dCA/IG5leHRQcm9wcy5mYWxsYmFjayA6IGNoaWxkcmVuO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5leHREaWRUaW1lb3V0O1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICBpZiAoY3VycmVudCQkMSA9PT0gbnVsbCkge1xuICAgIC8vIFBvcnRhbHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB3ZSBkb24ndCBhcHBlbmQgdGhlIGNoaWxkcmVuIGR1cmluZyBtb3VudFxuICAgIC8vIGJ1dCBhdCBjb21taXQuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIHRyYWNrIGluc2VydGlvbnMgd2hpY2ggdGhlIG5vcm1hbFxuICAgIC8vIGZsb3cgZG9lc24ndCBkbyBkdXJpbmcgbW91bnQuIFRoaXMgZG9lc24ndCBoYXBwZW4gYXQgdGhlIHJvb3QgYmVjYXVzZVxuICAgIC8vIHRoZSByb290IGFsd2F5cyBzdGFydHMgd2l0aCBhIFwiY3VycmVudFwiIHdpdGggYSBudWxsIGNoaWxkLlxuICAgIC8vIFRPRE86IENvbnNpZGVyIHVuaWZ5aW5nIHRoaXMgd2l0aCBob3cgdGhlIHJvb3Qgd29ya3MuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICB9IGVsc2Uge1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gIH1cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBwcm92aWRlclR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgY29udGV4dCA9IHByb3ZpZGVyVHlwZS5fY29udGV4dDtcblxuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG5cbiAgdmFyIG5ld1ZhbHVlID0gbmV3UHJvcHMudmFsdWU7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXdQcm9wcztcblxuICB7XG4gICAgdmFyIHByb3ZpZGVyUHJvcFR5cGVzID0gd29ya0luUHJvZ3Jlc3MudHlwZS5wcm9wVHlwZXM7XG5cbiAgICBpZiAocHJvdmlkZXJQcm9wVHlwZXMpIHtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3ZpZGVyUHJvcFR5cGVzLCBuZXdQcm9wcywgJ3Byb3AnLCAnQ29udGV4dC5Qcm92aWRlcicsIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgbmV3VmFsdWUpO1xuXG4gIGlmIChvbGRQcm9wcyAhPT0gbnVsbCkge1xuICAgIHZhciBvbGRWYWx1ZSA9IG9sZFByb3BzLnZhbHVlO1xuICAgIHZhciBjaGFuZ2VkQml0cyA9IGNhbGN1bGF0ZUNoYW5nZWRCaXRzKGNvbnRleHQsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgaWYgKGNoYW5nZWRCaXRzID09PSAwKSB7XG4gICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuICAgICAgaWYgKG9sZFByb3BzLmNoaWxkcmVuID09PSBuZXdQcm9wcy5jaGlsZHJlbiAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgY29udGV4dCB2YWx1ZSBjaGFuZ2VkLiBTZWFyY2ggZm9yIG1hdGNoaW5nIGNvbnN1bWVycyBhbmQgc2NoZWR1bGVcbiAgICAgIC8vIHRoZW0gdG8gdXBkYXRlLlxuICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgY2hhbmdlZEJpdHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV3Q2hpbGRyZW4gPSBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dENvbnN1bWVyKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHJlbmRlciA9IG5ld1Byb3BzLmNoaWxkcmVuO1xuXG4gIHtcbiAgICAhKHR5cGVvZiByZW5kZXIgPT09ICdmdW5jdGlvbicpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkICcgKyBcInRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgXCIgKyAndGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlICcgKyAnaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC4nKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIHZhciBuZXdWYWx1ZSA9IHJlYWRDb250ZXh0KGNvbnRleHQsIG5ld1Byb3BzLnVuc3RhYmxlX29ic2VydmVkQml0cyk7XG4gIHZhciBuZXdDaGlsZHJlbiA9IHZvaWQgMDtcbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDMuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgbmV3Q2hpbGRyZW4gPSByZW5kZXIobmV3VmFsdWUpO1xuICAgIHNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgfVxuXG4gIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBuZXdDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuLypcbiAgZnVuY3Rpb24gcmV1c2VDaGlsZHJlbkVmZmVjdHMocmV0dXJuRmliZXIgOiBGaWJlciwgZmlyc3RDaGlsZCA6IEZpYmVyKSB7XG4gICAgbGV0IGNoaWxkID0gZmlyc3RDaGlsZDtcbiAgICBkbyB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgZmlyc3QgYW5kIGxhc3QgZWZmZWN0IG9mIHRoZSBwYXJlbnQgY29ycmVzcG9uZHNcbiAgICAgIC8vIHRvIHRoZSBjaGlsZHJlbidzIGZpcnN0IGFuZCBsYXN0IGVmZmVjdC5cbiAgICAgIGlmICghcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSBjaGlsZC5maXJzdEVmZmVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5sYXN0RWZmZWN0KSB7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0KSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGQuZmlyc3RFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkLmxhc3RFZmZlY3Q7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoY2hpbGQgPSBjaGlsZC5zaWJsaW5nKTtcbiAgfVxuICAqL1xuXG5mdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBjYW5jZWxXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gIGlmIChjdXJyZW50JCQxICE9PSBudWxsKSB7XG4gICAgLy8gUmV1c2UgcHJldmlvdXMgY29udGV4dCBsaXN0XG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RDb250ZXh0RGVwZW5kZW5jeSA9IGN1cnJlbnQkJDEuZmlyc3RDb250ZXh0RGVwZW5kZW5jeTtcbiAgfVxuXG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgLy8gRG9uJ3QgdXBkYXRlIFwiYmFzZVwiIHJlbmRlciB0aW1lcyBmb3IgYmFpbG91dHMuXG4gICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkcmVuIGhhdmUgYW55IHBlbmRpbmcgd29yay5cbiAgdmFyIGNoaWxkRXhwaXJhdGlvblRpbWUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZEV4cGlyYXRpb25UaW1lO1xuICBpZiAoY2hpbGRFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IGNoaWxkRXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoZSBjaGlsZHJlbiBkb24ndCBoYXZlIGFueSB3b3JrIGVpdGhlci4gV2UgY2FuIHNraXAgdGhlbS5cbiAgICAvLyBUT0RPOiBPbmNlIHdlIGFkZCBiYWNrIHJlc3VtaW5nLCB3ZSBzaG91bGQgY2hlY2sgaWYgdGhlIGNoaWxkcmVuIGFyZVxuICAgIC8vIGEgd29yay1pbi1wcm9ncmVzcyBzZXQuIElmIHNvLCB3ZSBuZWVkIHRvIHRyYW5zZmVyIHRoZWlyIGVmZmVjdHMuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBmaWJlciBkb2Vzbid0IGhhdmUgd29yaywgYnV0IGl0cyBzdWJ0cmVlIGRvZXMuIENsb25lIHRoZSBjaGlsZFxuICAgIC8vIGZpYmVycyBhbmQgY29udGludWUuXG4gICAgY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG59XG5cbi8vIFRPRE86IERlbGV0ZSBtZW1vaXplUHJvcHMvU3RhdGUgYW5kIG1vdmUgdG8gcmVjb25jaWxlL2JhaWxvdXQgaW5zdGVhZFxuZnVuY3Rpb24gbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpIHtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5leHRQcm9wcztcbn1cblxuZnVuY3Rpb24gbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBuZXh0U3RhdGUpIHtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgLy8gRG9uJ3QgcmVzZXQgdGhlIHVwZGF0ZVF1ZXVlLCBpbiBjYXNlIHRoZXJlIGFyZSBwZW5kaW5nIHVwZGF0ZXMuIFJlc2V0dGluZ1xuICAvLyBpcyBoYW5kbGVkIGJ5IHByb2Nlc3NVcGRhdGVRdWV1ZS5cbn1cblxuZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgdXBkYXRlRXhwaXJhdGlvblRpbWUgPSB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZTtcbiAgaWYgKCFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICh1cGRhdGVFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHVwZGF0ZUV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpKSB7XG4gICAgLy8gVGhpcyBmaWJlciBkb2VzIG5vdCBoYXZlIGFueSBwZW5kaW5nIHdvcmsuIEJhaWxvdXQgd2l0aG91dCBlbnRlcmluZ1xuICAgIC8vIHRoZSBiZWdpbiBwaGFzZS4gVGhlcmUncyBzdGlsbCBzb21lIGJvb2trZWVwaW5nIHdlIHRoYXQgbmVlZHMgdG8gYmUgZG9uZVxuICAgIC8vIGluIHRoaXMgb3B0aW1pemVkIHBhdGgsIG1vc3RseSBwdXNoaW5nIHN0dWZmIG9udG8gdGhlIHN0YWNrLlxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdGhlbmFibGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgIHZhciBfQ29tcG9uZW50ID0gZ2V0UmVzdWx0RnJvbVJlc29sdmVkVGhlbmFibGUodGhlbmFibGUpO1xuICAgICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihfQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnZhbHVlO1xuICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgbmV3VmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIH1cblxuICAvLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjbGVhciB0aGUgZXhwaXJhdGlvbiB0aW1lLlxuICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9Db21wb25lbnQzID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudDMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfQ29tcG9uZW50NCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudDQsIF91bnJlc29sdmVkUHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnRMYXp5OlxuICAgICAge1xuICAgICAgICB2YXIgX3RoZW5hYmxlMiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBfQ29tcG9uZW50NSA9IGdldFJlc3VsdEZyb21SZXNvbHZlZFRoZW5hYmxlKF90aGVuYWJsZTIpO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczIgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAgIHZhciBfY2hpbGQgPSB1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBfQ29tcG9uZW50NSwgcmVzb2x2ZURlZmF1bHRQcm9wcyhfQ29tcG9uZW50NSwgX3VucmVzb2x2ZWRQcm9wczIpLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBfdW5yZXNvbHZlZFByb3BzMjtcbiAgICAgICAgcmV0dXJuIF9jaGlsZDtcbiAgICAgIH1cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX0NvbXBvbmVudDYgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAgIHJldHVybiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudDYsIF91bnJlc29sdmVkUHJvcHMzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgICB7XG4gICAgICAgIHZhciBfdGhlbmFibGUzID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF9Db21wb25lbnQ3ID0gZ2V0UmVzdWx0RnJvbVJlc29sdmVkVGhlbmFibGUoX3RoZW5hYmxlMyk7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzNCA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIF9jaGlsZDIgPSB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudDcsIHJlc29sdmVEZWZhdWx0UHJvcHMoX0NvbXBvbmVudDcsIF91bnJlc29sdmVkUHJvcHM0KSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gX3VucmVzb2x2ZWRQcm9wczQ7XG4gICAgICAgIHJldHVybiBfY2hpbGQyO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdFJvb3QoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdFRleHQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIGNhc2UgUGxhY2Vob2xkZXJDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlUGxhY2Vob2xkZXJDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICByZXR1cm4gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAge1xuICAgICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHJldHVybiB1cGRhdGVGb3J3YXJkUmVmKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCB0eXBlLCB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICBjYXNlIEZvcndhcmRSZWZMYXp5OlxuICAgICAgdmFyIF90aGVuYWJsZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICB2YXIgX0NvbXBvbmVudDIgPSBnZXRSZXN1bHRGcm9tUmVzb2x2ZWRUaGVuYWJsZShfdGhlbmFibGUpO1xuICAgICAgdmFyIHVucmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIHZhciBjaGlsZCA9IHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIF9Db21wb25lbnQyLCByZXNvbHZlRGVmYXVsdFByb3BzKF9Db21wb25lbnQyLCB1bnJlc29sdmVkUHJvcHMpLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gdW5yZXNvbHZlZFByb3BzO1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBjYXNlIE1vZGU6XG4gICAgICByZXR1cm4gdXBkYXRlTW9kZShjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICByZXR1cm4gdXBkYXRlUHJvZmlsZXIoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHJldHVybiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICAgIHJldHVybiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBkZWZhdWx0OlxuICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gVGFnIHRoZSBmaWJlciB3aXRoIGFuIHVwZGF0ZSBlZmZlY3QuIFRoaXMgdHVybnMgYSBQbGFjZW1lbnQgaW50b1xuICAvLyBhIFBsYWNlbWVudEFuZFVwZGF0ZS5cbiAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gbWFya1JlZiQxKHdvcmtJblByb2dyZXNzKSB7XG4gIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBSZWY7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZEFsbENoaWxkcmVuKHBhcmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnRhbCBjaGlsZCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAvLyB0aGUgcG9ydGFsIGRpcmVjdGx5LlxuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG52YXIgdXBkYXRlSG9zdENvbnRhaW5lciA9IHZvaWQgMDtcbnZhciB1cGRhdGVIb3N0Q29tcG9uZW50JDEgPSB2b2lkIDA7XG52YXIgdXBkYXRlSG9zdFRleHQkMSA9IHZvaWQgMDtcbmlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gIC8vIE11dGF0aW9uIG1vZGVcblxuICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgLy8gTm9vcFxuICB9O1xuICB1cGRhdGVIb3N0Q29tcG9uZW50JDEgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZCB0b1xuICAgIC8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgdmFyIG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIEluIG11dGF0aW9uIG1vZGUsIHRoaXMgaXMgc3VmZmljaWVudCBmb3IgYSBiYWlsb3V0IGJlY2F1c2VcbiAgICAgIC8vIHdlIHdvbid0IHRvdWNoIHRoaXMgbm9kZSBldmVuIGlmIGNoaWxkcmVuIGNoYW5nZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ2V0IHVwZGF0ZWQgYmVjYXVzZSBvbmUgb2Ygb3VyIGNoaWxkcmVuIHVwZGF0ZWQsIHdlIGRvbid0XG4gICAgLy8gaGF2ZSBuZXdQcm9wcyBzbyB3ZSdsbCBoYXZlIHRvIHJldXNlIHRoZW0uXG4gICAgLy8gVE9ETzogU3BsaXQgdGhlIHVwZGF0ZSBBUEkgYXMgc2VwYXJhdGUgZm9yIHRoZSBwcm9wcyB2cy4gY2hpbGRyZW4uXG4gICAgLy8gRXZlbiBiZXR0ZXIgd291bGQgYmUgaWYgY2hpbGRyZW4gd2VyZW4ndCBzcGVjaWFsIGNhc2VkIGF0IGFsbCB0aG8uXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgIC8vIFRPRE86IEV4cGVyaWVuY2luZyBhbiBlcnJvciB3aGVyZSBvbGRQcm9wcyBpcyBudWxsLiBTdWdnZXN0cyBhIGhvc3RcbiAgICAvLyBjb21wb25lbnQgaXMgaGl0dGluZyB0aGUgcmVzdW1lIHBhdGguIEZpZ3VyZSBvdXQgd2h5LiBQb3NzaWJseVxuICAgIC8vIHJlbGF0ZWQgdG8gYGhpZGRlbmAuXG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTtcbiAgICAvLyBUT0RPOiBUeXBlIHRoaXMgc3BlY2lmaWMgdG8gdGhpcyB0eXBlIG9mIGNvbXBvbmVudC5cbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHVwZGF0ZVBheWxvYWQ7XG4gICAgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gICAgLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpcyBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgaWYgKHVwZGF0ZVBheWxvYWQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcbiAgdXBkYXRlSG9zdFRleHQkMSA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgIC8vIElmIHRoZSB0ZXh0IGRpZmZlcnMsIG1hcmsgaXQgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaW4gZG9uZSBpbiBjb21taXRXb3JrLlxuICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH07XG59IGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgLy8gUGVyc2lzdGVudCBob3N0IHRyZWUgbW9kZVxuXG4gIC8vIEFuIHVuZm9ydHVuYXRlIGZvcmsgb2YgYXBwZW5kQWxsQ2hpbGRyZW4gYmVjYXVzZSB3ZSBoYXZlIHR3byBkaWZmZXJlbnQgcGFyZW50IHR5cGVzLlxuICB2YXIgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXJDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnRhbCBjaGlsZCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH07XG4gIHVwZGF0ZUhvc3RDb250YWluZXIgPSBmdW5jdGlvbiAod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgcG9ydGFsT3JSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBjaGlsZHJlblVuY2hhbmdlZCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID09PSBudWxsO1xuICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCkge1xuICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBwb3J0YWxPclJvb3QuY29udGFpbmVySW5mbztcbiAgICAgIHZhciBuZXdDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lcik7XG4gICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKG5ld0NoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuID0gbmV3Q2hpbGRTZXQ7XG4gICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhlIGNvbnRhaW5lciB0byBzd2FwIG91dCB0aGUgY29udGFpbmVyLlxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lciwgbmV3Q2hpbGRTZXQpO1xuICAgIH1cbiAgfTtcbiAgdXBkYXRlSG9zdENvbXBvbmVudCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgdmFyIGN1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCB0aGVuIG5vbmUgb2Ygb3VyIGNoaWxkcmVuIGhhZCBhbnkgdXBkYXRlcy5cbiAgICAvLyBUaGlzIGd1YXJhbnRlZXMgdGhhdCB3ZSBjYW4gcmV1c2UgYWxsIG9mIHRoZW0uXG4gICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPT09IG51bGw7XG4gICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkICYmIG9sZFByb3BzID09PSBuZXdQcm9wcykge1xuICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtaWdodCByZWxlYXNlIGEgcHJldmlvdXMgY2xvbmUuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZWN5Y2xhYmxlSW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMpIHtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKHJlY3ljbGFibGVJbnN0YW5jZSwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCk7XG4gICAgfVxuICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCAmJiB1cGRhdGVQYXlsb2FkID09PSBudWxsKSB7XG4gICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1pZ2h0IHJlbGVhc2UgYSBwcmV2aW91cyBjbG9uZS5cbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5ld0luc3RhbmNlID0gY2xvbmVJbnN0YW5jZShjdXJyZW50SW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgd29ya0luUHJvZ3Jlc3MsIGNoaWxkcmVuVW5jaGFuZ2VkLCByZWN5Y2xhYmxlSW5zdGFuY2UpO1xuICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihuZXdJbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5ld0luc3RhbmNlO1xuICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCkge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG90aGVyIGVmZmVjdHMgaW4gdGhpcyB0cmVlLCB3ZSBuZWVkIHRvIGZsYWcgdGhpcyBub2RlIGFzIGhhdmluZyBvbmUuXG4gICAgICAvLyBFdmVuIHRob3VnaCB3ZSdyZSBub3QgZ29pbmcgdG8gdXNlIGl0IGZvciBhbnl0aGluZy5cbiAgICAgIC8vIE90aGVyd2lzZSBwYXJlbnRzIHdvbid0IGtub3cgdGhhdCB0aGVyZSBhcmUgbmV3IGNoaWxkcmVuIHRvIHByb3BhZ2F0ZSB1cHdhcmRzLlxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cbiAgICAgIGFwcGVuZEFsbENoaWxkcmVuKG5ld0luc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9O1xuICB1cGRhdGVIb3N0VGV4dCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgIC8vIElmIHRoZSB0ZXh0IGNvbnRlbnQgZGlmZmVycywgd2UnbGwgY3JlYXRlIGEgbmV3IHRleHQgaW5zdGFuY2UgZm9yIGl0LlxuICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShuZXdUZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgLy8gV2UnbGwgaGF2ZSB0byBtYXJrIGl0IGFzIGhhdmluZyBhbiBlZmZlY3QsIGV2ZW4gdGhvdWdoIHdlIHdvbid0IHVzZSB0aGUgZWZmZWN0IGZvciBhbnl0aGluZy5cbiAgICAgIC8vIFRoaXMgbGV0cyB0aGUgcGFyZW50cyBrbm93IHRoYXQgYXQgbGVhc3Qgb25lIG9mIHRoZWlyIGNoaWxkcmVuIGhhcyBjaGFuZ2VkLlxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gTm8gaG9zdCBvcGVyYXRpb25zXG4gIHVwZGF0ZUhvc3RDb250YWluZXIgPSBmdW5jdGlvbiAod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBOb29wXG4gIH07XG4gIHVwZGF0ZUhvc3RDb21wb25lbnQkMSA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgIC8vIE5vb3BcbiAgfTtcbiAgdXBkYXRlSG9zdFRleHQkMSA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgIC8vIE5vb3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29tcGxldGVXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50TGF6eTpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnRMYXp5OlxuICAgICAge1xuICAgICAgICB2YXIgX0NvbXBvbmVudCA9IGdldFJlc3VsdEZyb21SZXNvbHZlZFRoZW5hYmxlKHdvcmtJblByb2dyZXNzLnR5cGUpO1xuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoX0NvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIGZpYmVyUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgIGZpYmVyUm9vdC5jb250ZXh0ID0gZmliZXJSb290LnBlbmRpbmdDb250ZXh0O1xuICAgICAgICAgIGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgICAvLyB0aGF0IHdlcmVuJ3QgaHlkcmF0ZWQuXG4gICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIC8vIFRoaXMgcmVzZXRzIHRoZSBoYWNreSBzdGF0ZSB0byBmaXggaXNNb3VudGVkIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAgIC8vIFRPRE86IERlbGV0ZSB0aGlzIHdoZW4gd2UgZGVsZXRlIGlzTW91bnRlZCBhbmQgZmluZERPTU5vZGUuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG5cbiAgICAgICAgICBpZiAoY3VycmVudC5yZWYgIT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgICAgICAgbWFya1JlZiQxKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgISh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIGNyZWF0ZUluc3RhbmNlIHRvIGJlZ2luV29yayBhbmQga2VlcCBpdCBvbiBhIGNvbnRleHRcbiAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgLy8gb3IgY29tcGxldGVXb3JrIGRlcGVuZGluZyBvbiB3ZSB3YW50IHRvIGFkZCB0aGVuIHRvcC0+ZG93biBvclxuICAgICAgICAgIC8vIGJvdHRvbS0+dXAuIFRvcC0+ZG93biBpcyBmYXN0ZXIgaW4gSUUxMS5cbiAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgaWYgKHdhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgYW5kIGNyZWF0ZUluc3RhbmNlIHN0ZXAgaW50byB0aGUgYmVnaW5QaGFzZVxuICAgICAgICAgICAgLy8gdG8gY29uc29saWRhdGUuXG4gICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICAgICAgICAgIC8vIElmIGNoYW5nZXMgdG8gdGhlIGh5ZHJhdGVkIG5vZGUgbmVlZHMgdG8gYmUgYXBwbGllZCBhdCB0aGVcbiAgICAgICAgICAgICAgLy8gY29tbWl0LXBoYXNlIHdlIG1hcmsgdGhpcyBhcyBzdWNoLlxuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UodHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKGluc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICAgIC8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbiAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgc3VjaCByZW5kZXJlcnMgZ2V0IHNjaGVkdWxlZCBmb3IgbGF0ZXIgd29yay5cbiAgICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihpbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVmIG9uIGEgaG9zdCBub2RlIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICAgICAgICAgICAgbWFya1JlZiQxKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgdmFyIG5ld1RleHQgPSBuZXdQcm9wcztcbiAgICAgICAgaWYgKGN1cnJlbnQgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZFxuICAgICAgICAgIC8vIHRvIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgICAgdXBkYXRlSG9zdFRleHQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXdUZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgISh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgdmFyIF93YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UobmV3VGV4dCwgX3Jvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBGb3J3YXJkUmVmTGF6eTpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUGxhY2Vob2xkZXJDb21wb25lbnQ6XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBNb2RlOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIC8vIFBvcCBwcm92aWRlciBmaWJlclxuICAgICAgcG9wUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICBicmVhaztcbiAgICAvLyBFcnJvciBjYXNlc1xuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBoYXZlIGJlY29tZSBkZXRlcm1pbmF0ZSBiZWZvcmUgY29tcGxldGluZy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICBkZWZhdWx0OlxuICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIFRoaXMgbW9kdWxlIGlzIGZvcmtlZCBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnRzLlxuLy8gQnkgZGVmYXVsdCwgcmV0dXJuIGB0cnVlYCB0byBsb2cgZXJyb3JzIHRvIHRoZSBjb25zb2xlLlxuLy8gRm9ya3MgY2FuIHJldHVybiBgZmFsc2VgIGlmIHRoaXMgaXNuJ3QgZGVzaXJhYmxlLlxuZnVuY3Rpb24gc2hvd0Vycm9yRGlhbG9nKGNhcHR1cmVkRXJyb3IpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGxvZ0NhcHR1cmVkRXJyb3IoY2FwdHVyZWRFcnJvcikge1xuICB2YXIgbG9nRXJyb3IgPSBzaG93RXJyb3JEaWFsb2coY2FwdHVyZWRFcnJvcik7XG5cbiAgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0Vycm9yRGlhbG9nKCkgdG8gcHJldmVudCBkZWZhdWx0IGNvbnNvbGUuZXJyb3IgbG9nZ2luZy5cbiAgLy8gVGhpcyBlbmFibGVzIHJlbmRlcmVycyBsaWtlIFJlYWN0TmF0aXZlIHRvIGJldHRlciBtYW5hZ2UgcmVkYm94IGJlaGF2aW9yLlxuICBpZiAobG9nRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVycm9yID0gY2FwdHVyZWRFcnJvci5lcnJvcjtcbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnROYW1lLFxuICAgICAgICBjb21wb25lbnRTdGFjayA9IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICAgIHdpbGxSZXRyeSA9IGNhcHR1cmVkRXJyb3Iud2lsbFJldHJ5O1xuXG4gICAgLy8gQnJvd3NlcnMgc3VwcG9ydCBzaWxlbmNpbmcgdW5jYXVnaHQgZXJyb3JzIGJ5IGNhbGxpbmdcbiAgICAvLyBgcHJldmVudERlZmF1bHQoKWAgaW4gd2luZG93IGBlcnJvcmAgaGFuZGxlci5cbiAgICAvLyBXZSByZWNvcmQgdGhpcyBpbmZvcm1hdGlvbiBhcyBhbiBleHBhbmRvIG9uIHRoZSBlcnJvci5cblxuICAgIGlmIChlcnJvciAhPSBudWxsICYmIGVycm9yLl9zdXBwcmVzc0xvZ2dpbmcpIHtcbiAgICAgIGlmIChlcnJvckJvdW5kYXJ5Rm91bmQgJiYgd2lsbFJldHJ5KSB7XG4gICAgICAgIC8vIFRoZSBlcnJvciBpcyByZWNvdmVyYWJsZSBhbmQgd2FzIHNpbGVuY2VkLlxuICAgICAgICAvLyBJZ25vcmUgaXQgYW5kIGRvbid0IHByaW50IHRoZSBzdGFjayBhZGRlbmR1bS5cbiAgICAgICAgLy8gVGhpcyBpcyBoYW5keSBmb3IgdGVzdGluZyBlcnJvciBib3VuZGFyaWVzIHdpdGhvdXQgbm9pc2UuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSBlcnJvciBpcyBmYXRhbC4gU2luY2UgdGhlIHNpbGVuY2luZyBtaWdodCBoYXZlXG4gICAgICAvLyBiZWVuIGFjY2lkZW50YWwsIHdlJ2xsIHN1cmZhY2UgaXQgYW55d2F5LlxuICAgICAgLy8gSG93ZXZlciwgdGhlIGJyb3dzZXIgd291bGQgaGF2ZSBzaWxlbmNlZCB0aGUgb3JpZ2luYWwgZXJyb3JcbiAgICAgIC8vIHNvIHdlJ2xsIHByaW50IGl0IGZpcnN0LCBhbmQgdGhlbiBwcmludCB0aGUgc3RhY2sgYWRkZW5kdW0uXG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIC8vIEZvciBhIG1vcmUgZGV0YWlsZWQgZGVzY3JpcHRpb24gb2YgdGhpcyBibG9jaywgc2VlOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTMzODRcbiAgICB9XG5cbiAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lID8gJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPCcgKyBjb21wb25lbnROYW1lICsgJz4gY29tcG9uZW50OicgOiAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHM6JztcblxuICAgIHZhciBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9IHZvaWQgMDtcbiAgICAvLyBlcnJvckJvdW5kYXJ5Rm91bmQgY2hlY2sgaXMgc3VmZmljaWVudDsgZXJyb3JCb3VuZGFyeU5hbWUgY2hlY2sgaXMgdG8gc2F0aXNmeSBGbG93LlxuICAgIGlmIChlcnJvckJvdW5kYXJ5Rm91bmQgJiYgZXJyb3JCb3VuZGFyeU5hbWUpIHtcbiAgICAgIGlmICh3aWxsUmV0cnkpIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnUmVhY3Qgd2lsbCB0cnkgdG8gcmVjcmVhdGUgdGhpcyBjb21wb25lbnQgdHJlZSBmcm9tIHNjcmF0Y2ggJyArICgndXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgJyArIGVycm9yQm91bmRhcnlOYW1lICsgJy4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ1RoaXMgZXJyb3Igd2FzIGluaXRpYWxseSBoYW5kbGVkIGJ5IHRoZSBlcnJvciBib3VuZGFyeSAnICsgZXJyb3JCb3VuZGFyeU5hbWUgKyAnLlxcbicgKyAnUmVjcmVhdGluZyB0aGUgdHJlZSBmcm9tIHNjcmF0Y2ggZmFpbGVkIHNvIFJlYWN0IHdpbGwgdW5tb3VudCB0aGUgdHJlZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICsgJ1Zpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuJztcbiAgICB9XG4gICAgdmFyIGNvbWJpbmVkTWVzc2FnZSA9ICcnICsgY29tcG9uZW50TmFtZU1lc3NhZ2UgKyBjb21wb25lbnRTdGFjayArICdcXG5cXG4nICsgKCcnICsgZXJyb3JCb3VuZGFyeU1lc3NhZ2UpO1xuXG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdpdGgganVzdCB0aGUgY29tcG9uZW50IHN0YWNrLlxuICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2UgYW5kIEpTIHN0YWNrIGJlY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAvLyBoYXMgYWxyZWFkeSBwcmludGVkIGl0LiBFdmVuIGlmIHRoZSBhcHBsaWNhdGlvbiBzd2FsbG93cyB0aGUgZXJyb3IsIGl0IGlzIHN0aWxsXG4gICAgLy8gZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIHRoYW5rcyB0byB0aGUgREVWLW9ubHkgZmFrZSBldmVudCB0cmljayBpbiBSZWFjdEVycm9yVXRpbHMuXG4gICAgY29uc29sZS5lcnJvcihjb21iaW5lZE1lc3NhZ2UpO1xuICB9XG59XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG52YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBudWxsO1xue1xuICBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG5ldyBTZXQoKTtcbn1cblxuZnVuY3Rpb24gbG9nRXJyb3IoYm91bmRhcnksIGVycm9ySW5mbykge1xuICB2YXIgc291cmNlID0gZXJyb3JJbmZvLnNvdXJjZTtcbiAgdmFyIHN0YWNrID0gZXJyb3JJbmZvLnN0YWNrO1xuICBpZiAoc3RhY2sgPT09IG51bGwgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgc3RhY2sgPSBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKTtcbiAgfVxuXG4gIHZhciBjYXB0dXJlZEVycm9yID0ge1xuICAgIGNvbXBvbmVudE5hbWU6IHNvdXJjZSAhPT0gbnVsbCA/IGdldENvbXBvbmVudE5hbWUoc291cmNlLnR5cGUpIDogbnVsbCxcbiAgICBjb21wb25lbnRTdGFjazogc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnLFxuICAgIGVycm9yOiBlcnJvckluZm8udmFsdWUsXG4gICAgZXJyb3JCb3VuZGFyeTogbnVsbCxcbiAgICBlcnJvckJvdW5kYXJ5TmFtZTogbnVsbCxcbiAgICBlcnJvckJvdW5kYXJ5Rm91bmQ6IGZhbHNlLFxuICAgIHdpbGxSZXRyeTogZmFsc2VcbiAgfTtcblxuICBpZiAoYm91bmRhcnkgIT09IG51bGwgJiYgYm91bmRhcnkudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgIGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeSA9IGJvdW5kYXJ5LnN0YXRlTm9kZTtcbiAgICBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShib3VuZGFyeS50eXBlKTtcbiAgICBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlGb3VuZCA9IHRydWU7XG4gICAgY2FwdHVyZWRFcnJvci53aWxsUmV0cnkgPSB0cnVlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBsb2dDYXB0dXJlZEVycm9yKGNhcHR1cmVkRXJyb3IpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVGhpcyBtZXRob2QgbXVzdCBub3QgdGhyb3csIG9yIFJlYWN0IGludGVybmFsIHN0YXRlIHdpbGwgZ2V0IG1lc3NlZCB1cC5cbiAgICAvLyBJZiBjb25zb2xlLmVycm9yIGlzIG92ZXJyaWRkZW4sIG9yIGxvZ0NhcHR1cmVkRXJyb3IoKSBzaG93cyBhIGRpYWxvZyB0aGF0IHRocm93cyxcbiAgICAvLyB3ZSB3YW50IHRvIHJlcG9ydCB0aGlzIGVycm9yIG91dHNpZGUgb2YgdGhlIG5vcm1hbCBzdGFjayBhcyBhIGxhc3QgcmVzb3J0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTMxODhcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciA9IGZ1bmN0aW9uIChjdXJyZW50JCQxLCBpbnN0YW5jZSkge1xuICBzdGFydFBoYXNlVGltZXIoY3VycmVudCQkMSwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gIGluc3RhbmNlLnByb3BzID0gY3VycmVudCQkMS5tZW1vaXplZFByb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQkJDEubWVtb2l6ZWRTdGF0ZTtcbiAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgc3RvcFBoYXNlVGltZXIoKTtcbn07XG5cbi8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG5mdW5jdGlvbiBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCQkMSwgaW5zdGFuY2UpIHtcbiAge1xuICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIsIG51bGwsIGN1cnJlbnQkJDEsIGluc3RhbmNlKTtcbiAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgdmFyIHVubW91bnRFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQkJDEsIHVubW91bnRFcnJvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50JCQxKSB7XG4gIHZhciByZWYgPSBjdXJyZW50JCQxLnJlZjtcbiAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCByZWYsIG51bGwsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIHZhciByZWZFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50JCQxLCByZWZFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkxpZmVDeWNsZXMoY3VycmVudCQkMSwgZmluaXNoZWRXb3JrKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgICB7XG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnICYgU25hcHNob3QpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCQkMSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQkJDEubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50JCQxLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICBzdGFydFBoYXNlVGltZXIoZmluaXNoZWRXb3JrLCAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUnKTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHZhciBzbmFwc2hvdCA9IGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGRpZFdhcm5TZXQgPSBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtcbiAgICAgICAgICAgICAgaWYgKHNuYXBzaG90ID09PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5TZXQuaGFzKGZpbmlzaGVkV29yay50eXBlKSkge1xuICAgICAgICAgICAgICAgIGRpZFdhcm5TZXQuYWRkKGZpbmlzaGVkV29yay50eXBlKTtcbiAgICAgICAgICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpOiBBIHNuYXBzaG90IHZhbHVlIChvciBudWxsKSAnICsgJ211c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlID0gc25hcHNob3Q7XG4gICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAvLyBOb3RoaW5nIHRvIGRvIGZvciB0aGVzZSBjb21wb25lbnQgdHlwZXNcbiAgICAgIHJldHVybjtcbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMaWZlQ3ljbGVzKGZpbmlzaGVkUm9vdCwgY3VycmVudCQkMSwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRFeHBpcmF0aW9uVGltZSkge1xuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnRMYXp5OlxuICAgICAge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGlmIChjdXJyZW50JCQxID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydFBoYXNlVGltZXIoZmluaXNoZWRXb3JrLCAnY29tcG9uZW50RGlkTW91bnQnKTtcbiAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50JCQxLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudCQkMS5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgc3RhcnRQaGFzZVRpbWVyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlKTtcbiAgICAgICAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGNvbW1pdFVwZGF0ZVF1ZXVlKGZpbmlzaGVkV29yaywgdXBkYXRlUXVldWUsIGluc3RhbmNlLCBjb21taXR0ZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHZhciBfdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgIGlmIChfdXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay5jaGlsZC50YWcpIHtcbiAgICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICAgIF9pbnN0YW5jZSA9IGdldFB1YmxpY0luc3RhbmNlKGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50TGF6eTpcbiAgICAgICAgICAgICAgICBfaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssIF91cGRhdGVRdWV1ZSwgX2luc3RhbmNlLCBjb21taXR0ZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgIC8vIFJlbmRlcmVycyBtYXkgc2NoZWR1bGUgd29yayB0byBiZSBkb25lIGFmdGVyIGhvc3QgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuICAgICAgICAvLyAoZWcgRE9NIHJlbmRlcmVyIG1heSBzY2hlZHVsZSBhdXRvLWZvY3VzIGZvciBpbnB1dHMgYW5kIGZvcm0gY29udHJvbHMpLlxuICAgICAgICAvLyBUaGVzZSBlZmZlY3RzIHNob3VsZCBvbmx5IGJlIGNvbW1pdHRlZCB3aGVuIGNvbXBvbmVudHMgYXJlIGZpcnN0IG1vdW50ZWQsXG4gICAgICAgIC8vIGFrYSB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQvYWx0ZXJuYXRlLlxuICAgICAgICBpZiAoY3VycmVudCQkMSA9PT0gbnVsbCAmJiBmaW5pc2hlZFdvcmsuZWZmZWN0VGFnICYgVXBkYXRlKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICBjb21taXRNb3VudChfaW5zdGFuY2UyLCB0eXBlLCBwcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCB0ZXh0LlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAge1xuICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCBwb3J0YWxzLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHtcbiAgICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgICAgICB2YXIgb25SZW5kZXIgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5vblJlbmRlcjtcblxuICAgICAgICAgIGlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgICAgICAgICBvblJlbmRlcihmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCwgY3VycmVudCQkMSA9PT0gbnVsbCA/ICdtb3VudCcgOiAndXBkYXRlJywgZmluaXNoZWRXb3JrLmFjdHVhbER1cmF0aW9uLCBmaW5pc2hlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiwgZmluaXNoZWRXb3JrLmFjdHVhbFN0YXJ0VGltZSwgZ2V0Q29tbWl0VGltZSgpLCBmaW5pc2hlZFJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvblJlbmRlcihmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCwgY3VycmVudCQkMSA9PT0gbnVsbCA/ICdtb3VudCcgOiAndXBkYXRlJywgZmluaXNoZWRXb3JrLmFjdHVhbER1cmF0aW9uLCBmaW5pc2hlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiwgZmluaXNoZWRXb3JrLmFjdHVhbFN0YXJ0VGltZSwgZ2V0Q29tbWl0VGltZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgUGxhY2Vob2xkZXJDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmIChlbmFibGVTdXNwZW5zZSkge1xuICAgICAgICAgIGlmICgoZmluaXNoZWRXb3JrLm1vZGUgJiBTdHJpY3RNb2RlKSA9PT0gTm9FZmZlY3QpIHtcbiAgICAgICAgICAgIC8vIEluIGxvb3NlIG1vZGUsIGEgcGxhY2Vob2xkZXIgdGltZXMgb3V0IGJ5IHNjaGVkdWxpbmcgYSBzeW5jaHJvbm91c1xuICAgICAgICAgICAgLy8gdXBkYXRlIGluIHRoZSBjb21taXQgcGhhc2UuIFVzZSBgdXBkYXRlUXVldWVgIGZpZWxkIHRvIHNpZ25hbCB0aGF0XG4gICAgICAgICAgICAvLyB0aGUgVGltZW91dCBuZWVkcyB0byBzd2l0Y2ggdG8gdGhlIHBsYWNlaG9sZGVyLiBXZSBkb24ndCBuZWVkIGFuXG4gICAgICAgICAgICAvLyBlbnRpcmUgcXVldWUuIEFueSBub24tbnVsbCB2YWx1ZSB3b3Jrcy5cbiAgICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBJbnRlbnRpb25hbGx5IHVzaW5nIGEgdmFsdWUgb3RoZXIgdGhhbiBhbiBVcGRhdGVRdWV1ZS5cbiAgICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IGVtcHR5T2JqZWN0O1xuICAgICAgICAgICAgc2NoZWR1bGVXb3JrKGZpbmlzaGVkV29yaywgU3luYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIHN0cmljdCBtb2RlLCB0aGUgVXBkYXRlIGVmZmVjdCBpcyB1c2VkIHRvIHJlY29yZCB0aGUgdGltZSBhdFxuICAgICAgICAgICAgLy8gd2hpY2ggdGhlIHBsYWNlaG9sZGVyIHRpbWVkIG91dC5cbiAgICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IHJlcXVlc3RDdXJyZW50VGltZSgpO1xuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IHsgdGltZWRPdXRBdDogY3VycmVudFRpbWUgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG4gIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgIHZhciBpbnN0YW5jZVRvVXNlID0gdm9pZCAwO1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBpbnN0YW5jZVRvVXNlID0gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGluc3RhbmNlVG9Vc2UgPSBpbnN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlZihpbnN0YW5jZVRvVXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBpZiAoIXJlZi5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpKSB7XG4gICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnVW5leHBlY3RlZCByZWYgb2JqZWN0IHByb3ZpZGVkIGZvciAlcy4gJyArICdVc2UgZWl0aGVyIGEgcmVmLXNldHRlciBmdW5jdGlvbiBvciBSZWFjdC5jcmVhdGVSZWYoKS4lcycsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpLCBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVmLmN1cnJlbnQgPSBpbnN0YW5jZVRvVXNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCQkMSkge1xuICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQkJDEucmVmO1xuICBpZiAoY3VycmVudFJlZiAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgY3VycmVudFJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3VycmVudFJlZihudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLy8gVXNlci1vcmlnaW5hdGluZyBlcnJvcnMgKGxpZmVjeWNsZXMgYW5kIHJlZnMpIHNob3VsZCBub3QgaW50ZXJydXB0XG4vLyBkZWxldGlvbiwgc28gZG9uJ3QgbGV0IHRoZW0gdGhyb3cuIEhvc3Qtb3JpZ2luYXRpbmcgZXJyb3JzIHNob3VsZFxuLy8gaW50ZXJydXB0IGRlbGV0aW9uLCBzbyBpdCdzIG9rYXlcbmZ1bmN0aW9uIGNvbW1pdFVubW91bnQoY3VycmVudCQkMSkge1xuICBvbkNvbW1pdFVubW91bnQoY3VycmVudCQkMSk7XG5cbiAgc3dpdGNoIChjdXJyZW50JCQxLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgICB7XG4gICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50JCQxKTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gY3VycmVudCQkMS5zdGF0ZU5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCQkMSwgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50JCQxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBpcyByZWN1cnNpdmUuXG4gICAgICAgIC8vIFdlIGFyZSBhbHNvIG5vdCB1c2luZyB0aGlzIHBhcmVudCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgd2lsbCBnZXQgcHVzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50JCQxKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgZW1wdHlQb3J0YWxDb250YWluZXIoY3VycmVudCQkMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdE5lc3RlZFVubW91bnRzKHJvb3QpIHtcbiAgLy8gV2hpbGUgd2UncmUgaW5zaWRlIGEgcmVtb3ZlZCBob3N0IG5vZGUgd2UgZG9uJ3Qgd2FudCB0byBjYWxsXG4gIC8vIHJlbW92ZUNoaWxkIG9uIHRoZSBpbm5lciBub2RlcyBiZWNhdXNlIHRoZXkncmUgcmVtb3ZlZCBieSB0aGUgdG9wXG4gIC8vIGNhbGwgYW55d2F5LiBXZSBhbHNvIHdhbnQgdG8gY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCBvbiBhbGxcbiAgLy8gY29tcG9zaXRlcyBiZWZvcmUgdGhpcyBob3N0IG5vZGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSB0cmVlLiBUaGVyZWZvcmVcbiAgdmFyIG5vZGUgPSByb290O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbW1pdFVubW91bnQobm9kZSk7XG4gICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB0aGV5IG1heSBjb250YWluIG1vcmUgY29tcG9zaXRlIG9yIGhvc3Qgbm9kZXMuXG4gICAgLy8gU2tpcCBwb3J0YWxzIGJlY2F1c2UgY29tbWl0VW5tb3VudCgpIGN1cnJlbnRseSB2aXNpdHMgdGhlbSByZWN1cnNpdmVseS5cbiAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCAmJiAoXG4gICAgLy8gSWYgd2UgdXNlIG11dGF0aW9uIHdlIGRyaWxsIGRvd24gaW50byBwb3J0YWxzIHVzaW5nIGNvbW1pdFVubW91bnQgYWJvdmUuXG4gICAgLy8gSWYgd2UgZG9uJ3QgdXNlIG11dGF0aW9uIHdlIGRyaWxsIGRvd24gaW50byBwb3J0YWxzIGhlcmUgaW5zdGVhZC5cbiAgICAhc3VwcG9ydHNNdXRhdGlvbiB8fCBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gcm9vdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaEZpYmVyKGN1cnJlbnQkJDEpIHtcbiAgLy8gQ3V0IG9mZiB0aGUgcmV0dXJuIHBvaW50ZXJzIHRvIGRpc2Nvbm5lY3QgaXQgZnJvbSB0aGUgdHJlZS4gSWRlYWxseSwgd2VcbiAgLy8gc2hvdWxkIGNsZWFyIHRoZSBjaGlsZCBwb2ludGVyIG9mIHRoZSBwYXJlbnQgYWx0ZXJuYXRlIHRvIGxldCB0aGlzXG4gIC8vIGdldCBHQzplZCBidXQgd2UgZG9uJ3Qga25vdyB3aGljaCBmb3Igc3VyZSB3aGljaCBwYXJlbnQgaXMgdGhlIGN1cnJlbnRcbiAgLy8gb25lIHNvIHdlJ2xsIHNldHRsZSBmb3IgR0M6aW5nIHRoZSBzdWJ0cmVlIG9mIHRoaXMgY2hpbGQuIFRoaXMgY2hpbGRcbiAgLy8gaXRzZWxmIHdpbGwgYmUgR0M6ZWQgd2hlbiB0aGUgcGFyZW50IHVwZGF0ZXMgdGhlIG5leHQgdGltZS5cbiAgY3VycmVudCQkMS5yZXR1cm4gPSBudWxsO1xuICBjdXJyZW50JCQxLmNoaWxkID0gbnVsbDtcbiAgaWYgKGN1cnJlbnQkJDEuYWx0ZXJuYXRlKSB7XG4gICAgY3VycmVudCQkMS5hbHRlcm5hdGUuY2hpbGQgPSBudWxsO1xuICAgIGN1cnJlbnQkJDEuYWx0ZXJuYXRlLnJldHVybiA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1wdHlQb3J0YWxDb250YWluZXIoY3VycmVudCQkMSkge1xuICBpZiAoIXN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcG9ydGFsID0gY3VycmVudCQkMS5zdGF0ZU5vZGU7XG4gIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsLmNvbnRhaW5lckluZm87XG5cbiAgdmFyIGVtcHR5Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXJJbmZvKTtcbiAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIGVtcHR5Q2hpbGRTZXQpO1xufVxuXG5mdW5jdGlvbiBjb21taXRDb250YWluZXIoZmluaXNoZWRXb3JrKSB7XG4gIGlmICghc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIHZhciBwb3J0YWxPclJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICB2YXIgY29udGFpbmVySW5mbyA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvLFxuICAgICAgICAgICAgX3BlbmRpbmdDaGlsZHJlbiA9IHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW47XG5cbiAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIF9wZW5kaW5nQ2hpbGRyZW4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFBhcmVudEZpYmVyKGZpYmVyKSB7XG4gIHZhciBwYXJlbnQgPSBmaWJlci5yZXR1cm47XG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpZiAoaXNIb3N0UGFyZW50KHBhcmVudCkpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gIH1cbiAgaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xufVxuXG5mdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBmaWJlci50YWcgPT09IEhvc3RSb290IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFBvcnRhbDtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgLy8gV2UncmUgZ29pbmcgdG8gc2VhcmNoIGZvcndhcmQgaW50byB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGEgc2libGluZyBob3N0XG4gIC8vIG5vZGUuIFVuZm9ydHVuYXRlbHksIGlmIG11bHRpcGxlIGluc2VydGlvbnMgYXJlIGRvbmUgaW4gYSByb3cgd2UgaGF2ZSB0b1xuICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgc2libGluZ3M6IHdoaWxlICh0cnVlKSB7XG4gICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBpc0hvc3RQYXJlbnQobm9kZS5yZXR1cm4pKSB7XG4gICAgICAgIC8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbiAgICAgICAgLy8gbGFzdCBzaWJsaW5nLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIG5vZGUudGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgLy8gVHJ5IHRvIHNlYXJjaCBkb3duIHVudGlsIHdlIGZpbmQgb25lLlxuICAgICAgaWYgKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgLy8gV2UgYWxzbyBza2lwIHBvcnRhbHMgYmVjYXVzZSB0aGV5IGFyZSBub3QgcGFydCBvZiB0aGlzIGhvc3QgdHJlZS5cbiAgICAgIGlmIChub2RlLmNoaWxkID09PSBudWxsIHx8IG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cbiAgICBpZiAoIShub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkpIHtcbiAgICAgIC8vIEZvdW5kIGl0IVxuICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKSB7XG4gIGlmICghc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFJlY3Vyc2l2ZWx5IGluc2VydCBhbGwgaG9zdCBub2RlcyBpbnRvIHRoZSBwYXJlbnQuXG4gIHZhciBwYXJlbnRGaWJlciA9IGdldEhvc3RQYXJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuXG4gIC8vIE5vdGU6IHRoZXNlIHR3byB2YXJpYWJsZXMgKm11c3QqIGFsd2F5cyBiZSB1cGRhdGVkIHRvZ2V0aGVyLlxuICB2YXIgcGFyZW50ID0gdm9pZCAwO1xuICB2YXIgaXNDb250YWluZXIgPSB2b2lkIDA7XG5cbiAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICBpc0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICBpc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBob3N0IHBhcmVudCBmaWJlci4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuICBpZiAocGFyZW50RmliZXIuZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgLy8gUmVzZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgcGFyZW50IGJlZm9yZSBkb2luZyBhbnkgaW5zZXJ0aW9uc1xuICAgIHJlc2V0VGV4dENvbnRlbnQocGFyZW50KTtcbiAgICAvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xuICAgIHBhcmVudEZpYmVyLmVmZmVjdFRhZyAmPSB+Q29udGVudFJlc2V0O1xuICB9XG5cbiAgdmFyIGJlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICB2YXIgbm9kZSA9IGZpbmlzaGVkV29yaztcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIGlmIChpc0NvbnRhaW5lcikge1xuICAgICAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zZXJ0QmVmb3JlKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0NvbnRhaW5lcikge1xuICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBwZW5kQ2hpbGQocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAvLyBJZiB0aGUgaW5zZXJ0aW9uIGl0c2VsZiBpcyBhIHBvcnRhbCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAvLyB0aGUgcG9ydGFsIGRpcmVjdGx5LlxuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50JCQxKSB7XG4gIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGRlbGV0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICB2YXIgbm9kZSA9IGN1cnJlbnQkJDE7XG5cbiAgLy8gRWFjaCBpdGVyYXRpb24sIGN1cnJlbnRQYXJlbnQgaXMgcG9wdWxhdGVkIHdpdGggbm9kZSdzIGhvc3QgcGFyZW50IGlmIG5vdFxuICAvLyBjdXJyZW50UGFyZW50SXNWYWxpZC5cbiAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG5cbiAgLy8gTm90ZTogdGhlc2UgdHdvIHZhcmlhYmxlcyAqbXVzdCogYWx3YXlzIGJlIHVwZGF0ZWQgdG9nZXRoZXIuXG4gIHZhciBjdXJyZW50UGFyZW50ID0gdm9pZCAwO1xuICB2YXIgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdm9pZCAwO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCFjdXJyZW50UGFyZW50SXNWYWxpZCkge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUucmV0dXJuO1xuICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgIShwYXJlbnQgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgICAgfVxuICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKG5vZGUpO1xuICAgICAgLy8gQWZ0ZXIgYWxsIHRoZSBjaGlsZHJlbiBoYXZlIHVubW91bnRlZCwgaXQgaXMgbm93IHNhZmUgdG8gcmVtb3ZlIHRoZVxuICAgICAgLy8gbm9kZSBmcm9tIHRoZSB0cmVlLlxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXIoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgdmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlbS5cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAvLyBXaGVuIHdlIGdvIGludG8gYSBwb3J0YWwsIGl0IGJlY29tZXMgdGhlIHBhcmVudCB0byByZW1vdmUgZnJvbS5cbiAgICAgIC8vIFdlIHdpbGwgcmVhc3NpZ24gaXQgYmFjayB3aGVuIHdlIHBvcCB0aGUgcG9ydGFsIG9uIHRoZSB3YXkgdXAuXG4gICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHBvcnRhbHMgbWlnaHQgY29udGFpbiBob3N0IGNvbXBvbmVudHMuXG4gICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0VW5tb3VudChub2RlKTtcbiAgICAgIC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgbWF5IGZpbmQgbW9yZSBob3N0IGNvbXBvbmVudHMgYmVsb3cuXG4gICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnQkJDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSBjdXJyZW50JCQxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBXaGVuIHdlIGdvIG91dCBvZiB0aGUgcG9ydGFsLCB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlIHBhcmVudC5cbiAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3Qga2VlcCBhIHN0YWNrIG9mIHRoZW0sIHdlIHdpbGwgc2VhcmNoIGZvciBpdC5cbiAgICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0RGVsZXRpb24oY3VycmVudCQkMSkge1xuICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgaG9zdCBub2RlcyBmcm9tIHRoZSBwYXJlbnQuXG4gICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCQkMSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICBjb21taXROZXN0ZWRVbm1vdW50cyhjdXJyZW50JCQxKTtcbiAgfVxuICBkZXRhY2hGaWJlcihjdXJyZW50JCQxKTtcbn1cblxuZnVuY3Rpb24gY29tbWl0V29yayhjdXJyZW50JCQxLCBmaW5pc2hlZFdvcmspIHtcbiAgaWYgKCFzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgY29tbWl0Q29udGFpbmVyKGZpbmlzaGVkV29yayk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50TGF6eTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKGluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb21taXQgdGhlIHdvcmsgcHJlcGFyZWQgZWFybGllci5cbiAgICAgICAgICB2YXIgbmV3UHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQkJDEgIT09IG51bGwgPyBjdXJyZW50JCQxLm1lbW9pemVkUHJvcHMgOiBuZXdQcm9wcztcbiAgICAgICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAgIC8vIFRPRE86IFR5cGUgdGhlIHVwZGF0ZVF1ZXVlIHRvIGJlIHNwZWNpZmljIHRvIGhvc3QgY29tcG9uZW50cy5cbiAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgICEoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHNob3VsZCBoYXZlIGEgdGV4dCBub2RlIGluaXRpYWxpemVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIG5ld1RleHQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgLy8gRm9yIGh5ZHJhdGlvbiB3ZSByZXVzZSB0aGUgdXBkYXRlIHBhdGggYnV0IHdlIHRyZWF0IHRoZSBvbGRQcm9wc1xuICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQkJDEgIT09IG51bGwgPyBjdXJyZW50JCQxLm1lbW9pemVkUHJvcHMgOiBuZXdUZXh0O1xuICAgICAgICBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgUGxhY2Vob2xkZXJDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRSZXNldFRleHRDb250ZW50KGN1cnJlbnQkJDEpIHtcbiAgaWYgKCFzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlc2V0VGV4dENvbnRlbnQoY3VycmVudCQkMS5zdGF0ZU5vZGUpO1xufVxuXG5mdW5jdGlvbiBOb29wQ29tcG9uZW50KCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUm9vdEVycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXhwaXJhdGlvblRpbWUpO1xuICAvLyBVbm1vdW50IHRoZSByb290IGJ5IHJlbmRlcmluZyBudWxsLlxuICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG4gIHVwZGF0ZS5wYXlsb2FkID0geyBlbGVtZW50OiBudWxsIH07XG4gIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIG9uVW5jYXVnaHRFcnJvcihlcnJvcik7XG4gICAgbG9nRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG4gIH07XG4gIHJldHVybiB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUoZmliZXIsIGVycm9ySW5mbywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShleHBpcmF0aW9uVGltZSk7XG4gIHVwZGF0ZS50YWcgPSBDYXB0dXJlVXBkYXRlO1xuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoID0gZmliZXIudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2g7XG4gIGlmIChlbmFibGVHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggJiYgdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgICB1cGRhdGUucGF5bG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2goZXJyb3IpO1xuICAgIH07XG4gIH1cblxuICB2YXIgaW5zdCA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgaWYgKGluc3QgIT09IG51bGwgJiYgdHlwZW9mIGluc3QuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjaygpIHtcbiAgICAgIGlmICghZW5hYmxlR2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoIHx8IGdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUbyBwcmVzZXJ2ZSB0aGUgcHJlZXhpc3RpbmcgcmV0cnkgYmVoYXZpb3Igb2YgZXJyb3IgYm91bmRhcmllcyxcbiAgICAgICAgLy8gd2Uga2VlcCB0cmFjayBvZiB3aGljaCBvbmVzIGFscmVhZHkgZmFpbGVkIGR1cmluZyB0aGlzIGJhdGNoLlxuICAgICAgICAvLyBUaGlzIGdldHMgcmVzZXQgYmVmb3JlIHdlIHlpZWxkIGJhY2sgdG8gdGhlIGJyb3dzZXIuXG4gICAgICAgIC8vIFRPRE86IFdhcm4gaW4gc3RyaWN0IG1vZGUgaWYgZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoIGlzXG4gICAgICAgIC8vIG5vdCBkZWZpbmVkLlxuICAgICAgICBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkKHRoaXMpO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuICAgICAgdmFyIHN0YWNrID0gZXJyb3JJbmZvLnN0YWNrO1xuICAgICAgbG9nRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG4gICAgICB0aGlzLmNvbXBvbmVudERpZENhdGNoKGVycm9yLCB7XG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBzdGFjayAhPT0gbnVsbCA/IHN0YWNrIDogJydcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24ocm9vdCwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCB2YWx1ZSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgLy8gVGhlIHNvdXJjZSBmaWJlciBkaWQgbm90IGNvbXBsZXRlLlxuICBzb3VyY2VGaWJlci5lZmZlY3RUYWcgfD0gSW5jb21wbGV0ZTtcbiAgLy8gSXRzIGVmZmVjdCBsaXN0IGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgc291cmNlRmliZXIuZmlyc3RFZmZlY3QgPSBzb3VyY2VGaWJlci5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICBpZiAoZW5hYmxlU3VzcGVuc2UgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRoaXMgaXMgYSB0aGVuYWJsZS5cbiAgICB2YXIgdGhlbmFibGUgPSB2YWx1ZTtcblxuICAgIC8vIEZpbmQgdGhlIGVhcmxpZXN0IHRpbWVvdXQgdGhyZXNob2xkIG9mIGFsbCB0aGUgcGxhY2Vob2xkZXJzIGluIHRoZVxuICAgIC8vIGFuY2VzdG9yIHBhdGguIFdlIGNvdWxkIGF2b2lkIHRoaXMgdHJhdmVyc2FsIGJ5IHN0b3JpbmcgdGhlIHRocmVzaG9sZHMgb25cbiAgICAvLyB0aGUgc3RhY2ssIGJ1dCB3ZSBjaG9vc2Ugbm90IHRvIGJlY2F1c2Ugd2Ugb25seSBoaXQgdGhpcyBwYXRoIGlmIHdlJ3JlXG4gICAgLy8gSU8tYm91bmQgKGkuZS4gaWYgc29tZXRoaW5nIHN1c3BlbmRzKS4gV2hlcmVhcyB0aGUgc3RhY2sgaXMgdXNlZCBldmVuIGluXG4gICAgLy8gdGhlIG5vbi1JTy0gYm91bmQgY2FzZS5cbiAgICB2YXIgX3dvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXI7XG4gICAgdmFyIGVhcmxpZXN0VGltZW91dE1zID0gLTE7XG4gICAgdmFyIHN0YXJ0VGltZU1zID0gLTE7XG4gICAgZG8ge1xuICAgICAgaWYgKF93b3JrSW5Qcm9ncmVzcy50YWcgPT09IFBsYWNlaG9sZGVyQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gX3dvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlID09PSB0cnVlICYmIGN1cnJlbnQuc3RhdGVOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gUmVhY2hlZCBhIHBsYWNlaG9sZGVyIHRoYXQgYWxyZWFkeSB0aW1lZCBvdXQuIEVhY2ggdGltZWQgb3V0XG4gICAgICAgICAgLy8gcGxhY2Vob2xkZXIgYWN0cyBhcyB0aGUgcm9vdCBvZiBhIG5ldyBzdXNwZW5zZSBib3VuZGFyeS5cblxuICAgICAgICAgIC8vIFVzZSB0aGUgdGltZSBhdCB3aGljaCB0aGUgcGxhY2Vob2xkZXIgdGltZWQgb3V0IGFzIHRoZSBzdGFydCB0aW1lXG4gICAgICAgICAgLy8gZm9yIHRoZSBjdXJyZW50IHJlbmRlci5cbiAgICAgICAgICB2YXIgdGltZWRPdXRBdCA9IGN1cnJlbnQuc3RhdGVOb2RlLnRpbWVkT3V0QXQ7XG4gICAgICAgICAgc3RhcnRUaW1lTXMgPSBleHBpcmF0aW9uVGltZVRvTXModGltZWRPdXRBdCk7XG5cbiAgICAgICAgICAvLyBEbyBub3Qgc2VhcmNoIGFueSBmdXJ0aGVyLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aW1lb3V0UHJvcE1zID0gX3dvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5kZWxheU1zO1xuICAgICAgICBpZiAodHlwZW9mIHRpbWVvdXRQcm9wTXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgaWYgKHRpbWVvdXRQcm9wTXMgPD0gMCkge1xuICAgICAgICAgICAgZWFybGllc3RUaW1lb3V0TXMgPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWFybGllc3RUaW1lb3V0TXMgPT09IC0xIHx8IHRpbWVvdXRQcm9wTXMgPCBlYXJsaWVzdFRpbWVvdXRNcykge1xuICAgICAgICAgICAgZWFybGllc3RUaW1lb3V0TXMgPSB0aW1lb3V0UHJvcE1zO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX3dvcmtJblByb2dyZXNzID0gX3dvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICB9IHdoaWxlIChfd29ya0luUHJvZ3Jlc3MgIT09IG51bGwpO1xuXG4gICAgLy8gU2NoZWR1bGUgdGhlIG5lYXJlc3QgUGxhY2Vob2xkZXIgdG8gcmUtcmVuZGVyIHRoZSB0aW1lZCBvdXQgdmlldy5cbiAgICBfd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICBkbyB7XG4gICAgICBpZiAoX3dvcmtJblByb2dyZXNzLnRhZyA9PT0gUGxhY2Vob2xkZXJDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGRpZFRpbWVvdXQgPSBfd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgaWYgKCFkaWRUaW1lb3V0KSB7XG4gICAgICAgICAgLy8gRm91bmQgdGhlIG5lYXJlc3QgYm91bmRhcnkuXG5cbiAgICAgICAgICAvLyBJZiB0aGUgYm91bmRhcnkgaXMgbm90IGluIGFzeW5jIG1vZGUsIHdlIHNob3VsZCBub3Qgc3VzcGVuZCwgYW5kXG4gICAgICAgICAgLy8gbGlrZXdpc2UsIHdoZW4gdGhlIHByb21pc2UgcmVzb2x2ZXMsIHdlIHNob3VsZCBwaW5nIHN5bmNocm9ub3VzbHkuXG4gICAgICAgICAgdmFyIHBpbmdUaW1lID0gKF93b3JrSW5Qcm9ncmVzcy5tb2RlICYgQXN5bmNNb2RlKSA9PT0gTm9FZmZlY3QgPyBTeW5jIDogcmVuZGVyRXhwaXJhdGlvblRpbWU7XG5cbiAgICAgICAgICAvLyBBdHRhY2ggYSBsaXN0ZW5lciB0byB0aGUgcHJvbWlzZSB0byBcInBpbmdcIiB0aGUgcm9vdCBhbmQgcmV0cnkuXG4gICAgICAgICAgdmFyIG9uUmVzb2x2ZU9yUmVqZWN0ID0gcmV0cnlTdXNwZW5kZWRSb290LmJpbmQobnVsbCwgcm9vdCwgX3dvcmtJblByb2dyZXNzLCBwaW5nVGltZSk7XG4gICAgICAgICAgdGhlbmFibGUudGhlbihvblJlc29sdmVPclJlamVjdCwgb25SZXNvbHZlT3JSZWplY3QpO1xuXG4gICAgICAgICAgLy8gSWYgdGhlIGJvdW5kYXJ5IGlzIG91dHNpZGUgb2Ygc3RyaWN0IG1vZGUsIHdlIHNob3VsZCAqbm90KiBzdXNwZW5kXG4gICAgICAgICAgLy8gdGhlIGNvbW1pdC4gUHJldGVuZCBhcyBpZiB0aGUgc3VzcGVuZGVkIGNvbXBvbmVudCByZW5kZXJlZCBudWxsIGFuZFxuICAgICAgICAgIC8vIGtlZXAgcmVuZGVyaW5nLiBJbiB0aGUgY29tbWl0IHBoYXNlLCB3ZSdsbCBzY2hlZHVsZSBhIHN1YnNlcXVlbnRcbiAgICAgICAgICAvLyBzeW5jaHJvbm91cyB1cGRhdGUgdG8gcmUtcmVuZGVyIHRoZSBQbGFjZWhvbGRlci5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIE5vdGU6IEl0IGRvZXNuJ3QgbWF0dGVyIHdoZXRoZXIgdGhlIGNvbXBvbmVudCB0aGF0IHN1c3BlbmRlZCB3YXNcbiAgICAgICAgICAvLyBpbnNpZGUgYSBzdHJpY3QgbW9kZSB0cmVlLiBJZiB0aGUgUGxhY2Vob2xkZXIgaXMgb3V0c2lkZSBvZiBpdCwgd2VcbiAgICAgICAgICAvLyBzaG91bGQgKm5vdCogc3VzcGVuZCB0aGUgY29tbWl0LlxuICAgICAgICAgIGlmICgoX3dvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSA9PT0gTm9FZmZlY3QpIHtcbiAgICAgICAgICAgIF93b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuXG4gICAgICAgICAgICAvLyBVbm1vdW50IHRoZSBzb3VyY2UgZmliZXIncyBjaGlsZHJlblxuICAgICAgICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihzb3VyY2VGaWJlci5hbHRlcm5hdGUsIHNvdXJjZUZpYmVyLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIHNvdXJjZUZpYmVyLmVmZmVjdFRhZyAmPSB+SW5jb21wbGV0ZTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VGaWJlci50YWcgPT09IEluZGV0ZXJtaW5hdGVDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgLy8gTGV0J3MganVzdCBhc3N1bWUgaXQncyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LiBUaGlzIGZpYmVyIHdpbGxcbiAgICAgICAgICAgICAgLy8gYmUgdW5tb3VudGVkIGluIHRoZSBpbW1lZGlhdGUgbmV4dCBjb21taXQsIGFueXdheS5cbiAgICAgICAgICAgICAgc291cmNlRmliZXIudGFnID0gRnVuY3Rpb25hbENvbXBvbmVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNvdXJjZUZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgfHwgc291cmNlRmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudExhenkpIHtcbiAgICAgICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gY29tbWl0IHRoaXMgZmliZXIgZXZlbiB0aG91Z2ggaXQgZGlkbid0XG4gICAgICAgICAgICAgIC8vIGNvbXBsZXRlLiBCdXQgd2Ugc2hvdWxkbid0IGNhbGwgYW55IGxpZmVjeWNsZSBtZXRob2RzIG9yXG4gICAgICAgICAgICAgIC8vIGNhbGxiYWNrcy4gUmVtb3ZlIGFsbCBsaWZlY3ljbGUgZWZmZWN0IHRhZ3MuXG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyLmVmZmVjdFRhZyAmPSB+TGlmZWN5Y2xlRWZmZWN0TWFzaztcbiAgICAgICAgICAgICAgaWYgKHNvdXJjZUZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGFib3V0IHRvIG1vdW50IGEgY2xhc3MgY29tcG9uZW50IHRoYXQgZG9lc24ndCBoYXZlIGFuXG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UuIFR1cm4gdGhpcyBpbnRvIGEgZHVtbXkgZnVuY3Rpb25hbCBjb21wb25lbnQgaW5zdGVhZCxcbiAgICAgICAgICAgICAgICAvLyB0byBwcmV2ZW50IHR5cGUgZXJyb3JzLiBUaGlzIGlzIGEgYml0IHdlaXJkIGJ1dCBpdCdzIGFuIGVkZ2VcbiAgICAgICAgICAgICAgICAvLyBjYXNlIGFuZCB3ZSdyZSBhYm91dCB0byBzeW5jaHJvbm91c2x5IGRlbGV0ZSB0aGlzXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50LCBhbnl3YXkuXG4gICAgICAgICAgICAgICAgc291cmNlRmliZXIudGFnID0gRnVuY3Rpb25hbENvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBzb3VyY2VGaWJlci50eXBlID0gTm9vcENvbXBvbmVudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFeGl0IHdpdGhvdXQgc3VzcGVuZGluZy5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb25maXJtZWQgdGhhdCB0aGUgYm91bmRhcnkgaXMgaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiBDb250aW51ZSB3aXRoXG4gICAgICAgICAgLy8gdGhlIG5vcm1hbCBzdXNwZW5kIHBhdGguXG5cbiAgICAgICAgICB2YXIgYWJzb2x1dGVUaW1lb3V0TXMgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKGVhcmxpZXN0VGltZW91dE1zID09PSAtMSkge1xuICAgICAgICAgICAgLy8gSWYgbm8gZXhwbGljaXQgdGhyZXNob2xkIGlzIGdpdmVuLCBkZWZhdWx0IHRvIGFuIGFiaXRyYXJpbHkgbGFyZ2VcbiAgICAgICAgICAgIC8vIHZhbHVlLiBUaGUgYWN0dWFsIHNpemUgZG9lc24ndCBtYXR0ZXIgYmVjYXVzZSB0aGUgdGhyZXNob2xkIGZvciB0aGVcbiAgICAgICAgICAgIC8vIHdob2xlIHRyZWUgd2lsbCBiZSBjbGFtcGVkIHRvIHRoZSBleHBpcmF0aW9uIHRpbWUuXG4gICAgICAgICAgICBhYnNvbHV0ZVRpbWVvdXRNcyA9IG1heFNpZ25lZDMxQml0SW50O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRUaW1lTXMgPT09IC0xKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgc3VzcGVuZCBoYXBwZW5lZCBvdXRzaWRlIG9mIGFueSBhbHJlYWR5IHRpbWVkLW91dFxuICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlcnMuIFdlIGRvbid0IGtub3cgZXhhY3RseSB3aGVuIHRoZSB1cGRhdGUgd2FzIHNjaGVkdWxlZCxcbiAgICAgICAgICAgICAgLy8gYnV0IHdlIGNhbiBpbmZlciBhbiBhcHByb3hpbWF0ZSBzdGFydCB0aW1lIGZyb20gdGhlIGV4cGlyYXRpb25cbiAgICAgICAgICAgICAgLy8gdGltZS4gRmlyc3QsIGZpbmQgdGhlIGVhcmxpZXN0IHVuY29tbWl0dGVkIGV4cGlyYXRpb24gdGltZSBpbiB0aGVcbiAgICAgICAgICAgICAgLy8gdHJlZSwgaW5jbHVkaW5nIHdvcmsgdGhhdCBpcyBzdXNwZW5kZWQuIFRoZW4gc3VidHJhY3QgdGhlIG9mZnNldFxuICAgICAgICAgICAgICAvLyB1c2VkIHRvIGNvbXB1dGUgYW4gYXN5bmMgdXBkYXRlJ3MgZXhwaXJhdGlvbiB0aW1lLiBUaGlzIHdpbGwgY2F1c2VcbiAgICAgICAgICAgICAgLy8gaGlnaCBwcmlvcml0eSAoaW50ZXJhY3RpdmUpIHdvcmsgdG8gZXhwaXJlIGVhcmxpZXIgdGhhbiBuZWNlc3NhcnksXG4gICAgICAgICAgICAgIC8vIGJ1dCB3ZSBjYW4gYWNjb3VudCBmb3IgdGhpcyBieSBhZGp1c3RpbmcgZm9yIHRoZSBKdXN0IE5vdGljZWFibGVcbiAgICAgICAgICAgICAgLy8gRGlmZmVyZW5jZS5cbiAgICAgICAgICAgICAgdmFyIGVhcmxpZXN0RXhwaXJhdGlvblRpbWUgPSBmaW5kRWFybGllc3RPdXRzdGFuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgICB2YXIgZWFybGllc3RFeHBpcmF0aW9uVGltZU1zID0gZXhwaXJhdGlvblRpbWVUb01zKGVhcmxpZXN0RXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgICBzdGFydFRpbWVNcyA9IGVhcmxpZXN0RXhwaXJhdGlvblRpbWVNcyAtIExPV19QUklPUklUWV9FWFBJUkFUSU9OO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWJzb2x1dGVUaW1lb3V0TXMgPSBzdGFydFRpbWVNcyArIGVhcmxpZXN0VGltZW91dE1zO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE1hcmsgdGhlIGVhcmxpZXN0IHRpbWVvdXQgaW4gdGhlIHN1c3BlbmRlZCBmaWJlcidzIGFuY2VzdG9yIHBhdGguXG4gICAgICAgICAgLy8gQWZ0ZXIgY29tcGxldGluZyB0aGUgcm9vdCwgd2UnbGwgdGFrZSB0aGUgbGFyZ2VzdCBvZiBhbGwgdGhlXG4gICAgICAgICAgLy8gc3VzcGVuZGVkIGZpYmVyJ3MgdGltZW91dHMgYW5kIHVzZSBpdCB0byBjb21wdXRlIGEgdGltZW91dCBmb3IgdGhlXG4gICAgICAgICAgLy8gd2hvbGUgdHJlZS5cbiAgICAgICAgICByZW5kZXJEaWRTdXNwZW5kKHJvb3QsIGFic29sdXRlVGltZW91dE1zLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICAgICAgICBfd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgICAgX3dvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgYm91bmRhcnkgYWxyZWFkeSBjYXB0dXJlZCBkdXJpbmcgdGhpcyByZW5kZXIuIENvbnRpbnVlIHRvIHRoZVxuICAgICAgICAvLyBuZXh0IGJvdW5kYXJ5LlxuICAgICAgfVxuICAgICAgX3dvcmtJblByb2dyZXNzID0gX3dvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICB9IHdoaWxlIChfd29ya0luUHJvZ3Jlc3MgIT09IG51bGwpO1xuICAgIC8vIE5vIGJvdW5kYXJ5IHdhcyBmb3VuZC4gRmFsbHRocm91Z2ggdG8gZXJyb3IgbW9kZS5cbiAgICB2YWx1ZSA9IG5ldyBFcnJvcignQW4gdXBkYXRlIHdhcyBzdXNwZW5kZWQsIGJ1dCBubyBwbGFjZWhvbGRlciBVSSB3YXMgcHJvdmlkZWQuJyk7XG4gIH1cblxuICAvLyBXZSBkaWRuJ3QgZmluZCBhIGJvdW5kYXJ5IHRoYXQgY291bGQgaGFuZGxlIHRoaXMgdHlwZSBvZiBleGNlcHRpb24uIFN0YXJ0XG4gIC8vIG92ZXIgYW5kIHRyYXZlcnNlIHBhcmVudCBwYXRoIGFnYWluLCB0aGlzIHRpbWUgdHJlYXRpbmcgdGhlIGV4Y2VwdGlvblxuICAvLyBhcyBhbiBlcnJvci5cbiAgcmVuZGVyRGlkRXJyb3IoKTtcbiAgdmFsdWUgPSBjcmVhdGVDYXB0dXJlZFZhbHVlKHZhbHVlLCBzb3VyY2VGaWJlcik7XG4gIHZhciB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICBkbyB7XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2Vycm9ySW5mbyA9IHZhbHVlO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTaG91bGRDYXB0dXJlO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX2Vycm9ySW5mbywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50TGF6eTpcbiAgICAgICAgLy8gQ2FwdHVyZSBhbmQgcmV0cnlcbiAgICAgICAgdmFyIGVycm9ySW5mbyA9IHZhbHVlO1xuICAgICAgICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJiBEaWRDYXB0dXJlKSA9PT0gTm9FZmZlY3QgJiYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiBlbmFibGVHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggfHwgaW5zdGFuY2UgIT09IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nICYmICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gU2hvdWxkQ2FwdHVyZTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgICAgIC8vIFNjaGVkdWxlIHRoZSBlcnJvciBib3VuZGFyeSB0byByZS1yZW5kZXIgdXNpbmcgdXBkYXRlZCBzdGF0ZVxuICAgICAgICAgIHZhciBfdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgZXJyb3JJbmZvLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBfdXBkYXRlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gIH0gd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKTtcbn1cblxuZnVuY3Rpb24gdW53aW5kV29yayh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICBpZiAoZWZmZWN0VGFnICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyA9IGVmZmVjdFRhZyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgICB7XG4gICAgICAgIHZhciBfQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZS5fcmVhY3RSZXN1bHQ7XG4gICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihfQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICBpZiAoX2VmZmVjdFRhZyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBfZWZmZWN0VGFnICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIF9lZmZlY3RUYWcyID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICAhKChfZWZmZWN0VGFnMiAmIERpZENhcHR1cmUpID09PSBOb0VmZmVjdCkgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGUgcm9vdCBmYWlsZWQgdG8gdW5tb3VudCBhZnRlciBhbiBlcnJvci4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBfZWZmZWN0VGFnMiAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICBjYXNlIFBsYWNlaG9sZGVyQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX2VmZmVjdFRhZzMgPSB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWc7XG4gICAgICAgIGlmIChfZWZmZWN0VGFnMyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBfZWZmZWN0VGFnMyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrKSB7XG4gIHN3aXRjaCAoaW50ZXJydXB0ZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IGludGVycnVwdGVkV29yay50eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuICAgICAgICBpZiAoY2hpbGRDb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBvcENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50TGF6eTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9jaGlsZENvbnRleHRUeXBlcyA9IGludGVycnVwdGVkV29yay50eXBlLl9yZWFjdFJlc3VsdC5jaGlsZENvbnRleHRUeXBlcztcbiAgICAgICAgaWYgKF9jaGlsZENvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBfY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBvcENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcG9wUHJvdmlkZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxufVxuXG52YXIgRGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0XG59O1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xuXG5cbnZhciBkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24gPSB2b2lkIDA7XG52YXIgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gdm9pZCAwO1xudmFyIHdhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkID0gdm9pZCAwO1xudmFyIHdhcm5BYm91dEludmFsaWRVcGRhdGVzID0gdm9pZCAwO1xuXG5pZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAvLyBQcm92aWRlIGV4cGxpY2l0IGVycm9yIG1lc3NhZ2Ugd2hlbiBwcm9kdWN0aW9uK3Byb2ZpbGluZyBidW5kbGUgb2YgZS5nLiByZWFjdC1kb21cbiAgLy8gaXMgdXNlZCB3aXRoIHByb2R1Y3Rpb24gKG5vbi1wcm9maWxpbmcpIGJ1bmRsZSBvZiBzY2hlZHVsZS90cmFjaW5nXG4gICEodHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZiAhPSBudWxsICYmIHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0l0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gcnVuIHRoZSBwcm9maWxpbmcgdmVyc2lvbiBvZiBhIHJlbmRlcmVyIChmb3IgZXhhbXBsZSwgYHJlYWN0LWRvbS9wcm9maWxpbmdgKSB3aXRob3V0IGFsc28gcmVwbGFjaW5nIHRoZSBgc2NoZWR1bGUvdHJhY2luZ2AgbW9kdWxlIHdpdGggYHNjaGVkdWxlL3RyYWNpbmctcHJvZmlsaW5nYC4gWW91ciBidW5kbGVyIG1pZ2h0IGhhdmUgYSBzZXR0aW5nIGZvciBhbGlhc2luZyBib3RoIG1vZHVsZXMuIExlYXJuIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3JlYWN0LXByb2ZpbGluZycpIDogdm9pZCAwO1xufVxuXG57XG4gIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IGZhbHNlO1xuICBkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQgPSBmYWxzZTtcbiAgdmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG4gIHdhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgLy8gV2Ugc2hvdyB0aGUgd2hvbGUgc3RhY2sgYnV0IGRlZHVwZSBvbiB0aGUgdG9wIGNvbXBvbmVudCdzIG5hbWUgYmVjYXVzZVxuICAgIC8vIHRoZSBwcm9ibGVtYXRpYyBjb2RlIGFsbW9zdCBhbHdheXMgbGllcyBpbnNpZGUgdGhhdCBjb21wb25lbnQuXG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdSZWFjdENsYXNzJztcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgXCJDYW4ndCBjYWxsIHNldFN0YXRlIChvciBmb3JjZVVwZGF0ZSkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gVGhpcyBcIiArICdpcyBhIG5vLW9wLCBidXQgaXQgaW5kaWNhdGVzIGEgbWVtb3J5IGxlYWsgaW4geW91ciBhcHBsaWNhdGlvbi4gVG8gJyArICdmaXgsIGNhbmNlbCBhbGwgc3Vic2NyaXB0aW9ucyBhbmQgYXN5bmNocm9ub3VzIHRhc2tzIGluIHRoZSAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IG1ldGhvZC4lcycsIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChmaWJlcikpO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gIH07XG5cbiAgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBzd2l0Y2ggKHBoYXNlKSB7XG4gICAgICBjYXNlICdnZXRDaGlsZENvbnRleHQnOlxuICAgICAgICBpZiAoZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ3NldFN0YXRlKC4uLik6IENhbm5vdCBjYWxsIHNldFN0YXRlKCkgaW5zaWRlIGdldENoaWxkQ29udGV4dCgpJyk7XG4gICAgICAgIGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVuZGVyJzpcbiAgICAgICAgaWYgKGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzIHdpdGhpbiAnICsgJ2ByZW5kZXJgKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuJyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gVXNlZCB0byBlbnN1cmUgY29tcHV0ZVVuaXF1ZUFzeW5jRXhwaXJhdGlvbiBpcyBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcuXG52YXIgbGFzdFVuaXF1ZUFzeW5jRXhwaXJhdGlvbiA9IDA7XG5cbi8vIFJlcHJlc2VudHMgdGhlIGV4cGlyYXRpb24gdGltZSB0aGF0IGluY29taW5nIHVwZGF0ZXMgc2hvdWxkIHVzZS4gKElmIHRoaXNcbi8vIGlzIE5vV29yaywgdXNlIHRoZSBkZWZhdWx0IHN0cmF0ZWd5OiBhc3luYyB1cGRhdGVzIGluIGFzeW5jIG1vZGUsIHN5bmNcbi8vIHVwZGF0ZXMgaW4gc3luYyBtb2RlLilcbnZhciBleHBpcmF0aW9uQ29udGV4dCA9IE5vV29yaztcblxudmFyIGlzV29ya2luZyA9IGZhbHNlO1xuXG4vLyBUaGUgbmV4dCB3b3JrIGluIHByb2dyZXNzIGZpYmVyIHRoYXQgd2UncmUgY3VycmVudGx5IHdvcmtpbmcgb24uXG52YXIgbmV4dFVuaXRPZldvcmsgPSBudWxsO1xudmFyIG5leHRSb290ID0gbnVsbDtcbi8vIFRoZSB0aW1lIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgd29yay5cbnZhciBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG52YXIgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zID0gLTE7XG52YXIgbmV4dFJlbmRlckRpZEVycm9yID0gZmFsc2U7XG5cbi8vIFRoZSBuZXh0IGZpYmVyIHdpdGggYW4gZWZmZWN0IHRoYXQgd2UncmUgY3VycmVudGx5IGNvbW1pdHRpbmcuXG52YXIgbmV4dEVmZmVjdCA9IG51bGw7XG5cbnZhciBpc0NvbW1pdHRpbmckMSA9IGZhbHNlO1xuXG52YXIgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsO1xuXG4vLyBVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy5cbnZhciBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcblxuLy8gRG8gbm90IGRlY3JlbWVudCBpbnRlcmFjdGlvbiBjb3VudHMgaW4gdGhlIGV2ZW50IG9mIHN1c3BlbnNlIHRpbWVvdXRzLlxuLy8gVGhpcyB3b3VsZCBsZWFkIHRvIHByZW1hdHVyZWx5IGNhbGxpbmcgdGhlIGludGVyYWN0aW9uLWNvbXBsZXRlIGhvb2suXG52YXIgc3VzcGVuc2VEaWRUaW1lb3V0ID0gZmFsc2U7XG5cbnZhciBzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzID0gdm9pZCAwO1xudmFyIHJlcGxheVVuaXRPZldvcmsgPSB2b2lkIDA7XG52YXIgaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrID0gdm9pZCAwO1xudmFyIG9yaWdpbmFsUmVwbGF5RXJyb3IgPSB2b2lkIDA7XG52YXIgcmV0aHJvd09yaWdpbmFsRXJyb3IgPSB2b2lkIDA7XG5pZiAodHJ1ZSAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICBzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzID0gbnVsbDtcbiAgaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrID0gZmFsc2U7XG4gIG9yaWdpbmFsUmVwbGF5RXJyb3IgPSBudWxsO1xuICByZXBsYXlVbml0T2ZXb3JrID0gZnVuY3Rpb24gKGZhaWxlZFVuaXRPZldvcmssIHRocm93blZhbHVlLCBpc1lpZWxkeSkge1xuICAgIGlmICh0aHJvd25WYWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdGhyb3duVmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aHJvd25WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBEb24ndCByZXBsYXkgcHJvbWlzZXMuIFRyZWF0IGV2ZXJ5dGhpbmcgZWxzZSBsaWtlIGFuIGVycm9yLlxuICAgICAgLy8gVE9ETzogTmVlZCB0byBmaWd1cmUgb3V0IGEgZGlmZmVyZW50IHN0cmF0ZWd5IGlmL3doZW4gd2UgYWRkXG4gICAgICAvLyBzdXBwb3J0IGZvciBjYXRjaGluZyBvdGhlciB0eXBlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBzdGF0ZSBvZiB0aGUgd29yay1pbi1wcm9ncmVzc1xuICAgIGlmIChzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uIERvbid0IHRocm93IGJlY2F1c2UgdGhpcyBjb2RlIGlzIERFVi1vbmx5LlxuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnQ291bGQgbm90IHJlcGxheSByZW5kZXJpbmcgYWZ0ZXIgYW4gZXJyb3IuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVihmYWlsZWRVbml0T2ZXb3JrLCBzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzKTtcblxuICAgIHN3aXRjaCAoZmFpbGVkVW5pdE9mV29yay50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIoZmFpbGVkVW5pdE9mV29yayk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gZmFpbGVkVW5pdE9mV29yay50eXBlO1xuICAgICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgICBwb3BDb250ZXh0KGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX0NvbXBvbmVudCA9IGdldFJlc3VsdEZyb21SZXNvbHZlZFRoZW5hYmxlKGZhaWxlZFVuaXRPZldvcmsudHlwZSk7XG4gICAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKF9Db21wb25lbnQpKSB7XG4gICAgICAgICAgICBwb3BDb250ZXh0KGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgICBwb3BQcm92aWRlcihmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlcGxheSB0aGUgYmVnaW4gcGhhc2UuXG4gICAgaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrID0gdHJ1ZTtcbiAgICBvcmlnaW5hbFJlcGxheUVycm9yID0gdGhyb3duVmFsdWU7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIHdvcmtMb29wLCBudWxsLCBpc1lpZWxkeSk7XG4gICAgaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrID0gZmFsc2U7XG4gICAgb3JpZ2luYWxSZXBsYXlFcnJvciA9IG51bGw7XG4gICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciByZXBsYXlFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIGlmIChyZXBsYXlFcnJvciAhPSBudWxsICYmIHRocm93blZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBSZWFkaW5nIHRoZSBleHBhbmRvIHByb3BlcnR5IGlzIGludGVudGlvbmFsbHlcbiAgICAgICAgICAvLyBpbnNpZGUgYHRyeWAgYmVjYXVzZSBpdCBtaWdodCBiZSBhIGdldHRlciBvciBQcm94eS5cbiAgICAgICAgICBpZiAocmVwbGF5RXJyb3IuX3N1cHByZXNzTG9nZ2luZykge1xuICAgICAgICAgICAgLy8gQWxzbyBzdXBwcmVzcyBsb2dnaW5nIGZvciB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gICAgICAgICAgICB0aHJvd25WYWx1ZS5fc3VwcHJlc3NMb2dnaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGlubmVyKSB7XG4gICAgICAgICAgLy8gSWdub3JlLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBiZWdpbiBwaGFzZSBkaWQgbm90IGZhaWwgdGhlIHNlY29uZCB0aW1lLCBzZXQgdGhpcyBwb2ludGVyXG4gICAgICAvLyBiYWNrIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAgICAgIG5leHRVbml0T2ZXb3JrID0gZmFpbGVkVW5pdE9mV29yaztcbiAgICB9XG4gIH07XG4gIHJldGhyb3dPcmlnaW5hbEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG9yaWdpbmFsUmVwbGF5RXJyb3I7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc2V0U3RhY2soKSB7XG4gIGlmIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgIHZhciBpbnRlcnJ1cHRlZFdvcmsgPSBuZXh0VW5pdE9mV29yay5yZXR1cm47XG4gICAgd2hpbGUgKGludGVycnVwdGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrKGludGVycnVwdGVkV29yayk7XG4gICAgICBpbnRlcnJ1cHRlZFdvcmsgPSBpbnRlcnJ1cHRlZFdvcmsucmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzKCk7XG4gICAgY2hlY2tUaGF0U3RhY2tJc0VtcHR5KCk7XG4gIH1cblxuICBuZXh0Um9vdCA9IG51bGw7XG4gIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zID0gLTE7XG4gIG5leHRSZW5kZXJEaWRFcnJvciA9IGZhbHNlO1xuICBuZXh0VW5pdE9mV29yayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEFsbEhvc3RFZmZlY3RzKCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihuZXh0RWZmZWN0KTtcbiAgICB9XG4gICAgcmVjb3JkRWZmZWN0KCk7XG5cbiAgICB2YXIgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG5cbiAgICBpZiAoZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICBjb21taXRSZXNldFRleHRDb250ZW50KG5leHRFZmZlY3QpO1xuICAgIH1cblxuICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgIHZhciBjdXJyZW50JCQxID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICBpZiAoY3VycmVudCQkMSAhPT0gbnVsbCkge1xuICAgICAgICBjb21taXREZXRhY2hSZWYoY3VycmVudCQkMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBzd2l0Y2ggc3RhdGVtZW50IGlzIG9ubHkgY29uY2VybmVkIGFib3V0IHBsYWNlbWVudCxcbiAgICAvLyB1cGRhdGVzLCBhbmQgZGVsZXRpb25zLiBUbyBhdm9pZCBuZWVkaW5nIHRvIGFkZCBhIGNhc2UgZm9yIGV2ZXJ5XG4gICAgLy8gcG9zc2libGUgYml0bWFwIHZhbHVlLCB3ZSByZW1vdmUgdGhlIHNlY29uZGFyeSBlZmZlY3RzIGZyb20gdGhlXG4gICAgLy8gZWZmZWN0IHRhZyBhbmQgc3dpdGNoIG9uIHRoYXQgdmFsdWUuXG4gICAgdmFyIHByaW1hcnlFZmZlY3RUYWcgPSBlZmZlY3RUYWcgJiAoUGxhY2VtZW50IHwgVXBkYXRlIHwgRGVsZXRpb24pO1xuICAgIHN3aXRjaCAocHJpbWFyeUVmZmVjdFRhZykge1xuICAgICAgY2FzZSBQbGFjZW1lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgIC8vIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgICAgICAgIC8vIFRPRE86IGZpbmRET01Ob2RlIGRvZXNuJ3QgcmVseSBvbiB0aGlzIGFueSBtb3JlIGJ1dCBpc01vdW50ZWRcbiAgICAgICAgICAvLyBkb2VzIGFuZCBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZCBhbnl3YXkgc28gd2Ugc2hvdWxkIGJlIGFibGVcbiAgICAgICAgICAvLyB0byBraWxsIHRoaXMuXG4gICAgICAgICAgbmV4dEVmZmVjdC5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBQbGFjZW1lbnRBbmRVcGRhdGU6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBQbGFjZW1lbnRcbiAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgIC8vIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG5cbiAgICAgICAgICAvLyBVcGRhdGVcbiAgICAgICAgICB2YXIgX2N1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBVcGRhdGU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2N1cnJlbnQyID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0V29yayhfY3VycmVudDIsIG5leHRFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIERlbGV0aW9uOlxuICAgICAgICB7XG4gICAgICAgICAgY29tbWl0RGVsZXRpb24obmV4dEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxuXG4gIHtcbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZWN5Y2xlcygpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB7XG4gICAgICBzZXRDdXJyZW50RmliZXIobmV4dEVmZmVjdCk7XG4gICAgfVxuXG4gICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuICAgIGlmIChlZmZlY3RUYWcgJiBTbmFwc2hvdCkge1xuICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICB2YXIgY3VycmVudCQkMSA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlQ3ljbGVzKGN1cnJlbnQkJDEsIG5leHRFZmZlY3QpO1xuICAgIH1cblxuICAgIC8vIERvbid0IGNsZWFudXAgZWZmZWN0cyB5ZXQ7XG4gICAgLy8gVGhpcyB3aWxsIGJlIGRvbmUgYnkgY29tbWl0QWxsTGlmZUN5Y2xlcygpXG4gICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxuXG4gIHtcbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEFsbExpZmVDeWNsZXMoZmluaXNoZWRSb290LCBjb21taXR0ZWRFeHBpcmF0aW9uVGltZSkge1xuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoKTtcblxuICAgIGlmICh3YXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcykge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nRGVwcmVjYXRpb25XYXJuaW5ncygpO1xuICAgIH1cblxuICAgIGlmICh3YXJuQWJvdXRMZWdhY3lDb250ZXh0QVBJKSB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nKCk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuXG4gICAgaWYgKGVmZmVjdFRhZyAmIChVcGRhdGUgfCBDYWxsYmFjaykpIHtcbiAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgdmFyIGN1cnJlbnQkJDEgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgIGNvbW1pdExpZmVDeWNsZXMoZmluaXNoZWRSb290LCBjdXJyZW50JCQxLCBuZXh0RWZmZWN0LCBjb21taXR0ZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKGVmZmVjdFRhZyAmIFJlZikge1xuICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICBjb21taXRBdHRhY2hSZWYobmV4dEVmZmVjdCk7XG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgY2xlYW4gdGhlc2UgdXAgc28gdGhhdCB3ZSBkb24ndCBhY2NpZGVudGFsbHkga2VlcCB0aGVtLlxuICAgIC8vIEknbSBub3QgYWN0dWFsbHkgc3VyZSB0aGlzIG1hdHRlcnMgYmVjYXVzZSB3ZSBjYW4ndCByZXNldCBmaXJzdEVmZmVjdFxuICAgIC8vIGFuZCBsYXN0RWZmZWN0IHNpbmNlIHRoZXkncmUgb24gZXZlcnkgbm9kZSwgbm90IGp1c3QgdGhlIGVmZmVjdGZ1bFxuICAgIC8vIG9uZXMuIFNvIHdlIGhhdmUgdG8gY2xlYW4gZXZlcnl0aGluZyBhcyB3ZSByZXVzZSBub2RlcyBhbnl3YXkuXG4gICAgbmV4dEVmZmVjdC5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXNldCB0aGUgZWZmZWN0VGFnIGhlcmUgc28gdGhhdCB3ZSBjYW4gcmVseSBvbiBlZmZlY3RcbiAgICAvLyB0YWdzIHRvIHJlYXNvbiBhYm91dCB0aGUgY3VycmVudCBsaWZlLWN5Y2xlLlxuICAgIG5leHRFZmZlY3QgPSBuZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkICE9PSBudWxsICYmIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhpbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQoaW5zdGFuY2UpIHtcbiAgaWYgKGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID09PSBudWxsKSB7XG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBuZXcgU2V0KFtpbnN0YW5jZV0pO1xuICB9IGVsc2Uge1xuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmFkZChpbnN0YW5jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0Um9vdChyb290LCBmaW5pc2hlZFdvcmspIHtcbiAgaXNXb3JraW5nID0gdHJ1ZTtcbiAgaXNDb21taXR0aW5nJDEgPSB0cnVlO1xuICBzdGFydENvbW1pdFRpbWVyKCk7XG5cbiAgIShyb290LmN1cnJlbnQgIT09IGZpbmlzaGVkV29yaykgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIHJlbGF0ZWQgdG8gdGhlIHJldHVybiBmaWVsZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgdmFyIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lID0gcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWU7XG4gICEoY29tbWl0dGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29tbWl0IGFuIGluY29tcGxldGUgcm9vdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgLy8gVXBkYXRlIHRoZSBwZW5kaW5nIHByaW9yaXR5IGxldmVscyB0byBhY2NvdW50IGZvciB0aGUgd29yayB0aGF0IHdlIGFyZVxuICAvLyBhYm91dCB0byBjb21taXQuIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSBjYWxsaW5nIHRoZSBsaWZlY3ljbGVzLCBzaW5jZVxuICAvLyB0aGV5IG1heSBzY2hlZHVsZSBhZGRpdGlvbmFsIHVwZGF0ZXMuXG4gIHZhciB1cGRhdGVFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdCA9IGZpbmlzaGVkV29yay5leHBpcmF0aW9uVGltZTtcbiAgdmFyIGNoaWxkRXhwaXJhdGlvblRpbWVCZWZvcmVDb21taXQgPSBmaW5pc2hlZFdvcmsuY2hpbGRFeHBpcmF0aW9uVGltZTtcbiAgdmFyIGVhcmxpZXN0UmVtYWluaW5nVGltZUJlZm9yZUNvbW1pdCA9IHVwZGF0ZUV4cGlyYXRpb25UaW1lQmVmb3JlQ29tbWl0ID09PSBOb1dvcmsgfHwgY2hpbGRFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdCAhPT0gTm9Xb3JrICYmIGNoaWxkRXhwaXJhdGlvblRpbWVCZWZvcmVDb21taXQgPCB1cGRhdGVFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdCA/IGNoaWxkRXhwaXJhdGlvblRpbWVCZWZvcmVDb21taXQgOiB1cGRhdGVFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdDtcbiAgbWFya0NvbW1pdHRlZFByaW9yaXR5TGV2ZWxzKHJvb3QsIGVhcmxpZXN0UmVtYWluaW5nVGltZUJlZm9yZUNvbW1pdCk7XG5cbiAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBudWxsO1xuICB2YXIgY29tbWl0dGVkSW50ZXJhY3Rpb25zID0gZW5hYmxlU2NoZWR1bGVyVHJhY2luZyA/IFtdIDogbnVsbDtcbiAgaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICAvLyBSZXN0b3JlIGFueSBwZW5kaW5nIGludGVyYWN0aW9ucyBhdCB0aGlzIHBvaW50LFxuICAgIC8vIFNvIHRoYXQgY2FzY2FkaW5nIHdvcmsgdHJpZ2dlcmVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlIHdpbGwgYmUgYWNjb3VudGVkIGZvci5cbiAgICBwcmV2SW50ZXJhY3Rpb25zID0gdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuICAgIHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnM7XG5cbiAgICAvLyBXZSBhcmUgcG90ZW50aWFsbHkgZmluaXNoZWQgd2l0aCB0aGUgY3VycmVudCBiYXRjaCBvZiBpbnRlcmFjdGlvbnMuXG4gICAgLy8gU28gd2Ugc2hvdWxkIGNsZWFyIHRoZW0gb3V0IG9mIHRoZSBwZW5kaW5nIGludGVyYWN0aW9uIG1hcC5cbiAgICAvLyBXZSBkbyB0aGlzIGF0IHRoZSBzdGFydCBvZiBjb21taXQgaW4gY2FzZSBjYXNjYWRpbmcgd29yayBpcyBzY2hlZHVsZWQgYnkgY29tbWl0IHBoYXNlIGxpZmVjeWNsZXMuXG4gICAgLy8gSW4gdGhhdCBldmVudCwgaW50ZXJhY3Rpb24gZGF0YSBtYXkgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwZW5kaW5nIG1hcCBmb3IgYSBmdXR1cmUgY29tbWl0LlxuICAgIC8vIFdlIGFsc28gc3RvcmUgdGhlIGludGVyYWN0aW9ucyB3ZSBhcmUgYWJvdXQgdG8gY29tbWl0IHNvIHRoYXQgd2UgY2FuIG5vdGlmeSBzdWJzY3JpYmVycyBhZnRlciB3ZSdyZSBkb25lLlxuICAgIC8vIFRoZXNlIGFyZSBzdG9yZWQgYXMgYW4gQXJyYXkgcmF0aGVyIHRoYW4gYSBTZXQsXG4gICAgLy8gQmVjYXVzZSB0aGUgc2FtZSBpbnRlcmFjdGlvbiBtYXkgYmUgcGVuZGluZyBmb3IgbXVsdGlwbGUgZXhwaXJhdGlvbiB0aW1lcyxcbiAgICAvLyBJbiB3aGljaCBjYXNlIGl0J3MgaW1wb3J0YW50IHRoYXQgd2UgZGVjcmVtZW50IHRoZSBjb3VudCB0aGUgcmlnaHQgbnVtYmVyIG9mIHRpbWVzIGFmdGVyIGZpbmlzaGluZy5cbiAgICByb290LnBlbmRpbmdJbnRlcmFjdGlvbk1hcC5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlZHVsZWRJbnRlcmFjdGlvbnMsIHNjaGVkdWxlZEV4cGlyYXRpb25UaW1lKSB7XG4gICAgICBpZiAoc2NoZWR1bGVkRXhwaXJhdGlvblRpbWUgPD0gY29tbWl0dGVkRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgY29tbWl0dGVkSW50ZXJhY3Rpb25zLnB1c2guYXBwbHkoY29tbWl0dGVkSW50ZXJhY3Rpb25zLCBBcnJheS5mcm9tKHNjaGVkdWxlZEludGVyYWN0aW9ucykpO1xuICAgICAgICByb290LnBlbmRpbmdJbnRlcmFjdGlvbk1hcC5kZWxldGUoc2NoZWR1bGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gUmVzZXQgdGhpcyB0byBudWxsIGJlZm9yZSBjYWxsaW5nIGxpZmVjeWNsZXNcbiAgUmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50ID0gbnVsbDtcblxuICB2YXIgZmlyc3RFZmZlY3QgPSB2b2lkIDA7XG4gIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnID4gUGVyZm9ybWVkV29yaykge1xuICAgIC8vIEEgZmliZXIncyBlZmZlY3QgbGlzdCBjb25zaXN0cyBvbmx5IG9mIGl0cyBjaGlsZHJlbiwgbm90IGl0c2VsZi4gU28gaWZcbiAgICAvLyB0aGUgcm9vdCBoYXMgYW4gZWZmZWN0LCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LiBUaGVcbiAgICAvLyByZXN1bHRpbmcgbGlzdCBpcyB0aGUgc2V0IHRoYXQgd291bGQgYmVsb25nIHRvIHRoZSByb290J3MgcGFyZW50LCBpZlxuICAgIC8vIGl0IGhhZCBvbmU7IHRoYXQgaXMsIGFsbCB0aGUgZWZmZWN0cyBpbiB0aGUgdHJlZSBpbmNsdWRpbmcgdGhlIHJvb3QuXG4gICAgaWYgKGZpbmlzaGVkV29yay5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICBmaW5pc2hlZFdvcmsubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSBpcyBubyBlZmZlY3Qgb24gdGhlIHJvb3QuXG4gICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gIH1cblxuICBwcmVwYXJlRm9yQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7XG5cbiAgLy8gSW52b2tlIGluc3RhbmNlcyBvZiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSBiZWZvcmUgbXV0YXRpb24uXG4gIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgc3RhcnRDb21taXRTbmFwc2hvdEVmZmVjdHNUaW1lcigpO1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBkaWRFcnJvciA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IHZvaWQgMDtcbiAgICB7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlY3ljbGVzLCBudWxsKTtcbiAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgIShuZXh0RWZmZWN0ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIG5leHQgZWZmZWN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IobmV4dEVmZmVjdCwgZXJyb3IpO1xuICAgICAgLy8gQ2xlYW4tdXBcbiAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0b3BDb21taXRTbmFwc2hvdEVmZmVjdHNUaW1lcigpO1xuXG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgLy8gTWFyayB0aGUgY3VycmVudCBjb21taXQgdGltZSB0byBiZSBzaGFyZWQgYnkgYWxsIFByb2ZpbGVycyBpbiB0aGlzIGJhdGNoLlxuICAgIC8vIFRoaXMgZW5hYmxlcyB0aGVtIHRvIGJlIGdyb3VwZWQgbGF0ZXIuXG4gICAgcmVjb3JkQ29tbWl0VGltZSgpO1xuICB9XG5cbiAgLy8gQ29tbWl0IGFsbCB0aGUgc2lkZS1lZmZlY3RzIHdpdGhpbiBhIHRyZWUuIFdlJ2xsIGRvIHRoaXMgaW4gdHdvIHBhc3Nlcy5cbiAgLy8gVGhlIGZpcnN0IHBhc3MgcGVyZm9ybXMgYWxsIHRoZSBob3N0IGluc2VydGlvbnMsIHVwZGF0ZXMsIGRlbGV0aW9ucyBhbmRcbiAgLy8gcmVmIHVubW91bnRzLlxuICBuZXh0RWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG4gIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcigpO1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBfZGlkRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgX2Vycm9yID0gdm9pZCAwO1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBjb21taXRBbGxIb3N0RWZmZWN0cywgbnVsbCk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBfZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICBfZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfZGlkRXJyb3IpIHtcbiAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcik7XG4gICAgICAvLyBDbGVhbi11cFxuICAgICAgaWYgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcblxuICByZXNldEFmdGVyQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7XG5cbiAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgLy8gdGhlIGZpcnN0IHBhc3Mgb2YgdGhlIGNvbW1pdCBwaGFzZSwgc28gdGhhdCB0aGUgcHJldmlvdXMgdHJlZSBpcyBzdGlsbFxuICAvLyBjdXJyZW50IGR1cmluZyBjb21wb25lbnRXaWxsVW5tb3VudCwgYnV0IGJlZm9yZSB0aGUgc2Vjb25kIHBhc3MsIHNvIHRoYXRcbiAgLy8gdGhlIGZpbmlzaGVkIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuICByb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcms7XG5cbiAgLy8gSW4gdGhlIHNlY29uZCBwYXNzIHdlJ2xsIHBlcmZvcm0gYWxsIGxpZmUtY3ljbGVzIGFuZCByZWYgY2FsbGJhY2tzLlxuICAvLyBMaWZlLWN5Y2xlcyBoYXBwZW4gYXMgYSBzZXBhcmF0ZSBwYXNzIHNvIHRoYXQgYWxsIHBsYWNlbWVudHMsIHVwZGF0ZXMsXG4gIC8vIGFuZCBkZWxldGlvbnMgaW4gdGhlIGVudGlyZSB0cmVlIGhhdmUgYWxyZWFkeSBiZWVuIGludm9rZWQuXG4gIC8vIFRoaXMgcGFzcyBhbHNvIHRyaWdnZXJzIGFueSByZW5kZXJlci1zcGVjaWZpYyBpbml0aWFsIGVmZmVjdHMuXG4gIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgc3RhcnRDb21taXRMaWZlQ3ljbGVzVGltZXIoKTtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgX2RpZEVycm9yMiA9IGZhbHNlO1xuICAgIHZhciBfZXJyb3IyID0gdm9pZCAwO1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBjb21taXRBbGxMaWZlQ3ljbGVzLCBudWxsLCByb290LCBjb21taXR0ZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBfZGlkRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgX2Vycm9yMiA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF9kaWRFcnJvcjIpIHtcbiAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcjIpO1xuICAgICAgaWYgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc0NvbW1pdHRpbmckMSA9IGZhbHNlO1xuICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgc3RvcENvbW1pdExpZmVDeWNsZXNUaW1lcigpO1xuICBzdG9wQ29tbWl0VGltZXIoKTtcbiAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpO1xuICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbW1pdFdvcmsoZmluaXNoZWRXb3JrKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVFeHBpcmF0aW9uVGltZUFmdGVyQ29tbWl0ID0gZmluaXNoZWRXb3JrLmV4cGlyYXRpb25UaW1lO1xuICB2YXIgY2hpbGRFeHBpcmF0aW9uVGltZUFmdGVyQ29tbWl0ID0gZmluaXNoZWRXb3JrLmNoaWxkRXhwaXJhdGlvblRpbWU7XG4gIHZhciBlYXJsaWVzdFJlbWFpbmluZ1RpbWVBZnRlckNvbW1pdCA9IHVwZGF0ZUV4cGlyYXRpb25UaW1lQWZ0ZXJDb21taXQgPT09IE5vV29yayB8fCBjaGlsZEV4cGlyYXRpb25UaW1lQWZ0ZXJDb21taXQgIT09IE5vV29yayAmJiBjaGlsZEV4cGlyYXRpb25UaW1lQWZ0ZXJDb21taXQgPCB1cGRhdGVFeHBpcmF0aW9uVGltZUFmdGVyQ29tbWl0ID8gY2hpbGRFeHBpcmF0aW9uVGltZUFmdGVyQ29tbWl0IDogdXBkYXRlRXhwaXJhdGlvblRpbWVBZnRlckNvbW1pdDtcbiAgaWYgKGVhcmxpZXN0UmVtYWluaW5nVGltZUFmdGVyQ29tbWl0ID09PSBOb1dvcmspIHtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrLCB3ZSBjYW4gY2xlYXIgdGhlIHNldCBvZiBhbHJlYWR5IGZhaWxlZFxuICAgIC8vIGVycm9yIGJvdW5kYXJpZXMuXG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsO1xuICB9XG4gIG9uQ29tbWl0KHJvb3QsIGVhcmxpZXN0UmVtYWluaW5nVGltZUFmdGVyQ29tbWl0KTtcblxuICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgIHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHByZXZJbnRlcmFjdGlvbnM7XG5cbiAgICB2YXIgc3Vic2NyaWJlciA9IHZvaWQgMDtcblxuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyID0gdHJhY2luZy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcbiAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsICYmIHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMuc2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIHRocmVhZElEID0gY29tcHV0ZVRocmVhZElEKGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lLCByb290LmludGVyYWN0aW9uVGhyZWFkSUQpO1xuICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1N0b3BwZWQocm9vdC5tZW1vaXplZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJdCdzIG5vdCBzYWZlIGZvciBjb21taXRSb290KCkgdG8gdGhyb3cuXG4gICAgICAvLyBTdG9yZSB0aGUgZXJyb3IgZm9yIG5vdyBhbmQgd2UnbGwgcmUtdGhyb3cgaW4gZmluaXNoUmVuZGVyaW5nKCkuXG4gICAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgdW5oYW5kbGVkRXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gRG9uJ3QgdXBkYXRlIGludGVyYWN0aW9uIGNvdW50cyBpZiB3ZSdyZSBmcm96ZW4gZHVlIHRvIHN1c3BlbnNlLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBjYW4gc2tpcCB0aGUgY29tcGxldGVkLXdvcmsgY2hlY2sgZW50aXJlbHkuXG4gICAgICBpZiAoIXN1c3BlbnNlRGlkVGltZW91dCkge1xuICAgICAgICAvLyBOb3cgdGhhdCB3ZSdyZSBkb25lLCBjaGVjayB0aGUgY29tcGxldGVkIGJhdGNoIG9mIGludGVyYWN0aW9ucy5cbiAgICAgICAgLy8gSWYgbm8gbW9yZSB3b3JrIGlzIG91dHN0YW5kaW5nIGZvciBhIGdpdmVuIGludGVyYWN0aW9uLFxuICAgICAgICAvLyBXZSBuZWVkIHRvIG5vdGlmeSB0aGUgc3Vic2NyaWJlcnMgdGhhdCBpdCdzIGZpbmlzaGVkLlxuICAgICAgICBjb21taXR0ZWRJbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50LS07XG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwgJiYgaW50ZXJhY3Rpb24uX19jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBzYWZlIGZvciBjb21taXRSb290KCkgdG8gdGhyb3cuXG4gICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBlcnJvciBmb3Igbm93IGFuZCB3ZSdsbCByZS10aHJvdyBpbiBmaW5pc2hSZW5kZXJpbmcoKS5cbiAgICAgICAgICAgICAgaWYgKCFoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgICAgICAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDaGlsZEV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzLCByZW5kZXJUaW1lKSB7XG4gIGlmIChyZW5kZXJUaW1lICE9PSBOZXZlciAmJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZEV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgIC8vIFRoZSBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvbmVudCBhcmUgaGlkZGVuLiBEb24ndCBidWJibGUgdGhlaXJcbiAgICAvLyBleHBpcmF0aW9uIHRpbWVzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuZXdDaGlsZEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lciAmJiB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAvLyBXZSdyZSBpbiBwcm9maWxpbmcgbW9kZS5cbiAgICAvLyBMZXQncyB1c2UgdGhpcyBzYW1lIHRyYXZlcnNhbCB0byB1cGRhdGUgdGhlIHJlbmRlciBkdXJhdGlvbnMuXG4gICAgdmFyIGFjdHVhbER1cmF0aW9uID0gd29ya0luUHJvZ3Jlc3MuYWN0dWFsRHVyYXRpb247XG4gICAgdmFyIHRyZWVCYXNlRHVyYXRpb24gPSB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uO1xuXG4gICAgLy8gV2hlbiBhIGZpYmVyIGlzIGNsb25lZCwgaXRzIGFjdHVhbER1cmF0aW9uIGlzIHJlc2V0IHRvIDAuXG4gICAgLy8gVGhpcyB2YWx1ZSB3aWxsIG9ubHkgYmUgdXBkYXRlZCBpZiB3b3JrIGlzIGRvbmUgb24gdGhlIGZpYmVyIChpLmUuIGl0IGRvZXNuJ3QgYmFpbG91dCkuXG4gICAgLy8gV2hlbiB3b3JrIGlzIGRvbmUsIGl0IHNob3VsZCBidWJibGUgdG8gdGhlIHBhcmVudCdzIGFjdHVhbER1cmF0aW9uLlxuICAgIC8vIElmIHRoZSBmaWJlciBoYXMgbm90IGJlZW4gY2xvbmVkIHRob3VnaCwgKG1lYW5pbmcgbm8gd29yayB3YXMgZG9uZSksXG4gICAgLy8gVGhlbiB0aGlzIHZhbHVlIHdpbGwgcmVmbGVjdCB0aGUgYW1vdW50IG9mIHRpbWUgc3BlbnQgd29ya2luZyBvbiBhIHByZXZpb3VzIHJlbmRlci5cbiAgICAvLyBJbiB0aGF0IGNhc2UgaXQgc2hvdWxkIG5vdCBidWJibGUuXG4gICAgLy8gV2UgZGV0ZXJtaW5lIHdoZXRoZXIgaXQgd2FzIGNsb25lZCBieSBjb21wYXJpbmcgdGhlIGNoaWxkIHBvaW50ZXIuXG4gICAgdmFyIHNob3VsZEJ1YmJsZUFjdHVhbER1cmF0aW9ucyA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlLmNoaWxkO1xuXG4gICAgdmFyIGNoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICB2YXIgY2hpbGRVcGRhdGVFeHBpcmF0aW9uVGltZSA9IGNoaWxkLmV4cGlyYXRpb25UaW1lO1xuICAgICAgdmFyIGNoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZSA9IGNoaWxkLmNoaWxkRXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAobmV3Q2hpbGRFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IGNoaWxkVXBkYXRlRXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJiBjaGlsZFVwZGF0ZUV4cGlyYXRpb25UaW1lIDwgbmV3Q2hpbGRFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICBuZXdDaGlsZEV4cGlyYXRpb25UaW1lID0gY2hpbGRVcGRhdGVFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdDaGlsZEV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgY2hpbGRDaGlsZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgY2hpbGRDaGlsZEV4cGlyYXRpb25UaW1lIDwgbmV3Q2hpbGRFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICBuZXdDaGlsZEV4cGlyYXRpb25UaW1lID0gY2hpbGRDaGlsZEV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZEJ1YmJsZUFjdHVhbER1cmF0aW9ucykge1xuICAgICAgICBhY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIHRyZWVCYXNlRHVyYXRpb24gKz0gY2hpbGQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MuYWN0dWFsRHVyYXRpb24gPSBhY3R1YWxEdXJhdGlvbjtcbiAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gdHJlZUJhc2VEdXJhdGlvbjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX2NoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKF9jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9jaGlsZFVwZGF0ZUV4cGlyYXRpb25UaW1lID0gX2NoaWxkLmV4cGlyYXRpb25UaW1lO1xuICAgICAgdmFyIF9jaGlsZENoaWxkRXhwaXJhdGlvblRpbWUgPSBfY2hpbGQuY2hpbGRFeHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChuZXdDaGlsZEV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgX2NoaWxkVXBkYXRlRXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJiBfY2hpbGRVcGRhdGVFeHBpcmF0aW9uVGltZSA8IG5ld0NoaWxkRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbmV3Q2hpbGRFeHBpcmF0aW9uVGltZSA9IF9jaGlsZFVwZGF0ZUV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgaWYgKG5ld0NoaWxkRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBfY2hpbGRDaGlsZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgX2NoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZSA8IG5ld0NoaWxkRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbmV3Q2hpbGRFeHBpcmF0aW9uVGltZSA9IF9jaGlsZENoaWxkRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZEV4cGlyYXRpb25UaW1lID0gbmV3Q2hpbGRFeHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKSB7XG4gIC8vIEF0dGVtcHQgdG8gY29tcGxldGUgdGhlIGN1cnJlbnQgdW5pdCBvZiB3b3JrLCB0aGVuIG1vdmUgdG8gdGhlXG4gIC8vIG5leHQgc2libGluZy4gSWYgdGhlcmUgYXJlIG5vIG1vcmUgc2libGluZ3MsIHJldHVybiB0byB0aGVcbiAgLy8gcGFyZW50IGZpYmVyLlxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgIC8vIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50JCQxID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICAgIHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgIHZhciBzaWJsaW5nRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nO1xuXG4gICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJiBJbmNvbXBsZXRlKSA9PT0gTm9FZmZlY3QpIHtcbiAgICAgIC8vIFRoaXMgZmliZXIgY29tcGxldGVkLlxuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIHN0YXJ0UHJvZmlsZXJUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0VW5pdE9mV29yayA9IGNvbXBsZXRlV29yayhjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHJlbmRlciBkdXJhdGlvbiBhc3N1bWluZyB3ZSBkaWRuJ3QgZXJyb3IuXG4gICAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSh3b3JrSW5Qcm9ncmVzcywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0VW5pdE9mV29yayA9IGNvbXBsZXRlV29yayhjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0ID0gbmV4dFVuaXRPZldvcms7XG4gICAgICBzdG9wV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHtcbiAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBjb21wbGV0aW5nIHRoaXMgd29yayBzcGF3bmVkIG5ldyB3b3JrLCBkbyB0aGF0IG5leHQuIFdlJ2xsIGNvbWVcbiAgICAgICAgLy8gYmFjayBoZXJlIGFnYWluLlxuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsICYmXG4gICAgICAvLyBEbyBub3QgYXBwZW5kIGVmZmVjdHMgdG8gcGFyZW50cyBpZiBhIHNpYmxpbmcgZmFpbGVkIHRvIGNvbXBsZXRlXG4gICAgICAocmV0dXJuRmliZXIuZWZmZWN0VGFnICYgSW5jb21wbGV0ZSkgPT09IE5vRWZmZWN0KSB7XG4gICAgICAgIC8vIEFwcGVuZCBhbGwgdGhlIGVmZmVjdHMgb2YgdGhlIHN1YnRyZWUgYW5kIHRoaXMgZmliZXIgb250byB0aGUgZWZmZWN0XG4gICAgICAgIC8vIGxpc3Qgb2YgdGhlIHBhcmVudC4gVGhlIGNvbXBsZXRpb24gb3JkZXIgb2YgdGhlIGNoaWxkcmVuIGFmZmVjdHMgdGhlXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0IG9yZGVyLlxuICAgICAgICBpZiAocmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgZmliZXIgaGFkIHNpZGUtZWZmZWN0cywgd2UgYXBwZW5kIGl0IEFGVEVSIHRoZSBjaGlsZHJlbidzXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gV2UgY2FuIHBlcmZvcm0gY2VydGFpbiBzaWRlLWVmZmVjdHMgZWFybGllciBpZlxuICAgICAgICAvLyBuZWVkZWQsIGJ5IGRvaW5nIG11bHRpcGxlIHBhc3NlcyBvdmVyIHRoZSBlZmZlY3QgbGlzdC4gV2UgZG9uJ3Qgd2FudFxuICAgICAgICAvLyB0byBzY2hlZHVsZSBvdXIgb3duIHNpZGUtZWZmZWN0IG9uIG91ciBvd24gbGlzdCBiZWNhdXNlIGlmIGVuZCB1cFxuICAgICAgICAvLyByZXVzaW5nIGNoaWxkcmVuIHdlJ2xsIHNjaGVkdWxlIHRoaXMgZWZmZWN0IG9udG8gaXRzZWxmIHNpbmNlIHdlJ3JlXG4gICAgICAgIC8vIGF0IHRoZSBlbmQuXG4gICAgICAgIHZhciBlZmZlY3RUYWcgPSB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWc7XG4gICAgICAgIC8vIFNraXAgYm90aCBOb1dvcmsgYW5kIFBlcmZvcm1lZFdvcmsgdGFncyB3aGVuIGNyZWF0aW5nIHRoZSBlZmZlY3QgbGlzdC5cbiAgICAgICAgLy8gUGVyZm9ybWVkV29yayBlZmZlY3QgaXMgcmVhZCBieSBSZWFjdCBEZXZUb29scyBidXQgc2hvdWxkbid0IGJlIGNvbW1pdHRlZC5cbiAgICAgICAgaWYgKGVmZmVjdFRhZyA+IFBlcmZvcm1lZFdvcmspIHtcbiAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICAgIHJldHVybiBzaWJsaW5nRmliZXI7XG4gICAgICB9IGVsc2UgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGluIHRoaXMgcmV0dXJuRmliZXIuIENvbXBsZXRlIHRoZSByZXR1cm5GaWJlci5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAvLyBSZWNvcmQgdGhlIHJlbmRlciBkdXJhdGlvbiBmb3IgdGhlIGZpYmVyIHRoYXQgZXJyb3JlZC5cbiAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSh3b3JrSW5Qcm9ncmVzcywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUgYmVjYXVzZSBzb21ldGhpbmcgdGhyZXcuIFBvcCB2YWx1ZXMgb2ZmXG4gICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBlbnRlcmluZyB0aGUgY29tcGxldGUgcGhhc2UuIElmIHRoaXMgaXMgYSBib3VuZGFyeSxcbiAgICAgIC8vIGNhcHR1cmUgdmFsdWVzIGlmIHBvc3NpYmxlLlxuICAgICAgdmFyIF9uZXh0ID0gdW53aW5kV29yayh3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIC8vIEJlY2F1c2UgdGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlLCBkb24ndCByZXNldCBpdHMgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIERpZENhcHR1cmUpIHtcbiAgICAgICAgLy8gUmVzdGFydGluZyBhbiBlcnJvciBib3VuZGFyeVxuICAgICAgICBzdG9wRmFpbGVkV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfbmV4dCAhPT0gbnVsbCkge1xuICAgICAgICBzdG9wV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgICAgICAvLyBJbmNsdWRlIHRoZSB0aW1lIHNwZW50IHdvcmtpbmcgb24gZmFpbGVkIGNoaWxkcmVuIGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICAgIGlmIChfbmV4dC5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICAgIHZhciBhY3R1YWxEdXJhdGlvbiA9IF9uZXh0LmFjdHVhbER1cmF0aW9uO1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gX25leHQuY2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247XG4gICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9uZXh0LmFjdHVhbER1cmF0aW9uID0gYWN0dWFsRHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgY29tcGxldGluZyB0aGlzIHdvcmsgc3Bhd25lZCBuZXcgd29yaywgZG8gdGhhdCBuZXh0LiBXZSdsbCBjb21lXG4gICAgICAgIC8vIGJhY2sgaGVyZSBhZ2Fpbi5cbiAgICAgICAgLy8gU2luY2Ugd2UncmUgcmVzdGFydGluZywgcmVtb3ZlIGFueXRoaW5nIHRoYXQgaXMgbm90IGEgaG9zdCBlZmZlY3RcbiAgICAgICAgLy8gZnJvbSB0aGUgZWZmZWN0IHRhZy5cbiAgICAgICAgX25leHQuZWZmZWN0VGFnICY9IEhvc3RFZmZlY3RNYXNrO1xuICAgICAgICByZXR1cm4gX25leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBNYXJrIHRoZSBwYXJlbnQgZmliZXIgYXMgaW5jb21wbGV0ZSBhbmQgY2xlYXIgaXRzIGVmZmVjdCBsaXN0LlxuICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICByZXR1cm5GaWJlci5lZmZlY3RUYWcgfD0gSW5jb21wbGV0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNpYmxpbmdGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHdvcmsgdG8gZG8gaW4gdGhpcyByZXR1cm5GaWJlciwgZG8gdGhhdCBuZXh0LlxuICAgICAgICByZXR1cm4gc2libGluZ0ZpYmVyO1xuICAgICAgfSBlbHNlIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIG1vcmUgd29yayBpbiB0aGlzIHJldHVybkZpYmVyLiBDb21wbGV0ZSB0aGUgcmV0dXJuRmliZXIuXG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gV2l0aG91dCB0aGlzIGV4cGxpY2l0IG51bGwgcmV0dXJuIEZsb3cgY29tcGxhaW5zIG9mIGludmFsaWQgcmV0dXJuIHR5cGVcbiAgLy8gVE9ETyBSZW1vdmUgdGhlIGFib3ZlIHdoaWxlKHRydWUpIGxvb3BcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAvLyBJZGVhbGx5IG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZVxuICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAvLyBwcm9ncmVzcy5cbiAgdmFyIGN1cnJlbnQkJDEgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgLy8gU2VlIGlmIGJlZ2lubmluZyB0aGlzIHdvcmsgc3Bhd25zIG1vcmUgd29yay5cbiAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICB7XG4gICAgc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIGlmICh0cnVlICYmIHJlcGxheUZhaWxlZFVuaXRPZldvcmtXaXRoSW52b2tlR3VhcmRlZENhbGxiYWNrKSB7XG4gICAgc3Rhc2hlZFdvcmtJblByb2dyZXNzUHJvcGVydGllcyA9IGFzc2lnbkZpYmVyUHJvcGVydGllc0luREVWKHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciBuZXh0ID0gdm9pZCAwO1xuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgIHN0YXJ0UHJvZmlsZXJUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgbmV4dCA9IGJlZ2luV29yayhjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgIC8vIFJlY29yZCB0aGUgcmVuZGVyIGR1cmF0aW9uIGFzc3VtaW5nIHdlIGRpZG4ndCBiYWlsb3V0IChvciBlcnJvcikuXG4gICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKHdvcmtJblByb2dyZXNzLCB0cnVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV4dCA9IGJlZ2luV29yayhjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIHtcbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIGlmIChpc1JlcGxheWluZ0ZhaWxlZFVuaXRPZldvcmspIHtcbiAgICAgIC8vIEN1cnJlbnRseSByZXBsYXlpbmcgYSBmYWlsZWQgdW5pdCBvZiB3b3JrLiBUaGlzIHNob3VsZCBiZSB1bnJlYWNoYWJsZSxcbiAgICAgIC8vIGJlY2F1c2UgdGhlIHJlbmRlciBwaGFzZSBpcyBtZWFudCB0byBiZSBpZGVtcG90ZW50LCBhbmQgaXQgc2hvdWxkXG4gICAgICAvLyBoYXZlIHRocm93biBhZ2Fpbi4gU2luY2UgaXQgZGlkbid0LCByZXRocm93IHRoZSBvcmlnaW5hbCBlcnJvciwgc29cbiAgICAgIC8vIFJlYWN0J3MgaW50ZXJuYWwgc3RhY2sgaXMgbm90IG1pc2FsaWduZWQuXG4gICAgICByZXRocm93T3JpZ2luYWxFcnJvcigpO1xuICAgIH1cbiAgfVxuICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkJlZ2luV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICBuZXh0ID0gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIFJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudCA9IG51bGw7XG5cbiAgcmV0dXJuIG5leHQ7XG59XG5cbmZ1bmN0aW9uIHdvcmtMb29wKGlzWWllbGR5KSB7XG4gIGlmICghaXNZaWVsZHkpIHtcbiAgICAvLyBGbHVzaCB3b3JrIHdpdGhvdXQgeWllbGRpbmdcbiAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBGbHVzaCBhc3luY2hyb25vdXMgd29yayB1bnRpbCB0aGUgZGVhZGxpbmUgcnVucyBvdXQgb2YgdGltZS5cbiAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwgJiYgIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJSb290KHJvb3QsIGlzWWllbGR5LCBpc0V4cGlyZWQpIHtcbiAgISFpc1dvcmtpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW5kZXJSb290IHdhcyBjYWxsZWQgcmVjdXJzaXZlbHkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIGlzV29ya2luZyA9IHRydWU7XG4gIFJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudERpc3BhdGNoZXIgPSBEaXNwYXRjaGVyO1xuXG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHJvb3QubmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT247XG5cbiAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBudWxsO1xuICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgIC8vIFdlJ3JlIGFib3V0IHRvIHN0YXJ0IG5ldyB0cmFjZWQgd29yay5cbiAgICAvLyBSZXN0b3JlIHBlbmRpbmcgaW50ZXJhY3Rpb25zIHNvIGNhc2NhZGluZyB3b3JrIHRyaWdnZXJlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSB3aWxsIGJlIGFjY291bnRlZCBmb3IuXG4gICAgcHJldkludGVyYWN0aW9ucyA9IHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgICB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSByb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UncmUgc3RhcnRpbmcgZnJvbSBhIGZyZXNoIHN0YWNrLCBvciBpZiB3ZSdyZSByZXN1bWluZyBmcm9tXG4gIC8vIHByZXZpb3VzbHkgeWllbGRlZCB3b3JrLlxuICBpZiAoZXhwaXJhdGlvblRpbWUgIT09IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSB8fCByb290ICE9PSBuZXh0Um9vdCB8fCBuZXh0VW5pdE9mV29yayA9PT0gbnVsbCkge1xuICAgIC8vIFJlc2V0IHRoZSBzdGFjayBhbmQgc3RhcnQgd29ya2luZyBmcm9tIHRoZSByb290LlxuICAgIHJlc2V0U3RhY2soKTtcbiAgICBuZXh0Um9vdCA9IHJvb3Q7XG4gICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgbmV4dFVuaXRPZldvcmsgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhuZXh0Um9vdC5jdXJyZW50LCBudWxsLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHJvb3QucGVuZGluZ0NvbW1pdEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gICAgaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBpbnRlcmFjdGlvbnMgdGhpcyBiYXRjaCBvZiB3b3JrIGN1cnJlbnRseSBpbmNsdWRlcyxcbiAgICAgIC8vIFNvIHRoYXQgd2UgY2FuIGFjY3VyYXRlbHkgYXR0cmlidXRlIHRpbWUgc3BlbnQgd29ya2luZyBvbiBpdCxcbiAgICAgIHZhciBpbnRlcmFjdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICByb290LnBlbmRpbmdJbnRlcmFjdGlvbk1hcC5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlZHVsZWRJbnRlcmFjdGlvbnMsIHNjaGVkdWxlZEV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIGlmIChzY2hlZHVsZWRFeHBpcmF0aW9uVGltZSA8PSBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIHNjaGVkdWxlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGludGVyYWN0aW9ucy5hZGQoaW50ZXJhY3Rpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgc2V0IG9mIGludGVyYWN0aW9ucyBvbiB0aGUgRmliZXJSb290IGZvciBhIGZldyByZWFzb25zOlxuICAgICAgLy8gV2UgY2FuIHJlLXVzZSBpdCBpbiBob3QgZnVuY3Rpb25zIGxpa2UgcmVuZGVyUm9vdCgpIHdpdGhvdXQgaGF2aW5nIHRvIHJlY2FsY3VsYXRlIGl0LlxuICAgICAgLy8gV2Ugd2lsbCBhbHNvIHVzZSBpdCBpbiBjb21taXRXb3JrKCkgdG8gcGFzcyB0byBhbnkgUHJvZmlsZXIgb25SZW5kZXIoKSBob29rcy5cbiAgICAgIC8vIFRoaXMgYWxzbyBwcm92aWRlcyBEZXZUb29scyB3aXRoIGEgd2F5IHRvIGFjY2VzcyBpdCB3aGVuIHRoZSBvbkNvbW1pdFJvb3QoKSBob29rIGlzIGNhbGxlZC5cbiAgICAgIHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMgPSBpbnRlcmFjdGlvbnM7XG5cbiAgICAgIGlmIChpbnRlcmFjdGlvbnMuc2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSB0cmFjaW5nLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciB0aHJlYWRJRCA9IGNvbXB1dGVUaHJlYWRJRChleHBpcmF0aW9uVGltZSwgcm9vdC5pbnRlcmFjdGlvblRocmVhZElEKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdGFydGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBXb3JrIHRocm93biBieSBhbiBpbnRlcmFjdGlvbiB0cmFjaW5nIHN1YnNjcmliZXIgc2hvdWxkIGJlIHJldGhyb3duLFxuICAgICAgICAgICAgLy8gQnV0IG9ubHkgb25jZSBpdCdzIHNhZmUgKHRvIGF2b2lkIGxlYXZlaW5nIHRoZSBzY2hlZHVsZXIgaW4gYW4gaW52YWxpZCBzdGF0ZSkuXG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgZXJyb3IgZm9yIG5vdyBhbmQgd2UnbGwgcmUtdGhyb3cgaW4gZmluaXNoUmVuZGVyaW5nKCkuXG4gICAgICAgICAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICAgICAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdW5oYW5kbGVkRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZGlkRmF0YWwgPSBmYWxzZTtcblxuICBzdGFydFdvcmtMb29wVGltZXIobmV4dFVuaXRPZldvcmspO1xuXG4gIGRvIHtcbiAgICB0cnkge1xuICAgICAgd29ya0xvb3AoaXNZaWVsZHkpO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICBpZiAobmV4dFVuaXRPZldvcmsgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGZhdGFsIGVycm9yLlxuICAgICAgICBkaWRGYXRhbCA9IHRydWU7XG4gICAgICAgIG9uVW5jYXVnaHRFcnJvcih0aHJvd25WYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB7XG4gICAgICAgICAgLy8gUmVzZXQgZ2xvYmFsIGRlYnVnIHN0YXRlXG4gICAgICAgICAgLy8gV2UgYXNzdW1lIHRoaXMgaXMgZGVmaW5lZCBpbiBERVZcbiAgICAgICAgICByZXNldEN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZhaWxlZFVuaXRPZldvcmsgPSBuZXh0VW5pdE9mV29yaztcbiAgICAgICAgaWYgKHRydWUgJiYgcmVwbGF5RmFpbGVkVW5pdE9mV29ya1dpdGhJbnZva2VHdWFyZGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICByZXBsYXlVbml0T2ZXb3JrKGZhaWxlZFVuaXRPZldvcmssIHRocm93blZhbHVlLCBpc1lpZWxkeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiB3ZSBhbHJlYWR5IGtub3cgdGhpcyBpc24ndCB0cnVlIGluIHNvbWUgY2FzZXMuXG4gICAgICAgIC8vIEF0IGxlYXN0IHRoaXMgc2hvd3MgYSBuaWNlciBlcnJvciBtZXNzYWdlIHVudGlsIHdlIGZpZ3VyZSBvdXQgdGhlIGNhdXNlLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyNDQ5I2lzc3VlY29tbWVudC0zODY3Mjc0MzFcbiAgICAgICAgIShuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdGYWlsZWQgdG8gcmVwbGF5IHJlbmRlcmluZyBhZnRlciBhbiBlcnJvci4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSB3aXRoIGEgcmVwcm9kdWNpbmcgY2FzZSB0byBoZWxwIHVzIGZpbmQgaXQuJykgOiB2b2lkIDA7XG5cbiAgICAgICAgdmFyIHNvdXJjZUZpYmVyID0gbmV4dFVuaXRPZldvcms7XG4gICAgICAgIHZhciByZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLnJldHVybjtcbiAgICAgICAgaWYgKHJldHVybkZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgcm9vdC4gVGhlIHJvb3QgY291bGQgY2FwdHVyZSBpdHMgb3duIGVycm9ycy4gSG93ZXZlcixcbiAgICAgICAgICAvLyB3ZSBkb24ndCBrbm93IGlmIGl0IGVycm9ycyBiZWZvcmUgb3IgYWZ0ZXIgd2UgcHVzaGVkIHRoZSBob3N0XG4gICAgICAgICAgLy8gY29udGV4dC4gVGhpcyBpbmZvcm1hdGlvbiBpcyBuZWVkZWQgdG8gYXZvaWQgYSBzdGFjayBtaXNtYXRjaC5cbiAgICAgICAgICAvLyBCZWNhdXNlIHdlJ3JlIG5vdCBzdXJlLCB0cmVhdCB0aGlzIGFzIGEgZmF0YWwgZXJyb3IuIFdlIGNvdWxkIHRyYWNrXG4gICAgICAgICAgLy8gd2hpY2ggcGhhc2UgaXQgZmFpbHMgaW4sIGJ1dCBkb2Vzbid0IHNlZW0gd29ydGggaXQuIEF0IGxlYXN0XG4gICAgICAgICAgLy8gZm9yIG5vdy5cbiAgICAgICAgICBkaWRGYXRhbCA9IHRydWU7XG4gICAgICAgICAgb25VbmNhdWdodEVycm9yKHRocm93blZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvd0V4Y2VwdGlvbihyb290LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHRocm93blZhbHVlLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gY29tcGxldGVVbml0T2ZXb3JrKHNvdXJjZUZpYmVyKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICAvLyBUcmFjZWQgd29yayBpcyBkb25lIGZvciBub3c7IHJlc3RvcmUgdGhlIHByZXZpb3VzIGludGVyYWN0aW9ucy5cbiAgICB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBwcmV2SW50ZXJhY3Rpb25zO1xuICB9XG5cbiAgLy8gV2UncmUgZG9uZSBwZXJmb3JtaW5nIHdvcmsuIFRpbWUgdG8gY2xlYW4gdXAuXG4gIGlzV29ya2luZyA9IGZhbHNlO1xuICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnREaXNwYXRjaGVyID0gbnVsbDtcbiAgcmVzZXRDb250ZXh0RGVwZW5kZW5jZXMoKTtcblxuICAvLyBZaWVsZCBiYWNrIHRvIG1haW4gdGhyZWFkLlxuICBpZiAoZGlkRmF0YWwpIHtcbiAgICB2YXIgX2RpZENvbXBsZXRlUm9vdCA9IGZhbHNlO1xuICAgIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnksIF9kaWRDb21wbGV0ZVJvb3QpO1xuICAgIGludGVycnVwdGVkQnkgPSBudWxsO1xuICAgIC8vIFRoZXJlIHdhcyBhIGZhdGFsIGVycm9yLlxuICAgIHtcbiAgICAgIHJlc2V0U3RhY2tBZnRlckZhdGFsRXJyb3JJbkRldigpO1xuICAgIH1cbiAgICAvLyBgbmV4dFJvb3RgIHBvaW50cyB0byB0aGUgaW4tcHJvZ3Jlc3Mgcm9vdC4gQSBub24tbnVsbCB2YWx1ZSBpbmRpY2F0ZXNcbiAgICAvLyB0aGF0IHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYW4gYXN5bmMgcmVuZGVyLiBTZXQgaXQgdG8gbnVsbCB0byBpbmRpY2F0ZVxuICAgIC8vIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIHRvIGJlIGRvbmUgaW4gdGhlIGN1cnJlbnQgYmF0Y2guXG4gICAgbmV4dFJvb3QgPSBudWxsO1xuICAgIG9uRmF0YWwocm9vdCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgLy8gVGhlcmUncyBzdGlsbCByZW1haW5pbmcgYXN5bmMgd29yayBpbiB0aGlzIHRyZWUsIGJ1dCB3ZSByYW4gb3V0IG9mIHRpbWVcbiAgICAvLyBpbiB0aGUgY3VycmVudCBmcmFtZS4gWWllbGQgYmFjayB0byB0aGUgcmVuZGVyZXIuIFVubGVzcyB3ZSdyZVxuICAgIC8vIGludGVycnVwdGVkIGJ5IGEgaGlnaGVyIHByaW9yaXR5IHVwZGF0ZSwgd2UnbGwgY29udGludWUgbGF0ZXIgZnJvbSB3aGVyZVxuICAgIC8vIHdlIGxlZnQgb2ZmLlxuICAgIHZhciBfZGlkQ29tcGxldGVSb290MiA9IGZhbHNlO1xuICAgIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnksIF9kaWRDb21wbGV0ZVJvb3QyKTtcbiAgICBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcbiAgICBvbllpZWxkKHJvb3QpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFdlIGNvbXBsZXRlZCB0aGUgd2hvbGUgdHJlZS5cbiAgdmFyIGRpZENvbXBsZXRlUm9vdCA9IHRydWU7XG4gIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnksIGRpZENvbXBsZXRlUm9vdCk7XG4gIHZhciByb290V29ya0luUHJvZ3Jlc3MgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlO1xuICAhKHJvb3RXb3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdGaW5pc2hlZCByb290IHNob3VsZCBoYXZlIGEgd29yay1pbi1wcm9ncmVzcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAvLyBgbmV4dFJvb3RgIHBvaW50cyB0byB0aGUgaW4tcHJvZ3Jlc3Mgcm9vdC4gQSBub24tbnVsbCB2YWx1ZSBpbmRpY2F0ZXNcbiAgLy8gdGhhdCB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGFuIGFzeW5jIHJlbmRlci4gU2V0IGl0IHRvIG51bGwgdG8gaW5kaWNhdGVcbiAgLy8gdGhlcmUncyBubyBtb3JlIHdvcmsgdG8gYmUgZG9uZSBpbiB0aGUgY3VycmVudCBiYXRjaC5cbiAgbmV4dFJvb3QgPSBudWxsO1xuICBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcblxuICBpZiAobmV4dFJlbmRlckRpZEVycm9yKSB7XG4gICAgLy8gVGhlcmUgd2FzIGFuIGVycm9yXG4gICAgaWYgKGhhc0xvd2VyUHJpb3JpdHlXb3JrKHJvb3QsIGV4cGlyYXRpb25UaW1lKSkge1xuICAgICAgLy8gVGhlcmUncyBsb3dlciBwcmlvcml0eSB3b3JrLiBJZiBzbywgaXQgbWF5IGhhdmUgdGhlIGVmZmVjdCBvZiBmaXhpbmdcbiAgICAgIC8vIHRoZSBleGNlcHRpb24gdGhhdCB3YXMganVzdCB0aHJvd24uIEV4aXQgd2l0aG91dCBjb21taXR0aW5nLiBUaGlzIGlzXG4gICAgICAvLyBzaW1pbGFyIHRvIGEgc3VzcGVuZCwgYnV0IHdpdGhvdXQgYSB0aW1lb3V0IGJlY2F1c2Ugd2UncmUgbm90IHdhaXRpbmdcbiAgICAgIC8vIGZvciBhIHByb21pc2UgdG8gcmVzb2x2ZS4gUmVhY3Qgd2lsbCByZXN0YXJ0IGF0IHRoZSBsb3dlclxuICAgICAgLy8gcHJpb3JpdHkgbGV2ZWwuXG4gICAgICBtYXJrU3VzcGVuZGVkUHJpb3JpdHlMZXZlbChyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICB2YXIgc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIHZhciByb290RXhwaXJhdGlvblRpbWUgPSByb290LmV4cGlyYXRpb25UaW1lO1xuICAgICAgb25TdXNwZW5kKHJvb3QsIHJvb3RXb3JrSW5Qcm9ncmVzcywgc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUsIHJvb3RFeHBpcmF0aW9uVGltZSwgLTEgLy8gSW5kaWNhdGVzIG5vIHRpbWVvdXRcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChcbiAgICAvLyBUaGVyZSdzIG5vIGxvd2VyIHByaW9yaXR5IHdvcmssIGJ1dCB3ZSdyZSByZW5kZXJpbmcgYXN5bmNocm9ub3VzbHkuXG4gICAgLy8gU3luY2hyb25zb3VseSBhdHRlbXB0IHRvIHJlbmRlciB0aGUgc2FtZSBsZXZlbCBvbmUgbW9yZSB0aW1lLiBUaGlzIGlzXG4gICAgLy8gc2ltaWxhciB0byBhIHN1c3BlbmQsIGJ1dCB3aXRob3V0IGEgdGltZW91dCBiZWNhdXNlIHdlJ3JlIG5vdCB3YWl0aW5nXG4gICAgLy8gZm9yIGEgcHJvbWlzZSB0byByZXNvbHZlLlxuICAgICFyb290LmRpZEVycm9yICYmICFpc0V4cGlyZWQpIHtcbiAgICAgIHJvb3QuZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgdmFyIF9zdXNwZW5kZWRFeHBpcmF0aW9uVGltZSA9IHJvb3QubmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24gPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIHZhciBfcm9vdEV4cGlyYXRpb25UaW1lID0gcm9vdC5leHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gICAgICBvblN1c3BlbmQocm9vdCwgcm9vdFdvcmtJblByb2dyZXNzLCBfc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUsIF9yb290RXhwaXJhdGlvblRpbWUsIC0xIC8vIEluZGljYXRlcyBubyB0aW1lb3V0XG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmFibGVTdXNwZW5zZSAmJiAhaXNFeHBpcmVkICYmIG5leHRMYXRlc3RBYnNvbHV0ZVRpbWVvdXRNcyAhPT0gLTEpIHtcbiAgICAvLyBUaGUgdHJlZSB3YXMgc3VzcGVuZGVkLlxuICAgIHZhciBfc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUyID0gZXhwaXJhdGlvblRpbWU7XG4gICAgbWFya1N1c3BlbmRlZFByaW9yaXR5TGV2ZWwocm9vdCwgX3N1c3BlbmRlZEV4cGlyYXRpb25UaW1lMik7XG5cbiAgICAvLyBGaW5kIHRoZSBlYXJsaWVzdCB1bmNvbW1pdHRlZCBleHBpcmF0aW9uIHRpbWUgaW4gdGhlIHRyZWUsIGluY2x1ZGluZ1xuICAgIC8vIHdvcmsgdGhhdCBpcyBzdXNwZW5kZWQuIFRoZSB0aW1lb3V0IHRocmVzaG9sZCBjYW5ub3QgYmUgbG9uZ2VyIHRoYW5cbiAgICAvLyB0aGUgb3ZlcmFsbCBleHBpcmF0aW9uLlxuICAgIHZhciBlYXJsaWVzdEV4cGlyYXRpb25UaW1lID0gZmluZEVhcmxpZXN0T3V0c3RhbmRpbmdQcmlvcml0eUxldmVsKHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB2YXIgZWFybGllc3RFeHBpcmF0aW9uVGltZU1zID0gZXhwaXJhdGlvblRpbWVUb01zKGVhcmxpZXN0RXhwaXJhdGlvblRpbWUpO1xuICAgIGlmIChlYXJsaWVzdEV4cGlyYXRpb25UaW1lTXMgPCBuZXh0TGF0ZXN0QWJzb2x1dGVUaW1lb3V0TXMpIHtcbiAgICAgIG5leHRMYXRlc3RBYnNvbHV0ZVRpbWVvdXRNcyA9IGVhcmxpZXN0RXhwaXJhdGlvblRpbWVNcztcbiAgICB9XG5cbiAgICAvLyBTdWJ0cmFjdCB0aGUgY3VycmVudCB0aW1lIGZyb20gdGhlIGFic29sdXRlIHRpbWVvdXQgdG8gZ2V0IHRoZSBudW1iZXJcbiAgICAvLyBvZiBtaWxsaXNlY29uZHMgdW50aWwgdGhlIHRpbWVvdXQuIEluIG90aGVyIHdvcmRzLCBjb252ZXJ0IGFuIGFic29sdXRlXG4gICAgLy8gdGltZXN0YW1wIHRvIGEgcmVsYXRpdmUgdGltZS4gVGhpcyBpcyB0aGUgdmFsdWUgdGhhdCBpcyBwYXNzZWRcbiAgICAvLyB0byBgc2V0VGltZW91dGAuXG4gICAgdmFyIGN1cnJlbnRUaW1lTXMgPSBleHBpcmF0aW9uVGltZVRvTXMocmVxdWVzdEN1cnJlbnRUaW1lKCkpO1xuICAgIHZhciBtc1VudGlsVGltZW91dCA9IG5leHRMYXRlc3RBYnNvbHV0ZVRpbWVvdXRNcyAtIGN1cnJlbnRUaW1lTXM7XG4gICAgbXNVbnRpbFRpbWVvdXQgPSBtc1VudGlsVGltZW91dCA8IDAgPyAwIDogbXNVbnRpbFRpbWVvdXQ7XG5cbiAgICAvLyBUT0RPOiBBY2NvdW50IGZvciB0aGUgSnVzdCBOb3RpY2VhYmxlIERpZmZlcmVuY2VcblxuICAgIHZhciBfcm9vdEV4cGlyYXRpb25UaW1lMiA9IHJvb3QuZXhwaXJhdGlvblRpbWU7XG4gICAgb25TdXNwZW5kKHJvb3QsIHJvb3RXb3JrSW5Qcm9ncmVzcywgX3N1c3BlbmRlZEV4cGlyYXRpb25UaW1lMiwgX3Jvb3RFeHBpcmF0aW9uVGltZTIsIG1zVW50aWxUaW1lb3V0KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBSZWFkeSB0byBjb21taXQuXG4gIG9uQ29tcGxldGUocm9vdCwgcm9vdFdvcmtJblByb2dyZXNzLCBleHBpcmF0aW9uVGltZSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoKHNvdXJjZUZpYmVyLCB2YWx1ZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgISghaXNXb3JraW5nIHx8IGlzQ29tbWl0dGluZyQxKSA/IGludmFyaWFudChmYWxzZSwgJ2Rpc3BhdGNoOiBDYW5ub3QgZGlzcGF0Y2ggZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuJykgOiB2b2lkIDA7XG5cbiAgdmFyIGZpYmVyID0gc291cmNlRmliZXIucmV0dXJuO1xuICB3aGlsZSAoZmliZXIgIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnRMYXp5OlxuICAgICAgICB2YXIgY3RvciA9IGZpYmVyLnR5cGU7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpKSB7XG4gICAgICAgICAgdmFyIGVycm9ySW5mbyA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICAgICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9lcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlKHZhbHVlLCBzb3VyY2VGaWJlcik7XG4gICAgICAgICAgdmFyIF91cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUoZmliZXIsIF9lcnJvckluZm8sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCBfdXBkYXRlKTtcbiAgICAgICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gIH1cblxuICBpZiAoc291cmNlRmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIEVycm9yIHdhcyB0aHJvd24gYXQgdGhlIHJvb3QuIFRoZXJlIGlzIG5vIHBhcmVudCwgc28gdGhlIHJvb3RcbiAgICAvLyBpdHNlbGYgc2hvdWxkIGNhcHR1cmUgaXQuXG4gICAgdmFyIHJvb3RGaWJlciA9IHNvdXJjZUZpYmVyO1xuICAgIHZhciBfZXJyb3JJbmZvMiA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHJvb3RGaWJlcik7XG4gICAgdmFyIF91cGRhdGUyID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKHJvb3RGaWJlciwgX2Vycm9ySW5mbzIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBlbnF1ZXVlVXBkYXRlKHJvb3RGaWJlciwgX3VwZGF0ZTIpO1xuICAgIHNjaGVkdWxlV29yayhyb290RmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZXJyb3IpIHtcbiAgcmV0dXJuIGRpc3BhdGNoKGZpYmVyLCBlcnJvciwgU3luYyk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVUaHJlYWRJRChleHBpcmF0aW9uVGltZSwgaW50ZXJhY3Rpb25UaHJlYWRJRCkge1xuICAvLyBJbnRlcmFjdGlvbiB0aHJlYWRzIGFyZSB1bmlxdWUgcGVyIHJvb3QgYW5kIGV4cGlyYXRpb24gdGltZS5cbiAgcmV0dXJuIGV4cGlyYXRpb25UaW1lICogMTAwMCArIGludGVyYWN0aW9uVGhyZWFkSUQ7XG59XG5cbi8vIENyZWF0ZXMgYSB1bmlxdWUgYXN5bmMgZXhwaXJhdGlvbiB0aW1lLlxuZnVuY3Rpb24gY29tcHV0ZVVuaXF1ZUFzeW5jRXhwaXJhdGlvbigpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gcmVxdWVzdEN1cnJlbnRUaW1lKCk7XG4gIHZhciByZXN1bHQgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKGN1cnJlbnRUaW1lKTtcbiAgaWYgKHJlc3VsdCA8PSBsYXN0VW5pcXVlQXN5bmNFeHBpcmF0aW9uKSB7XG4gICAgLy8gU2luY2Ugd2UgYXNzdW1lIHRoZSBjdXJyZW50IHRpbWUgbW9ub3RvbmljYWxseSBpbmNyZWFzZXMsIHdlIG9ubHkgaGl0XG4gICAgLy8gdGhpcyBicmFuY2ggd2hlbiBjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uIGlzIGZpcmVkIG11bHRpcGxlIHRpbWVzXG4gICAgLy8gd2l0aGluIGEgMjAwbXMgd2luZG93IChvciB3aGF0ZXZlciB0aGUgYXN5bmMgYnVja2V0IHNpemUgaXMpLlxuICAgIHJlc3VsdCA9IGxhc3RVbmlxdWVBc3luY0V4cGlyYXRpb24gKyAxO1xuICB9XG4gIGxhc3RVbmlxdWVBc3luY0V4cGlyYXRpb24gPSByZXN1bHQ7XG4gIHJldHVybiBsYXN0VW5pcXVlQXN5bmNFeHBpcmF0aW9uO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGN1cnJlbnRUaW1lLCBmaWJlcikge1xuICB2YXIgZXhwaXJhdGlvblRpbWUgPSB2b2lkIDA7XG4gIGlmIChleHBpcmF0aW9uQ29udGV4dCAhPT0gTm9Xb3JrKSB7XG4gICAgLy8gQW4gZXhwbGljaXQgZXhwaXJhdGlvbiBjb250ZXh0IHdhcyBzZXQ7XG4gICAgZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgfSBlbHNlIGlmIChpc1dvcmtpbmcpIHtcbiAgICBpZiAoaXNDb21taXR0aW5nJDEpIHtcbiAgICAgIC8vIFVwZGF0ZXMgdGhhdCBvY2N1ciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBzaG91bGQgaGF2ZSBzeW5jIHByaW9yaXR5XG4gICAgICAvLyBieSBkZWZhdWx0LlxuICAgICAgZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVzIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlIHNob3VsZCBleHBpcmUgYXQgdGhlIHNhbWUgdGltZSBhc1xuICAgICAgLy8gdGhlIHdvcmsgdGhhdCBpcyBiZWluZyByZW5kZXJlZC5cbiAgICAgIGV4cGlyYXRpb25UaW1lID0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBObyBleHBsaWNpdCBleHBpcmF0aW9uIGNvbnRleHQgd2FzIHNldCwgYW5kIHdlJ3JlIG5vdCBjdXJyZW50bHlcbiAgICAvLyBwZXJmb3JtaW5nIHdvcmsuIENhbGN1bGF0ZSBhIG5ldyBleHBpcmF0aW9uIHRpbWUuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBBc3luY01vZGUpIHtcbiAgICAgIGlmIChpc0JhdGNoaW5nSW50ZXJhY3RpdmVVcGRhdGVzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJhY3RpdmUgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUludGVyYWN0aXZlRXhwaXJhdGlvbihjdXJyZW50VGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGFzeW5jIHVwZGF0ZVxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVBc3luY0V4cGlyYXRpb24oY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiByZW5kZXJpbmcgYSB0cmVlLCBkbyBub3QgdXBkYXRlIGF0IHRoZSBzYW1lXG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWUgdGhhdCBpcyBhbHJlYWR5IHJlbmRlcmluZy5cbiAgICAgIGlmIChuZXh0Um9vdCAhPT0gbnVsbCAmJiBleHBpcmF0aW9uVGltZSA9PT0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIGV4cGlyYXRpb25UaW1lICs9IDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzeW5jIHVwZGF0ZVxuICAgICAgZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgIH1cbiAgfVxuICBpZiAoaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcykge1xuICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJhY3RpdmUgdXBkYXRlLiBLZWVwIHRyYWNrIG9mIHRoZSBsb3dlc3QgcGVuZGluZ1xuICAgIC8vIGludGVyYWN0aXZlIGV4cGlyYXRpb24gdGltZS4gVGhpcyBhbGxvd3MgdXMgdG8gc3luY2hyb25vdXNseSBmbHVzaFxuICAgIC8vIGFsbCBpbnRlcmFjdGl2ZSB1cGRhdGVzIHdoZW4gbmVlZGVkLlxuICAgIGlmIChsb3dlc3RQcmlvcml0eVBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgZXhwaXJhdGlvblRpbWUgPiBsb3dlc3RQcmlvcml0eVBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lKSB7XG4gICAgICBsb3dlc3RQcmlvcml0eVBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBleHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZChyb290LCBhYnNvbHV0ZVRpbWVvdXRNcywgc3VzcGVuZGVkVGltZSkge1xuICAvLyBTY2hlZHVsZSB0aGUgdGltZW91dC5cbiAgaWYgKGFic29sdXRlVGltZW91dE1zID49IDAgJiYgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zIDwgYWJzb2x1dGVUaW1lb3V0TXMpIHtcbiAgICBuZXh0TGF0ZXN0QWJzb2x1dGVUaW1lb3V0TXMgPSBhYnNvbHV0ZVRpbWVvdXRNcztcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJEaWRFcnJvcigpIHtcbiAgbmV4dFJlbmRlckRpZEVycm9yID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0cnlTdXNwZW5kZWRSb290KHJvb3QsIGZpYmVyLCBzdXNwZW5kZWRUaW1lKSB7XG4gIGlmIChlbmFibGVTdXNwZW5zZSkge1xuICAgIHZhciByZXRyeVRpbWUgPSB2b2lkIDA7XG5cbiAgICBpZiAoaXNQcmlvcml0eUxldmVsU3VzcGVuZGVkKHJvb3QsIHN1c3BlbmRlZFRpbWUpKSB7XG4gICAgICAvLyBQaW5nIGF0IHRoZSBvcmlnaW5hbCBsZXZlbFxuICAgICAgcmV0cnlUaW1lID0gc3VzcGVuZGVkVGltZTtcbiAgICAgIG1hcmtQaW5nZWRQcmlvcml0eUxldmVsKHJvb3QsIHJldHJ5VGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFBsYWNlaG9sZGVyIGFscmVhZHkgdGltZWQgb3V0LiBDb21wdXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZVxuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gcmVxdWVzdEN1cnJlbnRUaW1lKCk7XG4gICAgICByZXRyeVRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGN1cnJlbnRUaW1lLCBmaWJlcik7XG4gICAgICBtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgcmV0cnlUaW1lKTtcbiAgICB9XG5cbiAgICBzY2hlZHVsZVdvcmtUb1Jvb3QoZmliZXIsIHJldHJ5VGltZSk7XG4gICAgdmFyIHJvb3RFeHBpcmF0aW9uVGltZSA9IHJvb3QuZXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKHJvb3RFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgICAgICAvLyBSZXN0b3JlIHByZXZpb3VzIGludGVyYWN0aW9ucyBzbyB0aGF0IG5ldyB3b3JrIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGVtLlxuICAgICAgICB2YXIgcHJldkludGVyYWN0aW9ucyA9IHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgICAgICAgdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcm9vdC5tZW1vaXplZEludGVyYWN0aW9ucztcbiAgICAgICAgLy8gQmVjYXVzZSBzdXNwZW5zZSB0aW1lb3V0cyBkbyBub3QgZGVjcmVtZW50IHRoZSBpbnRlcmFjdGlvbiBjb3VudCxcbiAgICAgICAgLy8gQ29udGludWVkIHN1c3BlbnNlIHdvcmsgc2hvdWxkIGFsc28gbm90IGluY3JlbWVudCB0aGUgY291bnQuXG4gICAgICAgIHN0b3JlSW50ZXJhY3Rpb25zRm9yRXhwaXJhdGlvblRpbWUocm9vdCwgcm9vdEV4cGlyYXRpb25UaW1lLCBmYWxzZSk7XG4gICAgICAgIHJlcXVlc3RXb3JrKHJvb3QsIHJvb3RFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHByZXZJbnRlcmFjdGlvbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0V29yayhyb290LCByb290RXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVdvcmtUb1Jvb3QoZmliZXIsIGV4cGlyYXRpb25UaW1lKSB7XG4gIC8vIFVwZGF0ZSB0aGUgc291cmNlIGZpYmVyJ3MgZXhwaXJhdGlvbiB0aW1lXG4gIGlmIChmaWJlci5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IGZpYmVyLmV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICB9XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgKGFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IGFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSkge1xuICAgIGFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICB9XG4gIC8vIFdhbGsgdGhlIHBhcmVudCBwYXRoIHRvIHRoZSByb290IGFuZCB1cGRhdGUgdGhlIGNoaWxkIGV4cGlyYXRpb24gdGltZS5cbiAgdmFyIG5vZGUgPSBmaWJlci5yZXR1cm47XG4gIGlmIChub2RlID09PSBudWxsICYmIGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICByZXR1cm4gZmliZXIuc3RhdGVOb2RlO1xuICB9XG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlID0gbm9kZS5hbHRlcm5hdGU7XG4gICAgaWYgKG5vZGUuY2hpbGRFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuY2hpbGRFeHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICBub2RlLmNoaWxkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgKGFsdGVybmF0ZS5jaGlsZEV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiAoYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBhbHRlcm5hdGUuY2hpbGRFeHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSkge1xuICAgICAgYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICB9XG4gICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsICYmIG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHN0b3JlSW50ZXJhY3Rpb25zRm9yRXhwaXJhdGlvblRpbWUocm9vdCwgZXhwaXJhdGlvblRpbWUsIHVwZGF0ZUludGVyYWN0aW9uQ291bnRzKSB7XG4gIGlmICghZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpbnRlcmFjdGlvbnMgPSB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gIGlmIChpbnRlcmFjdGlvbnMuc2l6ZSA+IDApIHtcbiAgICB2YXIgcGVuZGluZ0ludGVyYWN0aW9ucyA9IHJvb3QucGVuZGluZ0ludGVyYWN0aW9uTWFwLmdldChleHBpcmF0aW9uVGltZSk7XG4gICAgaWYgKHBlbmRpbmdJbnRlcmFjdGlvbnMgIT0gbnVsbCkge1xuICAgICAgaW50ZXJhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgICAgIGlmICh1cGRhdGVJbnRlcmFjdGlvbkNvdW50cyAmJiAhcGVuZGluZ0ludGVyYWN0aW9ucy5oYXMoaW50ZXJhY3Rpb24pKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBwZW5kaW5nIGFzeW5jIHdvcmsgY291bnQgZm9yIHByZXZpb3VzbHkgdW5zY2hlZHVsZWQgaW50ZXJhY3Rpb24uXG4gICAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcGVuZGluZ0ludGVyYWN0aW9ucy5hZGQoaW50ZXJhY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QucGVuZGluZ0ludGVyYWN0aW9uTWFwLnNldChleHBpcmF0aW9uVGltZSwgbmV3IFNldChpbnRlcmFjdGlvbnMpKTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBwZW5kaW5nIGFzeW5jIHdvcmsgY291bnQgZm9yIHRoZSBjdXJyZW50IGludGVyYWN0aW9ucy5cbiAgICAgIGlmICh1cGRhdGVJbnRlcmFjdGlvbkNvdW50cykge1xuICAgICAgICBpbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50Kys7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdWJzY3JpYmVyID0gdHJhY2luZy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcbiAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIHRocmVhZElEID0gY29tcHV0ZVRocmVhZElEKGV4cGlyYXRpb25UaW1lLCByb290LmludGVyYWN0aW9uVGhyZWFkSUQpO1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTY2hlZHVsZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpIHtcbiAgcmVjb3JkU2NoZWR1bGVVcGRhdGUoKTtcblxuICB7XG4gICAgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgfHwgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudExhenkpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIHdhcm5BYm91dEludmFsaWRVcGRhdGVzKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcm9vdCA9IHNjaGVkdWxlV29ya1RvUm9vdChmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgIGlmICh0cnVlICYmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnRMYXp5KSkge1xuICAgICAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQoZmliZXIpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgIHN0b3JlSW50ZXJhY3Rpb25zRm9yRXhwaXJhdGlvblRpbWUocm9vdCwgZXhwaXJhdGlvblRpbWUsIHRydWUpO1xuICB9XG5cbiAgaWYgKCFpc1dvcmtpbmcgJiYgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgZXhwaXJhdGlvblRpbWUgPCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGlzIGFuIGludGVycnVwdGlvbi4gKFVzZWQgZm9yIHBlcmZvcm1hbmNlIHRyYWNraW5nLilcbiAgICBpbnRlcnJ1cHRlZEJ5ID0gZmliZXI7XG4gICAgcmVzZXRTdGFjaygpO1xuICB9XG4gIG1hcmtQZW5kaW5nUHJpb3JpdHlMZXZlbChyb290LCBleHBpcmF0aW9uVGltZSk7XG4gIGlmIChcbiAgLy8gSWYgd2UncmUgaW4gdGhlIHJlbmRlciBwaGFzZSwgd2UgZG9uJ3QgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHJvb3RcbiAgLy8gZm9yIGFuIHVwZGF0ZSwgYmVjYXVzZSB3ZSdsbCBkbyBpdCBiZWZvcmUgd2UgZXhpdC4uLlxuICAhaXNXb3JraW5nIHx8IGlzQ29tbWl0dGluZyQxIHx8XG4gIC8vIC4uLnVubGVzcyB0aGlzIGlzIGEgZGlmZmVyZW50IHJvb3QgdGhhbiB0aGUgb25lIHdlJ3JlIHJlbmRlcmluZy5cbiAgbmV4dFJvb3QgIT09IHJvb3QpIHtcbiAgICB2YXIgcm9vdEV4cGlyYXRpb25UaW1lID0gcm9vdC5leHBpcmF0aW9uVGltZTtcbiAgICByZXF1ZXN0V29yayhyb290LCByb290RXhwaXJhdGlvblRpbWUpO1xuICB9XG4gIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICAvLyBSZXNldCB0aGlzIGJhY2sgdG8gemVybyBzbyBzdWJzZXF1ZW50IHVwZGF0ZXMgZG9uJ3QgdGhyb3cuXG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgIGludmFyaWFudChmYWxzZSwgJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCByZXBlYXRlZGx5IGNhbGxzIHNldFN0YXRlIGluc2lkZSBjb21wb25lbnRXaWxsVXBkYXRlIG9yIGNvbXBvbmVudERpZFVwZGF0ZS4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgbmVzdGVkIHVwZGF0ZXMgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzeW5jVXBkYXRlcyhmbiwgYSwgYiwgYywgZCkge1xuICB2YXIgcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dCA9IGV4cGlyYXRpb25Db250ZXh0O1xuICBleHBpcmF0aW9uQ29udGV4dCA9IFN5bmM7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKGEsIGIsIGMsIGQpO1xuICB9IGZpbmFsbHkge1xuICAgIGV4cGlyYXRpb25Db250ZXh0ID0gcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dDtcbiAgfVxufVxuXG4vLyBUT0RPOiBFdmVyeXRoaW5nIGJlbG93IHRoaXMgaXMgd3JpdHRlbiBhcyBpZiBpdCBoYXMgYmVlbiBsaWZ0ZWQgdG8gdGhlXG4vLyByZW5kZXJlcnMuIEknbGwgZG8gdGhpcyBpbiBhIGZvbGxvdy11cC5cblxuLy8gTGlua2VkLWxpc3Qgb2Ygcm9vdHNcbnZhciBmaXJzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xudmFyIGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcblxudmFyIGNhbGxiYWNrRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG52YXIgY2FsbGJhY2tJRCA9IHZvaWQgMDtcbnZhciBpc1JlbmRlcmluZyA9IGZhbHNlO1xudmFyIG5leHRGbHVzaGVkUm9vdCA9IG51bGw7XG52YXIgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbnZhciBsb3dlc3RQcmlvcml0eVBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xudmFyIGRlYWRsaW5lRGlkRXhwaXJlID0gZmFsc2U7XG52YXIgaGFzVW5oYW5kbGVkRXJyb3IgPSBmYWxzZTtcbnZhciB1bmhhbmRsZWRFcnJvciA9IG51bGw7XG52YXIgZGVhZGxpbmUgPSBudWxsO1xuXG52YXIgaXNCYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbnZhciBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG52YXIgaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcyA9IGZhbHNlO1xuXG52YXIgY29tcGxldGVkQmF0Y2hlcyA9IG51bGw7XG5cbnZhciBvcmlnaW5hbFN0YXJ0VGltZU1zID0gc2NoZWR1bGUudW5zdGFibGVfbm93KCk7XG52YXIgY3VycmVudFJlbmRlcmVyVGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZShvcmlnaW5hbFN0YXJ0VGltZU1zKTtcbnZhciBjdXJyZW50U2NoZWR1bGVyVGltZSA9IGN1cnJlbnRSZW5kZXJlclRpbWU7XG5cbi8vIFVzZSB0aGVzZSB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3Agb2YgbmVzdGVkIHVwZGF0ZXNcbnZhciBORVNURURfVVBEQVRFX0xJTUlUID0gNTA7XG52YXIgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xudmFyIGxhc3RDb21taXR0ZWRSb290RHVyaW5nVGhpc0JhdGNoID0gbnVsbDtcblxudmFyIHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrID0gMTtcblxuZnVuY3Rpb24gcmVjb21wdXRlQ3VycmVudFJlbmRlcmVyVGltZSgpIHtcbiAgdmFyIGN1cnJlbnRUaW1lTXMgPSBzY2hlZHVsZS51bnN0YWJsZV9ub3coKSAtIG9yaWdpbmFsU3RhcnRUaW1lTXM7XG4gIGN1cnJlbnRSZW5kZXJlclRpbWUgPSBtc1RvRXhwaXJhdGlvblRpbWUoY3VycmVudFRpbWVNcyk7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2tXaXRoRXhwaXJhdGlvblRpbWUocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGNhbGxiYWNrRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykge1xuICAgIC8vIEEgY2FsbGJhY2sgaXMgYWxyZWFkeSBzY2hlZHVsZWQuIENoZWNrIGl0cyBleHBpcmF0aW9uIHRpbWUgKHRpbWVvdXQpLlxuICAgIGlmIChleHBpcmF0aW9uVGltZSA+IGNhbGxiYWNrRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIEV4aXN0aW5nIGNhbGxiYWNrIGhhcyBzdWZmaWNpZW50IHRpbWVvdXQuIEV4aXQuXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjYWxsYmFja0lEICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEV4aXN0aW5nIGNhbGxiYWNrIGhhcyBpbnN1ZmZpY2llbnQgdGltZW91dC4gQ2FuY2VsIGFuZCBzY2hlZHVsZSBhXG4gICAgICAgIC8vIG5ldyBvbmUuXG4gICAgICAgIHNjaGVkdWxlLnVuc3RhYmxlX2NhbmNlbFNjaGVkdWxlZFdvcmsoY2FsbGJhY2tJRCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFRoZSByZXF1ZXN0IGNhbGxiYWNrIHRpbWVyIGlzIGFscmVhZHkgcnVubmluZy4gRG9uJ3Qgc3RhcnQgYSBuZXcgb25lLlxuICB9IGVsc2Uge1xuICAgIHN0YXJ0UmVxdWVzdENhbGxiYWNrVGltZXIoKTtcbiAgfVxuXG4gIGNhbGxiYWNrRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgdmFyIGN1cnJlbnRNcyA9IHNjaGVkdWxlLnVuc3RhYmxlX25vdygpIC0gb3JpZ2luYWxTdGFydFRpbWVNcztcbiAgdmFyIGV4cGlyYXRpb25UaW1lTXMgPSBleHBpcmF0aW9uVGltZVRvTXMoZXhwaXJhdGlvblRpbWUpO1xuICB2YXIgdGltZW91dCA9IGV4cGlyYXRpb25UaW1lTXMgLSBjdXJyZW50TXM7XG4gIGNhbGxiYWNrSUQgPSBzY2hlZHVsZS51bnN0YWJsZV9zY2hlZHVsZVdvcmsocGVyZm9ybUFzeW5jV29yaywgeyB0aW1lb3V0OiB0aW1lb3V0IH0pO1xufVxuXG4vLyBGb3IgZXZlcnkgY2FsbCB0byByZW5kZXJSb290LCBvbmUgb2Ygb25GYXRhbCwgb25Db21wbGV0ZSwgb25TdXNwZW5kLCBhbmRcbi8vIG9uWWllbGQgaXMgY2FsbGVkIHVwb24gZXhpdGluZy4gV2UgdXNlIHRoZXNlIGluIGxpZXUgb2YgcmV0dXJuaW5nIGEgdHVwbGUuXG4vLyBJJ3ZlIGFsc28gY2hvc2VuIG5vdCB0byBpbmxpbmUgdGhlbSBpbnRvIHJlbmRlclJvb3QgYmVjYXVzZSB0aGVzZSB3aWxsXG4vLyBldmVudHVhbGx5IGJlIGxpZnRlZCBpbnRvIHRoZSByZW5kZXJlci5cbmZ1bmN0aW9uIG9uRmF0YWwocm9vdCkge1xuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcGxldGUocm9vdCwgZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSkge1xuICByb290LnBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByb290LmZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yaztcbn1cblxuZnVuY3Rpb24gb25TdXNwZW5kKHJvb3QsIGZpbmlzaGVkV29yaywgc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUsIHJvb3RFeHBpcmF0aW9uVGltZSwgbXNVbnRpbFRpbWVvdXQpIHtcbiAgcm9vdC5leHBpcmF0aW9uVGltZSA9IHJvb3RFeHBpcmF0aW9uVGltZTtcbiAgaWYgKGVuYWJsZVN1c3BlbnNlICYmIG1zVW50aWxUaW1lb3V0ID09PSAwICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgLy8gRG9uJ3Qgd2FpdCBhbiBhZGRpdGlvbmFsIHRpY2suIENvbW1pdCB0aGUgdHJlZSBpbW1lZGlhdGVseS5cbiAgICByb290LnBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZSA9IHN1c3BlbmRlZEV4cGlyYXRpb25UaW1lO1xuICAgIHJvb3QuZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrO1xuICB9IGVsc2UgaWYgKG1zVW50aWxUaW1lb3V0ID4gMCkge1xuICAgIC8vIFdhaXQgYG1zVW50aWxUaW1lb3V0YCBtaWxsaXNlY29uZHMgYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgcm9vdC50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KG9uVGltZW91dC5iaW5kKG51bGwsIHJvb3QsIGZpbmlzaGVkV29yaywgc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUpLCBtc1VudGlsVGltZW91dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25ZaWVsZChyb290KSB7XG4gIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gb25UaW1lb3V0KHJvb3QsIGZpbmlzaGVkV29yaywgc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGVuYWJsZVN1c3BlbnNlKSB7XG4gICAgLy8gVGhlIHJvb3QgdGltZWQgb3V0LiBDb21taXQgaXQuXG4gICAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZTtcbiAgICByb290LmZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yaztcbiAgICAvLyBSZWFkIHRoZSBjdXJyZW50IHRpbWUgYmVmb3JlIGVudGVyaW5nIHRoZSBjb21taXQgcGhhc2UuIFdlIGNhbiBiZVxuICAgIC8vIGNlcnRhaW4gdGhpcyB3b24ndCBjYXVzZSB0ZWFyaW5nIHJlbGF0ZWQgdG8gYmF0Y2hpbmcgb2YgZXZlbnQgdXBkYXRlc1xuICAgIC8vIGJlY2F1c2Ugd2UncmUgYXQgdGhlIHRvcCBvZiBhIHRpbWVyIGV2ZW50LlxuICAgIHJlY29tcHV0ZUN1cnJlbnRSZW5kZXJlclRpbWUoKTtcbiAgICBjdXJyZW50U2NoZWR1bGVyVGltZSA9IGN1cnJlbnRSZW5kZXJlclRpbWU7XG5cbiAgICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgICAgLy8gRG9uJ3QgdXBkYXRlIHBlbmRpbmcgaW50ZXJhY3Rpb24gY291bnRzIGZvciBzdXNwZW5zZSB0aW1lb3V0cyxcbiAgICAgIC8vIEJlY2F1c2Ugd2Uga25vdyB3ZSBzdGlsbCBuZWVkIHRvIGRvIG1vcmUgd29yayBpbiB0aGlzIGNhc2UuXG4gICAgICBzdXNwZW5zZURpZFRpbWVvdXQgPSB0cnVlO1xuICAgICAgZmx1c2hSb290KHJvb3QsIHN1c3BlbmRlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHN1c3BlbnNlRGlkVGltZW91dCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbHVzaFJvb3Qocm9vdCwgc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvbkNvbW1pdChyb290LCBleHBpcmF0aW9uVGltZSkge1xuICByb290LmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVxdWVzdEN1cnJlbnRUaW1lKCkge1xuICAvLyByZXF1ZXN0Q3VycmVudFRpbWUgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gY29tcHV0ZSBhbiBleHBpcmF0aW9uXG4gIC8vIHRpbWUuXG4gIC8vXG4gIC8vIEV4cGlyYXRpb24gdGltZXMgYXJlIGNvbXB1dGVkIGJ5IGFkZGluZyB0byB0aGUgY3VycmVudCB0aW1lICh0aGUgc3RhcnRcbiAgLy8gdGltZSkuIEhvd2V2ZXIsIGlmIHR3byB1cGRhdGVzIGFyZSBzY2hlZHVsZWQgd2l0aGluIHRoZSBzYW1lIGV2ZW50LCB3ZVxuICAvLyBzaG91bGQgdHJlYXQgdGhlaXIgc3RhcnQgdGltZXMgYXMgc2ltdWx0YW5lb3VzLCBldmVuIGlmIHRoZSBhY3R1YWwgY2xvY2tcbiAgLy8gdGltZSBoYXMgYWR2YW5jZWQgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIHNlY29uZCBjYWxsLlxuXG4gIC8vIEluIG90aGVyIHdvcmRzLCBiZWNhdXNlIGV4cGlyYXRpb24gdGltZXMgZGV0ZXJtaW5lIGhvdyB1cGRhdGVzIGFyZSBiYXRjaGVkLFxuICAvLyB3ZSB3YW50IGFsbCB1cGRhdGVzIG9mIGxpa2UgcHJpb3JpdHkgdGhhdCBvY2N1ciB3aXRoaW4gdGhlIHNhbWUgZXZlbnQgdG9cbiAgLy8gcmVjZWl2ZSB0aGUgc2FtZSBleHBpcmF0aW9uIHRpbWUuIE90aGVyd2lzZSB3ZSBnZXQgdGVhcmluZy5cbiAgLy9cbiAgLy8gV2Uga2VlcCB0cmFjayBvZiB0d28gc2VwYXJhdGUgdGltZXM6IHRoZSBjdXJyZW50IFwicmVuZGVyZXJcIiB0aW1lIGFuZCB0aGVcbiAgLy8gY3VycmVudCBcInNjaGVkdWxlclwiIHRpbWUuIFRoZSByZW5kZXJlciB0aW1lIGNhbiBiZSB1cGRhdGVkIHdoZW5ldmVyOyBpdFxuICAvLyBvbmx5IGV4aXN0cyB0byBtaW5pbWl6ZSB0aGUgY2FsbHMgcGVyZm9ybWFuY2Uubm93LlxuICAvL1xuICAvLyBCdXQgdGhlIHNjaGVkdWxlciB0aW1lIGNhbiBvbmx5IGJlIHVwZGF0ZWQgaWYgdGhlcmUncyBubyBwZW5kaW5nIHdvcmssIG9yXG4gIC8vIGlmIHdlIGtub3cgZm9yIGNlcnRhaW4gdGhhdCB3ZSdyZSBub3QgaW4gdGhlIG1pZGRsZSBvZiBhbiBldmVudC5cblxuICBpZiAoaXNSZW5kZXJpbmcpIHtcbiAgICAvLyBXZSdyZSBhbHJlYWR5IHJlbmRlcmluZy4gUmV0dXJuIHRoZSBtb3N0IHJlY2VudGx5IHJlYWQgdGltZS5cbiAgICByZXR1cm4gY3VycmVudFNjaGVkdWxlclRpbWU7XG4gIH1cbiAgLy8gQ2hlY2sgaWYgdGhlcmUncyBwZW5kaW5nIHdvcmsuXG4gIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCk7XG4gIGlmIChuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA9PT0gTmV2ZXIpIHtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIHBlbmRpbmcgd29yaywgb3IgaWYgdGhlIHBlbmRpbmcgd29yayBpcyBvZmZzY3JlZW4sIHdlIGNhblxuICAgIC8vIHJlYWQgdGhlIGN1cnJlbnQgdGltZSB3aXRob3V0IHJpc2sgb2YgdGVhcmluZy5cbiAgICByZWNvbXB1dGVDdXJyZW50UmVuZGVyZXJUaW1lKCk7XG4gICAgY3VycmVudFNjaGVkdWxlclRpbWUgPSBjdXJyZW50UmVuZGVyZXJUaW1lO1xuICAgIHJldHVybiBjdXJyZW50U2NoZWR1bGVyVGltZTtcbiAgfVxuICAvLyBUaGVyZSdzIGFscmVhZHkgcGVuZGluZyB3b3JrLiBXZSBtaWdodCBiZSBpbiB0aGUgbWlkZGxlIG9mIGEgYnJvd3NlclxuICAvLyBldmVudC4gSWYgd2Ugd2VyZSB0byByZWFkIHRoZSBjdXJyZW50IHRpbWUsIGl0IGNvdWxkIGNhdXNlIG11bHRpcGxlIHVwZGF0ZXNcbiAgLy8gd2l0aGluIHRoZSBzYW1lIGV2ZW50IHRvIHJlY2VpdmUgZGlmZmVyZW50IGV4cGlyYXRpb24gdGltZXMsIGxlYWRpbmcgdG9cbiAgLy8gdGVhcmluZy4gUmV0dXJuIHRoZSBsYXN0IHJlYWQgdGltZS4gRHVyaW5nIHRoZSBuZXh0IGlkbGUgY2FsbGJhY2ssIHRoZVxuICAvLyB0aW1lIHdpbGwgYmUgdXBkYXRlZC5cbiAgcmV0dXJuIGN1cnJlbnRTY2hlZHVsZXJUaW1lO1xufVxuXG4vLyByZXF1ZXN0V29yayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB3aGVuZXZlciBhIHJvb3QgcmVjZWl2ZXMgYW4gdXBkYXRlLlxuLy8gSXQncyB1cCB0byB0aGUgcmVuZGVyZXIgdG8gY2FsbCByZW5kZXJSb290IGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cbmZ1bmN0aW9uIHJlcXVlc3RXb3JrKHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gIGFkZFJvb3RUb1NjaGVkdWxlKHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgaWYgKGlzUmVuZGVyaW5nKSB7XG4gICAgLy8gUHJldmVudCByZWVudHJhbmN5LiBSZW1haW5pbmcgd29yayB3aWxsIGJlIHNjaGVkdWxlZCBhdCB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIGN1cnJlbnRseSByZW5kZXJpbmcgYmF0Y2guXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlzQmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgLy8gRmx1c2ggd29yayBhdCB0aGUgZW5kIG9mIHRoZSBiYXRjaC5cbiAgICBpZiAoaXNVbmJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgLy8gLi4udW5sZXNzIHdlJ3JlIGluc2lkZSB1bmJhdGNoZWRVcGRhdGVzLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZFxuICAgICAgLy8gZmx1c2ggaXQgbm93LlxuICAgICAgbmV4dEZsdXNoZWRSb290ID0gcm9vdDtcbiAgICAgIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgU3luYywgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IEdldCByaWQgb2YgU3luYyBhbmQgdXNlIGN1cnJlbnQgdGltZT9cbiAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBTeW5jKSB7XG4gICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gIH0gZWxzZSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uVGltZShyb290LCBleHBpcmF0aW9uVGltZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkUm9vdFRvU2NoZWR1bGUocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgLy8gQWRkIHRoZSByb290IHRvIHRoZSBzY2hlZHVsZS5cbiAgLy8gQ2hlY2sgaWYgdGhpcyByb290IGlzIGFscmVhZHkgcGFydCBvZiB0aGUgc2NoZWR1bGUuXG4gIGlmIChyb290Lm5leHRTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyByb290IGlzIG5vdCBhbHJlYWR5IHNjaGVkdWxlZC4gQWRkIGl0LlxuICAgIHJvb3QuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgPT09IG51bGwpIHtcbiAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICBsYXN0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgc2NoZWR1bGVkLCBidXQgaXRzIHByaW9yaXR5IG1heSBoYXZlIGluY3JlYXNlZC5cbiAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByb290LmV4cGlyYXRpb25UaW1lO1xuICAgIGlmIChyZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IGV4cGlyYXRpb25UaW1lIDwgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcHJpb3JpdHkuXG4gICAgICByb290LmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCkge1xuICB2YXIgaGlnaGVzdFByaW9yaXR5V29yayA9IE5vV29yaztcbiAgdmFyIGhpZ2hlc3RQcmlvcml0eVJvb3QgPSBudWxsO1xuICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpIHtcbiAgICB2YXIgcHJldmlvdXNTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3Q7XG4gICAgdmFyIHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgd2hpbGUgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHJvb3QuZXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPT09IE5vV29yaykge1xuICAgICAgICAvLyBUaGlzIHJvb3Qgbm8gbG9uZ2VyIGhhcyB3b3JrLiBSZW1vdmUgaXQgZnJvbSB0aGUgc2NoZWR1bGVyLlxuXG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2hlY2sgaXMgcmVkdWRhbnQsIGJ1dCBGbG93IGlzIGNvbmZ1c2VkIGJ5IHRoZSBicmFuY2hcbiAgICAgICAgLy8gYmVsb3cgd2hlcmUgd2Ugc2V0IGxhc3RTY2hlZHVsZWRSb290IHRvIG51bGwsIGV2ZW4gdGhvdWdoIHdlIGJyZWFrXG4gICAgICAgIC8vIGZyb20gdGhlIGxvb3AgcmlnaHQgYWZ0ZXIuXG4gICAgICAgICEocHJldmlvdXNTY2hlZHVsZWRSb290ICE9PSBudWxsICYmIGxhc3RTY2hlZHVsZWRSb290ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIGEgcHJldmlvdXMgYW5kIGxhc3Qgcm9vdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKHJvb3QgPT09IHJvb3QubmV4dFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHJvb3QgPT09IGZpcnN0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgdmFyIG5leHQgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG5leHQ7XG4gICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBuZXh0O1xuICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgbGFzdCByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcHJldmlvdXNTY2hlZHVsZWRSb290O1xuICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzU2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdCA9IHByZXZpb3VzU2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChoaWdoZXN0UHJpb3JpdHlXb3JrID09PSBOb1dvcmsgfHwgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPCBoaWdoZXN0UHJpb3JpdHlXb3JrKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcmlvcml0eSwgaWYgaXQncyBoaWdoZXJcbiAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlXb3JrID0gcmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgaGlnaGVzdFByaW9yaXR5Um9vdCA9IHJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhpZ2hlc3RQcmlvcml0eVdvcmsgPT09IFN5bmMpIHtcbiAgICAgICAgICAvLyBTeW5jIGlzIGhpZ2hlc3QgcHJpb3JpdHkgYnkgZGVmaW5pdGlvbiBzb1xuICAgICAgICAgIC8vIHdlIGNhbiBzdG9wIHNlYXJjaGluZy5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICByb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZXh0Rmx1c2hlZFJvb3QgPSBoaWdoZXN0UHJpb3JpdHlSb290O1xuICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gaGlnaGVzdFByaW9yaXR5V29yaztcbn1cblxuZnVuY3Rpb24gcGVyZm9ybUFzeW5jV29yayhkbCkge1xuICBpZiAoZGwuZGlkVGltZW91dCkge1xuICAgIC8vIFRoZSBjYWxsYmFjayB0aW1lZCBvdXQuIFRoYXQgbWVhbnMgYXQgbGVhc3Qgb25lIHVwZGF0ZSBoYXMgZXhwaXJlZC5cbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHJvb3Qgc2NoZWR1bGUuIElmIHRoZXkgY29udGFpbiBleHBpcmVkIHdvcmssIHNldFxuICAgIC8vIHRoZSBuZXh0IHJlbmRlciBleHBpcmF0aW9uIHRpbWUgdG8gdGhlIGN1cnJlbnQgdGltZS4gVGhpcyBoYXMgdGhlIGVmZmVjdFxuICAgIC8vIG9mIGZsdXNoaW5nIGFsbCBleHBpcmVkIHdvcmsgaW4gYSBzaW5nbGUgYmF0Y2gsIGluc3RlYWQgb2YgZmx1c2hpbmcgZWFjaFxuICAgIC8vIGxldmVsIG9uZSBhdCBhIHRpbWUuXG4gICAgaWYgKGZpcnN0U2NoZWR1bGVkUm9vdCAhPT0gbnVsbCkge1xuICAgICAgcmVjb21wdXRlQ3VycmVudFJlbmRlcmVyVGltZSgpO1xuICAgICAgdmFyIHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICBkbyB7XG4gICAgICAgIGRpZEV4cGlyZUF0RXhwaXJhdGlvblRpbWUocm9vdCwgY3VycmVudFJlbmRlcmVyVGltZSk7XG4gICAgICAgIC8vIFRoZSByb290IHNjaGVkdWxlIGlzIGNpcmN1bGFyLCBzbyB0aGlzIGlzIG5ldmVyIG51bGwuXG4gICAgICAgIHJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgfSB3aGlsZSAocm9vdCAhPT0gZmlyc3RTY2hlZHVsZWRSb290KTtcbiAgICB9XG4gIH1cbiAgcGVyZm9ybVdvcmsoTm9Xb3JrLCBkbCk7XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1TeW5jV29yaygpIHtcbiAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Xb3JrKG1pbkV4cGlyYXRpb25UaW1lLCBkbCkge1xuICBkZWFkbGluZSA9IGRsO1xuXG4gIC8vIEtlZXAgd29ya2luZyBvbiByb290cyB1bnRpbCB0aGVyZSdzIG5vIG1vcmUgd29yaywgb3IgdW50aWwgd2UgcmVhY2hcbiAgLy8gdGhlIGRlYWRsaW5lLlxuICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuXG4gIGlmIChkZWFkbGluZSAhPT0gbnVsbCkge1xuICAgIHJlY29tcHV0ZUN1cnJlbnRSZW5kZXJlclRpbWUoKTtcbiAgICBjdXJyZW50U2NoZWR1bGVyVGltZSA9IGN1cnJlbnRSZW5kZXJlclRpbWU7XG5cbiAgICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgICAgdmFyIGRpZEV4cGlyZSA9IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPCBjdXJyZW50UmVuZGVyZXJUaW1lO1xuICAgICAgdmFyIHRpbWVvdXQgPSBleHBpcmF0aW9uVGltZVRvTXMobmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICBzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIoZGlkRXhwaXJlLCB0aW1lb3V0KTtcbiAgICB9XG5cbiAgICB3aGlsZSAobmV4dEZsdXNoZWRSb290ICE9PSBudWxsICYmIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJiAobWluRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBtaW5FeHBpcmF0aW9uVGltZSA+PSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKSAmJiAoIWRlYWRsaW5lRGlkRXhwaXJlIHx8IGN1cnJlbnRSZW5kZXJlclRpbWUgPj0gbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSkpIHtcbiAgICAgIHBlcmZvcm1Xb3JrT25Sb290KG5leHRGbHVzaGVkUm9vdCwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSwgY3VycmVudFJlbmRlcmVyVGltZSA+PSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCk7XG4gICAgICByZWNvbXB1dGVDdXJyZW50UmVuZGVyZXJUaW1lKCk7XG4gICAgICBjdXJyZW50U2NoZWR1bGVyVGltZSA9IGN1cnJlbnRSZW5kZXJlclRpbWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwgJiYgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIChtaW5FeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG1pbkV4cGlyYXRpb25UaW1lID49IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChuZXh0Rmx1c2hlZFJvb3QsIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUsIHRydWUpO1xuICAgICAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcbiAgICB9XG4gIH1cblxuICAvLyBXZSdyZSBkb25lIGZsdXNoaW5nIHdvcmsuIEVpdGhlciB3ZSByYW4gb3V0IG9mIHRpbWUgaW4gdGhpcyBjYWxsYmFjayxcbiAgLy8gb3IgdGhlcmUncyBubyBtb3JlIHdvcmsgbGVmdCB3aXRoIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG5cbiAgLy8gSWYgd2UncmUgaW5zaWRlIGEgY2FsbGJhY2ssIHNldCB0aGlzIHRvIGZhbHNlIHNpbmNlIHdlIGp1c3QgY29tcGxldGVkIGl0LlxuICBpZiAoZGVhZGxpbmUgIT09IG51bGwpIHtcbiAgICBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgIGNhbGxiYWNrSUQgPSBudWxsO1xuICB9XG4gIC8vIElmIHRoZXJlJ3Mgd29yayBsZWZ0IG92ZXIsIHNjaGVkdWxlIGEgbmV3IGNhbGxiYWNrLlxuICBpZiAobmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uVGltZShuZXh0Rmx1c2hlZFJvb3QsIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgLy8gQ2xlYW4tdXAuXG4gIGRlYWRsaW5lID0gbnVsbDtcbiAgZGVhZGxpbmVEaWRFeHBpcmUgPSBmYWxzZTtcblxuICBmaW5pc2hSZW5kZXJpbmcoKTtcbn1cblxuZnVuY3Rpb24gZmx1c2hSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gICEhaXNSZW5kZXJpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICd3b3JrLmNvbW1pdCgpOiBDYW5ub3QgY29tbWl0IHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLiBUaGlzIGxpa2VseSBtZWFucyB5b3UgYXR0ZW1wdGVkIHRvIGNvbW1pdCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuJykgOiB2b2lkIDA7XG4gIC8vIFBlcmZvcm0gd29yayBvbiByb290IGFzIGlmIHRoZSBnaXZlbiBleHBpcmF0aW9uIHRpbWUgaXMgdGhlIGN1cnJlbnQgdGltZS5cbiAgLy8gVGhpcyBoYXMgdGhlIGVmZmVjdCBvZiBzeW5jaHJvbm91c2x5IGZsdXNoaW5nIGFsbCB3b3JrIHVwIHRvIGFuZFxuICAvLyBpbmNsdWRpbmcgdGhlIGdpdmVuIHRpbWUuXG4gIG5leHRGbHVzaGVkUm9vdCA9IHJvb3Q7XG4gIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUsIHRydWUpO1xuICAvLyBGbHVzaCBhbnkgc3luYyB3b3JrIHRoYXQgd2FzIHNjaGVkdWxlZCBieSBsaWZlY3ljbGVzXG4gIHBlcmZvcm1TeW5jV29yaygpO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hSZW5kZXJpbmcoKSB7XG4gIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgbGFzdENvbW1pdHRlZFJvb3REdXJpbmdUaGlzQmF0Y2ggPSBudWxsO1xuXG4gIGlmIChjb21wbGV0ZWRCYXRjaGVzICE9PSBudWxsKSB7XG4gICAgdmFyIGJhdGNoZXMgPSBjb21wbGV0ZWRCYXRjaGVzO1xuICAgIGNvbXBsZXRlZEJhdGNoZXMgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJhdGNoID0gYmF0Y2hlc1tpXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGJhdGNoLl9vbkNvbXBsZXRlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICAgICAgaGFzVW5oYW5kbGVkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIHVuaGFuZGxlZEVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaGFzVW5oYW5kbGVkRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSB1bmhhbmRsZWRFcnJvcjtcbiAgICB1bmhhbmRsZWRFcnJvciA9IG51bGw7XG4gICAgaGFzVW5oYW5kbGVkRXJyb3IgPSBmYWxzZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwZXJmb3JtV29ya09uUm9vdChyb290LCBleHBpcmF0aW9uVGltZSwgaXNFeHBpcmVkKSB7XG4gICEhaXNSZW5kZXJpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICdwZXJmb3JtV29ya09uUm9vdCB3YXMgY2FsbGVkIHJlY3Vyc2l2ZWx5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIGlzUmVuZGVyaW5nID0gdHJ1ZTtcblxuICAvLyBDaGVjayBpZiB0aGlzIGlzIGFzeW5jIHdvcmsgb3Igc3luYy9leHBpcmVkIHdvcmsuXG4gIGlmIChkZWFkbGluZSA9PT0gbnVsbCB8fCBpc0V4cGlyZWQpIHtcbiAgICAvLyBGbHVzaCB3b3JrIHdpdGhvdXQgeWllbGRpbmcuXG4gICAgLy8gVE9ETzogTm9uLXlpZWxkeSB3b3JrIGRvZXMgbm90IG5lY2Vzc2FyaWx5IGltcGx5IGV4cGlyZWQgd29yay4gQSByZW5kZXJlclxuICAgIC8vIG1heSB3YW50IHRvIHBlcmZvcm0gc29tZSB3b3JrIHdpdGhvdXQgeWllbGRpbmcsIGJ1dCBhbHNvIHdpdGhvdXRcbiAgICAvLyByZXF1aXJpbmcgdGhlIHJvb3QgdG8gY29tcGxldGUgKGJ5IHRyaWdnZXJpbmcgcGxhY2Vob2xkZXJzKS5cblxuICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICBpZiAoZmluaXNoZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBjb21wbGV0ZS4gV2UgY2FuIGNvbW1pdCBpdC5cbiAgICAgIGNvbXBsZXRlUm9vdChyb290LCBmaW5pc2hlZFdvcmssIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgLy8gSWYgdGhpcyByb290IHByZXZpb3VzbHkgc3VzcGVuZGVkLCBjbGVhciBpdHMgZXhpc3RpbmcgdGltZW91dCwgc2luY2VcbiAgICAgIC8vIHdlJ3JlIGFib3V0IHRvIHRyeSByZW5kZXJpbmcgYWdhaW4uXG4gICAgICB2YXIgdGltZW91dEhhbmRsZSA9IHJvb3QudGltZW91dEhhbmRsZTtcbiAgICAgIGlmIChlbmFibGVTdXNwZW5zZSAmJiB0aW1lb3V0SGFuZGxlICE9PSBub1RpbWVvdXQpIHtcbiAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIENvbXBsYWlucyBub1RpbWVvdXQgaXMgbm90IGEgVGltZW91dElELCBkZXNwaXRlIHRoZSBjaGVjayBhYm92ZVxuICAgICAgICBjYW5jZWxUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICAgICAgfVxuICAgICAgdmFyIGlzWWllbGR5ID0gZmFsc2U7XG4gICAgICByZW5kZXJSb290KHJvb3QsIGlzWWllbGR5LCBpc0V4cGlyZWQpO1xuICAgICAgZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG4gICAgICBpZiAoZmluaXNoZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGNvbXBsZXRlZCB0aGUgcm9vdC4gQ29tbWl0IGl0LlxuICAgICAgICBjb21wbGV0ZVJvb3Qocm9vdCwgZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEZsdXNoIGFzeW5jIHdvcmsuXG4gICAgdmFyIF9maW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICBpZiAoX2ZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICBjb21wbGV0ZVJvb3Qocm9vdCwgX2ZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICAvLyBJZiB0aGlzIHJvb3QgcHJldmlvdXNseSBzdXNwZW5kZWQsIGNsZWFyIGl0cyBleGlzdGluZyB0aW1lb3V0LCBzaW5jZVxuICAgICAgLy8gd2UncmUgYWJvdXQgdG8gdHJ5IHJlbmRlcmluZyBhZ2Fpbi5cbiAgICAgIHZhciBfdGltZW91dEhhbmRsZSA9IHJvb3QudGltZW91dEhhbmRsZTtcbiAgICAgIGlmIChlbmFibGVTdXNwZW5zZSAmJiBfdGltZW91dEhhbmRsZSAhPT0gbm9UaW1lb3V0KSB7XG4gICAgICAgIHJvb3QudGltZW91dEhhbmRsZSA9IG5vVGltZW91dDtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSBDb21wbGFpbnMgbm9UaW1lb3V0IGlzIG5vdCBhIFRpbWVvdXRJRCwgZGVzcGl0ZSB0aGUgY2hlY2sgYWJvdmVcbiAgICAgICAgY2FuY2VsVGltZW91dChfdGltZW91dEhhbmRsZSk7XG4gICAgICB9XG4gICAgICB2YXIgX2lzWWllbGR5ID0gdHJ1ZTtcbiAgICAgIHJlbmRlclJvb3Qocm9vdCwgX2lzWWllbGR5LCBpc0V4cGlyZWQpO1xuICAgICAgX2ZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UndmUgY29tcGxldGVkIHRoZSByb290LiBDaGVjayB0aGUgZGVhZGxpbmUgb25lIG1vcmUgdGltZVxuICAgICAgICAvLyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgaWYgKCFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgICAgLy8gU3RpbGwgdGltZSBsZWZ0LiBDb21taXQgdGhlIHJvb3QuXG4gICAgICAgICAgY29tcGxldGVSb290KHJvb3QsIF9maW5pc2hlZFdvcmssIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVyZSdzIG5vIHRpbWUgbGVmdC4gTWFyayB0aGlzIHJvb3QgYXMgY29tcGxldGUuIFdlJ2xsIGNvbWVcbiAgICAgICAgICAvLyBiYWNrIGFuZCBjb21taXQgaXQgbGF0ZXIuXG4gICAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBfZmluaXNoZWRXb3JrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29tcGxldGVSb290KHJvb3QsIGZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpIHtcbiAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhIGJhdGNoIHRoYXQgbWF0Y2hlcyB0aGlzIGV4cGlyYXRpb24gdGltZS5cbiAgdmFyIGZpcnN0QmF0Y2ggPSByb290LmZpcnN0QmF0Y2g7XG4gIGlmIChmaXJzdEJhdGNoICE9PSBudWxsICYmIGZpcnN0QmF0Y2guX2V4cGlyYXRpb25UaW1lIDw9IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGNvbXBsZXRlZEJhdGNoZXMgPT09IG51bGwpIHtcbiAgICAgIGNvbXBsZXRlZEJhdGNoZXMgPSBbZmlyc3RCYXRjaF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBsZXRlZEJhdGNoZXMucHVzaChmaXJzdEJhdGNoKTtcbiAgICB9XG4gICAgaWYgKGZpcnN0QmF0Y2guX2RlZmVyKSB7XG4gICAgICAvLyBUaGlzIHJvb3QgaXMgYmxvY2tlZCBmcm9tIGNvbW1pdHRpbmcgYnkgYSBiYXRjaC4gVW5zY2hlZHVsZSBpdCB1bnRpbFxuICAgICAgLy8gd2UgcmVjZWl2ZSBhbm90aGVyIHVwZGF0ZS5cbiAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrO1xuICAgICAgcm9vdC5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvLyBDb21taXQgdGhlIHJvb3QuXG4gIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcblxuICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgbmVzdGVkIHVwZGF0ZSAoYSBzeW5jIHVwZGF0ZSBzY2hlZHVsZWQgZHVyaW5nIHRoZVxuICAvLyBjb21taXQgcGhhc2UpLlxuICBpZiAocm9vdCA9PT0gbGFzdENvbW1pdHRlZFJvb3REdXJpbmdUaGlzQmF0Y2gpIHtcbiAgICAvLyBJZiB0aGUgbmV4dCByb290IGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyByb290LCB0aGlzIGlzIGEgbmVzdGVkXG4gICAgLy8gdXBkYXRlLiBUbyBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AsIGluY3JlbWVudCB0aGUgbmVzdGVkIHVwZGF0ZSBjb3VudC5cbiAgICBuZXN0ZWRVcGRhdGVDb3VudCsrO1xuICB9IGVsc2Uge1xuICAgIC8vIFJlc2V0IHdoZW5ldmVyIHdlIHN3aXRjaCByb290cy5cbiAgICBsYXN0Q29tbWl0dGVkUm9vdER1cmluZ1RoaXNCYXRjaCA9IHJvb3Q7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICB9XG4gIGNvbW1pdFJvb3Qocm9vdCwgZmluaXNoZWRXb3JrKTtcbn1cblxuLy8gV2hlbiB3b3JraW5nIG9uIGFzeW5jIHdvcmssIHRoZSByZWNvbmNpbGVyIGFza3MgdGhlIHJlbmRlcmVyIGlmIGl0IHNob3VsZFxuLy8geWllbGQgZXhlY3V0aW9uLiBGb3IgRE9NLCB3ZSBpbXBsZW1lbnQgdGhpcyB3aXRoIHJlcXVlc3RJZGxlQ2FsbGJhY2suXG5mdW5jdGlvbiBzaG91bGRZaWVsZCgpIHtcbiAgaWYgKGRlYWRsaW5lRGlkRXhwaXJlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGRlYWRsaW5lID09PSBudWxsIHx8IGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSA+IHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrKSB7XG4gICAgLy8gRGlzcmVnYXJkIGRlYWRsaW5lLmRpZFRpbWVvdXQuIE9ubHkgZXhwaXJlZCB3b3JrIHNob3VsZCBiZSBmbHVzaGVkXG4gICAgLy8gZHVyaW5nIGEgdGltZW91dC4gVGhpcyBwYXRoIGlzIG9ubHkgaGl0IGZvciBub24tZXhwaXJlZCB3b3JrLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZWFkbGluZURpZEV4cGlyZSA9IHRydWU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvblVuY2F1Z2h0RXJyb3IoZXJyb3IpIHtcbiAgIShuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGJlIHdvcmtpbmcgb24gYSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAvLyBVbnNjaGVkdWxlIHRoaXMgcm9vdCBzbyB3ZSBkb24ndCB3b3JrIG9uIGl0IGFnYWluIHVudGlsIHRoZXJlJ3NcbiAgLy8gYW5vdGhlciB1cGRhdGUuXG4gIG5leHRGbHVzaGVkUm9vdC5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgaWYgKCFoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgIGhhc1VuaGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICB9XG59XG5cbi8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCBpbnNpZGVcbi8vIHRoZSByZWNvbmNpbGVyLlxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMkMShmbiwgYSkge1xuICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKGEpO1xuICB9IGZpbmFsbHkge1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpZiAoIWlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1JlbmRlcmluZykge1xuICAgICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCBpbnNpZGVcbi8vIHRoZSByZWNvbmNpbGVyLlxuZnVuY3Rpb24gdW5iYXRjaGVkVXBkYXRlcyhmbiwgYSkge1xuICBpZiAoaXNCYXRjaGluZ1VwZGF0ZXMgJiYgIWlzVW5iYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBmbihhKTtcbn1cblxuLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IHdpdGhpblxuLy8gdGhlIHJlY29uY2lsZXIuXG5mdW5jdGlvbiBmbHVzaFN5bmMoZm4sIGEpIHtcbiAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ2ZsdXNoU3luYyB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgbGlmZWN5Y2xlIG1ldGhvZC4gSXQgY2Fubm90IGJlIGNhbGxlZCB3aGVuIFJlYWN0IGlzIGFscmVhZHkgcmVuZGVyaW5nLicpIDogdm9pZCAwO1xuICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHN5bmNVcGRhdGVzKGZuLCBhKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJhY3RpdmVVcGRhdGVzJDEoZm4sIGEsIGIpIHtcbiAgaWYgKGlzQmF0Y2hpbmdJbnRlcmFjdGl2ZVVwZGF0ZXMpIHtcbiAgICByZXR1cm4gZm4oYSwgYik7XG4gIH1cbiAgLy8gSWYgdGhlcmUgYXJlIGFueSBwZW5kaW5nIGludGVyYWN0aXZlIHVwZGF0ZXMsIHN5bmNocm9ub3VzbHkgZmx1c2ggdGhlbS5cbiAgLy8gVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHdlIHJlYWQgYW55IGhhbmRsZXJzLCBiZWNhdXNlIHRoZSBlZmZlY3Qgb2ZcbiAgLy8gdGhlIHByZXZpb3VzIGV2ZW50IG1heSBpbmZsdWVuY2Ugd2hpY2ggaGFuZGxlcnMgYXJlIGNhbGxlZCBkdXJpbmdcbiAgLy8gdGhpcyBldmVudC5cbiAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcgJiYgbG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgLy8gU3luY2hyb25vdXNseSBmbHVzaCBwZW5kaW5nIGludGVyYWN0aXZlIHVwZGF0ZXMuXG4gICAgcGVyZm9ybVdvcmsobG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSwgbnVsbCk7XG4gICAgbG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgfVxuICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nSW50ZXJhY3RpdmVVcGRhdGVzID0gaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcztcbiAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcyA9IHRydWU7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oYSwgYik7XG4gIH0gZmluYWxseSB7XG4gICAgaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgIHBlcmZvcm1TeW5jV29yaygpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaEludGVyYWN0aXZlVXBkYXRlcyQxKCkge1xuICBpZiAoIWlzUmVuZGVyaW5nICYmIGxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykge1xuICAgIC8vIFN5bmNocm9ub3VzbHkgZmx1c2ggcGVuZGluZyBpbnRlcmFjdGl2ZSB1cGRhdGVzLlxuICAgIHBlcmZvcm1Xb3JrKGxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgIGxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hDb250cm9sbGVkKGZuKSB7XG4gIHZhciBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzID0gaXNCYXRjaGluZ1VwZGF0ZXM7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBzeW5jVXBkYXRlcyhmbik7XG4gIH0gZmluYWxseSB7XG4gICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlmICghaXNCYXRjaGluZ1VwZGF0ZXMgJiYgIWlzUmVuZGVyaW5nKSB7XG4gICAgICBwZXJmb3JtU3luY1dvcmsoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gMCBpcyBQUk9ELCAxIGlzIERFVi5cbi8vIE1pZ2h0IGFkZCBQUk9GSUxFIGxhdGVyLlxuXG5cbnZhciBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gdm9pZCAwO1xuXG57XG4gIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KSB7XG4gIGlmICghcGFyZW50Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChwYXJlbnRDb21wb25lbnQpO1xuICB2YXIgcGFyZW50Q29udGV4dCA9IGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKTtcblxuICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgIHZhciBDb21wb25lbnQgPSBmaWJlci50eXBlO1xuICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgQ29tcG9uZW50LCBwYXJlbnRDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudExhenkpIHtcbiAgICB2YXIgX0NvbXBvbmVudCA9IGdldFJlc3VsdEZyb21SZXNvbHZlZFRoZW5hYmxlKGZpYmVyLnR5cGUpO1xuICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihfQ29tcG9uZW50KSkge1xuICAgICAgcmV0dXJuIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIF9Db21wb25lbnQsIHBhcmVudENvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJlbnRDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVJvb3RVcGRhdGUoY3VycmVudCQkMSwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUsIGNhbGxiYWNrKSB7XG4gIHtcbiAgICBpZiAocGhhc2UgPT09ICdyZW5kZXInICYmIGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMpIHtcbiAgICAgIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB0cnVlO1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7ICcgKyAndHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuICcgKyAnSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG4nICsgJ0NoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIGdldENvbXBvbmVudE5hbWUoY3VycmVudC50eXBlKSB8fCAnVW5rbm93bicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXhwaXJhdGlvblRpbWUpO1xuICAvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4gIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cbiAgdXBkYXRlLnBheWxvYWQgPSB7IGVsZW1lbnQ6IGVsZW1lbnQgfTtcblxuICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICEodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spIDogdm9pZCAwO1xuICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIGVucXVldWVVcGRhdGUoY3VycmVudCQkMSwgdXBkYXRlKTtcblxuICBzY2hlZHVsZVdvcmsoY3VycmVudCQkMSwgZXhwaXJhdGlvblRpbWUpO1xuICByZXR1cm4gZXhwaXJhdGlvblRpbWU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lckF0RXhwaXJhdGlvblRpbWUoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGV4cGlyYXRpb25UaW1lLCBjYWxsYmFjaykge1xuICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgbmVzdGVkIGNvbnRhaW5lciwgdGhpcyB3b24ndCBiZSB0aGUgcm9vdC5cbiAgdmFyIGN1cnJlbnQkJDEgPSBjb250YWluZXIuY3VycmVudDtcblxuICB7XG4gICAgaWYgKFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgIGlmIChjdXJyZW50JCQxLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uTW91bnRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uVW5tb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVwZGF0ZUNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0ID0gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KTtcbiAgaWYgKGNvbnRhaW5lci5jb250ZXh0ID09PSBudWxsKSB7XG4gICAgY29udGFpbmVyLmNvbnRleHQgPSBjb250ZXh0O1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5wZW5kaW5nQ29udGV4dCA9IGNvbnRleHQ7XG4gIH1cblxuICByZXR1cm4gc2NoZWR1bGVSb290VXBkYXRlKGN1cnJlbnQkJDEsIGVsZW1lbnQsIGV4cGlyYXRpb25UaW1lLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2UoY29tcG9uZW50KSB7XG4gIHZhciBmaWJlciA9IGdldChjb21wb25lbnQpO1xuICBpZiAoZmliZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgY29tcG9uZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiAlcycsIE9iamVjdC5rZXlzKGNvbXBvbmVudCkpO1xuICAgIH1cbiAgfVxuICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lcihjb250YWluZXJJbmZvLCBpc0FzeW5jLCBoeWRyYXRlKSB7XG4gIHJldHVybiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgaXNBc3luYywgaHlkcmF0ZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lcihlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spIHtcbiAgdmFyIGN1cnJlbnQkJDEgPSBjb250YWluZXIuY3VycmVudDtcbiAgdmFyIGN1cnJlbnRUaW1lID0gcmVxdWVzdEN1cnJlbnRUaW1lKCk7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudFRpbWUsIGN1cnJlbnQkJDEpO1xuICByZXR1cm4gdXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZShlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgZXhwaXJhdGlvblRpbWUsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZ2V0UHVibGljUm9vdEluc3RhbmNlKGNvbnRhaW5lcikge1xuICB2YXIgY29udGFpbmVyRmliZXIgPSBjb250YWluZXIuY3VycmVudDtcbiAgaWYgKCFjb250YWluZXJGaWJlci5jaGlsZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN3aXRjaCAoY29udGFpbmVyRmliZXIuY2hpbGQudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMoZmliZXIpIHtcbiAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhmaWJlcik7XG4gIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50b0RldlRvb2xzKGRldlRvb2xzQ29uZmlnKSB7XG4gIHZhciBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSA9IGRldlRvb2xzQ29uZmlnLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO1xuXG4gIHJldHVybiBpbmplY3RJbnRlcm5hbHMoX2Fzc2lnbih7fSwgZGV2VG9vbHNDb25maWcsIHtcbiAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuICAgICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICAgIH0sXG4gICAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgaWYgKCFmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSkge1xuICAgICAgICAvLyBNaWdodCBub3QgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIHJlbmRlcmVyLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgfVxuICB9KSk7XG59XG5cbi8vIFRoaXMgZmlsZSBpbnRlbnRpb25hbGx5IGRvZXMgKm5vdCogaGF2ZSB0aGUgRmxvdyBhbm5vdGF0aW9uLlxuLy8gRG9uJ3QgYWRkIGl0LiBTZWUgYC4vaW5saW5lLXR5cGVkLmpzYCBmb3IgYW4gZXhwbGFuYXRpb24uXG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXJJbmZvLFxuLy8gVE9ETzogZmlndXJlIG91dCB0aGUgQVBJIGZvciBjcm9zcy1yZW5kZXJlciBpbXBsZW1lbnRhdGlvbi5cbmltcGxlbWVudGF0aW9uKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgUG9ydGFsXG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BPUlRBTF9UWVBFLFxuICAgIGtleToga2V5ID09IG51bGwgPyBudWxsIDogJycgKyBrZXksXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgaW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uXG4gIH07XG59XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE2LjUuMic7XG5cbi8vIFRPRE86IFRoaXMgdHlwZSBpcyBzaGFyZWQgYmV0d2VlbiB0aGUgcmVjb25jaWxlciBhbmQgUmVhY3RET00sIGJ1dCB3aWxsXG4vLyBldmVudHVhbGx5IGJlIGxpZnRlZCBvdXQgdG8gdGhlIHJlbmRlcmVyLlxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG5cbnZhciB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzID0gdm9pZCAwO1xudmFyIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRVbnN0YWJsZUNyZWF0ZVBvcnRhbCA9IGZhbHNlO1xuXG57XG4gIGlmICh0eXBlb2YgTWFwICE9PSAnZnVuY3Rpb24nIHx8XG4gIC8vICRGbG93SXNzdWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgTWFwIGhhcyBubyBwcm90b3R5cGVcbiAgTWFwLnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBNYXAucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAvLyAkRmxvd0lzc3VlIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFNldCBoYXMgbm8gcHJvdG90eXBlXG4gIFNldC5wcm90b3R5cGUgPT0gbnVsbCB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5jbGVhciAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnUmVhY3QgZGVwZW5kcyBvbiBNYXAgYW5kIFNldCBidWlsdC1pbiB0eXBlcy4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycpO1xuICB9XG5cbiAgdG9wTGV2ZWxVcGRhdGVXYXJuaW5ncyA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgJiYgY29udGFpbmVyLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lci5faW50ZXJuYWxSb290LmN1cnJlbnQpO1xuICAgICAgaWYgKGhvc3RJbnN0YW5jZSkge1xuICAgICAgICAhKGhvc3RJbnN0YW5jZS5wYXJlbnROb2RlID09PSBjb250YWluZXIpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhpcyAnICsgJ2NvbnRhaW5lciB3YXMgcmVtb3ZlZCB3aXRob3V0IHVzaW5nIFJlYWN0LiBUaGlzIGlzIG5vdCAnICsgJ3N1cHBvcnRlZCBhbmQgd2lsbCBjYXVzZSBlcnJvcnMuIEluc3RlYWQsIGNhbGwgJyArICdSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlIHRvIGVtcHR5IGEgY29udGFpbmVyLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0ID0gISFjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEocm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUkMShyb290RWwpKTtcblxuICAgICEoIWhhc05vblJvb3RSZWFjdENoaWxkIHx8IGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKSA6IHZvaWQgMDtcblxuICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgfHwgIWNvbnRhaW5lci50YWdOYW1lIHx8IGNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdCT0RZJykgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpIDogdm9pZCAwO1xuICB9O1xuXG4gIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgICEoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsZXJOYW1lLCBjYWxsYmFjaykgOiB2b2lkIDA7XG4gIH07XG59XG5cbnNldFJlc3RvcmVJbXBsZW1lbnRhdGlvbihyZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5cbmZ1bmN0aW9uIFJlYWN0QmF0Y2gocm9vdCkge1xuICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uKCk7XG4gIHRoaXMuX2V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHRoaXMuX3Jvb3QgPSByb290O1xuICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgdGhpcy5fZGlkQ29tcGxldGUgPSBmYWxzZTtcbiAgdGhpcy5faGFzQ2hpbGRyZW4gPSBmYWxzZTtcbiAgdGhpcy5fY2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLl9kZWZlciA9IHRydWU7XG59XG5SZWFjdEJhdGNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgIXRoaXMuX2RlZmVyID8gaW52YXJpYW50KGZhbHNlLCAnYmF0Y2gucmVuZGVyOiBDYW5ub3QgcmVuZGVyIGEgYmF0Y2ggdGhhdCBhbHJlYWR5IGNvbW1pdHRlZC4nKSA6IHZvaWQgMDtcbiAgdGhpcy5faGFzQ2hpbGRyZW4gPSB0cnVlO1xuICB0aGlzLl9jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB2YXIgaW50ZXJuYWxSb290ID0gdGhpcy5fcm9vdC5faW50ZXJuYWxSb290O1xuICB2YXIgZXhwaXJhdGlvblRpbWUgPSB0aGlzLl9leHBpcmF0aW9uVGltZTtcbiAgdmFyIHdvcmsgPSBuZXcgUmVhY3RXb3JrKCk7XG4gIHVwZGF0ZUNvbnRhaW5lckF0RXhwaXJhdGlvblRpbWUoY2hpbGRyZW4sIGludGVybmFsUm9vdCwgbnVsbCwgZXhwaXJhdGlvblRpbWUsIHdvcmsuX29uQ29tbWl0KTtcbiAgcmV0dXJuIHdvcms7XG59O1xuUmVhY3RCYXRjaC5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkNvbXBsZXRlKSB7XG4gIGlmICh0aGlzLl9kaWRDb21wbGV0ZSkge1xuICAgIG9uQ29tcGxldGUoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgaWYgKGNhbGxiYWNrcyA9PT0gbnVsbCkge1xuICAgIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICB9XG4gIGNhbGxiYWNrcy5wdXNoKG9uQ29tcGxldGUpO1xufTtcblJlYWN0QmF0Y2gucHJvdG90eXBlLmNvbW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGludGVybmFsUm9vdCA9IHRoaXMuX3Jvb3QuX2ludGVybmFsUm9vdDtcbiAgdmFyIGZpcnN0QmF0Y2ggPSBpbnRlcm5hbFJvb3QuZmlyc3RCYXRjaDtcbiAgISh0aGlzLl9kZWZlciAmJiBmaXJzdEJhdGNoICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ2JhdGNoLmNvbW1pdDogQ2Fubm90IGNvbW1pdCBhIGJhdGNoIG11bHRpcGxlIHRpbWVzLicpIDogdm9pZCAwO1xuXG4gIGlmICghdGhpcy5faGFzQ2hpbGRyZW4pIHtcbiAgICAvLyBUaGlzIGJhdGNoIGlzIGVtcHR5LiBSZXR1cm4uXG4gICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgdGhpcy5fZGVmZXIgPSBmYWxzZTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXhwaXJhdGlvblRpbWUgPSB0aGlzLl9leHBpcmF0aW9uVGltZTtcblxuICAvLyBFbnN1cmUgdGhpcyBpcyB0aGUgZmlyc3QgYmF0Y2ggaW4gdGhlIGxpc3QuXG4gIGlmIChmaXJzdEJhdGNoICE9PSB0aGlzKSB7XG4gICAgLy8gVGhpcyBiYXRjaCBpcyBub3QgdGhlIGVhcmxpZXN0IGJhdGNoLiBXZSBuZWVkIHRvIG1vdmUgaXQgdG8gdGhlIGZyb250LlxuICAgIC8vIFVwZGF0ZSBpdHMgZXhwaXJhdGlvbiB0aW1lIHRvIGJlIHRoZSBleHBpcmF0aW9uIHRpbWUgb2YgdGhlIGVhcmxpZXN0XG4gICAgLy8gYmF0Y2gsIHNvIHRoYXQgd2UgY2FuIGZsdXNoIGl0IHdpdGhvdXQgZmx1c2hpbmcgdGhlIG90aGVyIGJhdGNoZXMuXG4gICAgaWYgKHRoaXMuX2hhc0NoaWxkcmVuKSB7XG4gICAgICBleHBpcmF0aW9uVGltZSA9IHRoaXMuX2V4cGlyYXRpb25UaW1lID0gZmlyc3RCYXRjaC5fZXhwaXJhdGlvblRpbWU7XG4gICAgICAvLyBSZW5kZXJpbmcgdGhpcyBiYXRjaCBhZ2FpbiBlbnN1cmVzIGl0cyBjaGlsZHJlbiB3aWxsIGJlIHRoZSBmaW5hbCBzdGF0ZVxuICAgICAgLy8gd2hlbiB3ZSBmbHVzaCAodXBkYXRlcyBhcmUgcHJvY2Vzc2VkIGluIGluc2VydGlvbiBvcmRlcjogbGFzdFxuICAgICAgLy8gdXBkYXRlIHdpbnMpLlxuICAgICAgLy8gVE9ETzogVGhpcyBmb3JjZXMgYSByZXN0YXJ0LiBTaG91bGQgd2UgcHJpbnQgYSB3YXJuaW5nP1xuICAgICAgdGhpcy5yZW5kZXIodGhpcy5fY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSB0aGUgYmF0Y2ggZnJvbSB0aGUgbGlzdC5cbiAgICB2YXIgcHJldmlvdXMgPSBudWxsO1xuICAgIHZhciBiYXRjaCA9IGZpcnN0QmF0Y2g7XG4gICAgd2hpbGUgKGJhdGNoICE9PSB0aGlzKSB7XG4gICAgICBwcmV2aW91cyA9IGJhdGNoO1xuICAgICAgYmF0Y2ggPSBiYXRjaC5fbmV4dDtcbiAgICB9XG4gICAgIShwcmV2aW91cyAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdiYXRjaC5jb21taXQ6IENhbm5vdCBjb21taXQgYSBiYXRjaCBtdWx0aXBsZSB0aW1lcy4nKSA6IHZvaWQgMDtcbiAgICBwcmV2aW91cy5fbmV4dCA9IGJhdGNoLl9uZXh0O1xuXG4gICAgLy8gQWRkIGl0IHRvIHRoZSBmcm9udC5cbiAgICB0aGlzLl9uZXh0ID0gZmlyc3RCYXRjaDtcbiAgICBmaXJzdEJhdGNoID0gaW50ZXJuYWxSb290LmZpcnN0QmF0Y2ggPSB0aGlzO1xuICB9XG5cbiAgLy8gU3luY2hyb25vdXNseSBmbHVzaCBhbGwgdGhlIHdvcmsgdXAgdG8gdGhpcyBiYXRjaCdzIGV4cGlyYXRpb24gdGltZS5cbiAgdGhpcy5fZGVmZXIgPSBmYWxzZTtcbiAgZmx1c2hSb290KGludGVybmFsUm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuXG4gIC8vIFBvcCB0aGUgYmF0Y2ggZnJvbSB0aGUgbGlzdC5cbiAgdmFyIG5leHQgPSB0aGlzLl9uZXh0O1xuICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgZmlyc3RCYXRjaCA9IGludGVybmFsUm9vdC5maXJzdEJhdGNoID0gbmV4dDtcblxuICAvLyBBcHBlbmQgdGhlIG5leHQgZWFybGllc3QgYmF0Y2gncyBjaGlsZHJlbiB0byB0aGUgdXBkYXRlIHF1ZXVlLlxuICBpZiAoZmlyc3RCYXRjaCAhPT0gbnVsbCAmJiBmaXJzdEJhdGNoLl9oYXNDaGlsZHJlbikge1xuICAgIGZpcnN0QmF0Y2gucmVuZGVyKGZpcnN0QmF0Y2guX2NoaWxkcmVuKTtcbiAgfVxufTtcblJlYWN0QmF0Y2gucHJvdG90eXBlLl9vbkNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGlkQ29tcGxldGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fZGlkQ29tcGxldGUgPSB0cnVlO1xuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICBpZiAoY2FsbGJhY2tzID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFRPRE86IEVycm9yIGhhbmRsaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XG4gICAgX2NhbGxiYWNrKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFJlYWN0V29yaygpIHtcbiAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgdGhpcy5fZGlkQ29tbWl0ID0gZmFsc2U7XG4gIC8vIFRPRE86IEF2b2lkIG5lZWQgdG8gYmluZCBieSByZXBsYWNpbmcgY2FsbGJhY2tzIGluIHRoZSB1cGRhdGUgcXVldWUgd2l0aFxuICAvLyBsaXN0IG9mIFdvcmsgb2JqZWN0cy5cbiAgdGhpcy5fb25Db21taXQgPSB0aGlzLl9vbkNvbW1pdC5iaW5kKHRoaXMpO1xufVxuUmVhY3RXb3JrLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uQ29tbWl0KSB7XG4gIGlmICh0aGlzLl9kaWRDb21taXQpIHtcbiAgICBvbkNvbW1pdCgpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICBpZiAoY2FsbGJhY2tzID09PSBudWxsKSB7XG4gICAgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzID0gW107XG4gIH1cbiAgY2FsbGJhY2tzLnB1c2gob25Db21taXQpO1xufTtcblJlYWN0V29yay5wcm90b3R5cGUuX29uQ29tbWl0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGlkQ29tbWl0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2RpZENvbW1pdCA9IHRydWU7XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gIGlmIChjYWxsYmFja3MgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gVE9ETzogRXJyb3IgaGFuZGxpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9jYWxsYmFjazIgPSBjYWxsYmFja3NbaV07XG4gICAgISh0eXBlb2YgX2NhbGxiYWNrMiA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBfY2FsbGJhY2syKSA6IHZvaWQgMDtcbiAgICBfY2FsbGJhY2syKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFJlYWN0Um9vdChjb250YWluZXIsIGlzQXN5bmMsIGh5ZHJhdGUpIHtcbiAgdmFyIHJvb3QgPSBjcmVhdGVDb250YWluZXIoY29udGFpbmVyLCBpc0FzeW5jLCBoeWRyYXRlKTtcbiAgdGhpcy5faW50ZXJuYWxSb290ID0gcm9vdDtcbn1cblJlYWN0Um9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgdmFyIHdvcmsgPSBuZXcgUmVhY3RXb3JrKCk7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAge1xuICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlbmRlcicpO1xuICB9XG4gIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHdvcmsudGhlbihjYWxsYmFjayk7XG4gIH1cbiAgdXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBudWxsLCB3b3JrLl9vbkNvbW1pdCk7XG4gIHJldHVybiB3b3JrO1xufTtcblJlYWN0Um9vdC5wcm90b3R5cGUudW5tb3VudCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgdmFyIHdvcmsgPSBuZXcgUmVhY3RXb3JrKCk7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAge1xuICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlbmRlcicpO1xuICB9XG4gIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHdvcmsudGhlbihjYWxsYmFjayk7XG4gIH1cbiAgdXBkYXRlQ29udGFpbmVyKG51bGwsIHJvb3QsIG51bGwsIHdvcmsuX29uQ29tbWl0KTtcbiAgcmV0dXJuIHdvcms7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS5sZWdhY3lfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIgPSBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY2FsbGJhY2spIHtcbiAgdmFyIHJvb3QgPSB0aGlzLl9pbnRlcm5hbFJvb3Q7XG4gIHZhciB3b3JrID0gbmV3IFJlYWN0V29yaygpO1xuICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gIHtcbiAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdyZW5kZXInKTtcbiAgfVxuICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB3b3JrLnRoZW4oY2FsbGJhY2spO1xuICB9XG4gIHVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgcm9vdCwgcGFyZW50Q29tcG9uZW50LCB3b3JrLl9vbkNvbW1pdCk7XG4gIHJldHVybiB3b3JrO1xufTtcblJlYWN0Um9vdC5wcm90b3R5cGUuY3JlYXRlQmF0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBiYXRjaCA9IG5ldyBSZWFjdEJhdGNoKHRoaXMpO1xuICB2YXIgZXhwaXJhdGlvblRpbWUgPSBiYXRjaC5fZXhwaXJhdGlvblRpbWU7XG5cbiAgdmFyIGludGVybmFsUm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgdmFyIGZpcnN0QmF0Y2ggPSBpbnRlcm5hbFJvb3QuZmlyc3RCYXRjaDtcbiAgaWYgKGZpcnN0QmF0Y2ggPT09IG51bGwpIHtcbiAgICBpbnRlcm5hbFJvb3QuZmlyc3RCYXRjaCA9IGJhdGNoO1xuICAgIGJhdGNoLl9uZXh0ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBJbnNlcnQgc29ydGVkIGJ5IGV4cGlyYXRpb24gdGltZSB0aGVuIGluc2VydGlvbiBvcmRlclxuICAgIHZhciBpbnNlcnRBZnRlciA9IG51bGw7XG4gICAgdmFyIGluc2VydEJlZm9yZSA9IGZpcnN0QmF0Y2g7XG4gICAgd2hpbGUgKGluc2VydEJlZm9yZSAhPT0gbnVsbCAmJiBpbnNlcnRCZWZvcmUuX2V4cGlyYXRpb25UaW1lIDw9IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICBpbnNlcnRBZnRlciA9IGluc2VydEJlZm9yZTtcbiAgICAgIGluc2VydEJlZm9yZSA9IGluc2VydEJlZm9yZS5fbmV4dDtcbiAgICB9XG4gICAgYmF0Y2guX25leHQgPSBpbnNlcnRCZWZvcmU7XG4gICAgaWYgKGluc2VydEFmdGVyICE9PSBudWxsKSB7XG4gICAgICBpbnNlcnRBZnRlci5fbmV4dCA9IGJhdGNoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBiYXRjaDtcbn07XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSB2YWxpZCBub2RlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGlzIGEgdmFsaWQgRE9NIG5vZGUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lcihub2RlKSB7XG4gIHJldHVybiAhIShub2RlICYmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1tb3VudC1wb2ludC11bnN0YWJsZSAnKSk7XG59XG5cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuICEhKHJvb3RFbGVtZW50ICYmIHJvb3RFbGVtZW50Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgcm9vdEVsZW1lbnQuaGFzQXR0cmlidXRlKFJPT1RfQVRUUklCVVRFX05BTUUpKTtcbn1cblxuc2V0QmF0Y2hpbmdJbXBsZW1lbnRhdGlvbihiYXRjaGVkVXBkYXRlcyQxLCBpbnRlcmFjdGl2ZVVwZGF0ZXMkMSwgZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXMkMSk7XG5cbnZhciB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSBmYWxzZTtcblxuZnVuY3Rpb24gbGVnYWN5Q3JlYXRlUm9vdEZyb21ET01Db250YWluZXIoY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUpIHtcbiAgdmFyIHNob3VsZEh5ZHJhdGUgPSBmb3JjZUh5ZHJhdGUgfHwgc2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljKGNvbnRhaW5lcik7XG4gIC8vIEZpcnN0IGNsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxuICBpZiAoIXNob3VsZEh5ZHJhdGUpIHtcbiAgICB2YXIgd2FybmVkID0gZmFsc2U7XG4gICAgdmFyIHJvb3RTaWJsaW5nID0gdm9pZCAwO1xuICAgIHdoaWxlIChyb290U2libGluZyA9IGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCF3YXJuZWQgJiYgcm9vdFNpYmxpbmcubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290U2libGluZy5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpIHtcbiAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ3JlbmRlcigpOiBUYXJnZXQgbm9kZSBoYXMgbWFya3VwIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgdGhlcmUgJyArICdhcmUgdW5yZWxhdGVkIG5vZGVzIGFzIHdlbGwuIFRoaXMgaXMgbW9zdCBjb21tb25seSBjYXVzZWQgYnkgJyArICd3aGl0ZS1zcGFjZSBpbnNlcnRlZCBhcm91bmQgc2VydmVyLXJlbmRlcmVkIG1hcmt1cC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHJvb3RTaWJsaW5nKTtcbiAgICB9XG4gIH1cbiAge1xuICAgIGlmIChzaG91bGRIeWRyYXRlICYmICFmb3JjZUh5ZHJhdGUgJiYgIXdhcm5lZEFib3V0SHlkcmF0ZUFQSSkge1xuICAgICAgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gdHJ1ZTtcbiAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAncmVuZGVyKCk6IENhbGxpbmcgUmVhY3RET00ucmVuZGVyKCkgdG8gaHlkcmF0ZSBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwICcgKyAnd2lsbCBzdG9wIHdvcmtpbmcgaW4gUmVhY3QgdjE3LiBSZXBsYWNlIHRoZSBSZWFjdERPTS5yZW5kZXIoKSBjYWxsICcgKyAnd2l0aCBSZWFjdERPTS5oeWRyYXRlKCkgaWYgeW91IHdhbnQgUmVhY3QgdG8gYXR0YWNoIHRvIHRoZSBzZXJ2ZXIgSFRNTC4nKTtcbiAgICB9XG4gIH1cbiAgLy8gTGVnYWN5IHJvb3RzIGFyZSBub3QgYXN5bmMgYnkgZGVmYXVsdC5cbiAgdmFyIGlzQXN5bmMgPSBmYWxzZTtcbiAgcmV0dXJuIG5ldyBSZWFjdFJvb3QoY29udGFpbmVyLCBpc0FzeW5jLCBzaG91bGRIeWRyYXRlKTtcbn1cblxuZnVuY3Rpb24gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUsIGNhbGxiYWNrKSB7XG4gIC8vIFRPRE86IEVuc3VyZSBhbGwgZW50cnkgcG9pbnRzIGNvbnRhaW4gdGhpcyBjaGVja1xuICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAnVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IHZvaWQgMDtcblxuICB7XG4gICAgdG9wTGV2ZWxVcGRhdGVXYXJuaW5ncyhjb250YWluZXIpO1xuICB9XG5cbiAgLy8gVE9ETzogV2l0aG91dCBgYW55YCB0eXBlLCBGbG93IHNheXMgXCJQcm9wZXJ0eSBjYW5ub3QgYmUgYWNjZXNzZWQgb24gYW55XG4gIC8vIG1lbWJlciBvZiBpbnRlcnNlY3Rpb24gdHlwZS5cIiBXaHl5eXl5eS5cbiAgdmFyIHJvb3QgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgaWYgKCFyb290KSB7XG4gICAgLy8gSW5pdGlhbCBtb3VudFxuICAgIHJvb3QgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IGxlZ2FjeUNyZWF0ZVJvb3RGcm9tRE9NQ29udGFpbmVyKGNvbnRhaW5lciwgZm9yY2VIeWRyYXRlKTtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgb3JpZ2luYWxDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290Ll9pbnRlcm5hbFJvb3QpO1xuICAgICAgICBvcmlnaW5hbENhbGxiYWNrLmNhbGwoaW5zdGFuY2UpO1xuICAgICAgfTtcbiAgICB9XG4gICAgLy8gSW5pdGlhbCBtb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgdW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocGFyZW50Q29tcG9uZW50ICE9IG51bGwpIHtcbiAgICAgICAgcm9vdC5sZWdhY3lfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5yZW5kZXIoY2hpbGRyZW4sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgX29yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBnZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdC5faW50ZXJuYWxSb290KTtcbiAgICAgICAgX29yaWdpbmFsQ2FsbGJhY2suY2FsbChpbnN0YW5jZSk7XG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBVcGRhdGVcbiAgICBpZiAocGFyZW50Q29tcG9uZW50ICE9IG51bGwpIHtcbiAgICAgIHJvb3QubGVnYWN5X3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgY2hpbGRyZW4sIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdC5yZW5kZXIoY2hpbGRyZW4sIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290Ll9pbnRlcm5hbFJvb3QpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lcikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuXG4gICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuICAvLyBUT0RPOiBwYXNzIFJlYWN0RE9NIHBvcnRhbCBpbXBsZW1lbnRhdGlvbiBhcyB0aGlyZCBhcmd1bWVudFxuICByZXR1cm4gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lciwgbnVsbCwga2V5KTtcbn1cblxudmFyIFJlYWN0RE9NID0ge1xuICBjcmVhdGVQb3J0YWw6IGNyZWF0ZVBvcnRhbCxcblxuICBmaW5kRE9NTm9kZTogZnVuY3Rpb24gKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICAgIHtcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgICBpZiAob3duZXIgIT09IG51bGwgJiYgb3duZXIuc3RhdGVOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB3YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXI7XG4gICAgICAgICF3YXJuZWRBYm91dFJlZnNJblJlbmRlciA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzIGlzIGFjY2Vzc2luZyBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lci50eXBlKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgICAgb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmluZEhvc3RJbnN0YW5jZShjb21wb25lbnRPckVsZW1lbnQpO1xuICB9LFxuICBoeWRyYXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IHRocm93IG9yIHdhcm4gaWYgd2UgY291bGRuJ3QgaHlkcmF0ZT9cbiAgICByZXR1cm4gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCB0cnVlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCBmYWxzZSwgY2FsbGJhY2spO1xuICB9LFxuICB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcbiAgICAhKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIGhhcyhwYXJlbnRDb21wb25lbnQpKSA/IGludmFyaWFudChmYWxzZSwgJ3BhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG5cbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB2YXIgcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0ID0gcm9vdEVsICYmICFnZXRJbnN0YW5jZUZyb21Ob2RlJDEocm9vdEVsKTtcbiAgICAgICAgISFyZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsIFwidW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3UncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50IFwiICsgJ3dhcyByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIFVubW91bnQgc2hvdWxkIG5vdCBiZSBiYXRjaGVkLlxuICAgICAgdW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIG51bGwsIGNvbnRhaW5lciwgZmFsc2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAvLyBJZiB5b3UgY2FsbCB1bm1vdW50Q29tcG9uZW50QXROb2RlIHR3aWNlIGluIHF1aWNrIHN1Y2Nlc3Npb24sIHlvdSdsbFxuICAgICAgLy8gZ2V0IGB0cnVlYCB0d2ljZS4gVGhhdCdzIHByb2JhYmx5IGZpbmU/XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICB2YXIgX3Jvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShfcm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUkMShfcm9vdEVsKSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRhaW5lciBpdHNlbGYgaXMgYSBSZWFjdCByb290IG5vZGUuXG4gICAgICAgIHZhciBpc0NvbnRhaW5lclJlYWN0Um9vdCA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIGlzVmFsaWRDb250YWluZXIoY29udGFpbmVyLnBhcmVudE5vZGUpICYmICEhY29udGFpbmVyLnBhcmVudE5vZGUuX3JlYWN0Um9vdENvbnRhaW5lcjtcblxuICAgICAgICAhIWhhc05vblJvb3RSZWFjdENoaWxkID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG5cbiAgLy8gVGVtcG9yYXJ5IGFsaWFzIHNpbmNlIHdlIGFscmVhZHkgc2hpcHBlZCBSZWFjdCAxNiBSQyB3aXRoIGl0LlxuICAvLyBUT0RPOiByZW1vdmUgaW4gUmVhY3QgMTcuXG4gIHVuc3RhYmxlX2NyZWF0ZVBvcnRhbDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghZGlkV2FybkFib3V0VW5zdGFibGVDcmVhdGVQb3J0YWwpIHtcbiAgICAgIGRpZFdhcm5BYm91dFVuc3RhYmxlQ3JlYXRlUG9ydGFsID0gdHJ1ZTtcbiAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnVGhlIFJlYWN0RE9NLnVuc3RhYmxlX2NyZWF0ZVBvcnRhbCgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RET00uY3JlYXRlUG9ydGFsKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSSwgJyArICdidXQgd2l0aG91dCB0aGUgXCJ1bnN0YWJsZV9cIiBwcmVmaXguJyk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9LFxuXG5cbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzJDEsXG5cbiAgdW5zdGFibGVfaW50ZXJhY3RpdmVVcGRhdGVzOiBpbnRlcmFjdGl2ZVVwZGF0ZXMkMSxcblxuICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcblxuICB1bnN0YWJsZV9mbHVzaENvbnRyb2xsZWQ6IGZsdXNoQ29udHJvbGxlZCxcblxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDoge1xuICAgIC8vIEtlZXAgaW4gc3luYyB3aXRoIFJlYWN0RE9NVW5zdGFibGVOYXRpdmVEZXBlbmRlbmNpZXMuanNcbiAgICAvLyBhbmQgUmVhY3RUZXN0VXRpbHMuanMuIFRoaXMgaXMgYW4gYXJyYXkgZm9yIGJldHRlciBtaW5pZmljYXRpb24uXG4gICAgRXZlbnRzOiBbZ2V0SW5zdGFuY2VGcm9tTm9kZSQxLCBnZXROb2RlRnJvbUluc3RhbmNlJDEsIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMSwgaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSwgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcywgZW5xdWV1ZVN0YXRlUmVzdG9yZSwgcmVzdG9yZVN0YXRlSWZOZWVkZWQsIGRpc3BhdGNoRXZlbnQsIHJ1bkV2ZW50c0luQmF0Y2hdXG4gIH1cbn07XG5cblJlYWN0RE9NLnVuc3RhYmxlX2NyZWF0ZVJvb3QgPSBmdW5jdGlvbiBjcmVhdGVSb290KGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAndW5zdGFibGVfY3JlYXRlUm9vdCguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuICB2YXIgaHlkcmF0ZSA9IG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmh5ZHJhdGUgPT09IHRydWU7XG4gIHJldHVybiBuZXcgUmVhY3RSb290KGNvbnRhaW5lciwgdHJ1ZSwgaHlkcmF0ZSk7XG59O1xuXG52YXIgZm91bmREZXZUb29scyA9IGluamVjdEludG9EZXZUb29scyh7XG4gIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcbiAgYnVuZGxlVHlwZTogMSxcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuICByZW5kZXJlclBhY2thZ2VOYW1lOiAncmVhY3QtZG9tJ1xufSk7XG5cbntcbiAgaWYgKCFmb3VuZERldlRvb2xzICYmIGNhblVzZURPTSAmJiB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZikge1xuICAgIC8vIElmIHdlJ3JlIGluIENocm9tZSBvciBGaXJlZm94LCBwcm92aWRlIGEgZG93bmxvYWQgbGluayBpZiBub3QgaW5zdGFsbGVkLlxuICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPT09IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID4gLTEpIHtcbiAgICAgIHZhciBwcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgIC8vIERvbid0IHdhcm4gaW4gZXhvdGljIGNhc2VzIGxpa2UgY2hyb21lLWV4dGVuc2lvbjovLy5cbiAgICAgIGlmICgvXihodHRwcz98ZmlsZSk6JC8udGVzdChwcm90b2NvbCkpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCclY0Rvd25sb2FkIHRoZSBSZWFjdCBEZXZUb29scyAnICsgJ2ZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnICsgKHByb3RvY29sID09PSAnZmlsZTonID8gJ1xcbllvdSBtaWdodCBuZWVkIHRvIHVzZSBhIGxvY2FsIEhUVFAgc2VydmVyIChpbnN0ZWFkIG9mIGZpbGU6Ly8pOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMtZmFxJyA6ICcnKSwgJ2ZvbnQtd2VpZ2h0OmJvbGQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5cbnZhciBSZWFjdERPTSQyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmF1bHQ6IFJlYWN0RE9NXG59KTtcblxudmFyIFJlYWN0RE9NJDMgPSAoIFJlYWN0RE9NJDIgJiYgUmVhY3RET00gKSB8fCBSZWFjdERPTSQyO1xuXG4vLyBUT0RPOiBkZWNpZGUgb24gdGhlIHRvcC1sZXZlbCBleHBvcnQgZm9ybS5cbi8vIFRoaXMgaXMgaGFja3kgYnV0IG1ha2VzIGl0IHdvcmsgd2l0aCBib3RoIFJvbGx1cCBhbmQgSmVzdC5cbnZhciByZWFjdERvbSA9IFJlYWN0RE9NJDMuZGVmYXVsdCB8fCBSZWFjdERPTSQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0RG9tO1xuICB9KSgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlLXRyYWNpbmcucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGUtdHJhY2luZy5kZXZlbG9wbWVudC5qcycpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlL3RyYWNpbmcuanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjUuMlxuICogc2NoZWR1bGUtdHJhY2luZy5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYj0wO2V4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWY9bnVsbDtleHBvcnRzLl9fc3Vic2NyaWJlclJlZj1udWxsO2V4cG9ydHMudW5zdGFibGVfY2xlYXI9ZnVuY3Rpb24oYSl7cmV0dXJuIGEoKX07ZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50PWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O2V4cG9ydHMudW5zdGFibGVfZ2V0VGhyZWFkSUQ9ZnVuY3Rpb24oKXtyZXR1cm4rK2J9O2V4cG9ydHMudW5zdGFibGVfdHJhY2U9ZnVuY3Rpb24oYSxkLGMpe3JldHVybiBjKCl9O2V4cG9ydHMudW5zdGFibGVfd3JhcD1mdW5jdGlvbihhKXtyZXR1cm4gYX07ZXhwb3J0cy51bnN0YWJsZV9zdWJzY3JpYmU9ZnVuY3Rpb24oKXt9O2V4cG9ydHMudW5zdGFibGVfdW5zdWJzY3JpYmU9ZnVuY3Rpb24oKXt9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlL2Nqcy9zY2hlZHVsZS10cmFjaW5nLnByb2R1Y3Rpb24ubWluLmpzIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi41LjJcbiAqIHNjaGVkdWxlLXRyYWNpbmcuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRXhwb3J0cyBSZWFjdERPTS5jcmVhdGVSb290XG5cblxuLy8gRXhwZXJpbWVudGFsIGVycm9yLWJvdW5kYXJ5IEFQSSB0aGF0IGNhbiByZWNvdmVyIGZyb20gZXJyb3JzIHdpdGhpbiBhIHNpbmdsZVxuLy8gcmVuZGVyIHBoYXNlXG5cbi8vIFN1c3BlbnNlXG5cbi8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiBiZWdpbi1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlIHJlZHVjZXJzOlxuXG5cbi8vIEluIHNvbWUgY2FzZXMsIFN0cmljdE1vZGUgc2hvdWxkIGFsc28gZG91YmxlLXJlbmRlciBsaWZlY3ljbGVzLlxuLy8gVGhpcyBjYW4gYmUgY29uZnVzaW5nIGZvciB0ZXN0cyB0aG91Z2gsXG4vLyBBbmQgaXQgY2FuIGJlIGJhZCBmb3IgcGVyZm9ybWFuY2UgaW4gcHJvZHVjdGlvbi5cbi8vIFRoaXMgZmVhdHVyZSBmbGFnIGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yOlxuXG5cbi8vIFRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIGRlYnVnZ2VyLCB3ZVxuLy8gcmVwbGF5IHRoZSBiZWdpbiBwaGFzZSBvZiBhIGZhaWxlZCBjb21wb25lbnQgaW5zaWRlIGludm9rZUd1YXJkZWRDYWxsYmFjay5cblxuXG4vLyBXYXJuIGFib3V0IGRlcHJlY2F0ZWQsIGFzeW5jLXVuc2FmZSBsaWZlY3ljbGVzOyByZWxhdGVzIHRvIFJGQyAjNjpcblxuXG4vLyBXYXJuIGFib3V0IGxlZ2FjeSBjb250ZXh0IEFQSVxuXG5cbi8vIEdhdGhlciBhZHZhbmNlZCB0aW1pbmcgbWV0cmljcyBmb3IgUHJvZmlsZXIgc3VidHJlZXMuXG5cblxuLy8gVHJhY2Ugd2hpY2ggaW50ZXJhY3Rpb25zIHRyaWdnZXIgZWFjaCBjb21taXQuXG52YXIgZW5hYmxlU2NoZWR1bGVyVHJhY2luZyA9IHRydWU7XG5cbi8vIE9ubHkgdXNlZCBpbiB3d3cgYnVpbGRzLlxuXG5cbi8vIE9ubHkgdXNlZCBpbiB3d3cgYnVpbGRzLlxuXG5cbi8vIFJlYWN0IEZpcmU6IHByZXZlbnQgdGhlIHZhbHVlIGFuZCBjaGVja2VkIGF0dHJpYnV0ZXMgZnJvbSBzeW5jaW5nXG4vLyB3aXRoIHRoZWlyIHJlbGF0ZWQgRE9NIHByb3BlcnRpZXNcblxudmFyIERFRkFVTFRfVEhSRUFEX0lEID0gMDtcblxuLy8gQ291bnRlcnMgdXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLlxudmFyIGludGVyYWN0aW9uSURDb3VudGVyID0gMDtcbnZhciB0aHJlYWRJRENvdW50ZXIgPSAwO1xuXG4vLyBTZXQgb2YgY3VycmVudGx5IHRyYWNlZCBpbnRlcmFjdGlvbnMuXG4vLyBJbnRlcmFjdGlvbnMgXCJzdGFja1wi4oCTXG4vLyBNZWFuaW5nIHRoYXQgbmV3bHkgdHJhY2VkIGludGVyYWN0aW9ucyBhcmUgYXBwZW5kZWQgdG8gdGhlIHByZXZpb3VzbHkgYWN0aXZlIHNldC5cbi8vIFdoZW4gYW4gaW50ZXJhY3Rpb24gZ29lcyBvdXQgb2Ygc2NvcGUsIHRoZSBwcmV2aW91cyBzZXQgKGlmIGFueSkgaXMgcmVzdG9yZWQuXG5leHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmID0gbnVsbDtcblxuLy8gTGlzdGVuZXIocykgdG8gbm90aWZ5IHdoZW4gaW50ZXJhY3Rpb25zIGJlZ2luIGFuZCBlbmQuXG5leHBvcnRzLl9fc3Vic2NyaWJlclJlZiA9IG51bGw7XG5cbmlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYgPSB7XG4gICAgY3VycmVudDogbmV3IFNldCgpXG4gIH07XG4gIGV4cG9ydHMuX19zdWJzY3JpYmVyUmVmID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfY2xlYXIoY2FsbGJhY2spIHtcbiAgaWYgKCFlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH1cblxuICB2YXIgcHJldkludGVyYWN0aW9ucyA9IGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gbmV3IFNldCgpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH0gZmluYWxseSB7XG4gICAgZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcHJldkludGVyYWN0aW9ucztcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9nZXRDdXJyZW50KCkge1xuICBpZiAoIWVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldFRocmVhZElEKCkge1xuICByZXR1cm4gKyt0aHJlYWRJRENvdW50ZXI7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3RyYWNlKG5hbWUsIHRpbWVzdGFtcCwgY2FsbGJhY2spIHtcbiAgdmFyIHRocmVhZElEID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBERUZBVUxUX1RIUkVBRF9JRDtcblxuICBpZiAoIWVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfVxuXG4gIHZhciBpbnRlcmFjdGlvbiA9IHtcbiAgICBfX2NvdW50OiAxLFxuICAgIGlkOiBpbnRlcmFjdGlvbklEQ291bnRlcisrLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgdGltZXN0YW1wOiB0aW1lc3RhbXBcbiAgfTtcblxuICB2YXIgcHJldkludGVyYWN0aW9ucyA9IGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcblxuICAvLyBUcmFjZWQgaW50ZXJhY3Rpb25zIHNob3VsZCBzdGFjay9hY2N1bXVsYXRlLlxuICAvLyBUbyBkbyB0aGF0LCBjbG9uZSB0aGUgY3VycmVudCBpbnRlcmFjdGlvbnMuXG4gIC8vIFRoZSBwcmV2aW91cyBzZXQgd2lsbCBiZSByZXN0b3JlZCB1cG9uIGNvbXBsZXRpb24uXG4gIHZhciBpbnRlcmFjdGlvbnMgPSBuZXcgU2V0KHByZXZJbnRlcmFjdGlvbnMpO1xuICBpbnRlcmFjdGlvbnMuYWRkKGludGVyYWN0aW9uKTtcbiAgZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gaW50ZXJhY3Rpb25zO1xuXG4gIHZhciBzdWJzY3JpYmVyID0gZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcbiAgdmFyIHJldHVyblZhbHVlID0gdm9pZCAwO1xuXG4gIHRyeSB7XG4gICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblRyYWNlZChpbnRlcmFjdGlvbik7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1N0YXJ0ZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHByZXZJbnRlcmFjdGlvbnM7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdG9wcGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50LS07XG5cbiAgICAgICAgICAvLyBJZiBubyBhc3luYyB3b3JrIHdhcyBzY2hlZHVsZWQgZm9yIHRoaXMgaW50ZXJhY3Rpb24sXG4gICAgICAgICAgLy8gTm90aWZ5IHN1YnNjcmliZXJzIHRoYXQgaXQncyBjb21wbGV0ZWQuXG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwgJiYgaW50ZXJhY3Rpb24uX19jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV93cmFwKGNhbGxiYWNrKSB7XG4gIHZhciB0aHJlYWRJRCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9USFJFQURfSUQ7XG5cbiAgaWYgKCFlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9XG5cbiAgdmFyIHdyYXBwZWRJbnRlcmFjdGlvbnMgPSBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG5cbiAgdmFyIHN1YnNjcmliZXIgPSBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgIHN1YnNjcmliZXIub25Xb3JrU2NoZWR1bGVkKHdyYXBwZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgcGVuZGluZyBhc3luYyB3b3JrIGNvdW50IGZvciB0aGUgY3VycmVudCBpbnRlcmFjdGlvbnMuXG4gIC8vIFVwZGF0ZSBhZnRlciBjYWxsaW5nIHN1YnNjcmliZXJzIGluIGNhc2Ugb2YgZXJyb3IuXG4gIHdyYXBwZWRJbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICBpbnRlcmFjdGlvbi5fX2NvdW50Kys7XG4gIH0pO1xuXG4gIHZhciBoYXNSdW4gPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3cmFwcGVkKCkge1xuICAgIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuICAgIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHdyYXBwZWRJbnRlcmFjdGlvbnM7XG5cbiAgICBzdWJzY3JpYmVyID0gZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSB2b2lkIDA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdGFydGVkKHdyYXBwZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBwcmV2SW50ZXJhY3Rpb25zO1xuXG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RvcHBlZCh3cmFwcGVkSW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKCFoYXNSdW4pIHtcbiAgICAgICAgLy8gV2Ugb25seSBleHBlY3QgYSB3cmFwcGVkIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uY2UsXG4gICAgICAgIC8vIEJ1dCBpbiB0aGUgZXZlbnQgdGhhdCBpdCdzIGV4ZWN1dGVkIG1vcmUgdGhhbiBvbmNl4oCTXG4gICAgICAgIC8vIE9ubHkgZGVjcmVtZW50IHRoZSBvdXRzdGFuZGluZyBpbnRlcmFjdGlvbiBjb3VudHMgb25jZS5cbiAgICAgICAgaGFzUnVuID0gdHJ1ZTtcblxuICAgICAgICAvLyBVcGRhdGUgcGVuZGluZyBhc3luYyBjb3VudHMgZm9yIGFsbCB3cmFwcGVkIGludGVyYWN0aW9ucy5cbiAgICAgICAgLy8gSWYgdGhpcyB3YXMgdGhlIGxhc3Qgc2NoZWR1bGVkIGFzeW5jIHdvcmsgZm9yIGFueSBvZiB0aGVtLFxuICAgICAgICAvLyBNYXJrIHRoZW0gYXMgY29tcGxldGVkLlxuICAgICAgICB3cmFwcGVkSW50ZXJhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudC0tO1xuXG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwgJiYgaW50ZXJhY3Rpb24uX19jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3cmFwcGVkLmNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBzdWJzY3JpYmVyID0gZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBzdWJzY3JpYmVyLm9uV29ya0NhbmNlbGVkKHdyYXBwZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gVXBkYXRlIHBlbmRpbmcgYXN5bmMgY291bnRzIGZvciBhbGwgd3JhcHBlZCBpbnRlcmFjdGlvbnMuXG4gICAgICAvLyBJZiB0aGlzIHdhcyB0aGUgbGFzdCBzY2hlZHVsZWQgYXN5bmMgd29yayBmb3IgYW55IG9mIHRoZW0sXG4gICAgICAvLyBNYXJrIHRoZW0gYXMgY29tcGxldGVkLlxuICAgICAgd3JhcHBlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50LS07XG5cbiAgICAgICAgaWYgKHN1YnNjcmliZXIgJiYgaW50ZXJhY3Rpb24uX19jb3VudCA9PT0gMCkge1xuICAgICAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbnZhciBzdWJzY3JpYmVycyA9IG51bGw7XG5pZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICBzdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICBzdWJzY3JpYmVycy5hZGQoc3Vic2NyaWJlcik7XG5cbiAgICBpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMSkge1xuICAgICAgZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudCA9IHtcbiAgICAgICAgb25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQ6IG9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkLFxuICAgICAgICBvbkludGVyYWN0aW9uVHJhY2VkOiBvbkludGVyYWN0aW9uVHJhY2VkLFxuICAgICAgICBvbldvcmtDYW5jZWxlZDogb25Xb3JrQ2FuY2VsZWQsXG4gICAgICAgIG9uV29ya1NjaGVkdWxlZDogb25Xb3JrU2NoZWR1bGVkLFxuICAgICAgICBvbldvcmtTdGFydGVkOiBvbldvcmtTdGFydGVkLFxuICAgICAgICBvbldvcmtTdG9wcGVkOiBvbldvcmtTdG9wcGVkXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV91bnN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gIGlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgc3Vic2NyaWJlcnMuZGVsZXRlKHN1YnNjcmliZXIpO1xuXG4gICAgaWYgKHN1YnNjcmliZXJzLnNpemUgPT09IDApIHtcbiAgICAgIGV4cG9ydHMuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvbkludGVyYWN0aW9uVHJhY2VkKGludGVyYWN0aW9uKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG5cbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25UcmFjZWQoaW50ZXJhY3Rpb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkKGludGVyYWN0aW9uKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG5cbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkKGludGVyYWN0aW9uKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbldvcmtTY2hlZHVsZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCkge1xuICB2YXIgZGlkQ2F0Y2hFcnJvciA9IGZhbHNlO1xuICB2YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuXG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTY2hlZHVsZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Xb3JrU3RhcnRlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG5cbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uV29ya1N0YXJ0ZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Xb3JrU3RvcHBlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG5cbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uV29ya1N0b3BwZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Xb3JrQ2FuY2VsZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCkge1xuICB2YXIgZGlkQ2F0Y2hFcnJvciA9IGZhbHNlO1xuICB2YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuXG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtDYW5jZWxlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5leHBvcnRzLnVuc3RhYmxlX2NsZWFyID0gdW5zdGFibGVfY2xlYXI7XG5leHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnQgPSB1bnN0YWJsZV9nZXRDdXJyZW50O1xuZXhwb3J0cy51bnN0YWJsZV9nZXRUaHJlYWRJRCA9IHVuc3RhYmxlX2dldFRocmVhZElEO1xuZXhwb3J0cy51bnN0YWJsZV90cmFjZSA9IHVuc3RhYmxlX3RyYWNlO1xuZXhwb3J0cy51bnN0YWJsZV93cmFwID0gdW5zdGFibGVfd3JhcDtcbmV4cG9ydHMudW5zdGFibGVfc3Vic2NyaWJlID0gdW5zdGFibGVfc3Vic2NyaWJlO1xuZXhwb3J0cy51bnN0YWJsZV91bnN1YnNjcmliZSA9IHVuc3RhYmxlX3Vuc3Vic2NyaWJlO1xuICB9KSgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlL2Nqcy9zY2hlZHVsZS10cmFjaW5nLmRldmVsb3BtZW50LmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgcm91dGVzIGZyb20gJy4vcm91dGVzJ1xyXG5pbXBvcnQgeyByZW5kZXJSb3V0ZXMgfSBmcm9tICdyZWFjdC1yb3V0ZXItY29uZmlnJ1xyXG5cclxuXHJcbmNsYXNzIEFwcCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxoMT5UaGlzIGlzIEFwcCByb290IHBhZ2UuPC9oMT5cclxuICAgICAgICAgICAgICAgIDxoci8+XHJcbiAgICAgICAgICAgICAgICAgeyByZW5kZXJSb3V0ZXMocm91dGVzKSB9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIClcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQXBwXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zaGFyZWQvQXBwLmpzIiwiaW1wb3J0IEhvbWUgZnJvbSAnLi9Ib21lJ1xyXG5pbXBvcnQgTGFuZ3VhZ2VzIGZyb20gJy4vTGFuZ3VhZ2VzJ1xyXG5pbXBvcnQgVXNlcnMgZnJvbSAnLi9Vc2VycydcclxuaW1wb3J0IFJlcG9HcmlkIGZyb20gJy4vcmVwb0dyaWQnXHJcbmltcG9ydCBVc2VyR3JpZCBmcm9tICcuL3VzZXJHcmlkJ1xyXG5pbXBvcnQgeyBmZXRjaFBvcHVsYXJSZXBvcywgZmV0Y2hVc2VyIH0gZnJvbSAnLi9hcGknXHJcblxyXG5jb25zdCByb3V0ZXMgPSAgW1xyXG4gICAge1xyXG4gICAgICAgIHBhdGg6ICcvJyxcclxuICAgICAgICBleGFjdDogdHJ1ZSxcclxuICAgICAgICBjb21wb25lbnQ6IEhvbWVcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgcGF0aDogJy9sYW5ndWFnZXMnLFxyXG4gICAgICAgIGV4YWN0OiB0cnVlLFxyXG4gICAgICAgIGNvbXBvbmVudDogTGFuZ3VhZ2VzXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIHBhdGg6ICcvbGFuZ3VhZ2VzLzppZCcsXHJcbiAgICAgICAgY29tcG9uZW50OiBSZXBvR3JpZCxcclxuICAgICAgICBsb2FkRGF0YTogKHBhdGggPSAnJykgPT4gZmV0Y2hQb3B1bGFyUmVwb3MoXHJcbiAgICAgICAgICAgICAgICBwYXRoLnNwbGl0KCcvJykucG9wKClcclxuICAgICAgICAgICAgKVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBwYXRoOiAnL3VzZXJzJyxcclxuICAgICAgICBleGFjdDogdHJ1ZSxcclxuICAgICAgICBjb21wb25lbnQ6IFVzZXJzXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIHBhdGg6ICcvdXNlcnMvOmlkJyxcclxuICAgICAgICBjb21wb25lbnQ6IFVzZXJHcmlkLFxyXG4gICAgICAgIGxvYWREYXRhOiAocGF0aCA9ICcnKSA9PiBmZXRjaFVzZXIoXHJcbiAgICAgICAgICAgICAgICBwYXRoLnNwbGl0KCcvJykucG9wKClcclxuICAgICAgICAgICAgKVxyXG4gICAgfVxyXG5dXHJcblxyXG5leHBvcnQgZGVmYXVsdCByb3V0ZXNcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2hhcmVkL3JvdXRlcy5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7TmF2TGlua30gZnJvbSBcInJlYWN0LXJvdXRlci1kb21cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgIDxoMj5UaGlzIGlzIEhvbWUgcGFnZS48L2gyPlxyXG4gICAgICAgICAgICA8TmF2TGluayBhY3RpdmVTdHlsZT17e2ZvbnRXZWlnaHQ6ICdib2xkJ319IHRvPXtgL2xhbmd1YWdlc2B9PlxyXG4gICAgICAgICAgICAgICAgTGFuZ3VhZ2VzXHJcbiAgICAgICAgICAgIDwvTmF2TGluaz5cclxuICAgICAgICAgICAgPCBiciAvPlxyXG4gICAgICAgICAgICA8TmF2TGluayBhY3RpdmVTdHlsZT17e2ZvbnRXZWlnaHQ6ICdib2xkJ319IHRvPXtgL3VzZXJzYH0+XHJcbiAgICAgICAgICAgICAgICBVc2Vyc1xyXG4gICAgICAgICAgICA8L05hdkxpbms+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApXHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NoYXJlZC9Ib21lLmpzIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tIFwid2FybmluZ1wiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IHsgY3JlYXRlQnJvd3Nlckhpc3RvcnkgYXMgY3JlYXRlSGlzdG9yeSB9IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQgUm91dGVyIGZyb20gXCIuL1JvdXRlclwiO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgdXNlcyBIVE1MNSBoaXN0b3J5LlxuICovXG5cbnZhciBCcm93c2VyUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEJyb3dzZXJSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEJyb3dzZXJSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCcm93c2VyUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShfdGhpcy5wcm9wcyksIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgQnJvd3NlclJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgXCI8QnJvd3NlclJvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgXCIgKyBcInVzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IEJyb3dzZXJSb3V0ZXIgYXMgUm91dGVyIH1gLlwiKTtcbiAgfTtcblxuICBCcm93c2VyUm91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7IGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSwgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW4gfSk7XG4gIH07XG5cbiAgcmV0dXJuIEJyb3dzZXJSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkJyb3dzZXJSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZm9yY2VSZWZyZXNoOiBQcm9wVHlwZXMuYm9vbCxcbiAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gIGtleUxlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IEJyb3dzZXJSb3V0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvQnJvd3NlclJvdXRlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSAgKyAnYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cbiAgICAgIC8vIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge31cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICApO1xuICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIHRocm93IGVycjtcbiAgfTtcbiAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcbiAgICByZXR1cm4gc2hpbTtcbiAgfTtcbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBzaGltLFxuICAgIGJvb2w6IHNoaW0sXG4gICAgZnVuYzogc2hpbSxcbiAgICBudW1iZXI6IHNoaW0sXG4gICAgb2JqZWN0OiBzaGltLFxuICAgIHN0cmluZzogc2hpbSxcbiAgICBzeW1ib2w6IHNoaW0sXG5cbiAgICBhbnk6IHNoaW0sXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcbiAgICBlbGVtZW50OiBzaGltLFxuICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG4gICAgbm9kZTogc2hpbSxcbiAgICBvYmplY3RPZjogZ2V0U2hpbSxcbiAgICBvbmVPZjogZ2V0U2hpbSxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG4gICAgc2hhcGU6IGdldFNoaW0sXG4gICAgZXhhY3Q6IGdldFNoaW1cbiAgfTtcblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGVtcHR5RnVuY3Rpb247XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJmdW5jdGlvbiBpc0Fic29sdXRlKHBhdGhuYW1lKSB7XG4gIHJldHVybiBwYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJztcbn1cblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKSB7XG4gICAgbGlzdFtpXSA9IGxpc3Rba107XG4gIH1cblxuICBsaXN0LnBvcCgpO1xufVxuXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIGhlYXZpbHkgb24gbm9kZSdzIHVybC5wYXJzZVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGhuYW1lKHRvKSB7XG4gIHZhciBmcm9tID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcblxuICB2YXIgdG9QYXJ0cyA9IHRvICYmIHRvLnNwbGl0KCcvJykgfHwgW107XG4gIHZhciBmcm9tUGFydHMgPSBmcm9tICYmIGZyb20uc3BsaXQoJy8nKSB8fCBbXTtcblxuICB2YXIgaXNUb0FicyA9IHRvICYmIGlzQWJzb2x1dGUodG8pO1xuICB2YXIgaXNGcm9tQWJzID0gZnJvbSAmJiBpc0Fic29sdXRlKGZyb20pO1xuICB2YXIgbXVzdEVuZEFicyA9IGlzVG9BYnMgfHwgaXNGcm9tQWJzO1xuXG4gIGlmICh0byAmJiBpc0Fic29sdXRlKHRvKSkge1xuICAgIC8vIHRvIGlzIGFic29sdXRlXG4gICAgZnJvbVBhcnRzID0gdG9QYXJ0cztcbiAgfSBlbHNlIGlmICh0b1BhcnRzLmxlbmd0aCkge1xuICAgIC8vIHRvIGlzIHJlbGF0aXZlLCBkcm9wIHRoZSBmaWxlbmFtZVxuICAgIGZyb21QYXJ0cy5wb3AoKTtcbiAgICBmcm9tUGFydHMgPSBmcm9tUGFydHMuY29uY2F0KHRvUGFydHMpO1xuICB9XG5cbiAgaWYgKCFmcm9tUGFydHMubGVuZ3RoKSByZXR1cm4gJy8nO1xuXG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gdm9pZCAwO1xuICBpZiAoZnJvbVBhcnRzLmxlbmd0aCkge1xuICAgIHZhciBsYXN0ID0gZnJvbVBhcnRzW2Zyb21QYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBoYXNUcmFpbGluZ1NsYXNoID0gbGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicgfHwgbGFzdCA9PT0gJyc7XG4gIH0gZWxzZSB7XG4gICAgaGFzVHJhaWxpbmdTbGFzaCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IGZyb21QYXJ0cy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHBhcnQgPSBmcm9tUGFydHNbaV07XG5cbiAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKCFtdXN0RW5kQWJzKSBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICBmcm9tUGFydHMudW5zaGlmdCgnLi4nKTtcbiAgfWlmIChtdXN0RW5kQWJzICYmIGZyb21QYXJ0c1swXSAhPT0gJycgJiYgKCFmcm9tUGFydHNbMF0gfHwgIWlzQWJzb2x1dGUoZnJvbVBhcnRzWzBdKSkpIGZyb21QYXJ0cy51bnNoaWZ0KCcnKTtcblxuICB2YXIgcmVzdWx0ID0gZnJvbVBhcnRzLmpvaW4oJy8nKTtcblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiByZXN1bHQuc3Vic3RyKC0xKSAhPT0gJy8nKSByZXN1bHQgKz0gJy8nO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlc29sdmVQYXRobmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVzb2x2ZS1wYXRobmFtZS9pbmRleC5qcyIsInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gdmFsdWVFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYikgJiYgYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICByZXR1cm4gdmFsdWVFcXVhbChpdGVtLCBiW2luZGV4XSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgYVR5cGUgPSB0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYSk7XG4gIHZhciBiVHlwZSA9IHR5cGVvZiBiID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihiKTtcblxuICBpZiAoYVR5cGUgIT09IGJUeXBlKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGFUeXBlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBhVmFsdWUgPSBhLnZhbHVlT2YoKTtcbiAgICB2YXIgYlZhbHVlID0gYi52YWx1ZU9mKCk7XG5cbiAgICBpZiAoYVZhbHVlICE9PSBhIHx8IGJWYWx1ZSAhPT0gYikgcmV0dXJuIHZhbHVlRXF1YWwoYVZhbHVlLCBiVmFsdWUpO1xuXG4gICAgdmFyIGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG5cbiAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiBhS2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gdmFsdWVFcXVhbChhW2tleV0sIGJba2V5XSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbHVlRXF1YWw7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3ZhbHVlLWVxdWFsL2luZGV4LmpzIiwidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uIH0gZnJvbSAnLi9Mb2NhdGlvblV0aWxzJztcbmltcG9ydCB7IGFkZExlYWRpbmdTbGFzaCwgc3RyaXBUcmFpbGluZ1NsYXNoLCBoYXNCYXNlbmFtZSwgc3RyaXBCYXNlbmFtZSwgY3JlYXRlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcbmltcG9ydCBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciBmcm9tICcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJztcbmltcG9ydCB7IGNhblVzZURPTSwgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciwgZ2V0Q29uZmlybWF0aW9uLCBzdXBwb3J0c0hpc3RvcnksIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UsIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgfSBmcm9tICcuL0RPTVV0aWxzJztcblxudmFyIFBvcFN0YXRlRXZlbnQgPSAncG9wc3RhdGUnO1xudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxudmFyIGdldEhpc3RvcnlTdGF0ZSA9IGZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwge307XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJRSAxMSBzb21ldGltZXMgdGhyb3dzIHdoZW4gYWNjZXNzaW5nIHdpbmRvdy5oaXN0b3J5LnN0YXRlXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SZWFjdFRyYWluaW5nL2hpc3RvcnkvcHVsbC8yODlcbiAgICByZXR1cm4ge307XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgdXNlcyB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaW5jbHVkaW5nXG4gKiBwdXNoU3RhdGUsIHJlcGxhY2VTdGF0ZSwgYW5kIHRoZSBwb3BzdGF0ZSBldmVudC5cbiAqL1xudmFyIGNyZWF0ZUJyb3dzZXJIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgaW52YXJpYW50KGNhblVzZURPTSwgJ0Jyb3dzZXIgaGlzdG9yeSBuZWVkcyBhIERPTScpO1xuXG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Vc2VIaXN0b3J5ID0gc3VwcG9ydHNIaXN0b3J5KCk7XG4gIHZhciBuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lciA9ICFzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCk7XG5cbiAgdmFyIF9wcm9wcyRmb3JjZVJlZnJlc2ggPSBwcm9wcy5mb3JjZVJlZnJlc2gsXG4gICAgICBmb3JjZVJlZnJlc2ggPSBfcHJvcHMkZm9yY2VSZWZyZXNoID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9wcm9wcyRmb3JjZVJlZnJlc2gsXG4gICAgICBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdW5kZWZpbmVkID8gZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IHByb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHVuZGVmaW5lZCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gc3RyaXBUcmFpbGluZ1NsYXNoKGFkZExlYWRpbmdTbGFzaChwcm9wcy5iYXNlbmFtZSkpIDogJyc7XG5cbiAgdmFyIGdldERPTUxvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oaGlzdG9yeVN0YXRlKSB7XG4gICAgdmFyIF9yZWYgPSBoaXN0b3J5U3RhdGUgfHwge30sXG4gICAgICAgIGtleSA9IF9yZWYua2V5LFxuICAgICAgICBzdGF0ZSA9IF9yZWYuc3RhdGU7XG5cbiAgICB2YXIgX3dpbmRvdyRsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbixcbiAgICAgICAgcGF0aG5hbWUgPSBfd2luZG93JGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2ggPSBfd2luZG93JGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgaGFzaCA9IF93aW5kb3ckbG9jYXRpb24uaGFzaDtcblxuXG4gICAgdmFyIHBhdGggPSBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG5cbiAgICB3YXJuaW5nKCFiYXNlbmFtZSB8fCBoYXNCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpO1xuXG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gc3RyaXBCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGtleSk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcFN0YXRlID0gZnVuY3Rpb24gaGFuZGxlUG9wU3RhdGUoZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgaW4gV2ViS2l0LlxuICAgIGlmIChpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuXG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGV2ZW50LnN0YXRlKSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSkpO1xuICB9O1xuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIGtleXMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3Iga2V5cyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxLZXlzLmluZGV4T2YodG9Mb2NhdGlvbi5rZXkpO1xuXG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcblxuICAgIHZhciBmcm9tSW5kZXggPSBhbGxLZXlzLmluZGV4T2YoZnJvbUxvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcblxuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSk7XG4gIHZhciBhbGxLZXlzID0gW2luaXRpYWxMb2NhdGlvbi5rZXldO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gYmFzZW5hbWUgKyBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIHZhciBuZXh0S2V5cyA9IGFsbEtleXMuc2xpY2UoMCwgcHJldkluZGV4ID09PSAtMSA/IDAgOiBwcmV2SW5kZXggKyAxKTtcblxuICAgICAgICAgIG5leHRLZXlzLnB1c2gobG9jYXRpb24ua2V5KTtcbiAgICAgICAgICBhbGxLZXlzID0gbmV4dEtleXM7XG5cbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKTtcblxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXksXG4gICAgICAgICAgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcblxuXG4gICAgICBpZiAoY2FuVXNlSGlzdG9yeSkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleToga2V5LCBzdGF0ZTogc3RhdGUgfSwgbnVsbCwgaHJlZik7XG5cbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuXG4gICAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIGFsbEtleXNbcHJldkluZGV4XSA9IGxvY2F0aW9uLmtleTtcblxuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCByZXBsYWNlIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDA7XG5cbiAgdmFyIGNoZWNrRE9NTGlzdGVuZXJzID0gZnVuY3Rpb24gY2hlY2tET01MaXN0ZW5lcnMoZGVsdGEpIHtcbiAgICBsaXN0ZW5lckNvdW50ICs9IGRlbHRhO1xuXG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuXG4gICAgICBpZiAobmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIpIHJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQnJvd3Nlckhpc3Rvcnk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlQnJvd3Nlckhpc3RvcnkuanMiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5pbXBvcnQgeyBhZGRMZWFkaW5nU2xhc2gsIHN0cmlwTGVhZGluZ1NsYXNoLCBzdHJpcFRyYWlsaW5nU2xhc2gsIGhhc0Jhc2VuYW1lLCBzdHJpcEJhc2VuYW1lLCBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInO1xuaW1wb3J0IHsgY2FuVXNlRE9NLCBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyLCBnZXRDb25maXJtYXRpb24sIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoIH0gZnJvbSAnLi9ET01VdGlscyc7XG5cbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBIYXNoUGF0aENvZGVycyA9IHtcbiAgaGFzaGJhbmc6IHtcbiAgICBlbmNvZGVQYXRoOiBmdW5jdGlvbiBlbmNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aCA6ICchLycgKyBzdHJpcExlYWRpbmdTbGFzaChwYXRoKTtcbiAgICB9LFxuICAgIGRlY29kZVBhdGg6IGZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG4gICAgfVxuICB9LFxuICBub3NsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogc3RyaXBMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoXG4gIH0sXG4gIHNsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoLFxuICAgIGRlY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaFxuICB9XG59O1xuXG52YXIgZ2V0SGFzaFBhdGggPSBmdW5jdGlvbiBnZXRIYXNoUGF0aCgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaGFzaEluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBoYXNoSW5kZXggPT09IC0xID8gJycgOiBocmVmLnN1YnN0cmluZyhoYXNoSW5kZXggKyAxKTtcbn07XG5cbnZhciBwdXNoSGFzaFBhdGggPSBmdW5jdGlvbiBwdXNoSGFzaFBhdGgocGF0aCkge1xuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufTtcblxudmFyIHJlcGxhY2VIYXNoUGF0aCA9IGZ1bmN0aW9uIHJlcGxhY2VIYXNoUGF0aChwYXRoKSB7XG4gIHZhciBoYXNoSW5kZXggPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCcjJyk7XG5cbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLmhyZWYuc2xpY2UoMCwgaGFzaEluZGV4ID49IDAgPyBoYXNoSW5kZXggOiAwKSArICcjJyArIHBhdGgpO1xufTtcblxudmFyIGNyZWF0ZUhhc2hIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgaW52YXJpYW50KGNhblVzZURPTSwgJ0hhc2ggaGlzdG9yeSBuZWVkcyBhIERPTScpO1xuXG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Hb1dpdGhvdXRSZWxvYWQgPSBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpO1xuXG4gIHZhciBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdW5kZWZpbmVkID8gZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGhhc2hUeXBlID0gcHJvcHMuaGFzaFR5cGUsXG4gICAgICBoYXNoVHlwZSA9IF9wcm9wcyRoYXNoVHlwZSA9PT0gdW5kZWZpbmVkID8gJ3NsYXNoJyA6IF9wcm9wcyRoYXNoVHlwZTtcblxuICB2YXIgYmFzZW5hbWUgPSBwcm9wcy5iYXNlbmFtZSA/IHN0cmlwVHJhaWxpbmdTbGFzaChhZGRMZWFkaW5nU2xhc2gocHJvcHMuYmFzZW5hbWUpKSA6ICcnO1xuXG4gIHZhciBfSGFzaFBhdGhDb2RlcnMkaGFzaFQgPSBIYXNoUGF0aENvZGVyc1toYXNoVHlwZV0sXG4gICAgICBlbmNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmVuY29kZVBhdGgsXG4gICAgICBkZWNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmRlY29kZVBhdGg7XG5cblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbigpIHtcbiAgICB2YXIgcGF0aCA9IGRlY29kZVBhdGgoZ2V0SGFzaFBhdGgoKSk7XG5cbiAgICB3YXJuaW5nKCFiYXNlbmFtZSB8fCBoYXNCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpO1xuXG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gc3RyaXBCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24ocGF0aCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICB2YXIgaWdub3JlUGF0aCA9IG51bGw7XG5cbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKHBhdGgpO1xuXG4gICAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSB7XG4gICAgICAvLyBFbnN1cmUgd2UgYWx3YXlzIGhhdmUgYSBwcm9wZXJseS1lbmNvZGVkIGhhc2guXG4gICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICAgICAgdmFyIHByZXZMb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAgIGlmICghZm9yY2VOZXh0UG9wICYmIGxvY2F0aW9uc0FyZUVxdWFsKHByZXZMb2NhdGlvbiwgbG9jYXRpb24pKSByZXR1cm47IC8vIEEgaGFzaGNoYW5nZSBkb2Vzbid0IGFsd2F5cyA9PSBsb2NhdGlvbiBjaGFuZ2UuXG5cbiAgICAgIGlmIChpZ25vcmVQYXRoID09PSBjcmVhdGVQYXRoKGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBJZ25vcmUgdGhpcyBjaGFuZ2U7IHdlIGFscmVhZHkgc2V0U3RhdGUgaW4gcHVzaC9yZXBsYWNlLlxuXG4gICAgICBpZ25vcmVQYXRoID0gbnVsbDtcblxuICAgICAgaGFuZGxlUG9wKGxvY2F0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcCA9IGZ1bmN0aW9uIGhhbmRsZVBvcChsb2NhdGlvbikge1xuICAgIGlmIChmb3JjZU5leHRQb3ApIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuXG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV2ZXJ0UG9wKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZXZlcnRQb3AgPSBmdW5jdGlvbiByZXZlcnRQb3AoZnJvbUxvY2F0aW9uKSB7XG4gICAgdmFyIHRvTG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgLy8gVE9ETzogV2UgY291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG1vcmUgcmVsaWFibGUgYnlcbiAgICAvLyBrZWVwaW5nIGEgbGlzdCBvZiBwYXRocyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBwYXRocyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKHRvTG9jYXRpb24pKTtcblxuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG5cbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoY3JlYXRlUGF0aChmcm9tTG9jYXRpb24pKTtcblxuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRW5zdXJlIHRoZSBoYXNoIGlzIGVuY29kZWQgcHJvcGVybHkgYmVmb3JlIGRvaW5nIGFueXRoaW5nIGVsc2UuXG4gIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcblxuICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gIHZhciBhbGxQYXRocyA9IFtjcmVhdGVQYXRoKGluaXRpYWxMb2NhdGlvbildO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gJyMnICsgZW5jb2RlUGF0aChiYXNlbmFtZSArIGNyZWF0ZVBhdGgobG9jYXRpb24pKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHBhdGggPSBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBQVVNILCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICBwdXNoSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKGhpc3RvcnkubG9jYXRpb24pKTtcbiAgICAgICAgdmFyIG5leHRQYXRocyA9IGFsbFBhdGhzLnNsaWNlKDAsIHByZXZJbmRleCA9PT0gLTEgPyAwIDogcHJldkluZGV4ICsgMSk7XG5cbiAgICAgICAgbmV4dFBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIGFsbFBhdGhzID0gbmV4dFBhdGhzO1xuXG4gICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdIYXNoIGhpc3RvcnkgY2Fubm90IFBVU0ggdGhlIHNhbWUgcGF0aDsgYSBuZXcgZW50cnkgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2snKTtcblxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcmVwbGFjZSBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFJFUExBQ0UsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5pbmRleE9mKGNyZWF0ZVBhdGgoaGlzdG9yeS5sb2NhdGlvbikpO1xuXG4gICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsUGF0aHNbcHJldkluZGV4XSA9IHBhdGg7XG5cbiAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgd2FybmluZyhjYW5Hb1dpdGhvdXRSZWxvYWQsICdIYXNoIGhpc3RvcnkgZ28obikgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZCBpbiB0aGlzIGJyb3dzZXInKTtcblxuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzQmxvY2tlZCA9IGZhbHNlO1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgdmFyIHVuYmxvY2sgPSB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcblxuICAgIGlmICghaXNCbG9ja2VkKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICAgIGlzQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgaXNCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuYmxvY2soKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICB2YXIgdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZ2xvYmFsSGlzdG9yeS5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogaW5pdGlhbExvY2F0aW9uLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUhhc2hIaXN0b3J5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZUhhc2hIaXN0b3J5LmpzIiwidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCB7IGNyZWF0ZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7XG5pbXBvcnQgeyBjcmVhdGVMb2NhdGlvbiB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5pbXBvcnQgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgZnJvbSAnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcic7XG5cbnZhciBjbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKG4sIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgc3RvcmVzIGxvY2F0aW9ucyBpbiBtZW1vcnkuXG4gKi9cbnZhciBjcmVhdGVNZW1vcnlIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgX3Byb3BzJGluaXRpYWxFbnRyaWVzID0gcHJvcHMuaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsRW50cmllcyA9IF9wcm9wcyRpbml0aWFsRW50cmllcyA9PT0gdW5kZWZpbmVkID8gWycvJ10gOiBfcHJvcHMkaW5pdGlhbEVudHJpZXMsXG4gICAgICBfcHJvcHMkaW5pdGlhbEluZGV4ID0gcHJvcHMuaW5pdGlhbEluZGV4LFxuICAgICAgaW5pdGlhbEluZGV4ID0gX3Byb3BzJGluaXRpYWxJbmRleCA9PT0gdW5kZWZpbmVkID8gMCA6IF9wcm9wcyRpbml0aWFsSW5kZXgsXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG5cblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLZXkgPSBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGgpO1xuICB9O1xuXG4gIHZhciBpbmRleCA9IGNsYW1wKGluaXRpYWxJbmRleCwgMCwgaW5pdGlhbEVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIHZhciBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHJldHVybiB0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnID8gY3JlYXRlTG9jYXRpb24oZW50cnksIHVuZGVmaW5lZCwgY3JlYXRlS2V5KCkpIDogY3JlYXRlTG9jYXRpb24oZW50cnksIHVuZGVmaW5lZCwgZW50cnkua2V5IHx8IGNyZWF0ZUtleSgpKTtcbiAgfSk7XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gY3JlYXRlUGF0aDtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcHJldkluZGV4ID0gaGlzdG9yeS5pbmRleDtcbiAgICAgIHZhciBuZXh0SW5kZXggPSBwcmV2SW5kZXggKyAxO1xuXG4gICAgICB2YXIgbmV4dEVudHJpZXMgPSBoaXN0b3J5LmVudHJpZXMuc2xpY2UoMCk7XG4gICAgICBpZiAobmV4dEVudHJpZXMubGVuZ3RoID4gbmV4dEluZGV4KSB7XG4gICAgICAgIG5leHRFbnRyaWVzLnNwbGljZShuZXh0SW5kZXgsIG5leHRFbnRyaWVzLmxlbmd0aCAtIG5leHRJbmRleCwgbG9jYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEVudHJpZXMucHVzaChsb2NhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgZW50cmllczogbmV4dEVudHJpZXNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcmVwbGFjZSB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIGhpc3RvcnkuZW50cmllc1toaXN0b3J5LmluZGV4XSA9IGxvY2F0aW9uO1xuXG4gICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIHZhciBuZXh0SW5kZXggPSBjbGFtcChoaXN0b3J5LmluZGV4ICsgbiwgMCwgaGlzdG9yeS5lbnRyaWVzLmxlbmd0aCAtIDEpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuICAgIHZhciBsb2NhdGlvbiA9IGhpc3RvcnkuZW50cmllc1tuZXh0SW5kZXhdO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmIChvaykge1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIGluZGV4OiBuZXh0SW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNaW1pYyB0aGUgYmVoYXZpb3Igb2YgRE9NIGhpc3RvcmllcyBieVxuICAgICAgICAvLyBjYXVzaW5nIGEgcmVuZGVyIGFmdGVyIGEgY2FuY2VsbGVkIFBPUC5cbiAgICAgICAgc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGNhbkdvID0gZnVuY3Rpb24gY2FuR28obikge1xuICAgIHZhciBuZXh0SW5kZXggPSBoaXN0b3J5LmluZGV4ICsgbjtcbiAgICByZXR1cm4gbmV4dEluZGV4ID49IDAgJiYgbmV4dEluZGV4IDwgaGlzdG9yeS5lbnRyaWVzLmxlbmd0aDtcbiAgfTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBlbnRyaWVzLmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBlbnRyaWVzW2luZGV4XSxcbiAgICBpbmRleDogaW5kZXgsXG4gICAgZW50cmllczogZW50cmllcyxcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgY2FuR286IGNhbkdvLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlTWVtb3J5SGlzdG9yeTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tIFwid2FybmluZ1wiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IHsgY3JlYXRlSGFzaEhpc3RvcnkgYXMgY3JlYXRlSGlzdG9yeSB9IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQgUm91dGVyIGZyb20gXCIuL1JvdXRlclwiO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgdXNlcyB3aW5kb3cubG9jYXRpb24uaGFzaC5cbiAqL1xuXG52YXIgSGFzaFJvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhIYXNoUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBIYXNoUm91dGVyKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGFzaFJvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGlzdG9yeSA9IGNyZWF0ZUhpc3RvcnkoX3RoaXMucHJvcHMpLCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIEhhc2hSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksIFwiPEhhc2hSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksIFwiICsgXCJ1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBIYXNoUm91dGVyIGFzIFJvdXRlciB9YC5cIik7XG4gIH07XG5cbiAgSGFzaFJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnksIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pO1xuICB9O1xuXG4gIHJldHVybiBIYXNoUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5IYXNoUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICBoYXNoVHlwZTogUHJvcFR5cGVzLm9uZU9mKFtcImhhc2hiYW5nXCIsIFwibm9zbGFzaFwiLCBcInNsYXNoXCJdKSxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IEhhc2hSb3V0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvSGFzaFJvdXRlci5qcyIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgTWVtb3J5Um91dGVyIGZyb20gXCJyZWFjdC1yb3V0ZXIvZXMvTWVtb3J5Um91dGVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IE1lbW9yeVJvdXRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9NZW1vcnlSb3V0ZXIuanMiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IFJvdXRlIGZyb20gXCIuL1JvdXRlXCI7XG5pbXBvcnQgTGluayBmcm9tIFwiLi9MaW5rXCI7XG5cbi8qKlxuICogQSA8TGluaz4gd3JhcHBlciB0aGF0IGtub3dzIGlmIGl0J3MgXCJhY3RpdmVcIiBvciBub3QuXG4gKi9cbnZhciBOYXZMaW5rID0gZnVuY3Rpb24gTmF2TGluayhfcmVmKSB7XG4gIHZhciB0byA9IF9yZWYudG8sXG4gICAgICBleGFjdCA9IF9yZWYuZXhhY3QsXG4gICAgICBzdHJpY3QgPSBfcmVmLnN0cmljdCxcbiAgICAgIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbixcbiAgICAgIGFjdGl2ZUNsYXNzTmFtZSA9IF9yZWYuYWN0aXZlQ2xhc3NOYW1lLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBhY3RpdmVTdHlsZSA9IF9yZWYuYWN0aXZlU3R5bGUsXG4gICAgICBzdHlsZSA9IF9yZWYuc3R5bGUsXG4gICAgICBnZXRJc0FjdGl2ZSA9IF9yZWYuaXNBY3RpdmUsXG4gICAgICBhcmlhQ3VycmVudCA9IF9yZWZbXCJhcmlhLWN1cnJlbnRcIl0sXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtcInRvXCIsIFwiZXhhY3RcIiwgXCJzdHJpY3RcIiwgXCJsb2NhdGlvblwiLCBcImFjdGl2ZUNsYXNzTmFtZVwiLCBcImNsYXNzTmFtZVwiLCBcImFjdGl2ZVN0eWxlXCIsIFwic3R5bGVcIiwgXCJpc0FjdGl2ZVwiLCBcImFyaWEtY3VycmVudFwiXSk7XG5cbiAgdmFyIHBhdGggPSAodHlwZW9mIHRvID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YodG8pKSA9PT0gXCJvYmplY3RcIiA/IHRvLnBhdGhuYW1lIDogdG87XG5cbiAgLy8gUmVnZXggdGFrZW4gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL3BpbGxhcmpzL3BhdGgtdG8tcmVnZXhwL2Jsb2IvbWFzdGVyL2luZGV4LmpzI0wyMDJcbiAgdmFyIGVzY2FwZWRQYXRoID0gcGF0aCAmJiBwYXRoLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18L1xcXFxdKS9nLCBcIlxcXFwkMVwiKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZSwge1xuICAgIHBhdGg6IGVzY2FwZWRQYXRoLFxuICAgIGV4YWN0OiBleGFjdCxcbiAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgY2hpbGRyZW46IGZ1bmN0aW9uIGNoaWxkcmVuKF9yZWYyKSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBfcmVmMi5sb2NhdGlvbixcbiAgICAgICAgICBtYXRjaCA9IF9yZWYyLm1hdGNoO1xuXG4gICAgICB2YXIgaXNBY3RpdmUgPSAhIShnZXRJc0FjdGl2ZSA/IGdldElzQWN0aXZlKG1hdGNoLCBsb2NhdGlvbikgOiBtYXRjaCk7XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KExpbmssIF9leHRlbmRzKHtcbiAgICAgICAgdG86IHRvLFxuICAgICAgICBjbGFzc05hbWU6IGlzQWN0aXZlID8gW2NsYXNzTmFtZSwgYWN0aXZlQ2xhc3NOYW1lXS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSkuam9pbihcIiBcIikgOiBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiBpc0FjdGl2ZSA/IF9leHRlbmRzKHt9LCBzdHlsZSwgYWN0aXZlU3R5bGUpIDogc3R5bGUsXG4gICAgICAgIFwiYXJpYS1jdXJyZW50XCI6IGlzQWN0aXZlICYmIGFyaWFDdXJyZW50IHx8IG51bGxcbiAgICAgIH0sIHJlc3QpKTtcbiAgICB9XG4gIH0pO1xufTtcblxuTmF2TGluay5wcm9wVHlwZXMgPSB7XG4gIHRvOiBMaW5rLnByb3BUeXBlcy50byxcbiAgZXhhY3Q6IFByb3BUeXBlcy5ib29sLFxuICBzdHJpY3Q6IFByb3BUeXBlcy5ib29sLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9iamVjdCxcbiAgYWN0aXZlQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGFjdGl2ZVN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgaXNBY3RpdmU6IFByb3BUeXBlcy5mdW5jLFxuICBcImFyaWEtY3VycmVudFwiOiBQcm9wVHlwZXMub25lT2YoW1wicGFnZVwiLCBcInN0ZXBcIiwgXCJsb2NhdGlvblwiLCBcImRhdGVcIiwgXCJ0aW1lXCIsIFwidHJ1ZVwiXSlcbn07XG5cbk5hdkxpbmsuZGVmYXVsdFByb3BzID0ge1xuICBhY3RpdmVDbGFzc05hbWU6IFwiYWN0aXZlXCIsXG4gIFwiYXJpYS1jdXJyZW50XCI6IFwicGFnZVwiXG59O1xuXG5leHBvcnQgZGVmYXVsdCBOYXZMaW5rO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL05hdkxpbmsuanMiLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgUHJvbXB0IGZyb20gXCJyZWFjdC1yb3V0ZXIvZXMvUHJvbXB0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IFByb21wdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Qcm9tcHQuanMiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFJlZGlyZWN0IGZyb20gXCJyZWFjdC1yb3V0ZXIvZXMvUmVkaXJlY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgUmVkaXJlY3Q7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUmVkaXJlY3QuanMiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFN0YXRpY1JvdXRlciBmcm9tIFwicmVhY3Qtcm91dGVyL2VzL1N0YXRpY1JvdXRlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBTdGF0aWNSb3V0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvU3RhdGljUm91dGVyLmpzIiwiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBTd2l0Y2ggZnJvbSBcInJlYWN0LXJvdXRlci9lcy9Td2l0Y2hcIjtcblxuZXhwb3J0IGRlZmF1bHQgU3dpdGNoO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N3aXRjaC5qcyIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgZ2VuZXJhdGVQYXRoIGZyb20gXCJyZWFjdC1yb3V0ZXIvZXMvZ2VuZXJhdGVQYXRoXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGdlbmVyYXRlUGF0aDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9nZW5lcmF0ZVBhdGguanMiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IG1hdGNoUGF0aCBmcm9tIFwicmVhY3Qtcm91dGVyL2VzL21hdGNoUGF0aFwiO1xuXG5leHBvcnQgZGVmYXVsdCBtYXRjaFBhdGg7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvbWF0Y2hQYXRoLmpzIiwiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCB3aXRoUm91dGVyIGZyb20gXCJyZWFjdC1yb3V0ZXIvZXMvd2l0aFJvdXRlclwiO1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoUm91dGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL3dpdGhSb3V0ZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogdHJ1ZSxcbiAgICBtaXhpbnM6IHRydWUsXG4gICAgcHJvcFR5cGVzOiB0cnVlLFxuICAgIHR5cGU6IHRydWVcbn07XG5cbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICAgIG5hbWU6IHRydWUsXG4gICAgbGVuZ3RoOiB0cnVlLFxuICAgIHByb3RvdHlwZTogdHJ1ZSxcbiAgICBjYWxsZXI6IHRydWUsXG4gICAgY2FsbGVlOiB0cnVlLFxuICAgIGFyZ3VtZW50czogdHJ1ZSxcbiAgICBhcml0eTogdHJ1ZVxufTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YgJiYgZ2V0UHJvdG90eXBlT2YoT2JqZWN0KTtcblxuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGJsYWNrbGlzdCkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykgeyAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuXG4gICAgICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHZhciBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuICAgICAgICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50LCBibGFja2xpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIVJFQUNUX1NUQVRJQ1Nba2V5XSAmJiAhS05PV05fU1RBVElDU1trZXldICYmICghYmxhY2tsaXN0IHx8ICFibGFja2xpc3Rba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG4gICAgICAgICAgICAgICAgdHJ5IHsgLy8gQXZvaWQgZmFpbHVyZXMgZnJvbSByZWFkLW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBob2lzdE5vblJlYWN0U3RhdGljcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9kaXN0L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzLmNqcy5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7TmF2TGlua30gZnJvbSBcInJlYWN0LXJvdXRlci1kb21cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExhbmd1YWdlcygpIHtcclxuICAgIGNvbnN0IGxhbmd1YWdlcyA9IFt7XHJcbiAgICAgICAgbmFtZTogJ0FsbCcsXHJcbiAgICAgICAgcGFyYW06ICdhbGwnXHJcbiAgICB9LCB7XHJcbiAgICAgICAgbmFtZTogJ0phdmFTY3JpcHQnLFxyXG4gICAgICAgIHBhcmFtOiAnamF2YXNjcmlwdCcsXHJcbiAgICB9LCB7XHJcbiAgICAgICAgbmFtZTogJ1J1YnknLFxyXG4gICAgICAgIHBhcmFtOiAncnVieScsXHJcbiAgICB9LCB7XHJcbiAgICAgICAgbmFtZTogJ1B5dGhvbicsXHJcbiAgICAgICAgcGFyYW06ICdweXRob24nLFxyXG4gICAgfSwge1xyXG4gICAgICAgIG5hbWU6ICdKYXZhJyxcclxuICAgICAgICBwYXJhbTogJ2phdmEnLFxyXG4gICAgfV1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgIDxoMj5UaGlzIGlzIExhbmd1YWdlcyBwYWdlLjwvaDI+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIHtsYW5ndWFnZXMubWFwKCh7IG5hbWUsIHBhcmFtIH0pID0+IChcclxuICAgICAgICAgICAgICAgICAgICA8bGkga2V5PXtwYXJhbX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxOYXZMaW5rIGFjdGl2ZVN0eWxlPXt7Zm9udFdlaWdodDogJ2JvbGQnfX0gdG89e2AvbGFuZ3VhZ2VzLyR7cGFyYW19YH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9OYXZMaW5rPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIClcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2hhcmVkL0xhbmd1YWdlcy5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7TmF2TGlua30gZnJvbSBcInJlYWN0LXJvdXRlci1kb21cIjtcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBVc2VycygpIHtcclxuICAgIGNvbnN0IHVzZXJzID0gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWUnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW06ICdWbGFkaXNsYXZBcmthdmVua28nXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdJZ29yJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtOiAncG9sa3BvbGlvMScsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdTb21lb25lJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtOiAnc29tZW9uZScsXHJcbiAgICAgICAgICAgIH1cclxuICAgIF1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgIDxoMj5UaGlzIGlzIFVzZXJzIHBhZ2UuPC9oMj5cclxuICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAge3VzZXJzLm1hcCgoeyBuYW1lLCBwYXJhbSB9KSA9PiAoXHJcbiAgICAgICAgICAgICAgICAgICAgPGxpIGtleT17cGFyYW19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8TmF2TGluayBhY3RpdmVTdHlsZT17e2ZvbnRXZWlnaHQ6ICdib2xkJ319IHRvPXtgL3VzZXJzLyR7cGFyYW19YH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9OYXZMaW5rPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIClcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2hhcmVkL1VzZXJzLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgeyBmZXRjaFBvcHVsYXJSZXBvcyB9IGZyb20gJy4vYXBpJ1xyXG5cclxuY2xhc3MgUmVwb0dyaWQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpe1xyXG4gICAgICAgIHN1cGVyKHByb3BzKVxyXG5cclxuICAgICAgICBsZXQgcmVwb3NcclxuXHJcbiAgICAgICAgaWYgKF9faXNCcm93c2VyX18pIHtcclxuICAgICAgICAgICAgcmVwb3MgPSB3aW5kb3cuX19JTklUSUFMX0RBVEFfX1xyXG4gICAgICAgICAgICBkZWxldGUgd2luZG93Ll9fSU5JVElBTF9EQVRBX19cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXBvcyA9IHByb3BzLnN0YXRpY0NvbnRleHQuZGF0YVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgcmVwb3MsXHJcbiAgICAgICAgICAgIGxvYWRpbmc6IHJlcG9zID8gZmFsc2UgOiB0cnVlLFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5mZXRjaFJlcG9zID0gdGhpcy5mZXRjaFJlcG9zLmJpbmQodGhpcylcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLnJlcG9zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmV0Y2hSZXBvcyh0aGlzLnByb3BzLm1hdGNoLnBhcmFtcy5pZClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkVXBkYXRlIChwcmV2UHJvcHMpIHtcclxuICAgICAgICBpZiAocHJldlByb3BzLm1hdGNoLnBhcmFtcy5pZCAhPT0gdGhpcy5wcm9wcy5tYXRjaC5wYXJhbXMuaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5mZXRjaFJlcG9zKHRoaXMucHJvcHMubWF0Y2gucGFyYW1zLmlkKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmZXRjaFJlcG9zIChsYW5nKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSggKCkgPT4gKHtcclxuICAgICAgICAgICAgbG9hZGluZzogdHJ1ZVxyXG4gICAgICAgIH0pIClcclxuXHJcbiAgICAgICAgZmV0Y2hQb3B1bGFyUmVwb3MobGFuZylcclxuICAgICAgICAgICAgLnRoZW4oIHJlcG9zID0+IHRoaXMuc2V0U3RhdGUoICgpID0+ICh7XHJcbiAgICAgICAgICAgICAgICByZXBvcyxcclxuICAgICAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxyXG4gICAgICAgICAgICB9KSApIClcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgY29uc3QgeyByZXBvcywgbG9hZGluZyB9ID0gdGhpcy5zdGF0ZVxyXG5cclxuICAgICAgICBpZiAobG9hZGluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gPHA+TG9hZGluZy4uLjwvcD5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDx1bCBzdHlsZT17e2Rpc3BsYXk6ICdmbGV4JywgZmxleFdyYXA6ICd3cmFwJ319PlxyXG4gICAgICAgICAgICAgICAge3JlcG9zLm1hcCgoeyBuYW1lLCBvd25lciwgc3RhcmdhemVyc19jb3VudCwgaHRtbF91cmwgfSkgPT4gKFxyXG4gICAgICAgICAgICAgICAgICAgIDxsaSBrZXk9e25hbWV9IHN0eWxlPXt7bWFyZ2luOiAzMH19PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+PGEgaHJlZj17aHRtbF91cmx9PntuYW1lfTwvYT48L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPkB7b3duZXIubG9naW59PC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT57c3RhcmdhemVyc19jb3VudH0gc3RhcnM8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICApXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJlcG9HcmlkXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NoYXJlZC9yZXBvR3JpZC5qcyIsIi8vIHRoZSB3aGF0d2ctZmV0Y2ggcG9seWZpbGwgaW5zdGFsbHMgdGhlIGZldGNoKCkgZnVuY3Rpb25cbi8vIG9uIHRoZSBnbG9iYWwgb2JqZWN0ICh3aW5kb3cgb3Igc2VsZilcbi8vXG4vLyBSZXR1cm4gdGhhdCBhcyB0aGUgZXhwb3J0IGZvciB1c2UgaW4gV2VicGFjaywgQnJvd3NlcmlmeSBldGMuXG5yZXF1aXJlKCd3aGF0d2ctZmV0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gc2VsZi5mZXRjaC5iaW5kKHNlbGYpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2lzb21vcnBoaWMtZmV0Y2gvZmV0Y2gtbnBtLWJyb3dzZXJpZnkuanMiLCJ2YXIgc3VwcG9ydCA9IHtcbiAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBzZWxmLFxuICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gc2VsZiAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgYmxvYjpcbiAgICAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJlxuICAgICdCbG9iJyBpbiBzZWxmICYmXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KSgpLFxuICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBzZWxmXG59XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXcob2JqKSB7XG4gIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxufVxuXG5pZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgXVxuXG4gIHZhciBpc0FycmF5QnVmZmVyVmlldyA9XG4gICAgQXJyYXlCdWZmZXIuaXNWaWV3IHx8XG4gICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTFcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgbmFtZSA9IFN0cmluZyhuYW1lKVxuICB9XG4gIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpXG4gIH1cbiAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgdmFyIGl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKVxuICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXRlcmF0b3Jcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICB0aGlzLm1hcCA9IHt9XG5cbiAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICB9LCB0aGlzKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICB0aGlzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSlcbiAgICB9LCB0aGlzKVxuICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pXG4gICAgfSwgdGhpcylcbiAgfVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXVxuICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbFxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgIGlmICh0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcylcbiAgICB9XG4gIH1cbn1cblxuSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXVxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICBpdGVtcy5wdXNoKG5hbWUpXG4gIH0pXG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbn1cblxuSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIGl0ZW1zLnB1c2godmFsdWUpXG4gIH0pXG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXVxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pXG4gIH0pXG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbn1cblxuaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXNcbn1cblxuZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgfVxuICBib2R5LmJvZHlVc2VkID0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgfVxuICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpXG4gIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSlcbiAgfVxuICByZXR1cm4gY2hhcnMuam9pbignJylcbn1cblxuZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gIGlmIChidWYuc2xpY2UpIHtcbiAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gIH0gZWxzZSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aClcbiAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKVxuICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICB9XG59XG5cbmZ1bmN0aW9uIEJvZHkoKSB7XG4gIHRoaXMuYm9keVVzZWQgPSBmYWxzZVxuXG4gIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keVxuICAgIGlmICghYm9keSkge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKClcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKVxuICAgICAgLy8gSUUgMTAtMTEgY2FuJ3QgaGFuZGxlIGEgRGF0YVZpZXcgYm9keS5cbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pXG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KVxuICAgIH1cblxuICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gY29uc3VtZWQodGhpcykgfHwgUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICB9XG4gIH1cblxuICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICB9XG4gIH1cblxuICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG52YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXVxuXG5mdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgcmV0dXJuIG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xID8gdXBjYXNlZCA6IG1ldGhvZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuXG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgfVxuICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kXG4gICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsXG4gICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpXG4gIH1cblxuICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdzYW1lLW9yaWdpbidcbiAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICB9XG4gIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGxcbiAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbFxuICB0aGlzLnJlZmVycmVyID0gbnVsbFxuXG4gIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gIH1cbiAgdGhpcy5faW5pdEJvZHkoYm9keSlcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHtib2R5OiB0aGlzLl9ib2R5SW5pdH0pXG59XG5cbmZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgYm9keVxuICAgIC50cmltKClcbiAgICAuc3BsaXQoJyYnKVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKVxuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIH1cbiAgICB9KVxuICByZXR1cm4gZm9ybVxufVxuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKClcbiAgLy8gUmVwbGFjZSBpbnN0YW5jZXMgb2YgXFxyXFxuIGFuZCBcXG4gZm9sbG93ZWQgYnkgYXQgbGVhc3Qgb25lIHNwYWNlIG9yIGhvcml6b250YWwgdGFiIHdpdGggYSBzcGFjZVxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMlxuICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKVxuICBwcmVQcm9jZXNzZWRIZWFkZXJzLnNwbGl0KC9cXHI/XFxuLykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpXG4gICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpXG4gICAgaWYgKGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKVxuICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiBoZWFkZXJzXG59XG5cbkJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuZXhwb3J0IGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzXG4gIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDBcbiAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snXG4gIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJ1xuICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbn1cblxuQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSlcblxuUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgIHVybDogdGhpcy51cmxcbiAgfSlcbn1cblxuUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcidcbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbnZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XVxuXG5SZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gIH1cblxuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbn1cblxuZXhwb3J0IHZhciBET01FeGNlcHRpb24gPSBzZWxmLkRPTUV4Y2VwdGlvblxudHJ5IHtcbiAgbmV3IERPTUV4Y2VwdGlvbigpXG59IGNhdGNoIChlcnIpIHtcbiAgRE9NRXhjZXB0aW9uID0gZnVuY3Rpb24obWVzc2FnZSwgbmFtZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2VcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdmFyIGVycm9yID0gRXJyb3IobWVzc2FnZSlcbiAgICB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2tcbiAgfVxuICBET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpXG4gIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBET01FeGNlcHRpb25cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoKGlucHV0LCBpbml0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgfVxuXG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cbiAgICBmdW5jdGlvbiBhYm9ydFhocigpIHtcbiAgICAgIHhoci5hYm9ydCgpXG4gICAgfVxuXG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICB9XG4gICAgICBvcHRpb25zLnVybCA9ICdyZXNwb25zZVVSTCcgaW4geGhyID8geGhyLnJlc3BvbnNlVVJMIDogb3B0aW9ucy5oZWFkZXJzLmdldCgnWC1SZXF1ZXN0LVVSTCcpXG4gICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpXG4gICAgfVxuXG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgfVxuXG4gICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICB9XG5cbiAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgIH1cblxuICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSlcblxuICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnb21pdCcpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InXG4gICAgfVxuXG4gICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgIH0pXG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpXG5cbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gRE9ORSAoc3VjY2VzcyBvciBmYWlsdXJlKVxuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICByZXF1ZXN0LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdClcbiAgfSlcbn1cblxuZmV0Y2gucG9seWZpbGwgPSB0cnVlXG5cbmlmICghc2VsZi5mZXRjaCkge1xuICBzZWxmLmZldGNoID0gZmV0Y2hcbiAgc2VsZi5IZWFkZXJzID0gSGVhZGVyc1xuICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0XG4gIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9mZXRjaC5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgZmV0Y2hVc2VyIH0gZnJvbSAnLi9hcGknXHJcblxyXG5jbGFzcyBVc2VyR3JpZCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcyl7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpXHJcblxyXG4gICAgICAgIGxldCB1c2VyXHJcblxyXG4gICAgICAgIGlmIChfX2lzQnJvd3Nlcl9fKSB7XHJcbiAgICAgICAgICAgIHVzZXIgPSB3aW5kb3cuX19JTklUSUFMX0RBVEFfX1xyXG4gICAgICAgICAgICBkZWxldGUgd2luZG93Ll9fSU5JVElBTF9EQVRBX19cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB1c2VyID0gcHJvcHMuc3RhdGljQ29udGV4dC5kYXRhXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICB1c2VyLFxyXG4gICAgICAgICAgICBsb2FkaW5nOiB1c2VyID8gZmFsc2UgOiB0cnVlLFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5nZXRVc2VyID0gdGhpcy5nZXRVc2VyLmJpbmQodGhpcylcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLnVzZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5nZXRVc2VyKHRoaXMucHJvcHMubWF0Y2gucGFyYW1zLmlkKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRVcGRhdGUgKHByZXZQcm9wcykge1xyXG4gICAgICAgIGlmIChwcmV2UHJvcHMubWF0Y2gucGFyYW1zLmlkICE9PSB0aGlzLnByb3BzLm1hdGNoLnBhcmFtcy5pZCkge1xyXG4gICAgICAgICAgICB0aGlzLmdldFVzZXIodGhpcy5wcm9wcy5tYXRjaC5wYXJhbXMuaWQpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldFVzZXIgKG5hbWUpIHtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKCAoKSA9PiAoe1xyXG4gICAgICAgICAgICBsb2FkaW5nOiB0cnVlXHJcbiAgICAgICAgfSkgKVxyXG5cclxuICAgICAgICBmZXRjaFVzZXIobmFtZSlcclxuICAgICAgICAgICAgLnRoZW4oIHVzZXIgPT4gdGhpcy5zZXRTdGF0ZSggKCkgPT4gKHtcclxuICAgICAgICAgICAgICAgIHVzZXIsXHJcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgfSkgKSApXHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlciwgbG9hZGluZyB9ID0gdGhpcy5zdGF0ZVxyXG5cclxuICAgICAgICBpZiAobG9hZGluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gPHA+TG9hZGluZy4uLjwvcD5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8aW1nIHNyYz17dXNlci5hdmF0YXJfdXJsfSBhbHQ9XCJBdmF0YXJcIi8+XHJcbiAgICAgICAgICAgICAgICA8YSBocmVmPXt1c2VyLnVybH0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGg1Pnt1c2VyLmxvZ2lufTwvaDU+XHJcbiAgICAgICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICAgICAgICA8cD5Gb2xsb3dlcnM6IHt1c2VyLmZvbGxvd2Vyc308L3A+XHJcbiAgICAgICAgICAgICAgICA8cD5Gb2xsb3dpbmc6IHt1c2VyLmZvbGxvd2luZ308L3A+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIClcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVXNlckdyaWRcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2hhcmVkL3VzZXJHcmlkLmpzIiwiaW1wb3J0IHsgbWF0Y2hQYXRoLCBSb3V0ZXIsIFN3aXRjaCwgUm91dGUgfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuZnVuY3Rpb24gbWF0Y2hSb3V0ZXMocm91dGVzLCBwYXRobmFtZSxcbi8qbm90IHB1YmxpYyBBUEkqL1xuYnJhbmNoKSB7XG4gIGlmIChicmFuY2ggPT09IHZvaWQgMCkge1xuICAgIGJyYW5jaCA9IFtdO1xuICB9XG5cbiAgcm91dGVzLnNvbWUoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgdmFyIG1hdGNoID0gcm91dGUucGF0aCA/IG1hdGNoUGF0aChwYXRobmFtZSwgcm91dGUpIDogYnJhbmNoLmxlbmd0aCA/IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV0ubWF0Y2ggLy8gdXNlIHBhcmVudCBtYXRjaFxuICAgIDogUm91dGVyLmNvbXB1dGVSb290TWF0Y2gocGF0aG5hbWUpOyAvLyB1c2UgZGVmYXVsdCBcInJvb3RcIiBtYXRjaFxuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBicmFuY2gucHVzaCh7XG4gICAgICAgIHJvdXRlOiByb3V0ZSxcbiAgICAgICAgbWF0Y2g6IG1hdGNoXG4gICAgICB9KTtcblxuICAgICAgaWYgKHJvdXRlLnJvdXRlcykge1xuICAgICAgICBtYXRjaFJvdXRlcyhyb3V0ZS5yb3V0ZXMsIHBhdGhuYW1lLCBicmFuY2gpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaDtcbiAgfSk7XG4gIHJldHVybiBicmFuY2g7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJvdXRlcyhyb3V0ZXMsIGV4dHJhUHJvcHMsIHN3aXRjaFByb3BzKSB7XG4gIGlmIChleHRyYVByb3BzID09PSB2b2lkIDApIHtcbiAgICBleHRyYVByb3BzID0ge307XG4gIH1cblxuICBpZiAoc3dpdGNoUHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHN3aXRjaFByb3BzID0ge307XG4gIH1cblxuICByZXR1cm4gcm91dGVzID8gUmVhY3QuY3JlYXRlRWxlbWVudChTd2l0Y2gsIHN3aXRjaFByb3BzLCByb3V0ZXMubWFwKGZ1bmN0aW9uIChyb3V0ZSwgaSkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlLCB7XG4gICAgICBrZXk6IHJvdXRlLmtleSB8fCBpLFxuICAgICAgcGF0aDogcm91dGUucGF0aCxcbiAgICAgIGV4YWN0OiByb3V0ZS5leGFjdCxcbiAgICAgIHN0cmljdDogcm91dGUuc3RyaWN0LFxuICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIHJvdXRlLnJlbmRlciA/IHJvdXRlLnJlbmRlcihfZXh0ZW5kcyh7fSwgcHJvcHMsIGV4dHJhUHJvcHMsIHtcbiAgICAgICAgICByb3V0ZTogcm91dGVcbiAgICAgICAgfSkpIDogUmVhY3QuY3JlYXRlRWxlbWVudChyb3V0ZS5jb21wb25lbnQsIF9leHRlbmRzKHt9LCBwcm9wcywgZXh0cmFQcm9wcywge1xuICAgICAgICAgIHJvdXRlOiByb3V0ZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pKSA6IG51bGw7XG59XG5cbmV4cG9ydCB7IG1hdGNoUm91dGVzLCByZW5kZXJSb3V0ZXMgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItY29uZmlnL2VzbS9yZWFjdC1yb3V0ZXItY29uZmlnLmpzIiwiaW1wb3J0IF9NZW1vcnlSb3V0ZXIgZnJvbSBcIi4vTWVtb3J5Um91dGVyXCI7XG5leHBvcnQgeyBfTWVtb3J5Um91dGVyIGFzIE1lbW9yeVJvdXRlciB9O1xuaW1wb3J0IF9Qcm9tcHQgZnJvbSBcIi4vUHJvbXB0XCI7XG5leHBvcnQgeyBfUHJvbXB0IGFzIFByb21wdCB9O1xuaW1wb3J0IF9SZWRpcmVjdCBmcm9tIFwiLi9SZWRpcmVjdFwiO1xuZXhwb3J0IHsgX1JlZGlyZWN0IGFzIFJlZGlyZWN0IH07XG5pbXBvcnQgX1JvdXRlIGZyb20gXCIuL1JvdXRlXCI7XG5leHBvcnQgeyBfUm91dGUgYXMgUm91dGUgfTtcbmltcG9ydCBfUm91dGVyIGZyb20gXCIuL1JvdXRlclwiO1xuZXhwb3J0IHsgX1JvdXRlciBhcyBSb3V0ZXIgfTtcbmltcG9ydCBfU3RhdGljUm91dGVyIGZyb20gXCIuL1N0YXRpY1JvdXRlclwiO1xuZXhwb3J0IHsgX1N0YXRpY1JvdXRlciBhcyBTdGF0aWNSb3V0ZXIgfTtcbmltcG9ydCBfU3dpdGNoIGZyb20gXCIuL1N3aXRjaFwiO1xuZXhwb3J0IHsgX1N3aXRjaCBhcyBTd2l0Y2ggfTtcbmltcG9ydCBfZ2VuZXJhdGVQYXRoIGZyb20gXCIuL2dlbmVyYXRlUGF0aFwiO1xuZXhwb3J0IHsgX2dlbmVyYXRlUGF0aCBhcyBnZW5lcmF0ZVBhdGggfTtcbmltcG9ydCBfbWF0Y2hQYXRoIGZyb20gXCIuL21hdGNoUGF0aFwiO1xuZXhwb3J0IHsgX21hdGNoUGF0aCBhcyBtYXRjaFBhdGggfTtcbmltcG9ydCBfd2l0aFJvdXRlciBmcm9tIFwiLi93aXRoUm91dGVyXCI7XG5leHBvcnQgeyBfd2l0aFJvdXRlciBhcyB3aXRoUm91dGVyIH07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9pbmRleC5qcyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMuanMiXSwic291cmNlUm9vdCI6IiJ9